{"pr_number": 7275, "pr_title": "xds: implement routing in xDS resolver with config selector API", "pr_createdAt": "2020-07-31T09:02:08Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7275", "timeline": [{"oid": "5411ff8917af7ec40de4077977f82d49a24c62ce", "url": "https://github.com/grpc/grpc-java/commit/5411ff8917af7ec40de4077977f82d49a24c62ce", "message": "Implement routing logic with ConfigSelector API inside the xDS resolver.", "committedDate": "2020-07-31T08:52:37Z", "type": "commit"}, {"oid": "e1ba6b14595d1707a3e0af79ef8ff67e3a3eea1e", "url": "https://github.com/grpc/grpc-java/commit/e1ba6b14595d1707a3e0af79ef8ff67e3a3eea1e", "message": "Eliminate Gson dependency", "committedDate": "2020-07-31T08:53:00Z", "type": "commit"}, {"oid": "275eb07237ccfabae580618607d7f83440f8b8b5", "url": "https://github.com/grpc/grpc-java/commit/275eb07237ccfabae580618607d7f83440f8b8b5", "message": "Clean up tests.", "committedDate": "2020-07-31T08:53:15Z", "type": "commit"}, {"oid": "b02c66e42691dc92914dac5757d60952293cfa0e", "url": "https://github.com/grpc/grpc-java/commit/b02c66e42691dc92914dac5757d60952293cfa0e", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector", "committedDate": "2020-07-31T09:00:42Z", "type": "commit"}, {"oid": "23ed13ae910c87f25297076cef1cfd80a58fa353", "url": "https://github.com/grpc/grpc-java/commit/23ed13ae910c87f25297076cef1cfd80a58fa353", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector", "committedDate": "2020-07-31T19:13:02Z", "type": "commit"}, {"oid": "3788dfb75d7fe9274878cfac87027e5b9e66e2ae", "url": "https://github.com/grpc/grpc-java/commit/3788dfb75d7fe9274878cfac87027e5b9e66e2ae", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector", "committedDate": "2020-07-31T21:31:13Z", "type": "commit"}, {"oid": "bb2fa57478a8ed9d79f6c8812d61d26d871a9cc2", "url": "https://github.com/grpc/grpc-java/commit/bb2fa57478a8ed9d79f6c8812d61d26d871a9cc2", "message": "Delete old xDS name resolver tests, which involves very complicated interaction with xDS server.", "committedDate": "2020-08-01T01:12:03Z", "type": "commit"}, {"oid": "e88dcf1433dad1fea546dc64ca1bef072b7f49e0", "url": "https://github.com/grpc/grpc-java/commit/e88dcf1433dad1fea546dc64ca1bef072b7f49e0", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector", "committedDate": "2020-08-01T02:02:30Z", "type": "commit"}, {"oid": "27259466e2b0d4d9f58c787d8be6d802c014c479", "url": "https://github.com/grpc/grpc-java/commit/27259466e2b0d4d9f58c787d8be6d802c014c479", "message": "Change ConfigSelector result's config to type ConfigOrError.", "committedDate": "2020-08-03T09:41:25Z", "type": "commit"}, {"oid": "251a723abef740ad31c652d2a292bd4cbab1906d", "url": "https://github.com/grpc/grpc-java/commit/251a723abef740ad31c652d2a292bd4cbab1906d", "message": "Expose the simple constructor of RouteMatch for testing.", "committedDate": "2020-08-03T09:42:27Z", "type": "commit"}, {"oid": "6d0e485ae04e04d4a1774e906255ce7d70fee03a", "url": "https://github.com/grpc/grpc-java/commit/6d0e485ae04e04d4a1774e906255ce7d70fee03a", "message": "Introduce XdsClientPoolFactory interface for injecting a mock XdsClient for testing purposes.", "committedDate": "2020-08-03T09:43:43Z", "type": "commit"}, {"oid": "9bcf1ed0cc08e7e4736a7fbc731dfe0b39d2d915", "url": "https://github.com/grpc/grpc-java/commit/9bcf1ed0cc08e7e4736a7fbc731dfe0b39d2d915", "message": "Completes xDS config selector for per-method timeout and add tests.", "committedDate": "2020-08-03T09:44:56Z", "type": "commit"}, {"oid": "a5aaedd6f8bfdbc5b57fa759b3341cc959596e4a", "url": "https://github.com/grpc/grpc-java/commit/a5aaedd6f8bfdbc5b57fa759b3341cc959596e4a", "message": "Fix style.", "committedDate": "2020-08-03T17:38:56Z", "type": "commit"}, {"oid": "a553bf7e74eea746cf2e206036ed1f563f32c260", "url": "https://github.com/grpc/grpc-java/commit/a553bf7e74eea746cf2e206036ed1f563f32c260", "message": "Add comments for some important checkpoints.", "committedDate": "2020-08-03T18:08:46Z", "type": "commit"}, {"oid": "f51d1d4b7616e790adae22ecc6bf994ff4bb0502", "url": "https://github.com/grpc/grpc-java/commit/f51d1d4b7616e790adae22ecc6bf994ff4bb0502", "message": "Add test coverage for cases routing to weighted clusters.", "committedDate": "2020-08-03T18:30:27Z", "type": "commit"}, {"oid": "b26e9d47dcd104beebaa9c4afbc3888e447decae", "url": "https://github.com/grpc/grpc-java/commit/b26e9d47dcd104beebaa9c4afbc3888e447decae", "message": "Clean up the CallOption key for passing selected cluster name to top-level load balancer.", "committedDate": "2020-08-03T18:36:13Z", "type": "commit"}, {"oid": "1f5bf8b47ee345147efcb767c5b926b9feb59c99", "url": "https://github.com/grpc/grpc-java/commit/1f5bf8b47ee345147efcb767c5b926b9feb59c99", "message": "Add TODO for further cleanup.", "committedDate": "2020-08-03T18:42:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5ODc5MA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r465398790", "bodyText": "Why not just have ConfigOrError instead of Status and ConfigOrError? Although one is before parsing the other is after parsing, for the user of Result, they don't seem like to check error twice and distinguish between error from Status and error from ConfigOrError.\nResult.forError(error) can just create a result with Result.config.getError() being that error.", "author": "dapengzhang0", "createdAt": "2020-08-05T00:12:39Z", "path": "api/src/main/java/io/grpc/InternalConfigSelector.java", "diffHunk": "@@ -41,14 +42,14 @@\n   public static final class Result {\n     private final Status status;\n     @Nullable\n-    private final Object config;\n+    private final ConfigOrError config;", "originalCommit": "1f5bf8b47ee345147efcb767c5b926b9feb59c99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxMDgzNQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r465410835", "bodyText": "They are two different things. Result.status is the status information for ConfigSelector's selectConfig operation. It could include error information like failing to find a route.\nMaking Result.config a ConfigOrError is for API completeness. Result.config is from the result of ServiceConfigParser.parseServiceConfig(...), which may give a config object or an error. Since the raw config of Result.config is generated by us internally, it should never cause ServiceConfigParser to give an error (otherwise, mostly that's a programmer bug). From an API's perspective, I'd prefer to just wire the output of ServiceConfigParser.parseServiceConfig(...) to what a Result would return to its consumers. Another option is to assert the result of ServiceConfigParser.parseServiceConfig(...) is not an error. So Result.config will still be an Object that guarantees to be a valid config. I don't have a strong opinion regarding these two choices.", "author": "voidzcy", "createdAt": "2020-08-05T00:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5ODc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxODczNw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r465418737", "bodyText": "I think it's better to \"enforce\" the producer of Result to assert it is not an error because of otherwise a programming bug.", "author": "dapengzhang0", "createdAt": "2020-08-05T01:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5ODc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwNDAzNg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r465404036", "bodyText": "Why adding this method to a Factory class? Why not pass bootstrapInfo object to the constructor of XdsClientPoolFactory implementation?", "author": "dapengzhang0", "createdAt": "2020-08-05T00:31:59Z", "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -671,4 +673,11 @@ boolean isUseProtocolV3() {\n       return useProtocolV3;\n     }\n   }\n+\n+  interface XdsClientPoolFactory {\n+\n+    void bootstrap() throws IOException;", "originalCommit": "1f5bf8b47ee345147efcb767c5b926b9feb59c99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwNjkxNA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r465406914", "bodyText": "Ah. This was a very hard API decision, as it was trying to flatten the circular workflow.\nThe goal was to inject an XdsClient to the resolver. However, creating an XdsClient depends on reading the bootstrap file. Reading bootstrap file does not happen until resolver's start(...) is called. So this workflow is circular and we are never able to inject an XdsClient unless we also inject an object that takes responsibility of both reading bootstrap file and creating an XdsClient. This is what an XdsClientPoolFactory is \ud83d\ude04 .\nNote the layer of XdsClientFactory is redundant now. Since we still have the \"EDS-only\" usage, I will leave it now and clean up in a later PR.", "author": "voidzcy", "createdAt": "2020-08-05T00:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwNDAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0NTA1Mg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r466845052", "bodyText": "The workflow issue can be resolved by passing bootstrapInfo as an argument of newXdsClientObjectPool() instead. See https://gist.github.com/dapengzhang0/707e4b845fe68648c68d880b76053cb1\nXdsClientPoolFactory shouldn't do two things: File IO + creating client pool. Also, that would make the factory stateful.", "author": "dapengzhang0", "createdAt": "2020-08-07T06:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwNDAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkyMzI1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r466923259", "bodyText": "Yeah, that works better. Thanks. Updated.\nAlso, I moved this breaking changes to XdsNameResolver2 so that we can review and merge timely without being blocked by other parts and less risk for server breakages.", "author": "voidzcy", "createdAt": "2020-08-07T09:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwNDAzNg=="}], "type": "inlineReview"}, {"oid": "27a49060def9e01fe8393ac666a83ce9d3c1201e", "url": "https://github.com/grpc/grpc-java/commit/27a49060def9e01fe8393ac666a83ce9d3c1201e", "message": "Change back to have ConfigSelector's Result contain the real config.", "committedDate": "2020-08-05T23:07:07Z", "type": "commit"}, {"oid": "bb0b541454eb990c1dcf0307e403043f8bd2c702", "url": "https://github.com/grpc/grpc-java/commit/bb0b541454eb990c1dcf0307e403043f8bd2c702", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector", "committedDate": "2020-08-05T23:07:58Z", "type": "commit"}, {"oid": "48d43cde64692c52c19ddce845376c177483b0d8", "url": "https://github.com/grpc/grpc-java/commit/48d43cde64692c52c19ddce845376c177483b0d8", "message": "Pass bootstrap info as arguement for creating an XdsClient pool.", "committedDate": "2020-08-07T08:56:16Z", "type": "commit"}, {"oid": "afc450b9e627fefe7904a2f9a0054e445b20fa0b", "url": "https://github.com/grpc/grpc-java/commit/afc450b9e627fefe7904a2f9a0054e445b20fa0b", "message": "Move new name resolver implementations into separate files and restore the old implementation.", "committedDate": "2020-08-07T09:09:20Z", "type": "forcePushed"}, {"oid": "86fb85f82ff3d40be38c85ec60bd86a59354c40f", "url": "https://github.com/grpc/grpc-java/commit/86fb85f82ff3d40be38c85ec60bd86a59354c40f", "message": "Move new name resolver implementations into separate files and restore the old implementation.", "committedDate": "2020-08-07T09:10:04Z", "type": "forcePushed"}, {"oid": "5e4629090621b0bac94ab653ce4fb600c2b04c80", "url": "https://github.com/grpc/grpc-java/commit/5e4629090621b0bac94ab653ce4fb600c2b04c80", "message": "Move new name resolver implementations into separate files and restore the old implementation.", "committedDate": "2020-08-07T09:13:02Z", "type": "forcePushed"}, {"oid": "1d6a13705e63a21d40bb57942df70d36a39053a2", "url": "https://github.com/grpc/grpc-java/commit/1d6a13705e63a21d40bb57942df70d36a39053a2", "message": "Move new name resolver implementations into separate files and restore the old implementation.", "committedDate": "2020-08-07T09:14:28Z", "type": "commit"}, {"oid": "1d6a13705e63a21d40bb57942df70d36a39053a2", "url": "https://github.com/grpc/grpc-java/commit/1d6a13705e63a21d40bb57942df70d36a39053a2", "message": "Move new name resolver implementations into separate files and restore the old implementation.", "committedDate": "2020-08-07T09:14:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3Njg4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467176882", "bodyText": "Could this refCount be null? A serious problem is that routes and clusterRefs are not updated atomically. retainCluster() is not run in synchronization context, so it's hard for me to verify the correctness.", "author": "dapengzhang0", "createdAt": "2020-08-07T17:34:27Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final Map<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);", "originalCommit": "1d6a13705e63a21d40bb57942df70d36a39053a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4ODkzNg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467188936", "bodyText": "Yeah, there could be race problems. The cluster to retain may be being removed by another call. Fixed here.\nAnother place is when a new update is received and try to create reference count for new clusters, checking if a cluster reference already exists and creating the reference for it could be interleaved by another thread that deletes the reference for this cluster. Fixed there too.", "author": "voidzcy", "createdAt": "2020-08-07T17:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3Njg4Mg=="}], "type": "inlineReview"}, {"oid": "ab0eda90a6356f6c13cb35c0c49636e21805bf67", "url": "https://github.com/grpc/grpc-java/commit/ab0eda90a6356f6c13cb35c0c49636e21805bf67", "message": "Suppress warning for modifying in the loop of concurrent map.", "committedDate": "2020-08-07T17:34:41Z", "type": "commit"}, {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7", "url": "https://github.com/grpc/grpc-java/commit/09e5276429b949546dc7e310c11c88a0c29428d7", "message": "Fix race for cluster being removed while adding new clusters.", "committedDate": "2020-08-07T17:59:42Z", "type": "commit"}, {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7", "url": "https://github.com/grpc/grpc-java/commit/09e5276429b949546dc7e310c11c88a0c29428d7", "message": "Fix race for cluster being removed while adding new clusters.", "committedDate": "2020-08-07T17:59:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1Mzg1MA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467253850", "bodyText": "Why all these INFO logs? We shouldn't be logging anything in normal flows.", "author": "ejona86", "createdAt": "2020-08-07T20:27:55Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);", "originalCommit": "09e5276429b949546dc7e310c11c88a0c29428d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NzYwNg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467287606", "bodyText": "It's different, XdsLogLevel.INFO corresponds to JUL's FINER (see \n  \n    \n      grpc-java/xds/src/main/java/io/grpc/xds/XdsLogger.java\n    \n    \n        Lines 89 to 102\n      in\n      19d690b\n    \n    \n    \n    \n\n        \n          \n             /** \n        \n\n        \n          \n              * Log levels. See the table below for the mapping from the XdsLogger levels to \n        \n\n        \n          \n              * Java logger levels. \n        \n\n        \n          \n              * <pre> \n        \n\n        \n          \n              * +---------------------+-------------------+ \n        \n\n        \n          \n              * | XdsLogger Level     | Java Logger Level | \n        \n\n        \n          \n              * +---------------------+-------------------+ \n        \n\n        \n          \n              * | DEBUG               | FINEST            | \n        \n\n        \n          \n              * | INFO                | FINER             | \n        \n\n        \n          \n              * | WARNING             | FINE              | \n        \n\n        \n          \n              * | ERROR               | FINE              | \n        \n\n        \n          \n              * +---------------------+-------------------+ \n        \n\n        \n          \n              * </pre> \n        \n\n        \n          \n              */ \n        \n    \n  \n\n).", "author": "voidzcy", "createdAt": "2020-08-07T21:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1Mzg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NTQ1Mg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467255452", "bodyText": "Why generate a JSON string? Why not the data structure directly?", "author": "ejona86", "createdAt": "2020-08-07T20:31:52Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    String serviceConfigJson = generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfigJson);\n+    ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private ConfigOrError parseServiceConfig(String serviceConfigJson) {\n+    Map<String, ?> serviceConfig;\n+    try {\n+      serviceConfig = (Map<String, ?>) JsonParser.parse(serviceConfigJson);\n+    } catch (IOException e) {\n+      return ConfigOrError.fromError(\n+          Status.INTERNAL.withCause(e).withDescription(\"bug: malformed service config\"));\n+    }\n+    return serviceConfigParser.parseServiceConfig(serviceConfig);\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    StringBuilder sb = new StringBuilder();", "originalCommit": "09e5276429b949546dc7e310c11c88a0c29428d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NjQ1Mw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467286453", "bodyText": "Yeah, previously we used to generate the data structure, I mean parsed JSON (aka, Map<String, ?>). But that was hard to read given that most times the config is deeply nested and reviewers were usually having hard time (from my personal experience) following the logic of maps of maps of maps, etc. If you are talking about directly generate the parsed service config (aka, ManagedChannelServiceConfig), isn't that kept as channel's internal on purpose so that plugins do not depend on that API?", "author": "voidzcy", "createdAt": "2020-08-07T21:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MjA0MA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470442040", "bodyText": "As we discussed offline, switched to generating Map<String, ?> instead of doing string concatenation. I still keep the way of using JsonParser and JSON string for doing testing, as that is much easier for verifying the output and read/maintain the test.", "author": "voidzcy", "createdAt": "2020-08-14T06:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NTc0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467255747", "bodyText": "Just use wildcard service/method?", "author": "ejona86", "createdAt": "2020-08-07T20:32:33Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    String serviceConfigJson = generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfigJson);\n+    ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private ConfigOrError parseServiceConfig(String serviceConfigJson) {\n+    Map<String, ?> serviceConfig;\n+    try {\n+      serviceConfig = (Map<String, ?>) JsonParser.parse(serviceConfigJson);\n+    } catch (IOException e) {\n+      return ConfigOrError.fromError(\n+          Status.INTERNAL.withCause(e).withDescription(\"bug: malformed service config\"));\n+    }\n+    return serviceConfigParser.parseServiceConfig(serviceConfig);\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\n\");\n+    sb.append(\"  \\\"methodConfig\\\": [{\\n\");\n+    sb.append(\"    \\\"name\\\": [{\\n\");\n+    sb.append(\"      \\\"service\\\": \\\"\" + serviceName + \"\\\",\\n\");", "originalCommit": "09e5276429b949546dc7e310c11c88a0c29428d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NjMzMQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470856331", "bodyText": "Fixed, see the same comment below.", "author": "voidzcy", "createdAt": "2020-08-14T20:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NjMwNA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467256304", "bodyText": "Cluster is not escaped properly. Are we sure it doesn't contain special characters?", "author": "ejona86", "createdAt": "2020-08-07T20:34:02Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    String serviceConfigJson = generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfigJson);\n+    ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private ConfigOrError parseServiceConfig(String serviceConfigJson) {\n+    Map<String, ?> serviceConfig;\n+    try {\n+      serviceConfig = (Map<String, ?>) JsonParser.parse(serviceConfigJson);\n+    } catch (IOException e) {\n+      return ConfigOrError.fromError(\n+          Status.INTERNAL.withCause(e).withDescription(\"bug: malformed service config\"));\n+    }\n+    return serviceConfigParser.parseServiceConfig(serviceConfig);\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\n\");\n+    sb.append(\"  \\\"methodConfig\\\": [{\\n\");\n+    sb.append(\"    \\\"name\\\": [{\\n\");\n+    sb.append(\"      \\\"service\\\": \\\"\" + serviceName + \"\\\",\\n\");\n+    sb.append(\"      \\\"method\\\": \\\"\" + methodName + \"\\\"\\n\");\n+    sb.append(\"    }],\\n\");\n+    sb.append(\"    \\\"timeout\\\": \\\"\" + timeoutNano / 1_000_000_000.0 + \"s\\\"\\n\");\n+    sb.append(\"  }]\\n\");\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithLoadBalancingConfig(Collection<String> clusters) {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\n\");\n+    sb.append(\"  \\\"loadBalancingConfig\\\": [{\\n\");\n+    sb.append(\"    \\\"cluster_manager_experimental\\\": {\\n\");\n+    sb.append(\"      \\\"childPolicy\\\": {\\n\");\n+    int i = 0;\n+    for (String cluster : clusters) {\n+      sb.append(\"        \\\"\" + cluster + \"\\\": {\\n\");\n+      sb.append(\"          \\\"lbPolicy\\\": [{\\n\");\n+      sb.append(\"            \\\"cds_experimental\\\": {\\n\");\n+      sb.append(\"              \\\"cluster\\\": \\\"\" + cluster + \"\\\"\\n\");", "originalCommit": "09e5276429b949546dc7e310c11c88a0c29428d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8ad3313c6d4aac296c3b24f7d8bcfa8abb83c7cc", "url": "https://github.com/grpc/grpc-java/commit/8ad3313c6d4aac296c3b24f7d8bcfa8abb83c7cc", "message": "Generate Java service config struct instead of doing string concatenation.", "committedDate": "2020-08-12T22:45:22Z", "type": "commit"}, {"oid": "fda028939f53058885e0050d103c0d43d26316bb", "url": "https://github.com/grpc/grpc-java/commit/fda028939f53058885e0050d103c0d43d26316bb", "message": "Delete unused variable.", "committedDate": "2020-08-13T21:29:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNTY1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r468225657", "bodyText": "\"route\" can mean a lot of things. Should we say \"Could not find xDS route matching RPC\"?", "author": "ejona86", "createdAt": "2020-08-10T22:42:17Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));", "originalCommit": "09e5276429b949546dc7e310c11c88a0c29428d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0ODE2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470848165", "bodyText": "Sure, improved.", "author": "voidzcy", "createdAt": "2020-08-14T20:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNTY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNjU4NA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r468226584", "bodyText": "How is it possible to get here with a null cluster? Aren't we guaranteed to have a cluster result here? How is it possible to go through the if or the else and not choose a cluster?", "author": "ejona86", "createdAt": "2020-08-10T22:45:01Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly", "originalCommit": "09e5276429b949546dc7e310c11c88a0c29428d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MzIwMw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470853203", "bodyText": "Yeah, this should never ever happen. The converted data should be guaranteed to be valid (aka, the weighted clusters list should have at least one cluster). I added that validation in the logic of parsing weighted clusters.", "author": "voidzcy", "createdAt": "2020-08-14T20:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNzc0MA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r468227740", "bodyText": "I don't think we want to do the service config generation and parsing for each RPC. That code should not be placed on the critical path, as we don't want performance pressure placed on it. It seems we should generate them ahead-of-time and just use the config object here.\nThis can be fine as a first cut, but we should consider when we'll improve it.", "author": "ejona86", "createdAt": "2020-08-10T22:48:32Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(", "originalCommit": "09e5276429b949546dc7e310c11c88a0c29428d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI3MzQ2MA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r474273460", "bodyText": "Putted a TODO item there.", "author": "voidzcy", "createdAt": "2020-08-20T21:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTk4Ng==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470661986", "bodyText": "\"Failed to load xds bootstrap\" or \"xds failed to bootstrap\"\nWe need \"xds\" or something like that in the message. Otherwise there's no clue what this is talking about.", "author": "ejona86", "createdAt": "2020-08-14T14:35:28Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MzI3OA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470853278", "bodyText": "Updated.", "author": "voidzcy", "createdAt": "2020-08-14T20:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2NDA3NA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470664074", "bodyText": "This seems a weird place for this class. I'd expect it to be either near its usage (start()) or after the normal methods (shutdown()).", "author": "ejona86", "createdAt": "2020-08-14T14:39:27Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MzgxNA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470853814", "bodyText": "Will address and format classes/methods correctly after all the other comments are addresses (just to avoid moving blocks of code around and make the review hard).", "author": "voidzcy", "createdAt": "2020-08-14T20:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2NDA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470673003", "bodyText": "This seems unnecessarily brittle. It seems we could really easily just fail the one RPC instead of bringing down the entire channel. I could understand doing this if we were really confident in our service config generation, but given user data is placed inside it it seems very possible that it is broken for just some inputs.", "author": "ejona86", "createdAt": "2020-08-14T14:50:21Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4NzM4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470887382", "bodyText": "Right. I had discussion with @dapengzhang0 at #7275 (comment) about this. I was more leaning towards making the config in the result of selectConfig() a ConfigOrError (instead of just the config Object) such that the client call has the option to fail the RPC or proceed with no method config. In either case, the client call needs to invoke the callback after it.\nThe other option as you mentioned here is to fail the selectConfig() operation, even if the call can be routed to a cluster.\nI do not have strong opinion between the two, while slightly leaning towards the first one as it seems to be more flexible for client call and the handling is slightly cleaner (i.e., it is always the call that releases the cluster).", "author": "voidzcy", "createdAt": "2020-08-14T22:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MzYxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471673619", "bodyText": "I was more leaning towards making the config in the result of selectConfig() a ConfigOrError (instead of just the config Object) such that the client call has the option to fail the RPC or proceed with no method config.\n\nWhy would the client call have a better idea of how to proceed? It is very clear in this code that we don't know the configuration to use. I don't understand how client call could fabricate some configuration that would make things \"okay.\"\n\nThe other option as you mentioned here is to fail the selectConfig() operation, even if the call can be routed to a cluster.\n\nIt can't be routed to the cluster though. We may know which cluster, but we don't know what configuration to use to that cluster. So we can't send any traffic to it. For all we know there is fault injection configuration to fail 100% of the calls.", "author": "ejona86", "createdAt": "2020-08-17T18:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY4NTU2NA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471685564", "bodyText": "It is very clear in this code that we don't know the configuration to use. I don't understand how client call could fabricate some configuration that would make things \"okay.\"\n\nBasically, the Result contains the cluster name (which we may know as you said even if the configuration is not known), and a ConfigOrError that contains the error for fail to get the configuration. So the client call takes the responsibility of whether or not to fail the call for cases that cluster name is known while configuration is invalid. Doesn't this sound better?", "author": "voidzcy", "createdAt": "2020-08-17T18:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY5MTE1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471691157", "bodyText": "So the client call takes the responsibility of whether or not to fail the call for cases that cluster name is known while configuration is invalid.\n\nWhat is the advantage? I was claiming that not failing the call is broken. We must fail the call.", "author": "ejona86", "createdAt": "2020-08-17T18:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcwNjIwMg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471706202", "bodyText": "Just some flexibility the API provides to client calls. If the answer is call should be failed for sure, then we do not need such flexibility. I will fix it.", "author": "voidzcy", "createdAt": "2020-08-17T18:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0ODk0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r472548947", "bodyText": "Fixed. It returns an error Result (and release the cluster in-place) if parsing config encounter error.", "author": "voidzcy", "createdAt": "2020-08-18T23:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3NjA2OA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470676068", "bodyText": "I know it isn't necessary, but for sanity's sake can we do this within the syncContext?", "author": "ejona86", "createdAt": "2020-08-14T14:55:24Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4NzU4OA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470887588", "bodyText": "Sounds fair, no consequence for removing it later. Changed.", "author": "voidzcy", "createdAt": "2020-08-14T22:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3NjA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3ODY3Ng==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470678676", "bodyText": "Reuse the same config selector? That would allow ManagedChannelImpl to avoid the AtomicReference.set() when the selector is identical to the previous version, if it wants to. It also makes it more obvious that it doesn't have internal state.", "author": "ejona86", "createdAt": "2020-08-14T14:59:48Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NDE0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470854141", "bodyText": "Fixed, using a single config selector instance for all resolution result update.", "author": "voidzcy", "createdAt": "2020-08-14T20:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3ODY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4MDA3OA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470680078", "bodyText": "Put google/error-prone#1767 as the comment.", "author": "ejona86", "createdAt": "2020-08-14T15:02:15Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NDE2Nw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470854167", "bodyText": "Done.", "author": "voidzcy", "createdAt": "2020-08-14T20:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4MDA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4NjY1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470686657", "bodyText": "This says what it does but does not provide a hint as to why. The ordering here is very important.\n\"Make newly added clusters selectable by config selector.\" could maybe change to \"Make newly added clusters selectable by config selector and deleted clusters no longer selectable.\"", "author": "ejona86", "createdAt": "2020-08-14T15:13:43Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NDM4Nw==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470854387", "bodyText": "Good point. Put them together to reflect the ordering.", "author": "voidzcy", "createdAt": "2020-08-14T20:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4NjY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4OTM4Ng==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470689386", "bodyText": "This isn't right. This loops through \"all deleted clusters,\" not \"all newly deleted clusters.\" Consider receiving the same update twice; both updates will run decrementAndGet() for the same clusters.", "author": "ejona86", "createdAt": "2020-08-14T15:18:40Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MDQyMg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470880422", "bodyText": "Good catch! I missed this consideration. Fixed now and added a test case to cover such case.", "author": "voidzcy", "createdAt": "2020-08-14T21:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4OTM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5MjczOA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470692738", "bodyText": "What happened to the nanosecond portion? Was it just dropped on the floor?", "author": "ejona86", "createdAt": "2020-08-14T15:23:13Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    String timeout = timeoutNano / 1_000_000_000.0 + \"s\";", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NjA3NQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470856075", "bodyText": "No, it's not. Actually the test case covers it. It's at generateServiceConfig_forMethodTimeoutConfig where the input timeout is 1 second plus 1 nanosecond, the output is 1.000000001s", "author": "voidzcy", "createdAt": "2020-08-14T20:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5MjczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2ODIwNQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471668205", "bodyText": "Oh, I missed this was stored into a string.", "author": "ejona86", "createdAt": "2020-08-17T18:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5MjczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5NjUwOQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470696509", "bodyText": "As I mentioned before, why not use wildcard service/method name?", "author": "ejona86", "createdAt": "2020-08-14T15:27:11Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    String timeout = timeoutNano / 1_000_000_000.0 + \"s\";\n+    Map<String, String> serviceMethod = new HashMap<>();\n+    serviceMethod.put(\"service\", serviceName);", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NjEzNg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470856136", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2020-08-14T20:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5NjUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5ODUyMA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470698520", "bodyText": "Delete?", "author": "ejona86", "createdAt": "2020-08-14T15:30:44Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    String timeout = timeoutNano / 1_000_000_000.0 + \"s\";\n+    Map<String, String> serviceMethod = new HashMap<>();\n+    serviceMethod.put(\"service\", serviceName);\n+    serviceMethod.put(\"method\", methodName);\n+    Map<String, Object> methodConfig = new HashMap<>();\n+    methodConfig.put(\n+        \"name\", Collections.singletonList(Collections.unmodifiableMap(serviceMethod)));\n+    methodConfig.put(\"timeout\", timeout);\n+    return Collections.singletonMap(\n+        \"methodConfig\", Collections.singletonList(Collections.unmodifiableMap(methodConfig)));\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithLoadBalancingConfig(Collection<String> clusters) {\n+    StringBuilder sb = new StringBuilder();", "originalCommit": "fda028939f53058885e0050d103c0d43d26316bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NjE4Ng==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470856186", "bodyText": "Oops, deleted.", "author": "voidzcy", "createdAt": "2020-08-14T20:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5ODUyMA=="}], "type": "inlineReview"}, {"oid": "5e385a1f1e5691e5a52465c5b320ed0bd4ddbe34", "url": "https://github.com/grpc/grpc-java/commit/5e385a1f1e5691e5a52465c5b320ed0bd4ddbe34", "message": "Delete unused code.", "committedDate": "2020-08-14T18:28:59Z", "type": "commit"}, {"oid": "484bf6322858c28091219385c8fca6326564d3f4", "url": "https://github.com/grpc/grpc-java/commit/484bf6322858c28091219385c8fca6326564d3f4", "message": "Delete should-never-happen code and improve status message.", "committedDate": "2020-08-14T20:05:24Z", "type": "commit"}, {"oid": "e337a996eb9fa5ef01f9ba53eaa6d856d2023fa9", "url": "https://github.com/grpc/grpc-java/commit/e337a996eb9fa5ef01f9ba53eaa6d856d2023fa9", "message": "Do not need to specify service/method for the generated method config.", "committedDate": "2020-08-14T20:14:03Z", "type": "commit"}, {"oid": "4b90b55beaaed35acac8d23f02ef2587ac716893", "url": "https://github.com/grpc/grpc-java/commit/4b90b55beaaed35acac8d23f02ef2587ac716893", "message": "Improve bootstrap failure message.", "committedDate": "2020-08-14T20:14:05Z", "type": "commit"}, {"oid": "bb739f294b0ddebff352a94b325400f8be42c6ed", "url": "https://github.com/grpc/grpc-java/commit/bb739f294b0ddebff352a94b325400f8be42c6ed", "message": "Add github issue link for error prone warning.", "committedDate": "2020-08-14T20:14:05Z", "type": "commit"}, {"oid": "f7c6bd8edd534ccf24ad547ea9bbdc7ae9c69543", "url": "https://github.com/grpc/grpc-java/commit/f7c6bd8edd534ccf24ad547ea9bbdc7ae9c69543", "message": "Ensure weighed clusters list contains at least one cluster.", "committedDate": "2020-08-14T20:33:24Z", "type": "forcePushed"}, {"oid": "5049c29d2230f0ade4005f3f6d56b0891b2b34d3", "url": "https://github.com/grpc/grpc-java/commit/5049c29d2230f0ade4005f3f6d56b0891b2b34d3", "message": "Use the same ConfigSelector instance.", "committedDate": "2020-08-14T21:10:20Z", "type": "commit"}, {"oid": "0a178a47c5a0b4be0b9609658ee16780f735de81", "url": "https://github.com/grpc/grpc-java/commit/0a178a47c5a0b4be0b9609658ee16780f735de81", "message": "Improve comment to reflect the ordering of updating selectable clusters before deleting non-selectable clusters.", "committedDate": "2020-08-14T21:10:22Z", "type": "commit"}, {"oid": "6d6c6cf63606256e7c6544491a75ea25e0bc3a07", "url": "https://github.com/grpc/grpc-java/commit/6d6c6cf63606256e7c6544491a75ea25e0bc3a07", "message": "Ensure weighed clusters list contains at least one cluster.", "committedDate": "2020-08-14T21:10:22Z", "type": "commit"}, {"oid": "8c9409428ab54c7a74d4831332e045ddc3ad67b6", "url": "https://github.com/grpc/grpc-java/commit/8c9409428ab54c7a74d4831332e045ddc3ad67b6", "message": "Should only mutate ref count for newly added/deleted clusters.", "committedDate": "2020-08-14T21:48:08Z", "type": "forcePushed"}, {"oid": "5baf3f10ade958a68a7ff08303c3973ea36d491b", "url": "https://github.com/grpc/grpc-java/commit/5baf3f10ade958a68a7ff08303c3973ea36d491b", "message": "Should only mutate ref count for newly added/deleted clusters.", "committedDate": "2020-08-14T21:51:15Z", "type": "forcePushed"}, {"oid": "922373baea2e025ebb13a5f743edcc1123564b07", "url": "https://github.com/grpc/grpc-java/commit/922373baea2e025ebb13a5f743edcc1123564b07", "message": "Should only mutate ref count for newly added/deleted clusters.", "committedDate": "2020-08-14T22:04:04Z", "type": "commit"}, {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003", "url": "https://github.com/grpc/grpc-java/commit/391c2e4909f1f9d5307db4bda3d8eefcb128f003", "message": "Run cluster removal operation in sync context.", "committedDate": "2020-08-14T22:04:06Z", "type": "commit"}, {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003", "url": "https://github.com/grpc/grpc-java/commit/391c2e4909f1f9d5307db4bda3d8eefcb128f003", "message": "Run cluster removal operation in sync context.", "committedDate": "2020-08-14T22:04:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0MzE4MA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471743180", "bodyText": "nit: XdsNameResolverProvider2", "author": "dapengzhang0", "createdAt": "2020-08-17T20:00:32Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Sets;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider", "originalCommit": "391c2e4909f1f9d5307db4bda3d8eefcb128f003", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0ODQ0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r472548442", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2020-08-18T23:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0MzE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0NzgxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471747819", "bodyText": "nit: move this to top. Usage of boostrapInfo should be put together.", "author": "dapengzhang0", "createdAt": "2020-08-17T20:09:50Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Sets;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+  private final ConfigSelector configSelector = new ConfigSelector();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(\n+          Status.UNAVAILABLE.withDescription(\"Failed to load xDS bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");", "originalCommit": "391c2e4909f1f9d5307db4bda3d8eefcb128f003", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0ODQyOQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r472548429", "bodyText": "Done.", "author": "voidzcy", "createdAt": "2020-08-18T23:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0NzgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc5MTMxOA==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471791318", "bodyText": "If the cluster is added back by onConfigChanged() in between above two lines, it will not putIfAbsent() to clusterRefs, and will be removed later by this runnable.", "author": "dapengzhang0", "createdAt": "2020-08-17T21:42:49Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Sets;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+  private final ConfigSelector configSelector = new ConfigSelector();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(\n+          Status.UNAVAILABLE.withDescription(\"Failed to load xDS bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Could not find xDS route matching RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodTimeoutConfig(\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(final String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        syncContext.execute(new Runnable() {", "originalCommit": "391c2e4909f1f9d5307db4bda3d8eefcb128f003", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgyNDA0OQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471824049", "bodyText": "If the cluster is added back by onConfigChanged() in between above two lines, it will not putIfAbsent() to clusterRefs\n\nGood point. I'll note that it is a problem even before remove() was moved into the sync context.\nIt looks like the for (String cluster : addedClusters) { is broken because it never calls retainCluster() if the cluster is already present; it had had zero references for the clusters in the set so it must acquire a reference for every cluster in addedClusters. In this case, retainCluster() would return false because the reference count couldn't be increased from 0\u21921.\nI'll say that I was bothered that releaseCluster() is passed a string instead of a specific object. That make would make fixing the bug easier. I wished the reference count was for a specific object whose reference was tied 1:1 with the reference count. That object could be AtomicInteger, but that seems a bit weird and hard to debug; we may want to extend AtomicInteger (or use AtomicIntegerFieldUpdater) to have it store the cluster name String as well.\nIf we leave things mostly-alone, then we could fix this by adding the missing retainCluster() to the addedClusters loop. If retainCluster() fails it would do the put(). We'd then also change release cluster to use the two-argument remove: clusterRefs.remove(cluster, atomicInteger).", "author": "ejona86", "createdAt": "2020-08-17T23:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc5MTMxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3NDE3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r472474179", "bodyText": "Before remove() is moved into the sync context, the race window is small. Yeah, but the problem does exists. But now, I think the fix isn't that complicated as add and remove operations for clusterRefs are all done in the sync context now.\nputIfAbsent() is no longer necessary (but clusterRefs still needs to be a concurrent map), we can just check if clusterRefs contains the cluster to be added. If it does, increment its ref count; if not, put AtomicInteger(1). These two steps do not need to be atomic. This fixes the problem of failing to add back clusters before the previous deleted one is removed from clusterRefs.\nWhen trying to remove the cluster with ref count 0 (also in the sync context), we need to check again its ref count is indeed 0. If it is, remove it from clusterRefs; if it is not, do nothing. These two steps do not need to be atomic as the the only chance that could increment the ref count from 0 to 1 is receiving a new update that adds the cluster back, which happens in the sync context. This prevents removing the cluster that is added back again after its ref count is 0.\nI added a test case (resolve_raceBetweenClusterReleasedAndResourceUpdateAddBackAgain) that reproduces this issue and now it is fixed.", "author": "voidzcy", "createdAt": "2020-08-18T20:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc5MTMxOA=="}], "type": "inlineReview"}, {"oid": "594dee0849c4d3d2cade702eafa0fab992ab1010", "url": "https://github.com/grpc/grpc-java/commit/594dee0849c4d3d2cade702eafa0fab992ab1010", "message": "style and typo.", "committedDate": "2020-08-18T00:53:24Z", "type": "commit"}, {"oid": "8138651f3ff7ba9e3c9d557b81e5b189eb8e499c", "url": "https://github.com/grpc/grpc-java/commit/8138651f3ff7ba9e3c9d557b81e5b189eb8e499c", "message": "Fix the race between a released cluster being removed and it is being added back in a new update.", "committedDate": "2020-08-18T20:28:15Z", "type": "commit"}, {"oid": "549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "url": "https://github.com/grpc/grpc-java/commit/549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "message": "Add test covering the case when a call is made such that a cluster is retained, and the cluster is removed and added back before the call finishes.", "committedDate": "2020-08-18T20:31:19Z", "type": "commit"}, {"oid": "549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "url": "https://github.com/grpc/grpc-java/commit/549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "message": "Add test covering the case when a call is made such that a cluster is retained, and the cluster is removed and added back before the call finishes.", "committedDate": "2020-08-18T20:31:19Z", "type": "forcePushed"}, {"oid": "a3e37c47cfad4f32a4a63e8b31669e115e96d946", "url": "https://github.com/grpc/grpc-java/commit/a3e37c47cfad4f32a4a63e8b31669e115e96d946", "message": "Fail config selection if parsing the generated config encounters error.", "committedDate": "2020-08-18T23:23:37Z", "type": "commit"}, {"oid": "d114bf4f3acd2ef5645dc38ccbcb398629dc0ae4", "url": "https://github.com/grpc/grpc-java/commit/d114bf4f3acd2ef5645dc38ccbcb398629dc0ae4", "message": "Add TODO for addressing the issue of generating and parsing config for each call.", "committedDate": "2020-08-18T23:27:10Z", "type": "commit"}, {"oid": "ebb5b5a955e9ee88e06aede7d0ff69cc0d660574", "url": "https://github.com/grpc/grpc-java/commit/ebb5b5a955e9ee88e06aede7d0ff69cc0d660574", "message": "Fixed style: rearrage methods/inner class, remove unnecessary annotations.", "committedDate": "2020-08-24T20:14:12Z", "type": "commit"}]}