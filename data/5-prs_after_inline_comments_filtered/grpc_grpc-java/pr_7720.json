{"pr_number": 7720, "pr_title": " check pending stream completion at delayed transport lifecycle", "pr_createdAt": "2020-12-11T00:20:14Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7720", "timeline": [{"oid": "ac999724b9610266a18d162830aaff7e6bef5d72", "url": "https://github.com/grpc/grpc-java/commit/ac999724b9610266a18d162830aaff7e6bef5d72", "message": "check pending stream completion at delayed transport lifecycle", "committedDate": "2020-12-10T20:23:58Z", "type": "commit"}, {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97", "url": "https://github.com/grpc/grpc-java/commit/1fe3bcea1d62dba739e36ac730caad1a78769c97", "message": "rename", "committedDate": "2020-12-10T22:40:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyMjU0Ng==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541222546", "bodyText": "You don't need the check, can always count down.", "author": "voidzcy", "createdAt": "2020-12-11T19:56:25Z", "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -302,7 +325,11 @@ public void run() {\n         listenerToClose.closed(reason, new Metadata());\n       }\n       drainPendingCalls();\n+      if (!isStreamTransferCompleted()) {", "originalCommit": "1fe3bcea1d62dba739e36ac730caad1a78769c97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDQ4NQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541224485", "bodyText": "Where is this signal checked? Why interrupting the cancellation thread works?", "author": "voidzcy", "createdAt": "2020-12-11T19:58:38Z", "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -132,6 +135,24 @@ final void setStream(ClientStream stream) {\n     drainPendingCalls();\n   }\n \n+  protected boolean isStreamTransferCompleted() {\n+    return realStreamStarted.getCount() == 0;\n+  }\n+\n+  protected void awaitStreamTransferCompletion() {\n+    // Wait until accepted RPCs transfer to the real stream so that we can properly cancel or\n+    // shutdown. Not waiting for transfer completion may cause pending calls orphaned. #636.\n+    boolean delegationComplete;\n+    try {\n+      delegationComplete = realStreamStarted.await(5, TimeUnit.SECONDS);\n+    } catch (InterruptedException ex) {\n+      delegationComplete = false;\n+    }\n+    if (!delegationComplete) {\n+      Thread.currentThread().interrupt();", "originalCommit": "1fe3bcea1d62dba739e36ac730caad1a78769c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUzMTM1NA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542531354", "bodyText": "To clarify this method is called at user cancel, shutdownNow() cancel, and reprocess once we detect shutdown() has been called. The interruption is handled no where, it will be propagated to the user(at ManagedChannelImpl main thread).\nThis path is only executed inside SyncContext where we only handle uncaught exceptions and put the channel into panic. And it looks like it is the only limited exception handling mechanism here at client side.\nI have been struggling when the failure handling here and am open for discussion. So I thought that either we have to enhance our exception propagation path, e.g. distinguish different exceptions and handle them at higher granularity. Before that, keeping it silent here looks generally inappropriate (today it is almost like that), so I interrupted the caller thread. The interruption can be handled at SyncContext, but then it seems better to propagate it out as well.", "author": "YifeiZhuang", "createdAt": "2020-12-14T16:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY3NDAzNA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542674034", "bodyText": "The interruption is handled no where, it will be propagated to the user(at ManagedChannelImpl main thread).\n\nIf the calling thread doesn't check its interrupted bit or isn't blocked on wait/join/sleep etc, it never knows. I don't think there is any case that this happens.\nI was expecting such an await to be somehow hooked up with Channel's awaitTermination(). That is, instead of doing synchronous wait, we use Future. Have you tried with that approach?", "author": "voidzcy", "createdAt": "2020-12-14T19:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY4Njc0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542686741", "bodyText": "I was expecting such an await to be somehow hooked up with Channel's awaitTermination(). That is, instead of doing synchronous wait, we use Future. Have you tried with that approach?\n\nI think it's already like that: awaitTermination() will be waiting for awaitTransferCompletion() here. So once awaitTransferCompletion() is done, dealyedTransport will be reporting termination through listener to ManagedChannelImpl to do further shutdown routine. Here just we set a time bound to awaitTransferCompletion(), as I thought that we perhaps should not wait forever(e.g. customer never call start() so the transfer would never be done. theoretically this can happen, but it won't for now, as we control that in ClientCallImpl shortly after we create the stream). But waiting forever is also an option.", "author": "YifeiZhuang", "createdAt": "2020-12-14T19:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyNDA5OA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542824098", "bodyText": "I think it's already like that: awaitTermination() will be waiting for awaitTransferCompletion() here.\n\nNow shutdownNow() may be synchronously waiting for awaitTransferCompletion() to complete. I don't think we want synchronous waits in the shutdown path. I am thinking of it'd be a callback for transfer completed (or cancelled), instead of a latch that needs to be waited on.", "author": "voidzcy", "createdAt": "2020-12-14T21:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkyNjQxNA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542926414", "bodyText": "Hm, potentially we can have settableFuture installed into delayedStream during reprocess() and then listen on the event when real stream started, and at the listener callback we check the shutdown status.", "author": "YifeiZhuang", "createdAt": "2020-12-14T23:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1MDY5OA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541250698", "bodyText": "The wait seems useless here. If it is delegating to realStream, all pending calls should have already been drained (the delayOrExecute for realStream.cancel() several lines above might be misleading, it's actually always executed inline). So at this point, the transfer is guaranteed to be done.", "author": "voidzcy", "createdAt": "2020-12-11T20:24:21Z", "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -302,7 +325,11 @@ public void run() {\n         listenerToClose.closed(reason, new Metadata());\n       }\n       drainPendingCalls();\n+      if (!isStreamTransferCompleted()) {\n+        realStreamStarted.countDown();\n+      }\n     }\n+    awaitStreamTransferCompletion();", "originalCommit": "1fe3bcea1d62dba739e36ac730caad1a78769c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUzODI1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542538259", "bodyText": "Hm, it seems not necessarily.\nIf the real stream is set, (L127) drainingPendingCall is not in sync path, so there is still some time window where the  delegation flag is set but the call not drained, i.e. start() not executed. So we await.\nAlso, in non delegation case, wait for noop count down should not hurt.", "author": "YifeiZhuang", "createdAt": "2020-12-14T16:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1MDY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY0NzYzMw==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542647633", "bodyText": "Oh, you are right. It may still be draining existing calls and the cancellation is added to the end, we need to wait.", "author": "voidzcy", "createdAt": "2020-12-14T18:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1MDY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgwMjc3NA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542802774", "bodyText": "But still, cancel() itself doesn't need to be waiting on the transfer to complete, right?", "author": "voidzcy", "createdAt": "2020-12-14T21:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1MDY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkxNjkwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542916901", "bodyText": "Good catch, it seems can be remove here. Because normally cancel() should not be waiting for transfer to complete. And when the last item was cancelled, I already checked the shutdown status in the subclass and would call awaitStreamTransferCompletion() for termination.", "author": "YifeiZhuang", "createdAt": "2020-12-14T23:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1MDY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1NzIyMQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541257221", "bodyText": "nit: public is redundant and this should be @VisibleForTesting .\nBut since there is already a getUncommittedStreamsCount() for testing, I don't think this method is useful anymore. All invocations to this method are already holding the lock and calling !toCheckCompletionStreams.isEmpty() is equally concise as calling this method.", "author": "voidzcy", "createdAt": "2020-12-11T20:31:07Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -252,13 +277,26 @@ public final boolean hasPendingStreams() {\n     }\n   }\n \n+  public final boolean hasUncommittedStreams() {", "originalCommit": "1fe3bcea1d62dba739e36ac730caad1a78769c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4MDkwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542780901", "bodyText": "Thanks. Actually get count is test only @visibleForTesting, but check emptiness is used in several places in the code path in a few methods and as a short version of the previous to make the code more concise.", "author": "YifeiZhuang", "createdAt": "2020-12-14T21:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1NzIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxNTc2Mg==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542815762", "bodyText": "I mean it should be private or eliminated (if use !toCheckCompletionStreams.isEmpty() directly, which is less verbose IMO).", "author": "voidzcy", "createdAt": "2020-12-14T21:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1NzIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2OTcwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541269701", "bodyText": "May not want to make excessive changes.", "author": "voidzcy", "createdAt": "2020-12-11T20:44:24Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -322,9 +373,10 @@ public void run() {\n         // transport starting streams and setting in-use state.  During the gap the whole channel's\n         // in-use state may be false. However, it shouldn't cause spurious switching to idleness\n         // (which would shutdown the transports and LoadBalancer) because the gap should be shorter\n-        // than IDLE_MODE_DEFAULT_TIMEOUT_MILLIS (1 second).\n+        // than IDLE_MODE_DEFAULT_TIMEOUT_MILLIS (30 millis).", "originalCommit": "1fe3bcea1d62dba739e36ac730caad1a78769c97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "url": "https://github.com/grpc/grpc-java/commit/eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "message": "fix travis test", "committedDate": "2020-12-14T05:37:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYwNjUyOQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542606529", "bodyText": "Make it final?", "author": "dapengzhang0", "createdAt": "2020-12-14T18:21:36Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -66,6 +66,23 @@\n   @Nonnull\n   @GuardedBy(\"lock\")\n   private Collection<PendingStream> pendingStreams = new LinkedHashSet<>();\n+  @GuardedBy(\"lock\")\n+  private Collection<PendingStream> toCheckCompletionStreams = new LinkedHashSet<>();\n+  private Runnable pollForStreamTransferCompletion = new Runnable() {", "originalCommit": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzMzcwMg==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542633702", "bodyText": "Note that getCount() is typically used for debugging and testing purposes. https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html#getCount()\nBetter avoid it in the main source if possible.", "author": "dapengzhang0", "createdAt": "2020-12-14T18:46:12Z", "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -132,6 +135,24 @@ final void setStream(ClientStream stream) {\n     drainPendingCalls();\n   }\n \n+  protected boolean isStreamTransferCompleted() {\n+    return realStreamStarted.getCount() == 0;", "originalCommit": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1NzA3Mg==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542657072", "bodyText": "I would prefer making toCheckCompletionStreams be either 'non-final and immutable' or 'final and mutable', but not 'non-final' and 'mutable'.", "author": "dapengzhang0", "createdAt": "2020-12-14T19:05:57Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -270,48 +308,61 @@ final int getPendingStreamsCount() {\n    * <p>This method <strong>must not</strong> be called concurrently with itself.\n    */\n   final void reprocess(@Nullable SubchannelPicker picker) {\n-    ArrayList<PendingStream> toProcess;\n+    ArrayList<PendingStream> toCreateRealStream;\n+    ArrayList<PendingStream> toCheckCompletion;\n     synchronized (lock) {\n       lastPicker = picker;\n       lastPickerVersion++;\n-      if (picker == null || !hasPendingStreams()) {\n+      if ((picker == null || !hasPendingStreams()) && !hasUncommittedStreams()) {\n         return;\n       }\n-      toProcess = new ArrayList<>(pendingStreams);\n+      toCreateRealStream = new ArrayList<>(pendingStreams);\n+      toCheckCompletion = new ArrayList<>(toCheckCompletionStreams);\n     }\n-    ArrayList<PendingStream> toRemove = new ArrayList<>();\n+    ArrayList<PendingStream> newlyCreated = new ArrayList<>();\n \n-    for (final PendingStream stream : toProcess) {\n-      PickResult pickResult = picker.pickSubchannel(stream.args);\n-      CallOptions callOptions = stream.args.getCallOptions();\n-      final ClientTransport transport = GrpcUtil.getTransportFromPickResult(pickResult,\n-          callOptions.isWaitForReady());\n-      if (transport != null) {\n-        Executor executor = defaultAppExecutor;\n-        // createRealStream may be expensive. It will start real streams on the transport. If\n-        // there are pending requests, they will be serialized too, which may be expensive. Since\n-        // we are now on transport thread, we need to offload the work to an executor.\n-        if (callOptions.getExecutor() != null) {\n-          executor = callOptions.getExecutor();\n-        }\n-        executor.execute(new Runnable() {\n+\n+    if (picker != null) {\n+      for (final PendingStream stream : toCreateRealStream) {\n+        PickResult pickResult = picker.pickSubchannel(stream.args);\n+        CallOptions callOptions = stream.args.getCallOptions();\n+        final ClientTransport transport = GrpcUtil.getTransportFromPickResult(pickResult,\n+            callOptions.isWaitForReady());\n+        if (transport != null) {\n+          Executor executor = defaultAppExecutor;\n+          // createRealStream may be expensive. It will start real streams on the transport. If\n+          // there are pending requests, they will be serialized too, which may be expensive. Since\n+          // we are now on transport thread, we need to offload the work to an executor.\n+          if (callOptions.getExecutor() != null) {\n+            executor = callOptions.getExecutor();\n+          }\n+          executor.execute(new Runnable() {\n             @Override\n             public void run() {\n               stream.createRealStream(transport);\n             }\n           });\n-        toRemove.add(stream);\n-      }  // else: stay pending\n+          newlyCreated.add(stream);\n+        }  // else: stay pending\n+      }\n+    }\n+    toCheckCompletion.addAll(newlyCreated);\n+    ArrayList<PendingStream> completed = new ArrayList<>();\n+    for (final PendingStream stream : toCheckCompletion) {\n+      if (stream.isStreamTransferCompleted()) {\n+        completed.add(stream);\n+      }\n     }\n-\n     synchronized (lock) {\n       // Between this synchronized and the previous one:\n       //   - Streams may have been cancelled, which may turn pendingStreams into emptiness.\n-      //   - shutdown() may be called, which may turn pendingStreams into null.\n-      if (!hasPendingStreams()) {\n+      //   - shutdownNow() may be called, which may turn pendingStreams into emptiness.\n+      if (!hasPendingStreams() && !hasUncommittedStreams()) {\n         return;\n       }\n-      pendingStreams.removeAll(toRemove);\n+      pendingStreams.removeAll(newlyCreated);\n+      toCheckCompletionStreams.addAll(newlyCreated);", "originalCommit": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2MjgxMQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542662811", "bodyText": "What about using the same name for toCheckCompletionStreams and uncommittedStreams?", "author": "dapengzhang0", "createdAt": "2020-12-14T19:11:11Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -252,13 +277,26 @@ public final boolean hasPendingStreams() {\n     }\n   }\n \n+  public final boolean hasUncommittedStreams() {\n+    synchronized (lock) {\n+      return !toCheckCompletionStreams.isEmpty();\n+    }\n+  }\n+\n   @VisibleForTesting\n   final int getPendingStreamsCount() {\n     synchronized (lock) {\n       return pendingStreams.size();\n     }\n   }\n \n+  @VisibleForTesting\n+  final int getUncommittedStreamsCount() {\n+    synchronized (lock) {\n+      return toCheckCompletionStreams.size();", "originalCommit": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2NjAxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542666019", "bodyText": "You don't need copy the list, just saving the reference should be sufficient.", "author": "dapengzhang0", "createdAt": "2020-12-14T19:14:04Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -66,6 +66,23 @@\n   @Nonnull\n   @GuardedBy(\"lock\")\n   private Collection<PendingStream> pendingStreams = new LinkedHashSet<>();\n+  @GuardedBy(\"lock\")\n+  private Collection<PendingStream> toCheckCompletionStreams = new LinkedHashSet<>();\n+  private Runnable pollForStreamTransferCompletion = new Runnable() {\n+    @Override\n+    public void run() {\n+      ArrayList<PendingStream> savedToCheckCompletionStreams;\n+      synchronized (lock) {\n+        savedToCheckCompletionStreams = new ArrayList<>(toCheckCompletionStreams);", "originalCommit": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MzQzOA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542743438", "bodyText": "I think changing this line is not necessary. Regardless of hasUncommittedStreams, if return then stream.createRealStream() or drain() will not be called and will not cause trouble.", "author": "dapengzhang0", "createdAt": "2020-12-14T20:25:39Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -270,48 +308,61 @@ final int getPendingStreamsCount() {\n    * <p>This method <strong>must not</strong> be called concurrently with itself.\n    */\n   final void reprocess(@Nullable SubchannelPicker picker) {\n-    ArrayList<PendingStream> toProcess;\n+    ArrayList<PendingStream> toCreateRealStream;\n+    ArrayList<PendingStream> toCheckCompletion;\n     synchronized (lock) {\n       lastPicker = picker;\n       lastPickerVersion++;\n-      if (picker == null || !hasPendingStreams()) {\n+      if ((picker == null || !hasPendingStreams()) && !hasUncommittedStreams()) {", "originalCommit": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc1ODg2OA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542758868", "bodyText": "This line is because it needs to take care another case: when shutdown() is called but there are still uncommittedStreams, the shutdown path would return, then it will never shutdown. It relied on reprocess() to trigger the termination. (Similar to cancel() takes care of the last item and then trigger termination callback). This is different in shudownNow() which would take care of waiting uncommitted streams and then finalize termination.", "author": "YifeiZhuang", "createdAt": "2020-12-14T20:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MzQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyMzIwMg==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542823202", "bodyText": "hen shutdown() is called but there are still uncommittedStreams, the shutdown path would return, then it will never shutdown. It relied on reprocess() to trigger the termination.\n\nuncommittedStreams can be considered as existing RPCs, so shutdown() should not terminate them. uncommittedStreams will complete transfer by themselves, and they don't rely on a second reprocess().", "author": "dapengzhang0", "createdAt": "2020-12-14T21:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MzQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5OTkwMA==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542899900", "bodyText": "shutdown() never terminates then existing RPCs.  Do you mean we await() during shutdown()?\nIt seems it's hard to avoid that. Say, if there are both pendingStreams and uncommittedStreams when shutdown is called, so shutdown has to return. Then during next reprocess(), the newly created stream has not been drained , which would cause pendingStreams empty but uncommittedstream still has items in it, and we need a way to drain it. It looks reprocess() is that place, it would trigger in the next call or after idle timer.", "author": "YifeiZhuang", "createdAt": "2020-12-14T22:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MzQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk0MTkyNw==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542941927", "bodyText": "I think we should await() during shutdown(), because there is no \"next\" reprocess() after shutdown, so we can not rely on reprocess() for existing uncommittedStreams.\nAnother way is introducing an abstract method DelayedStream.onTransferComplete(), and implementing DelayedClientTransport.PendingStream.onTransferComplete() to managed decrement of `uncommittedStreams.", "author": "dapengzhang0", "createdAt": "2020-12-15T00:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MzQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDc1MQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542964751", "bodyText": "Thanks. Indeed it appears that idle timeout is permanently cancelled immediately after shutdown is called so there is no next reprocess().  It looks like just awaitTransferCompletion() during shutdown is not enough, moreover, I believe generally we are not supposed to await() during shutdown.", "author": "YifeiZhuang", "createdAt": "2020-12-15T01:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MzQzOA=="}], "type": "inlineReview"}, {"oid": "b1f553a81385a5b5a61033302305a84cc03f6f46", "url": "https://github.com/grpc/grpc-java/commit/b1f553a81385a5b5a61033302305a84cc03f6f46", "message": "Fix syntax: immutability and started flag", "committedDate": "2020-12-14T21:06:32Z", "type": "commit"}, {"oid": "81ab463a3acfb4ef193d83dce8f22afabd24490c", "url": "https://github.com/grpc/grpc-java/commit/81ab463a3acfb4ef193d83dce8f22afabd24490c", "message": "Revert \"Fix syntax: immutability and started flag\"\n\nThis reverts commit b1f553a81385a5b5a61033302305a84cc03f6f46.", "committedDate": "2020-12-16T05:06:22Z", "type": "commit"}, {"oid": "193eb481ed3e82257355ef1569a3bc8758d7dbe3", "url": "https://github.com/grpc/grpc-java/commit/193eb481ed3e82257355ef1569a3bc8758d7dbe3", "message": "Revert \"fix travis test\"\n\nThis reverts commit eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91.", "committedDate": "2020-12-16T05:06:26Z", "type": "commit"}, {"oid": "930437585c0d98b228173973f15b9a0ff4e5dfc9", "url": "https://github.com/grpc/grpc-java/commit/930437585c0d98b228173973f15b9a0ff4e5dfc9", "message": "Revert \"rename\"\n\nThis reverts commit 1fe3bcea1d62dba739e36ac730caad1a78769c97.", "committedDate": "2020-12-16T05:06:28Z", "type": "commit"}, {"oid": "56374ddb865ca87986ab76f26b53013cfb59980c", "url": "https://github.com/grpc/grpc-java/commit/56374ddb865ca87986ab76f26b53013cfb59980c", "message": "Revert \"check pending stream completion at delayed transport lifecycle\"\n\nThis reverts commit ac999724b9610266a18d162830aaff7e6bef5d72.", "committedDate": "2020-12-16T05:06:29Z", "type": "commit"}, {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4", "url": "https://github.com/grpc/grpc-java/commit/502429067108066fcb2840b9daa31fc3de7cf7a4", "message": "transfer complete abstract class", "committedDate": "2020-12-16T05:33:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0OTQ1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544549456", "bodyText": "nit: public redundant.", "author": "voidzcy", "createdAt": "2020-12-16T19:03:40Z", "path": "core/src/main/java/io/grpc/internal/TransferableClientStream.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+/**\n+ * A logical {@link ClientStream} that does internal transfer processing of the clint requests.\n+ */\n+abstract class TransferableClientStream implements ClientStream {\n+\n+  /**\n+   * Provides the place to define actions at the point when transfer is done.\n+   * Call this method to trigger those transfer completion activities. No-op by default.\n+   */\n+  public void onTransferComplete() {", "originalCommit": "502429067108066fcb2840b9daa31fc3de7cf7a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NTAyNg==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544865026", "bodyText": "Why introduce yet another class? I would just add onTransferComplete() to DelayedStream (making DelayedStream abstract).", "author": "dapengzhang0", "createdAt": "2020-12-17T07:24:20Z", "path": "core/src/main/java/io/grpc/internal/TransferableClientStream.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+/**\n+ * A logical {@link ClientStream} that does internal transfer processing of the clint requests.\n+ */\n+abstract class TransferableClientStream implements ClientStream {", "originalCommit": "502429067108066fcb2840b9daa31fc3de7cf7a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2ODUwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544868501", "bodyText": "The operations should be atomic otherwise not thread-safe. Use AtomicBoolean.compareAndSet() or AtomicReferenceFieldUpdater.compareAndSet(), or check it inside lock.\nAn alternative is to guarantee onTransferComplete() is only called once per lifecycle of stream, then transferCompleted is not needed. (Currently, there is one case that cancel() and start() are in a race to call onTransferComplete(). This case can be excluded.)", "author": "dapengzhang0", "createdAt": "2020-12-17T07:31:53Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -362,15 +361,25 @@ private void createRealStream(ClientTransport transport) {\n     public void cancel(Status reason) {\n       super.cancel(reason);\n       synchronized (lock) {\n-        if (reportTransportTerminated != null) {\n-          boolean justRemovedAnElement = pendingStreams.remove(this);\n-          if (!hasPendingStreams() && justRemovedAnElement) {\n-            syncContext.executeLater(reportTransportNotInUse);\n-            if (shutdownStatus != null) {\n-              syncContext.executeLater(reportTransportTerminated);\n-              reportTransportTerminated = null;\n-            }\n-          }\n+        boolean justRemovedAnElement = pendingStreams.remove(this);\n+        if (!hasPendingStreams() && justRemovedAnElement && reportTransportTerminated != null) {\n+          syncContext.executeLater(reportTransportNotInUse);\n+        }\n+      }\n+      syncContext.drain();\n+    }\n+\n+    @Override\n+    public void onTransferComplete() {\n+      if (transferCompleted) {\n+        return;\n+      }\n+      transferCompleted = true;", "originalCommit": "502429067108066fcb2840b9daa31fc3de7cf7a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3NzYyMw==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544877623", "bodyText": "No need to check reportTransportTerminated != null after the change. Previously if reportTransportTerminated == null, pendingStream is guaranteed reset to empty and justRemovedAnElement will never happen.", "author": "dapengzhang0", "createdAt": "2020-12-17T07:49:49Z", "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -362,15 +361,25 @@ private void createRealStream(ClientTransport transport) {\n     public void cancel(Status reason) {\n       super.cancel(reason);\n       synchronized (lock) {\n-        if (reportTransportTerminated != null) {\n-          boolean justRemovedAnElement = pendingStreams.remove(this);\n-          if (!hasPendingStreams() && justRemovedAnElement) {\n-            syncContext.executeLater(reportTransportNotInUse);\n-            if (shutdownStatus != null) {\n-              syncContext.executeLater(reportTransportTerminated);\n-              reportTransportTerminated = null;\n-            }\n-          }\n+        boolean justRemovedAnElement = pendingStreams.remove(this);\n+        if (!hasPendingStreams() && justRemovedAnElement && reportTransportTerminated != null) {", "originalCommit": "502429067108066fcb2840b9daa31fc3de7cf7a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MTAxNg==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r545281016", "bodyText": "I was thinking that in time order: 1. super.cancel() 2.onTransferComplete(), reportTransportTerminated=null 3. this lock block might reportNotInUse, which won't happen previously.", "author": "YifeiZhuang", "createdAt": "2020-12-17T17:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3NzYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4NzMwNQ==", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r546887305", "bodyText": "I still think the check for reportTransportTerminated != null is unnecessary and the (!hasPendingStreams() && justRemovedAnElement) is the canonical invariant for reportTransportNotInUse. But ether way seems working anyway.", "author": "dapengzhang0", "createdAt": "2020-12-21T19:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3NzYyMw=="}], "type": "inlineReview"}, {"oid": "7022f5e10c71b739443d54835736822218d533a7", "url": "https://github.com/grpc/grpc-java/commit/7022f5e10c71b739443d54835736822218d533a7", "message": "make delayedStream abstract class and fix thread safetiness", "committedDate": "2020-12-17T18:07:26Z", "type": "commit"}, {"oid": "cf2d51bfea41772bda8f7b335ce23ea2c4d10f22", "url": "https://github.com/grpc/grpc-java/commit/cf2d51bfea41772bda8f7b335ce23ea2c4d10f22", "message": "non-final ApplierDelayedStream inner class", "committedDate": "2020-12-17T18:26:43Z", "type": "commit"}]}