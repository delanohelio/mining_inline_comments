{"pr_number": 7432, "pr_title": "core: Inline AbstractServerImplBuilder", "pr_createdAt": "2020-09-16T20:27:29Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7432", "timeline": [{"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75", "url": "https://github.com/grpc/grpc-java/commit/98a944d6b0a49e04af0c80a7af5975052ad49b75", "message": "core: Inline AbstractServerImplBuilder", "committedDate": "2020-09-16T20:24:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NTQ1OA==", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r490585458", "bodyText": "s/mean/meant/", "author": "ejona86", "createdAt": "2020-09-17T21:58:26Z", "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "diffHunk": "@@ -44,62 +105,234 @@\n    * Creates a new server builder with given transport servers provider.\n    */\n   public ServerImplBuilder(ClientTransportServersBuilder clientTransportServersBuilder) {\n-    this.clientTransportServersBuilder = Preconditions\n-        .checkNotNull(clientTransportServersBuilder, \"clientTransportServersBuilder\");\n+    this.clientTransportServersBuilder = checkNotNull(clientTransportServersBuilder,\n+        \"clientTransportServersBuilder\");\n   }\n \n   @Override\n-  protected List<? extends InternalServer> buildTransportServers(\n-      List<? extends ServerStreamTracer.Factory> streamTracerFactories) {\n-    return clientTransportServersBuilder.buildClientTransportServers(streamTracerFactories);\n+  public ServerImplBuilder directExecutor() {\n+    return executor(MoreExecutors.directExecutor());\n   }\n \n   @Override\n-  public void setDeadlineTicker(Deadline.Ticker ticker) {\n-    super.setDeadlineTicker(ticker);\n+  public ServerImplBuilder executor(@Nullable Executor executor) {\n+    this.executorPool = executor != null ? new FixedObjectPool<>(executor) : DEFAULT_EXECUTOR_POOL;\n+    return this;\n   }\n \n   @Override\n-  public void setTracingEnabled(boolean value) {\n-    super.setTracingEnabled(value);\n+  public ServerImplBuilder addService(ServerServiceDefinition service) {\n+    registryBuilder.addService(checkNotNull(service, \"service\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsEnabled(boolean value) {\n-    super.setStatsEnabled(value);\n+  public ServerImplBuilder addService(BindableService bindableService) {\n+    return addService(checkNotNull(bindableService, \"bindableService\").bindService());\n   }\n \n   @Override\n-  public void setStatsRecordStartedRpcs(boolean value) {\n-    super.setStatsRecordStartedRpcs(value);\n+  public ServerImplBuilder addTransportFilter(ServerTransportFilter filter) {\n+    transportFilters.add(checkNotNull(filter, \"filter\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsRecordFinishedRpcs(boolean value) {\n-    super.setStatsRecordFinishedRpcs(value);\n+  public ServerImplBuilder intercept(ServerInterceptor interceptor) {\n+    interceptors.add(checkNotNull(interceptor, \"interceptor\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder addStreamTracerFactory(ServerStreamTracer.Factory factory) {\n+    streamTracerFactories.add(checkNotNull(factory, \"factory\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder fallbackHandlerRegistry(@Nullable HandlerRegistry registry) {\n+    this.fallbackRegistry = registry != null ? registry : DEFAULT_FALLBACK_REGISTRY;\n+    return this;\n   }\n \n   @Override\n+  public ServerImplBuilder decompressorRegistry(@Nullable DecompressorRegistry registry) {\n+    this.decompressorRegistry = registry != null ? registry : DEFAULT_DECOMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder compressorRegistry(@Nullable CompressorRegistry registry) {\n+    this.compressorRegistry = registry != null ? registry : DEFAULT_COMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder handshakeTimeout(long timeout, TimeUnit unit) {\n+    checkArgument(timeout > 0, \"handshake timeout is %s, but must be positive\", timeout);\n+    this.handshakeTimeoutMillis = checkNotNull(unit, \"unit\").toMillis(timeout);\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder setBinaryLog(@Nullable BinaryLog binaryLog) {\n+    this.binlog = binaryLog;\n+    return this;\n+  }\n+\n+  /**\n+   * Disable or enable stats features.  Enabled by default.\n+   */\n+  public void setStatsEnabled(boolean value) {\n+    this.statsEnabled = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC upstarts.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordStartedRpcs(boolean value) {\n+    recordStartedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC completions.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordFinishedRpcs(boolean value) {\n+    recordFinishedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable real-time metrics recording.  Effective only if {@link #setStatsEnabled} is\n+   * set to true.  Disabled by default.\n+   */\n   public void setStatsRecordRealTimeMetrics(boolean value) {\n-    super.setStatsRecordRealTimeMetrics(value);\n+    recordRealTimeMetrics = value;\n+  }\n+\n+  /**\n+   * Disable or enable tracing features.  Enabled by default.\n+   */\n+  public void setTracingEnabled(boolean value) {\n+    tracingEnabled = value;\n+  }\n+\n+  /**\n+   * Sets a custom deadline ticker.  This should only be called from InProcessServerBuilder.\n+   */\n+  public void setDeadlineTicker(Deadline.Ticker ticker) {\n+    this.ticker = checkNotNull(ticker, \"ticker\");\n   }\n \n   @Override\n+  public Server build() {\n+    return new ServerImpl(this, buildTransportServers(getTracerFactories()), Context.ROOT);\n+  }\n+\n+  @VisibleForTesting\n+  List<? extends ServerStreamTracer.Factory> getTracerFactories() {\n+    ArrayList<ServerStreamTracer.Factory> tracerFactories = new ArrayList<>();\n+    if (statsEnabled) {\n+      ServerStreamTracer.Factory censusStatsTracerFactory = null;\n+      try {\n+        Class<?> censusStatsAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusStatsAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusStatsAccessor.getDeclaredMethod(\n+                \"getServerStreamTracerFactory\",\n+                boolean.class,\n+                boolean.class,\n+                boolean.class);\n+        censusStatsTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod\n+                .invoke(\n+                    null,\n+                    recordStartedRpcs,\n+                    recordFinishedRpcs,\n+                    recordRealTimeMetrics);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (censusStatsTracerFactory != null) {\n+        tracerFactories.add(censusStatsTracerFactory);\n+      }\n+    }\n+    if (tracingEnabled) {\n+      ServerStreamTracer.Factory tracingStreamTracerFactory = null;\n+      try {\n+        Class<?> censusTracingAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusTracingAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusTracingAccessor.getDeclaredMethod(\"getServerStreamTracerFactory\");\n+        tracingStreamTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod.invoke(null);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (tracingStreamTracerFactory != null) {\n+        tracerFactories.add(tracingStreamTracerFactory);\n+      }\n+    }\n+    tracerFactories.addAll(streamTracerFactories);\n+    tracerFactories.trimToSize();\n+    return Collections.unmodifiableList(tracerFactories);\n+  }\n+\n   public InternalChannelz getChannelz() {\n-    return super.getChannelz();\n+    return channelz;\n   }\n \n-  @Override\n+  /**\n+   * Transport implementors must implement {@link ClientTransportServersBuilder} to transport\n+   * specific information for the server. This method is mean for Transport implementors and should", "originalCommit": "98a944d6b0a49e04af0c80a7af5975052ad49b75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzQ4Ng==", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r490587486", "bodyText": "I wouldn't expect any transports to need this method and I don't see any references. It seems it could be made private or inlined into build(). If you want to keep it for ServerImplBuilderTest, then the javadoc comment isn't really appropriate.", "author": "ejona86", "createdAt": "2020-09-17T22:03:33Z", "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "diffHunk": "@@ -44,62 +105,234 @@\n    * Creates a new server builder with given transport servers provider.\n    */\n   public ServerImplBuilder(ClientTransportServersBuilder clientTransportServersBuilder) {\n-    this.clientTransportServersBuilder = Preconditions\n-        .checkNotNull(clientTransportServersBuilder, \"clientTransportServersBuilder\");\n+    this.clientTransportServersBuilder = checkNotNull(clientTransportServersBuilder,\n+        \"clientTransportServersBuilder\");\n   }\n \n   @Override\n-  protected List<? extends InternalServer> buildTransportServers(\n-      List<? extends ServerStreamTracer.Factory> streamTracerFactories) {\n-    return clientTransportServersBuilder.buildClientTransportServers(streamTracerFactories);\n+  public ServerImplBuilder directExecutor() {\n+    return executor(MoreExecutors.directExecutor());\n   }\n \n   @Override\n-  public void setDeadlineTicker(Deadline.Ticker ticker) {\n-    super.setDeadlineTicker(ticker);\n+  public ServerImplBuilder executor(@Nullable Executor executor) {\n+    this.executorPool = executor != null ? new FixedObjectPool<>(executor) : DEFAULT_EXECUTOR_POOL;\n+    return this;\n   }\n \n   @Override\n-  public void setTracingEnabled(boolean value) {\n-    super.setTracingEnabled(value);\n+  public ServerImplBuilder addService(ServerServiceDefinition service) {\n+    registryBuilder.addService(checkNotNull(service, \"service\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsEnabled(boolean value) {\n-    super.setStatsEnabled(value);\n+  public ServerImplBuilder addService(BindableService bindableService) {\n+    return addService(checkNotNull(bindableService, \"bindableService\").bindService());\n   }\n \n   @Override\n-  public void setStatsRecordStartedRpcs(boolean value) {\n-    super.setStatsRecordStartedRpcs(value);\n+  public ServerImplBuilder addTransportFilter(ServerTransportFilter filter) {\n+    transportFilters.add(checkNotNull(filter, \"filter\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsRecordFinishedRpcs(boolean value) {\n-    super.setStatsRecordFinishedRpcs(value);\n+  public ServerImplBuilder intercept(ServerInterceptor interceptor) {\n+    interceptors.add(checkNotNull(interceptor, \"interceptor\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder addStreamTracerFactory(ServerStreamTracer.Factory factory) {\n+    streamTracerFactories.add(checkNotNull(factory, \"factory\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder fallbackHandlerRegistry(@Nullable HandlerRegistry registry) {\n+    this.fallbackRegistry = registry != null ? registry : DEFAULT_FALLBACK_REGISTRY;\n+    return this;\n   }\n \n   @Override\n+  public ServerImplBuilder decompressorRegistry(@Nullable DecompressorRegistry registry) {\n+    this.decompressorRegistry = registry != null ? registry : DEFAULT_DECOMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder compressorRegistry(@Nullable CompressorRegistry registry) {\n+    this.compressorRegistry = registry != null ? registry : DEFAULT_COMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder handshakeTimeout(long timeout, TimeUnit unit) {\n+    checkArgument(timeout > 0, \"handshake timeout is %s, but must be positive\", timeout);\n+    this.handshakeTimeoutMillis = checkNotNull(unit, \"unit\").toMillis(timeout);\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder setBinaryLog(@Nullable BinaryLog binaryLog) {\n+    this.binlog = binaryLog;\n+    return this;\n+  }\n+\n+  /**\n+   * Disable or enable stats features.  Enabled by default.\n+   */\n+  public void setStatsEnabled(boolean value) {\n+    this.statsEnabled = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC upstarts.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordStartedRpcs(boolean value) {\n+    recordStartedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC completions.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordFinishedRpcs(boolean value) {\n+    recordFinishedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable real-time metrics recording.  Effective only if {@link #setStatsEnabled} is\n+   * set to true.  Disabled by default.\n+   */\n   public void setStatsRecordRealTimeMetrics(boolean value) {\n-    super.setStatsRecordRealTimeMetrics(value);\n+    recordRealTimeMetrics = value;\n+  }\n+\n+  /**\n+   * Disable or enable tracing features.  Enabled by default.\n+   */\n+  public void setTracingEnabled(boolean value) {\n+    tracingEnabled = value;\n+  }\n+\n+  /**\n+   * Sets a custom deadline ticker.  This should only be called from InProcessServerBuilder.\n+   */\n+  public void setDeadlineTicker(Deadline.Ticker ticker) {\n+    this.ticker = checkNotNull(ticker, \"ticker\");\n   }\n \n   @Override\n+  public Server build() {\n+    return new ServerImpl(this, buildTransportServers(getTracerFactories()), Context.ROOT);\n+  }\n+\n+  @VisibleForTesting\n+  List<? extends ServerStreamTracer.Factory> getTracerFactories() {\n+    ArrayList<ServerStreamTracer.Factory> tracerFactories = new ArrayList<>();\n+    if (statsEnabled) {\n+      ServerStreamTracer.Factory censusStatsTracerFactory = null;\n+      try {\n+        Class<?> censusStatsAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusStatsAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusStatsAccessor.getDeclaredMethod(\n+                \"getServerStreamTracerFactory\",\n+                boolean.class,\n+                boolean.class,\n+                boolean.class);\n+        censusStatsTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod\n+                .invoke(\n+                    null,\n+                    recordStartedRpcs,\n+                    recordFinishedRpcs,\n+                    recordRealTimeMetrics);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (censusStatsTracerFactory != null) {\n+        tracerFactories.add(censusStatsTracerFactory);\n+      }\n+    }\n+    if (tracingEnabled) {\n+      ServerStreamTracer.Factory tracingStreamTracerFactory = null;\n+      try {\n+        Class<?> censusTracingAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusTracingAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusTracingAccessor.getDeclaredMethod(\"getServerStreamTracerFactory\");\n+        tracingStreamTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod.invoke(null);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (tracingStreamTracerFactory != null) {\n+        tracerFactories.add(tracingStreamTracerFactory);\n+      }\n+    }\n+    tracerFactories.addAll(streamTracerFactories);\n+    tracerFactories.trimToSize();\n+    return Collections.unmodifiableList(tracerFactories);\n+  }\n+\n   public InternalChannelz getChannelz() {\n-    return super.getChannelz();\n+    return channelz;\n   }\n \n-  @Override\n+  /**\n+   * Transport implementors must implement {@link ClientTransportServersBuilder} to transport\n+   * specific information for the server. This method is mean for Transport implementors and should\n+   * not be used by normal users.\n+   *\n+   * @param streamTracerFactories an immutable list of stream tracer factories\n+   */\n+  @VisibleForTesting\n+  List<? extends InternalServer> buildTransportServers(", "originalCommit": "98a944d6b0a49e04af0c80a7af5975052ad49b75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA0MDU0OA==", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r491040548", "bodyText": "I don't think that single test valuable anymore, so I went with removing the test, and inlining buildTransportServers into build.", "author": "sergiitk", "createdAt": "2020-09-18T15:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzQ4Ng=="}], "type": "inlineReview"}, {"oid": "fb2b307b09e03c21711cb19773c35dec2ebda25a", "url": "https://github.com/grpc/grpc-java/commit/fb2b307b09e03c21711cb19773c35dec2ebda25a", "message": "fixup! core: Inline AbstractServerImplBuilder", "committedDate": "2020-09-18T15:41:38Z", "type": "commit"}, {"oid": "cdb818337968502b7c155372c165229ff5e7d83b", "url": "https://github.com/grpc/grpc-java/commit/cdb818337968502b7c155372c165229ff5e7d83b", "message": "fixup! error prone suggestions", "committedDate": "2020-09-18T16:12:22Z", "type": "commit"}]}