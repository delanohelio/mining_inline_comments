{"pr_number": 6809, "pr_title": "xds: parse RDS response to ConfigUpdate for path matching", "pr_createdAt": "2020-03-06T01:38:34Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6809", "timeline": [{"oid": "f8a4f2f1409cb1598d4746546ca71838b3f4a257", "url": "https://github.com/grpc/grpc-java/commit/f8a4f2f1409cb1598d4746546ca71838b3f4a257", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-06T01:50:20Z", "type": "forcePushed"}, {"oid": "e9d59da1e2af0e45b70ef87f15c06a1de936b3dc", "url": "https://github.com/grpc/grpc-java/commit/e9d59da1e2af0e45b70ef87f15c06a1de936b3dc", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T19:27:29Z", "type": "forcePushed"}, {"oid": "30469ae0d032a69b834f6fbbaf6d0a539614a1cf", "url": "https://github.com/grpc/grpc-java/commit/30469ae0d032a69b834f6fbbaf6d0a539614a1cf", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T19:33:42Z", "type": "forcePushed"}, {"oid": "bdca2ab2775a9c4840a930438ca6514299c15381", "url": "https://github.com/grpc/grpc-java/commit/bdca2ab2775a9c4840a930438ca6514299c15381", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T19:43:26Z", "type": "forcePushed"}, {"oid": "0a63d8c6259c0afc3b66797be6cef3174193edcd", "url": "https://github.com/grpc/grpc-java/commit/0a63d8c6259c0afc3b66797be6cef3174193edcd", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T19:55:42Z", "type": "forcePushed"}, {"oid": "b2c12bb842b2f1ded9ccab2a84c11a03f56ca7cc", "url": "https://github.com/grpc/grpc-java/commit/b2c12bb842b2f1ded9ccab2a84c11a03f56ca7cc", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T20:18:38Z", "type": "forcePushed"}, {"oid": "1fd886f34af45f042190f888ff0411bbf4cd61a9", "url": "https://github.com/grpc/grpc-java/commit/1fd886f34af45f042190f888ff0411bbf4cd61a9", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T20:23:39Z", "type": "forcePushed"}, {"oid": "821921d4b5eea842b969e8e7121e7e2068af203b", "url": "https://github.com/grpc/grpc-java/commit/821921d4b5eea842b969e8e7121e7e2068af203b", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T23:11:06Z", "type": "commit"}, {"oid": "821921d4b5eea842b969e8e7121e7e2068af203b", "url": "https://github.com/grpc/grpc-java/commit/821921d4b5eea842b969e8e7121e7e2068af203b", "message": "xds: parse RDS response to ConfigUpdate for path matching", "committedDate": "2020-03-10T23:11:06Z", "type": "forcePushed"}, {"oid": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "url": "https://github.com/grpc/grpc-java/commit/2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java into parse-rds-for-xdsrouting", "committedDate": "2020-03-12T22:27:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MDk2Mg==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391970962", "bodyText": "Would be better to make them private and have getters.", "author": "voidzcy", "createdAt": "2020-03-13T00:23:19Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +340,194 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.Route}. */\n+  static final class Route {\n+    final RouteMatch routeMatch;", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwMzEzMg==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392503132", "bodyText": "This is just style preference. I'll do so for consistency in this class.", "author": "dapengzhang0", "createdAt": "2020-03-13T21:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MDk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjU1OA==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391976558", "bodyText": "What's the benefit of using Optional?  Using Optional for class field type is considered harmful (see this SO answer although it refers to Java8's Optional. Btw, Guava's Javadoc recommends users to use Java 8's Optional instead). Just use nullable.", "author": "voidzcy", "createdAt": "2020-03-13T00:48:17Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +340,194 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.Route}. */\n+  static final class Route {\n+    final RouteMatch routeMatch;\n+    final Optional<RouteAction> routeAction;", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQzNzI3Ng==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392437276", "bodyText": "The benefit:\nhttps://github.com/google/guava/wiki/UsingAndAvoidingNullExplained#whats-the-point\nThat might be opinionated as well as the SO.", "author": "dapengzhang0", "createdAt": "2020-03-13T19:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwNTc3Ng==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392505776", "bodyText": "According to its Javadoc, the most common usages for Optional are:\n\nAs a method return type, as an alternative to returning null to indicate that no value was available\nTo distinguish between \"unknown\" (for example, not present in a map) and \"known to have no value\" (present in the map, with value Optional.absent())\nTo wrap nullable references for storage in a collection that does not support null (though there are several other approaches to this that should be considered first)\n\nIt's not for usage of avoiding nullness just for convenience. This usage is completely an abuse, even your IDE will warn you \"Optional used as type for field\". For details, read the first item of Optional Anti-Patterns.", "author": "voidzcy", "createdAt": "2020-03-13T22:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMzI1NA==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392513254", "bodyText": "For the IDE waring and Optional Anti-Patterns, it's only a problem when you want to serialize the class. The usage here is the first one in the javadoc, though the field can be just nullable to be exactly the case.", "author": "dapengzhang0", "createdAt": "2020-03-13T22:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxOTIzOQ==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392519239", "bodyText": "\"Anti-pattern\" indicates it's a rule-of-thumb convention that you should avoid, even though it may not cause problem now. It's a bad practice to do that and it's more likely to cause problem in the future. I do not see any benefit than a nullable field (which is more elegant and efficient). Why using Optional as a class field type is the first category of usage (i.e., as return type)? The first category of usage is referring to the following pattern:\nclass Foo {\n   // nullable\n   private Bar bar;\n\n  Optional<Bar> getBar() {\n     // ...\n  }\n}", "author": "voidzcy", "createdAt": "2020-03-13T22:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3Njg1Nw==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391976857", "bodyText": "Getters would be better. Ditto.", "author": "voidzcy", "createdAt": "2020-03-13T00:49:40Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +340,194 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.Route}. */\n+  static final class Route {\n+    final RouteMatch routeMatch;\n+    final Optional<RouteAction> routeAction;\n+\n+    Route(RouteMatch routeMatch, Optional<RouteAction> routeAction) {\n+      this.routeMatch = routeMatch;\n+      this.routeAction = routeAction;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Route route = (Route) o;\n+      return Objects.equals(routeMatch, route.routeMatch)\n+          && Objects.equals(routeAction, route.routeAction);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(routeMatch, routeAction);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"routeMatch\", routeMatch)\n+          .add(\"routeAction\", routeAction)\n+          .toString();\n+    }\n+\n+    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      Optional<RouteAction> routeAction = Optional.absent();\n+      if (proto.hasRoute()) {\n+        routeAction = Optional.of(RouteAction.fromEnvoyProtoRouteAction(proto.getRoute()));\n+      }\n+      return new Route(routeMatch, routeAction);\n+    }\n+  }\n+\n+  /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n+  static final class RouteMatch {\n+    final String prefix;", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3ODExMA==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391978110", "bodyText": "Use Boolean.parseBoolean(...).", "author": "voidzcy", "createdAt": "2020-03-13T00:55:35Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -90,6 +92,10 @@\n   static final String ADS_TYPE_URL_EDS =\n       \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n \n+  // For now we do not support path matching unless enabled manually.\n+  private static boolean enablePathMatching = String.valueOf(true).equalsIgnoreCase(", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3OTYwNg==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391979606", "bodyText": "routes would never be null. Ditto below.", "author": "voidzcy", "createdAt": "2020-03-13T01:02:27Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -624,18 +632,26 @@ private void handleLdsResponseForConfigUpdate(DiscoveryResponse ldsResponse) {\n     adsStream.sendAckRequest(ADS_TYPE_URL_LDS, ImmutableList.of(ldsResourceName),\n         ldsResponse.getVersionInfo());\n \n-    if (clusterName != null || rdsRouteConfigName != null) {\n+    if (routes != null || rdsRouteConfigName != null) {", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyMTY5OA==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392421698", "bodyText": "routes initially is null. It's assigned conditionally. Why would route never be null?", "author": "dapengzhang0", "createdAt": "2020-03-13T19:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3OTYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwNzg3MQ==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392507871", "bodyText": "You are right. It's conditionally assigned.", "author": "voidzcy", "createdAt": "2020-03-13T22:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3OTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MDI0Mw==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391980243", "bodyText": "nit: the sentence has grammatical error, rephrase.", "author": "voidzcy", "createdAt": "2020-03-13T01:05:24Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -842,24 +869,98 @@ static String findClusterNameInRouteConfig(RouteConfiguration config, String hos\n       }\n     }\n \n+    List<EnvoyProtoData.Route> routes = new ArrayList<>();\n     // Proceed with the virtual host that has longest wildcard matched domain name with the\n     // hostname in original \"xds:\" URI.\n     // Note we would consider upstream cluster not found if the virtual host is not configured\n     // correctly for gRPC, even if there exist other virtual hosts with (lower priority)\n     // matching domains.\n     if (targetVirtualHost != null) {\n-      // The client will look only at the last route in the list (the default route),\n-      // whose match field must contain a prefix field whose value is empty string\n-      // and whose route field must be set.\n-      List<Route> routes = targetVirtualHost.getRoutesList();\n-      if (!routes.isEmpty()) {\n-        Route route = routes.get(routes.size() - 1);\n-        if (route.getMatch().getPrefix().isEmpty()) {\n-          if (route.hasRoute()) {\n-            return route.getRoute().getCluster();\n-          }\n+      List<Route> routesProto = targetVirtualHost.getRoutesList();\n+      for (Route route : routesProto) {\n+        routes.add(EnvoyProtoData.Route.fromEnvoyProtoRoute(route));\n+      }\n+    }\n+    return routes;\n+  }\n+\n+  /**\n+   * Validates the given list of routes and return error details if there's any error.\n+   */\n+  // We only validate the default route unless path matching is enabled.\n+  // We do more validation if path matching is enabled, but whether every single route should be", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MDI3Mg==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391980272", "bodyText": "nit: returns", "author": "voidzcy", "createdAt": "2020-03-13T01:05:30Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -842,24 +869,98 @@ static String findClusterNameInRouteConfig(RouteConfiguration config, String hos\n       }\n     }\n \n+    List<EnvoyProtoData.Route> routes = new ArrayList<>();\n     // Proceed with the virtual host that has longest wildcard matched domain name with the\n     // hostname in original \"xds:\" URI.\n     // Note we would consider upstream cluster not found if the virtual host is not configured\n     // correctly for gRPC, even if there exist other virtual hosts with (lower priority)\n     // matching domains.\n     if (targetVirtualHost != null) {\n-      // The client will look only at the last route in the list (the default route),\n-      // whose match field must contain a prefix field whose value is empty string\n-      // and whose route field must be set.\n-      List<Route> routes = targetVirtualHost.getRoutesList();\n-      if (!routes.isEmpty()) {\n-        Route route = routes.get(routes.size() - 1);\n-        if (route.getMatch().getPrefix().isEmpty()) {\n-          if (route.hasRoute()) {\n-            return route.getRoute().getCluster();\n-          }\n+      List<Route> routesProto = targetVirtualHost.getRoutesList();\n+      for (Route route : routesProto) {\n+        routes.add(EnvoyProtoData.Route.fromEnvoyProtoRoute(route));\n+      }\n+    }\n+    return routes;\n+  }\n+\n+  /**\n+   * Validates the given list of routes and return error details if there's any error.", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MDQ5Mg==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391980492", "bodyText": "nit: if it is something TBD. Mark it as TODO. Also I would suggest rephrasing the sentence .", "author": "voidzcy", "createdAt": "2020-03-13T01:06:31Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -842,24 +869,98 @@ static String findClusterNameInRouteConfig(RouteConfiguration config, String hos\n       }\n     }\n \n+    List<EnvoyProtoData.Route> routes = new ArrayList<>();\n     // Proceed with the virtual host that has longest wildcard matched domain name with the\n     // hostname in original \"xds:\" URI.\n     // Note we would consider upstream cluster not found if the virtual host is not configured\n     // correctly for gRPC, even if there exist other virtual hosts with (lower priority)\n     // matching domains.\n     if (targetVirtualHost != null) {\n-      // The client will look only at the last route in the list (the default route),\n-      // whose match field must contain a prefix field whose value is empty string\n-      // and whose route field must be set.\n-      List<Route> routes = targetVirtualHost.getRoutesList();\n-      if (!routes.isEmpty()) {\n-        Route route = routes.get(routes.size() - 1);\n-        if (route.getMatch().getPrefix().isEmpty()) {\n-          if (route.hasRoute()) {\n-            return route.getRoute().getCluster();\n-          }\n+      List<Route> routesProto = targetVirtualHost.getRoutesList();\n+      for (Route route : routesProto) {\n+        routes.add(EnvoyProtoData.Route.fromEnvoyProtoRoute(route));\n+      }\n+    }\n+    return routes;\n+  }\n+\n+  /**\n+   * Validates the given list of routes and return error details if there's any error.\n+   */\n+  // We only validate the default route unless path matching is enabled.\n+  // We do more validation if path matching is enabled, but whether every single route should be\n+  // valid or any type of error can be skipped is TBD. For now we consider the whole list invalid on\n+  // any single error.\n+  @Nullable\n+  private static String validateRoutes(List<EnvoyProtoData.Route> routes) {\n+    if (routes.isEmpty()) {\n+      return \"No routes found\";\n+    }\n+\n+    if (!enablePathMatching) {\n+      EnvoyProtoData.Route route = routes.get(routes.size() - 1);\n+      RouteMatch routeMatch = route.routeMatch;\n+      if (!routeMatch.path.isEmpty() || !routeMatch.prefix.isEmpty() || routeMatch.hasRegex) {\n+        return \"The last route must be the default route\";\n+      }\n+      if (!route.routeAction.isPresent()) {\n+        return \"Route action is not specified for the default route\";\n+      }\n+      if (route.routeAction.get().cluster.isEmpty()) {\n+        return \"Cluster is not specified for the default route\";\n+      }\n+      return null;\n+    }\n+\n+    Set<String> prefixMatches = new HashSet<>();\n+    Set<String> pathMatches = new HashSet<>();\n+    for (int i = 0; i < routes.size(); i++) {\n+      EnvoyProtoData.Route route = routes.get(i);\n+\n+      if (!route.routeAction.isPresent()) {\n+        return \"Route action is not specified for one of the routes\";\n+      }\n+\n+      RouteMatch routeMatch = route.routeMatch;\n+      String prefix = routeMatch.prefix;\n+      String path = routeMatch.path;\n+      // Whether some of the errors can be skipped is TBD.", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MjQwNA==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391982404", "bodyText": "This INFO log will print a list of complex structures, which is not appropriate for INFO level logs. Use INFO level logging to print concise descriptions for those routes or just print out the number of routes found. INFO level log messages are intended to be concise and informative.", "author": "voidzcy", "createdAt": "2020-03-13T01:15:22Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -786,25 +804,34 @@ private void handleRdsResponse(DiscoveryResponse rdsResponse) {\n \n     // Notify the ConfigWatcher if this RDS response contains the most recently requested\n     // RDS resource.\n-    if (clusterName != null) {\n+    if (routes != null) {\n       if (rdsRespTimer != null) {\n         rdsRespTimer.cancel();\n         rdsRespTimer = null;\n       }\n-      logger.log(XdsLogLevel.INFO, \"Found cluster name: {0}\", clusterName);\n-      ConfigUpdate configUpdate = ConfigUpdate.newBuilder().setClusterName(clusterName).build();\n+\n+      // Found clusterName in the in-lined RouteConfiguration.\n+      String clusterName = routes.get(routes.size() - 1).routeAction.get().cluster;\n+      if (!enablePathMatching) {\n+        logger.log(XdsLogLevel.INFO, \"Found cluster name: {0}\", clusterName);\n+      } else {\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Found routes: {0}\", routes);", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQzNDM1NA==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392434354", "bodyText": "Changed to DEBUG level. INFO level only logs count now.", "author": "dapengzhang0", "createdAt": "2020-03-13T19:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MjUxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391982511", "bodyText": "cluster name is always queried, why only logged when path matching is enabled?", "author": "voidzcy", "createdAt": "2020-03-13T01:15:51Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -786,25 +804,34 @@ private void handleRdsResponse(DiscoveryResponse rdsResponse) {\n \n     // Notify the ConfigWatcher if this RDS response contains the most recently requested\n     // RDS resource.\n-    if (clusterName != null) {\n+    if (routes != null) {\n       if (rdsRespTimer != null) {\n         rdsRespTimer.cancel();\n         rdsRespTimer = null;\n       }\n-      logger.log(XdsLogLevel.INFO, \"Found cluster name: {0}\", clusterName);\n-      ConfigUpdate configUpdate = ConfigUpdate.newBuilder().setClusterName(clusterName).build();\n+\n+      // Found clusterName in the in-lined RouteConfiguration.\n+      String clusterName = routes.get(routes.size() - 1).routeAction.get().cluster;\n+      if (!enablePathMatching) {\n+        logger.log(XdsLogLevel.INFO, \"Found cluster name: {0}\", clusterName);", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyNTE5Mw==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392425193", "bodyText": "cluster name is logged when path matching is NOT enabled, which keeps the existing behavior.\nWhen path matching is enabled, it logs the whole list of routes. In this case, the default route (last in the list) may not be a cluster, it could be weighted clusters.", "author": "dapengzhang0", "createdAt": "2020-03-13T19:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MjUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNDg4MA==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392524880", "bodyText": "But cluster name (routes.get(routes.size() - 1).getRouteAction().get().getCluster()) is always queried and clusterName in ConfigUpdate is always set. Is that information used when path matching is enabled? If it is, it should be logged.", "author": "voidzcy", "createdAt": "2020-03-13T23:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MjUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjY4NQ==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392526685", "bodyText": "When path matching is enabled:\nIn the weighted cluster case (), getCluster() returns an empty string, it does not make sense to log the empty string. The xds-routing lb will only use the list of routes in configUpdate.\nWhen path matching is not enabled (existing behavior):\nThe getCluster() of the default (last) route should always return a valid cluster name, in that case we log it. The cds lb will only use the clusterName in configUpdate.", "author": "dapengzhang0", "createdAt": "2020-03-13T23:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MjUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MzEzMQ==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r391983131", "bodyText": "Would to rewrite the entire error message instead of just appending an error detail. Also, this entire message becomes the error_details field in the message sent to TD, you should avoid having a nested \"Error detail:\".", "author": "voidzcy", "createdAt": "2020-03-13T01:18:42Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -767,16 +783,18 @@ private void handleRdsResponse(DiscoveryResponse rdsResponse) {\n         XdsLogLevel.INFO, \"Received RDS response for resources: {0}\", routeConfigNames);\n \n     // Resolved cluster name for the requested resource, if exists.\n-    String clusterName = null;\n+    List<EnvoyProtoData.Route> routes = null;\n     if (requestedRouteConfig != null) {\n-      clusterName = findClusterNameInRouteConfig(requestedRouteConfig, ldsResourceName);\n-      if (clusterName == null) {\n+      routes = findRoutesInRouteConfig(requestedRouteConfig, ldsResourceName);\n+      String errorDetail = validateRoutes(routes);\n+      if (errorDetail != null) {\n         adsStream.sendNackRequest(\n             ADS_TYPE_URL_RDS, ImmutableList.of(adsStream.rdsResourceName),\n             rdsResponse.getVersionInfo(),\n             \"RouteConfiguration \" + requestedRouteConfig.getName() + \": cannot find a \"\n                 + \"valid cluster name in any virtual hosts with domains matching: \"\n-                + ldsResourceName);\n+                + ldsResourceName", "originalCommit": "2d9b5cd6ceafb1c15442213735f2b3916958a5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQzNDUyMQ==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392434521", "bodyText": "Rephrased.", "author": "dapengzhang0", "createdAt": "2020-03-13T19:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MzEzMQ=="}], "type": "inlineReview"}, {"oid": "0dfcf28778d5d92926c8cad9e2f1e75020567551", "url": "https://github.com/grpc/grpc-java/commit/0dfcf28778d5d92926c8cad9e2f1e75020567551", "message": "fix logging", "committedDate": "2020-03-13T19:39:51Z", "type": "commit"}, {"oid": "a365fa511990e2fbb32de1ab1b25d6db97af5fcc", "url": "https://github.com/grpc/grpc-java/commit/a365fa511990e2fbb32de1ab1b25d6db97af5fcc", "message": "getter pattern boilerplate", "committedDate": "2020-03-13T21:31:42Z", "type": "commit"}, {"oid": "1ccc7faae24a8ec35f7b6e47e26430f63fdf1b36", "url": "https://github.com/grpc/grpc-java/commit/1ccc7faae24a8ec35f7b6e47e26430f63fdf1b36", "message": "Boolean.parseBoolean and fix doc", "committedDate": "2020-03-13T21:51:07Z", "type": "commit"}, {"oid": "0ccfd8d555c9e95e60e1fd5169b2820e46778475", "url": "https://github.com/grpc/grpc-java/commit/0ccfd8d555c9e95e60e1fd5169b2820e46778475", "message": "add todo", "committedDate": "2020-03-13T21:55:44Z", "type": "commit"}, {"oid": "0ccfd8d555c9e95e60e1fd5169b2820e46778475", "url": "https://github.com/grpc/grpc-java/commit/0ccfd8d555c9e95e60e1fd5169b2820e46778475", "message": "add todo", "committedDate": "2020-03-13T21:55:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwODk0MQ==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392508941", "bodyText": "nit: be formal. If it is part of method specification, put it inside the head comment of this method. If it is about implementation details, put it at where the code logic is present. If it is your personal note, should just delete it.", "author": "voidzcy", "createdAt": "2020-03-13T22:12:00Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -842,24 +868,99 @@ static String findClusterNameInRouteConfig(RouteConfiguration config, String hos\n       }\n     }\n \n+    List<EnvoyProtoData.Route> routes = new ArrayList<>();\n     // Proceed with the virtual host that has longest wildcard matched domain name with the\n     // hostname in original \"xds:\" URI.\n     // Note we would consider upstream cluster not found if the virtual host is not configured\n     // correctly for gRPC, even if there exist other virtual hosts with (lower priority)\n     // matching domains.\n     if (targetVirtualHost != null) {\n-      // The client will look only at the last route in the list (the default route),\n-      // whose match field must contain a prefix field whose value is empty string\n-      // and whose route field must be set.\n-      List<Route> routes = targetVirtualHost.getRoutesList();\n-      if (!routes.isEmpty()) {\n-        Route route = routes.get(routes.size() - 1);\n-        if (route.getMatch().getPrefix().isEmpty()) {\n-          if (route.hasRoute()) {\n-            return route.getRoute().getCluster();\n-          }\n+      List<Route> routesProto = targetVirtualHost.getRoutesList();\n+      for (Route route : routesProto) {\n+        routes.add(EnvoyProtoData.Route.fromEnvoyProtoRoute(route));\n+      }\n+    }\n+    return routes;\n+  }\n+\n+  /**\n+   * Validates the given list of routes and returns error details if there's any error.\n+   */\n+  // We only validate the default route unless path matching is enabled.", "originalCommit": "0ccfd8d555c9e95e60e1fd5169b2820e46778475", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d9f3ee4e336379eba9dbde7fda2fc33b5fa12094", "url": "https://github.com/grpc/grpc-java/commit/d9f3ee4e336379eba9dbde7fda2fc33b5fa12094", "message": "nullable field", "committedDate": "2020-03-13T22:35:42Z", "type": "commit"}, {"oid": "fd5a0d137b1b751d80b128c357f1b074d1de806d", "url": "https://github.com/grpc/grpc-java/commit/fd5a0d137b1b751d80b128c357f1b074d1de806d", "message": "relocate comment", "committedDate": "2020-03-13T22:43:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNDE3Nw==", "url": "https://github.com/grpc/grpc-java/pull/6809#discussion_r392524177", "bodyText": "I would just prefer using nullable return value and all the other places used that (it doesn't give us much benefit for using Optional). But I am fine with this.", "author": "voidzcy", "createdAt": "2020-03-13T23:14:29Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +341,239 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.Route}. */\n+  static final class Route {\n+    private final RouteMatch routeMatch;\n+    @Nullable\n+    private final RouteAction routeAction;\n+\n+    @VisibleForTesting\n+    Route(RouteMatch routeMatch, @Nullable RouteAction routeAction) {\n+      this.routeMatch = routeMatch;\n+      this.routeAction = routeAction;\n+    }\n+\n+    RouteMatch getRouteMatch() {\n+      return routeMatch;\n+    }\n+\n+    Optional<RouteAction> getRouteAction() {", "originalCommit": "fd5a0d137b1b751d80b128c357f1b074d1de806d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}