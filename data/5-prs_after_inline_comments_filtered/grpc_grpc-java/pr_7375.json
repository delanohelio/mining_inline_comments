{"pr_number": 7375, "pr_title": "core, api, benchmarks: Random acts of garbage reduction", "pr_createdAt": "2020-08-28T00:57:53Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7375", "timeline": [{"oid": "3e3e8af5d4ab7382602d58ceec7343620cd7322f", "url": "https://github.com/grpc/grpc-java/commit/3e3e8af5d4ab7382602d58ceec7343620cd7322f", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths", "committedDate": "2020-08-28T02:26:17Z", "type": "forcePushed"}, {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d", "url": "https://github.com/grpc/grpc-java/commit/f661a1c522faf479eb905f48d1e826603a20b75d", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths", "committedDate": "2020-08-28T03:47:59Z", "type": "commit"}, {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d", "url": "https://github.com/grpc/grpc-java/commit/f661a1c522faf479eb905f48d1e826603a20b75d", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths", "committedDate": "2020-08-28T03:47:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3NzI5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516377297", "bodyText": "So this avoids the copy constructor from allocating the object. Nice. Since this is zero-size, would it be even better to share a single copy cross-instance?", "author": "ejona86", "createdAt": "2020-11-03T01:05:19Z", "path": "api/src/main/java/io/grpc/CallOptions.java", "diffHunk": "@@ -61,7 +61,7 @@\n   @Nullable\n   private String compressorName;\n \n-  private Object[][] customOptions = new Object[0][2];\n+  private Object[][] customOptions;", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MTYzNg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549981636", "bodyText": "It's already the case that there will be a single copy since the constructors are private and all instances derive from DEFAULT.", "author": "njhill", "createdAt": "2020-12-30T07:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3NzI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3ODY0Mw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516378643", "bodyText": "I don't think we want to \"cheat\" with these benchmarks. Most users will pay these same costs.\nIf we really wanted to optimize this, we would have a single pre-created ByteString and use it to build a new one of the needed size. That would avoid allocating/copying any of the data. But then it is really a lie.", "author": "ejona86", "createdAt": "2020-11-03T01:09:48Z", "path": "benchmarks/src/main/java/io/grpc/benchmarks/Utils.java", "diffHunk": "@@ -252,7 +253,7 @@ public static SimpleResponse makeResponse(SimpleRequest request) {\n         throw Status.INTERNAL.augmentDescription(\"Error creating payload.\").asRuntimeException();\n       }\n \n-      ByteString body = ByteString.copyFrom(new byte[request.getResponseSize()]);\n+      ByteString body = UnsafeByteOperations.unsafeWrap(new byte[request.getResponseSize()]);", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MTY4OQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549981689", "bodyText": "Sure I can revert it. I just thought it might help to isolate the actual grpc parts within the benchmarks, assuming that they're intended more for relative measurements than simulating a particular real-world use case.", "author": "njhill", "createdAt": "2020-12-30T07:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3ODY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3OTU1MA==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516379550", "bodyText": "Oh, interesting. I didn't realize IdentityHashMap avoided the Map.Entries.", "author": "ejona86", "createdAt": "2020-11-03T01:13:19Z", "path": "core/src/main/java/io/grpc/inprocess/InProcessTransport.java", "diffHunk": "@@ -96,7 +97,8 @@\n   @GuardedBy(\"this\")\n   private Status shutdownStatus;\n   @GuardedBy(\"this\")\n-  private Set<InProcessStream> streams = new HashSet<>();\n+  private Set<InProcessStream> streams = Collections.newSetFromMap(\n+          new IdentityHashMap<InProcessStream, Boolean>());", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMTE3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r517031177", "bodyText": "Can do the same for CronetClientTransport.", "author": "voidzcy", "createdAt": "2020-11-04T00:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3OTU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516380207", "bodyText": "What changed here? It looks the same. The old version grabbed a variable a few more times, but not only is the variable non-volatile, it's even final. So I can't believe it would actually make any difference.", "author": "ejona86", "createdAt": "2020-11-03T01:15:40Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -50,9 +58,9 @@ public void addBuffer(ReadableBuffer buffer) {\n     }\n \n     CompositeReadableBuffer compositeBuffer = (CompositeReadableBuffer) buffer;\n-    while (!compositeBuffer.buffers.isEmpty()) {\n-      ReadableBuffer subBuffer = compositeBuffer.buffers.remove();\n-      buffers.add(subBuffer);\n+    Queue<ReadableBuffer> otherBuffers = compositeBuffer.buffers;", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MTgzNw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549981837", "bodyText": "I agree it's unlikely to make much/any difference especially here, but seems cleaner and good general practice. I.e. in theory less pointer chasing in the loop. Or could be my OCD.", "author": "njhill", "createdAt": "2020-12-30T07:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3ODMwMw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r550278303", "bodyText": "I don't think I agree with \"good general practice.\" I expect the optimizer to do loop invariant hoisting. For simple cases like this I'd put it in the same category as 'optimizing' /2 with >>1 or simplifying 1 + 2 to 3. But this isn't even that hot of a loop. With reasonably-sized buffers, it seems impossible to ever notice this optimization, even if we assume the processor isn't faster executing the later occurrences or the interpreter was being used.\nThe \"cleaner\" part for me was combining buffers.add() and the remove() onto the same line. But the original author could have done that and actively chose not to. But adding otherBuffers actually the change overall less clean to my eyes. In any case the original code seems reasonable as-is, so it seems best not to touch it.", "author": "ejona86", "createdAt": "2020-12-30T17:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDU5MzA0MA==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r550593040", "bodyText": "Sure, I'll revert it! Yes the \"cleanliness\" is probably subjective, I have a general preference for minimizing indirections, other things being equal (regardless of perf implications). I don't quite agree that it's in the same category as >>1, 1 + 2 -> 3 since those have a more obvious readability tradeoff.", "author": "njhill", "createdAt": "2020-12-31T17:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDYwMw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516380603", "bodyText": "I was not a fan of the previous behavior. I prefer an approach like this... although this may not provide any benefit. Since execute() didn't leak the reference to op, I'd expect op to be allocated on the stack. Although maybe the interface being called messes things up (since an op could leak a reference to itself when called). I'd be willing to take this anyway.", "author": "ejona86", "createdAt": "2020-11-03T01:17:21Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjQwOQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516382409", "bodyText": "Name this as one, since it is not truly immutable.", "author": "ejona86", "createdAt": "2020-11-03T01:24:39Z", "path": "core/src/main/java/io/grpc/internal/ReflectionLongAdderCounter.java", "diffHunk": "@@ -97,10 +97,12 @@ static boolean isAvailable() {\n     return initializationException == null;\n   }\n \n+  private static final Object[] ONE = new Object[] { 1L };", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzEwMg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516393102", "bodyText": "It's unclear if this change improves or worsens performance. Now the type of the return value changes, so the JIT will not optimize the calling code as much. On the other hand, there is less indirection when length is present in a single buffer.", "author": "ejona86", "createdAt": "2020-11-03T02:09:50Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n+  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+      buffer.skipBytes(length);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void skipBytes(int length) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.skipBytes(length);\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n+  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+      buffer.readBytes(dest, offset, length);\n+      return offset + length;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final byte[] dest, final int destOffset, int length) {\n-    execute(new ReadOperation() {\n-      int currentOffset = destOffset;\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.readBytes(dest, currentOffset, length);\n-        currentOffset += length;\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(BYTE_ARRAY_OP, length, dest, destOffset);\n   }\n \n+  private static final ReadOperation<ByteBuffer> BYTE_BUF_OP = new ReadOperation<ByteBuffer>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n+      // Change the limit so that only lengthToCopy bytes are available.\n+      int prevLimit = dest.limit();\n+      ((Buffer) dest).limit(dest.position() + length);\n+      // Write the bytes and restore the original limit.\n+      buffer.readBytes(dest);\n+      ((Buffer) dest).limit(prevLimit);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final ByteBuffer dest) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        // Change the limit so that only lengthToCopy bytes are available.\n-        int prevLimit = dest.limit();\n-        ((Buffer) dest).limit(dest.position() + length);\n-\n-        // Write the bytes and restore the original limit.\n-        buffer.readBytes(dest);\n-        ((Buffer) dest).limit(prevLimit);\n-        return 0;\n-      }\n-    }, dest.remaining());\n+    executeNoThrow(BYTE_BUF_OP, dest.remaining(), dest, 0);\n   }\n \n-  @Override\n-  public void readBytes(final OutputStream dest, int length) throws IOException {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) throws IOException {\n+  private static final ReadOperation<OutputStream> STREAM_OP = new ReadOperation<OutputStream>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n+            throws IOException {\n         buffer.readBytes(dest, length);\n         return 0;\n-      }\n-    };\n-    execute(op, length);\n-\n-    // If an exception occurred, throw it.\n-    if (op.isError()) {\n-      throw op.ex;\n     }\n+  };\n+\n+  @Override\n+  public void readBytes(final OutputStream dest, int length) throws IOException {\n+    execute(STREAM_OP, length, dest, 0);\n   }\n \n   @Override\n-  public CompositeReadableBuffer readBytes(int length) {\n+  public ReadableBuffer readBytes(int length) {\n+    if (length <= 0) {\n+      return ReadableBuffers.empty();", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDA3MA==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516394070", "bodyText": "We use AssertionError for impossible internally-guaranteed conditions.", "author": "ejona86", "createdAt": "2020-11-03T02:14:02Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -189,6 +211,16 @@ private void execute(ReadOperation op, int length) {\n       // Should never get here.\n       throw new AssertionError(\"Failed executing read operation\");\n     }\n+\n+    return value;\n+  }\n+\n+  private <T> int executeNoThrow(ReadOperation<T> op, int length, T dest, int value) {\n+    try {\n+      return execute(op, length, dest, value);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e); // shouldn't happen", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDYzNQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516394635", "bodyText": "Don't know if we care, but we could have a NonThrowingReadOperation that extends this interface and doesn't have throws IOException. executeNoThrow() could then have that as a parameter. That would preserve the checked exception checking.", "author": "ejona86", "createdAt": "2020-11-03T02:16:43Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -202,32 +234,11 @@ private void advanceBufferIfNecessary() {\n   }\n \n   /**\n-   * A simple read operation to perform on a single {@link ReadableBuffer}. All state management for\n-   * the buffers is done by {@link CompositeReadableBuffer#execute(ReadOperation, int)}.\n+   * A simple read operation to perform on a single {@link ReadableBuffer}.\n+   * All state management for the buffers is done by\n+   * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n-  private abstract static class ReadOperation {\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readUnsignedByte()}.\n-     */\n-    int value;\n-\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readBytes(OutputStream, int)}.\n-     */\n-    IOException ex;\n-\n-    final void read(ReadableBuffer buffer, int length) {\n-      try {\n-        value = readInternal(buffer, length);\n-      } catch (IOException e) {\n-        ex = e;\n-      }\n-    }\n-\n-    final boolean isError() {\n-      return ex != null;\n-    }\n-\n-    abstract int readInternal(ReadableBuffer buffer, int length) throws IOException;\n+  private interface ReadOperation<T> {", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MjM2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549982365", "bodyText": "I may not completely follow, but I don't see that this would buy much. Unless we wanted to also duplicate the execute() method contents which wouldn't be ideal.", "author": "njhill", "createdAt": "2020-12-30T07:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI2MjMwMg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r550262302", "bodyText": "No need to duplicate execute(). execute() and executeNoThrow() would work as you have it here. The difference is that executeNoThrow() could only be called with a ReadOperation that actually doesn't throw IOExceptions.", "author": "ejona86", "createdAt": "2020-12-30T17:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTQ1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516395459", "bodyText": "You might want to clean up the now-unnecessary finals. Not a big deal.", "author": "ejona86", "createdAt": "2020-11-03T02:20:14Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n+  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+      buffer.skipBytes(length);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void skipBytes(int length) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.skipBytes(length);\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n+  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+      buffer.readBytes(dest, offset, length);\n+      return offset + length;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final byte[] dest, final int destOffset, int length) {", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NzM2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516397365", "bodyText": "Somewhere the relationship between value and the returned int needs to be mentioned, since that might be surprising and doesn't \"jump out\" obviously in the code.", "author": "ejona86", "createdAt": "2020-11-03T02:29:05Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -202,32 +234,11 @@ private void advanceBufferIfNecessary() {\n   }\n \n   /**\n-   * A simple read operation to perform on a single {@link ReadableBuffer}. All state management for\n-   * the buffers is done by {@link CompositeReadableBuffer#execute(ReadOperation, int)}.\n+   * A simple read operation to perform on a single {@link ReadableBuffer}.\n+   * All state management for the buffers is done by\n+   * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n-  private abstract static class ReadOperation {\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readUnsignedByte()}.\n-     */\n-    int value;\n-\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readBytes(OutputStream, int)}.\n-     */\n-    IOException ex;\n-\n-    final void read(ReadableBuffer buffer, int length) {\n-      try {\n-        value = readInternal(buffer, length);\n-      } catch (IOException e) {\n-        ex = e;\n-      }\n-    }\n-\n-    final boolean isError() {\n-      return ex != null;\n-    }\n-\n-    abstract int readInternal(ReadableBuffer buffer, int length) throws IOException;\n+  private interface ReadOperation<T> {\n+    int read(ReadableBuffer buffer, int length, T dest, int value) throws IOException;", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjkwNg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516902906", "bodyText": "FWIW, this allocation should exist on the stack.", "author": "ejona86", "createdAt": "2020-11-03T19:23:49Z", "path": "core/src/main/java/io/grpc/internal/MessageFramer.java", "diffHunk": "@@ -218,28 +218,26 @@ private int writeKnownLengthUncompressed(InputStream message, int messageLength)\n               String.format(\"message too large %d > %d\", messageLength , maxOutboundMessageSize))\n           .asRuntimeException();\n     }\n-    ByteBuffer header = ByteBuffer.wrap(headerScratch);", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMzMzNw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r517023337", "bodyText": "FWIW, this allocation should exist on the stack.\n\nWhat do you mean by \"this allocation\"?", "author": "voidzcy", "createdAt": "2020-11-03T23:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMzU5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r517023596", "bodyText": "ByteBuffer.wrap() creates a new object.", "author": "ejona86", "createdAt": "2020-11-03T23:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjkwNg=="}], "type": "inlineReview"}, {"oid": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "url": "https://github.com/grpc/grpc-java/commit/04f4e98298c8d7fd23c5b455468b62ff2100bb37", "message": "Address review comments from @ejona86 and @voidzcy", "committedDate": "2021-01-01T01:31:26Z", "type": "commit"}, {"oid": "be28523602b5f0a7eb7bae474ac6588248bf5364", "url": "https://github.com/grpc/grpc-java/commit/be28523602b5f0a7eb7bae474ac6588248bf5364", "message": "Fix missing imports in CronetClientTransport.java", "committedDate": "2021-01-18T21:36:10Z", "type": "commit"}]}