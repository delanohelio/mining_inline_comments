{"pr_number": 6718, "pr_title": "xds: support for xDS data types needed for server side SDS support", "pr_createdAt": "2020-02-14T20:18:32Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6718", "timeline": [{"oid": "557d47361bf9e7528d035075d6ba6db3a13ea925", "url": "https://github.com/grpc/grpc-java/commit/557d47361bf9e7528d035075d6ba6db3a13ea925", "message": "xds: add server side support for SDS", "committedDate": "2020-02-14T20:16:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1Mzc2OQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379653769", "bodyText": "if we have a separate class otherwise ignore for shake of consistency.\nxds is using this pattern, but i think better way is having Converters class that converts proto to data object. the data class is completely not depending on the proto. when newer generation of proto is released, we just need to add new converter class , and mark deprecated for the old class.", "author": "creamsoup", "createdAt": "2020-02-14T21:31:54Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +339,270 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  static final class CidrRange {\n+    private final String addressPrefix;\n+    private final int prefixLen;\n+\n+    public CidrRange(String addressPrefix, int prefixLen) {\n+      this.addressPrefix = addressPrefix;\n+      this.prefixLen = prefixLen;\n+    }\n+\n+    static CidrRange fromEnvoyProtoCidrRange(", "originalCommit": "557d47361bf9e7528d035075d6ba6db3a13ea925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjMxOQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379852319", "bodyText": "First, I used the existing pattern in EnvoyProtoData which seems workable.\nSeparating the conversion into a Converter class seems like a good idea and can be implemented when v3 protos are introduced. Also I am not sure how different/similar v3 protos will be to existing ones. There is a distinct possibility that v3 protos would force us to also update our internal xDS data types (because of new concepts) so it might not be worth our while to develop a complex conversion structure.", "author": "sanjaypujare", "createdAt": "2020-02-15T19:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1Mzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NDAzMw==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379654033", "bodyText": "can we use immutable data structure? UnmodifiableCollection or ImmutableCollection", "author": "creamsoup", "createdAt": "2020-02-14T21:32:38Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +339,270 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  static final class CidrRange {\n+    private final String addressPrefix;\n+    private final int prefixLen;\n+\n+    public CidrRange(String addressPrefix, int prefixLen) {\n+      this.addressPrefix = addressPrefix;\n+      this.prefixLen = prefixLen;\n+    }\n+\n+    static CidrRange fromEnvoyProtoCidrRange(\n+        io.envoyproxy.envoy.api.v2.core.CidrRange proto) {\n+      return new CidrRange(proto.getAddressPrefix(), proto.getPrefixLen().getValue());\n+    }\n+\n+    public String getAddressPrefix() {\n+      return addressPrefix;\n+    }\n+\n+    public int getPrefixLen() {\n+      return prefixLen;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      CidrRange cidrRange = (CidrRange) o;\n+      return prefixLen == cidrRange.prefixLen\n+          && java.util.Objects.equals(addressPrefix, cidrRange.addressPrefix);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(addressPrefix, prefixLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CidrRange{\"\n+          + \"addressPrefix='\" + addressPrefix + '\\''\n+          + \", prefixLen=\" + prefixLen\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message\n+   * {@link io.envoyproxy.envoy.api.v2.listener.FilterChainMatch}.\n+   */\n+  static final class FilterChainMatch {\n+    private final int destinationPort;\n+    private final List<CidrRange> prefixRanges;\n+    private final List<String> applicationProtocols;\n+\n+    public FilterChainMatch(int destinationPort,\n+        List<CidrRange> prefixRanges, List<String> applicationProtocols) {\n+      this.destinationPort = destinationPort;\n+      this.prefixRanges = prefixRanges;", "originalCommit": "557d47361bf9e7528d035075d6ba6db3a13ea925", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTI2NA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379655264", "bodyText": "can this have better name? reading this will cause a lot of confusion. but i can understand if we can't come up with better name because this is too generic.", "author": "creamsoup", "createdAt": "2020-02-14T21:35:48Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +339,270 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  static final class CidrRange {\n+    private final String addressPrefix;\n+    private final int prefixLen;\n+\n+    public CidrRange(String addressPrefix, int prefixLen) {\n+      this.addressPrefix = addressPrefix;\n+      this.prefixLen = prefixLen;\n+    }\n+\n+    static CidrRange fromEnvoyProtoCidrRange(\n+        io.envoyproxy.envoy.api.v2.core.CidrRange proto) {\n+      return new CidrRange(proto.getAddressPrefix(), proto.getPrefixLen().getValue());\n+    }\n+\n+    public String getAddressPrefix() {\n+      return addressPrefix;\n+    }\n+\n+    public int getPrefixLen() {\n+      return prefixLen;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      CidrRange cidrRange = (CidrRange) o;\n+      return prefixLen == cidrRange.prefixLen\n+          && java.util.Objects.equals(addressPrefix, cidrRange.addressPrefix);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(addressPrefix, prefixLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CidrRange{\"\n+          + \"addressPrefix='\" + addressPrefix + '\\''\n+          + \", prefixLen=\" + prefixLen\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message\n+   * {@link io.envoyproxy.envoy.api.v2.listener.FilterChainMatch}.\n+   */\n+  static final class FilterChainMatch {\n+    private final int destinationPort;\n+    private final List<CidrRange> prefixRanges;\n+    private final List<String> applicationProtocols;\n+\n+    public FilterChainMatch(int destinationPort,\n+        List<CidrRange> prefixRanges, List<String> applicationProtocols) {\n+      this.destinationPort = destinationPort;\n+      this.prefixRanges = prefixRanges;\n+      this.applicationProtocols = applicationProtocols;\n+    }\n+\n+    static FilterChainMatch fromEnvoyProtoFilterChainMatch(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChainMatch proto) {\n+      List<CidrRange> prefixRanges = new ArrayList<>();\n+      for (io.envoyproxy.envoy.api.v2.core.CidrRange range : proto.getPrefixRangesList()) {\n+        prefixRanges.add(CidrRange.fromEnvoyProtoCidrRange(range));\n+      }\n+      List<String> applicationProtocols = new ArrayList<>();\n+      for (String appProtocol  : proto.getApplicationProtocolsList()) {\n+        applicationProtocols.add(appProtocol);\n+      }\n+      return new FilterChainMatch(\n+          proto.getDestinationPort().getValue(),\n+          prefixRanges,\n+          applicationProtocols);\n+    }\n+\n+    public int getDestinationPort() {\n+      return destinationPort;\n+    }\n+\n+    public List<CidrRange> getPrefixRanges() {\n+      return prefixRanges;\n+    }\n+\n+    public List<String> getApplicationProtocols() {\n+      return applicationProtocols;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      FilterChainMatch that = (FilterChainMatch) o;\n+      return destinationPort == that.destinationPort\n+          && java.util.Objects.equals(prefixRanges, that.prefixRanges)\n+          && java.util.Objects.equals(applicationProtocols, that.applicationProtocols);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(destinationPort, prefixRanges, applicationProtocols);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"FilterChainMatch{\"\n+          + \"destinationPort=\" + destinationPort\n+          + \", prefixRanges=\" + prefixRanges\n+          + \", applicationProtocols=\" + applicationProtocols\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message {@link io.envoyproxy.envoy.api.v2.listener.FilterChain}.\n+   */\n+  static final class FilterChain {\n+    private final FilterChainMatch filterChainMatch;\n+    // TODO(sanjaypujare): remove dependency on envoy data type along with rest of the code.\n+    private final io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext;\n+\n+\n+    public FilterChain(FilterChainMatch filterChainMatch,\n+        io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext) {\n+      this.filterChainMatch = filterChainMatch;\n+      this.downstreamTlsContext = downstreamTlsContext;\n+    }\n+\n+    static FilterChain fromEnvoyProtoFilterChain(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChain proto) {\n+      return new FilterChain(\n+          FilterChainMatch.fromEnvoyProtoFilterChainMatch(proto.getFilterChainMatch()),\n+          proto.getTlsContext()\n+      );\n+    }\n+\n+    public FilterChainMatch getFilterChainMatch() {\n+      return filterChainMatch;\n+    }\n+\n+    public io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext getDownstreamTlsContext() {\n+      return downstreamTlsContext;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      FilterChain that = (FilterChain) o;\n+      return java.util.Objects.equals(filterChainMatch, that.filterChainMatch)\n+          && java.util.Objects.equals(downstreamTlsContext, that.downstreamTlsContext);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(filterChainMatch, downstreamTlsContext);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"FilterChain{\"\n+          + \"filterChainMatch=\" + filterChainMatch\n+          + \", downstreamTlsContext=\" + downstreamTlsContext\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message {@link io.envoyproxy.envoy.api.v2.Listener} & related\n+   * classes.\n+   */\n+  static final class Listener {", "originalCommit": "557d47361bf9e7528d035075d6ba6db3a13ea925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjQ1OQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379852459", "bodyText": "I can certainly rename it but the idea was to match the name used in Envoy protos (so reader can easily map one to the other) and there is no possibility of name collisions if all (most) of xDS code will only use this Listener class and not the Envoy one. BTW, Listener may sound too generic but has a specific meaning in the xDS world", "author": "sanjaypujare", "createdAt": "2020-02-15T19:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379655727", "bodyText": "can we have separate ProtoData for sds? i don't think put everything here is a good idea especially the xds proto is huge and complex (and they have many many proto files. i am not saying they need to be 1:1 but some sort of hierarchy would be nice).", "author": "creamsoup", "createdAt": "2020-02-14T21:36:55Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +339,270 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  static final class CidrRange {", "originalCommit": "557d47361bf9e7528d035075d6ba6db3a13ea925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjU5Nw==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379852597", "bodyText": "This is not SDS specific: only that SDS will be the first one to use it. This is server side Listener stuff that is going to be needed for more server side features. We can split client vs server. @voidzcy what do you think?", "author": "sanjaypujare", "createdAt": "2020-02-15T19:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2NTQxNA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380865414", "bodyText": "Hmm... It is subtle. There is no clear distinction of which protos are used for client side and which are for server side. Some of them are used both client and server sides. Yes, I agree we probably do not want to dump everything here. Do we have a better solution? @creamsoup", "author": "voidzcy", "createdAt": "2020-02-18T18:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg3NTIxMg==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380875212", "bodyText": "i like to have bunch of smaller classes. so i would split into xdsProtoData like EdsProtoData, CdsProtoData, etc. eventually something similar to envoy proto's package structure (more like flattened way). for this PR, possibly SdsProtoData will have SDS specific protos. this can help readers to understand which xds service it interacts with.\ni used this converter / data / proto separation in bazel, it works very well. but, not so well in other build system imo.", "author": "creamsoup", "createdAt": "2020-02-18T19:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg3ODI3Mw==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380878273", "bodyText": "@creamsoup can you clarify your comment? Preferring \"bunch of smaller classes\" is actually opposite of \"flattened\", so I am a bit confused. Also talking to @ejona86 not having smaller classes (on the xDS side) seems to be the preferred way. So on the xDS side we should create definitions that match our usage instead of just mirroring those on the Envoy proto side.", "author": "sanjaypujare", "createdAt": "2020-02-18T19:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg4NjA4MA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380886080", "bodyText": "oops yes.\nflattened as package level. the data classes from various xds protos (has many sub-packages) can be in a single java package. but they can have their own classes such as Cds, Eds, Lds, Rds, Srds, Discovery, Common (common for listener, endpoint etc) etc.\nwhat do you mean not having smaller classes seems to be preferred? i meant the smaller as each DS (sorry if this was not clear), current code is somewhat in that structure (Cds, Eds, Sds, etc).\ni am referring envoy proto structure, because it is organized in the usage not having everything in one class. seems like you are interpreting it in too extreme case (all in one class vs as tiny as message?)", "author": "creamsoup", "createdAt": "2020-02-18T19:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5MzExOA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380893118", "bodyText": "@creamsoup okay, thanks for the clarification. So regarding not preferring smaller classes, let's consider an example: Listener contains (list of) FilterChain and a FilterChain contains DownstreamTlsContext in the original Envoy protos. We don't have to replicate this structure on our side but just define the top level Listener with all fields expanded \"inline\" unless the types FilterChain and DownstreamTlsContext are required elsewhere. Note this is just an example to illustrate the point.\nOn the Envoy side, they are not defined by us and so have less control over how types/protos are defined - but we don't have to follow the same structure.", "author": "sanjaypujare", "createdAt": "2020-02-18T19:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5NzgwNQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380897805", "bodyText": "yes, that's why i specifically says \"similar structure\". if it is same, no reason to have data classes. also, this is why I suggested to rename the Listener to something else.\nyour response still sounds like you are thinking too micro level, my comments was for overall structure. I completely agree that Listener can have its own fields as long as it can represent current Listener structure. What I was saying is this EnvoyProtoData is too big. a single class represents the whole envoy protos sounds very extreme, so we may need to split into smaller chunks.", "author": "creamsoup", "createdAt": "2020-02-18T19:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk3NTA2NA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380975064", "bodyText": "Created a separate EnvoyServerProtoData class", "author": "sanjaypujare", "createdAt": "2020-02-18T22:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMTk1MQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379711951", "bodyText": "above tests? you mean tests in SdsSslContextProviderTest/ScretVolumnSslContextProviderTest?", "author": "creamsoup", "createdAt": "2020-02-15T02:40:26Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/CommonTlsContextTestsUtil.java", "diffHunk": "@@ -134,4 +115,27 @@ static CommonTlsContext buildCommonTlsContextWithAdditionalValues(\n     }\n     return builder.build();\n   }\n+\n+  /**\n+   * Helper method to build DownstreamTlsContext for above tests. Called from other classes as well.", "originalCommit": "557d47361bf9e7528d035075d6ba6db3a13ea925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjYxOQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r379852619", "bodyText": "sorry  - let me clarify", "author": "sanjaypujare", "createdAt": "2020-02-15T19:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcxMTk1MQ=="}], "type": "inlineReview"}, {"oid": "5b2f9b6b4607cfa969ca25ce3947d002310dccec", "url": "https://github.com/grpc/grpc-java/commit/5b2f9b6b4607cfa969ca25ce3947d002310dccec", "message": "address review comments and adjust access to ctors", "committedDate": "2020-02-17T03:13:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1OTk1OQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380859959", "bodyText": "This seems to be a helper method only. Should be private and name it to something different than fromEnvoyProtoXXX. Here fromEnvoyProtoXXX methods are used as factory methods to create converted data objects.\nBtw, since this helper method is only used once and it's not complex, it can be inlined instead of being a standalone method.", "author": "voidzcy", "createdAt": "2020-02-18T18:38:13Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +339,271 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  static final class CidrRange {\n+    private final String addressPrefix;\n+    private final int prefixLen;\n+\n+    @VisibleForTesting\n+    CidrRange(String addressPrefix, int prefixLen) {\n+      this.addressPrefix = addressPrefix;\n+      this.prefixLen = prefixLen;\n+    }\n+\n+    static CidrRange fromEnvoyProtoCidrRange(\n+        io.envoyproxy.envoy.api.v2.core.CidrRange proto) {\n+      return new CidrRange(proto.getAddressPrefix(), proto.getPrefixLen().getValue());\n+    }\n+\n+    public String getAddressPrefix() {\n+      return addressPrefix;\n+    }\n+\n+    public int getPrefixLen() {\n+      return prefixLen;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      CidrRange cidrRange = (CidrRange) o;\n+      return prefixLen == cidrRange.prefixLen\n+          && java.util.Objects.equals(addressPrefix, cidrRange.addressPrefix);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(addressPrefix, prefixLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CidrRange{\"\n+          + \"addressPrefix='\" + addressPrefix + '\\''\n+          + \", prefixLen=\" + prefixLen\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message\n+   * {@link io.envoyproxy.envoy.api.v2.listener.FilterChainMatch}.\n+   */\n+  static final class FilterChainMatch {\n+    private final int destinationPort;\n+    private final List<CidrRange> prefixRanges;\n+    private final List<String> applicationProtocols;\n+\n+    private FilterChainMatch(int destinationPort,\n+        List<CidrRange> prefixRanges, List<String> applicationProtocols) {\n+      this.destinationPort = destinationPort;\n+      this.prefixRanges = prefixRanges;\n+      this.applicationProtocols = applicationProtocols;\n+    }\n+\n+    static FilterChainMatch fromEnvoyProtoFilterChainMatch(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChainMatch proto) {\n+      List<CidrRange> prefixRanges = new ArrayList<>();\n+      for (io.envoyproxy.envoy.api.v2.core.CidrRange range : proto.getPrefixRangesList()) {\n+        prefixRanges.add(CidrRange.fromEnvoyProtoCidrRange(range));\n+      }\n+      List<String> applicationProtocols = new ArrayList<>();\n+      for (String appProtocol  : proto.getApplicationProtocolsList()) {\n+        applicationProtocols.add(appProtocol);\n+      }\n+      return new FilterChainMatch(\n+          proto.getDestinationPort().getValue(),\n+          Collections.unmodifiableList(prefixRanges),\n+          Collections.unmodifiableList(applicationProtocols));\n+    }\n+\n+    public int getDestinationPort() {\n+      return destinationPort;\n+    }\n+\n+    public List<CidrRange> getPrefixRanges() {\n+      return prefixRanges;\n+    }\n+\n+    public List<String> getApplicationProtocols() {\n+      return applicationProtocols;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      FilterChainMatch that = (FilterChainMatch) o;\n+      return destinationPort == that.destinationPort\n+          && java.util.Objects.equals(prefixRanges, that.prefixRanges)\n+          && java.util.Objects.equals(applicationProtocols, that.applicationProtocols);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(destinationPort, prefixRanges, applicationProtocols);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"FilterChainMatch{\"\n+          + \"destinationPort=\" + destinationPort\n+          + \", prefixRanges=\" + prefixRanges\n+          + \", applicationProtocols=\" + applicationProtocols\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message {@link io.envoyproxy.envoy.api.v2.listener.FilterChain}.\n+   */\n+  static final class FilterChain {\n+    private final FilterChainMatch filterChainMatch;\n+    // TODO(sanjaypujare): remove dependency on envoy data type along with rest of the code.\n+    private final io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext;\n+\n+\n+    private FilterChain(FilterChainMatch filterChainMatch,\n+        io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext) {\n+      this.filterChainMatch = filterChainMatch;\n+      this.downstreamTlsContext = downstreamTlsContext;\n+    }\n+\n+    static FilterChain fromEnvoyProtoFilterChain(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChain proto) {\n+      return new FilterChain(\n+          FilterChainMatch.fromEnvoyProtoFilterChainMatch(proto.getFilterChainMatch()),\n+          proto.getTlsContext()\n+      );\n+    }\n+\n+    public FilterChainMatch getFilterChainMatch() {\n+      return filterChainMatch;\n+    }\n+\n+    public io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext getDownstreamTlsContext() {\n+      return downstreamTlsContext;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      FilterChain that = (FilterChain) o;\n+      return java.util.Objects.equals(filterChainMatch, that.filterChainMatch)\n+          && java.util.Objects.equals(downstreamTlsContext, that.downstreamTlsContext);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(filterChainMatch, downstreamTlsContext);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"FilterChain{\"\n+          + \"filterChainMatch=\" + filterChainMatch\n+          + \", downstreamTlsContext=\" + downstreamTlsContext\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message {@link io.envoyproxy.envoy.api.v2.Listener} & related\n+   * classes.\n+   */\n+  static final class Listener {\n+    private final String name;\n+    private final String address;\n+    private final List<FilterChain> filterChains;\n+\n+    private Listener(String name, String address,\n+        List<FilterChain> filterChains) {\n+      this.name = name;\n+      this.address = address;\n+      this.filterChains = filterChains;\n+    }\n+\n+    static String fromEnvoyProtoAddress(io.envoyproxy.envoy.api.v2.core.Address proto) {", "originalCommit": "5b2f9b6b4607cfa969ca25ce3947d002310dccec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxODMxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381018311", "bodyText": "Made changes (except inlining because in future we may have an internal Address class)", "author": "sanjaypujare", "createdAt": "2020-02-19T00:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1OTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2MDE5OA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380860198", "bodyText": "Is this nullable?", "author": "voidzcy", "createdAt": "2020-02-18T18:38:40Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -339,4 +339,271 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  static final class CidrRange {\n+    private final String addressPrefix;\n+    private final int prefixLen;\n+\n+    @VisibleForTesting\n+    CidrRange(String addressPrefix, int prefixLen) {\n+      this.addressPrefix = addressPrefix;\n+      this.prefixLen = prefixLen;\n+    }\n+\n+    static CidrRange fromEnvoyProtoCidrRange(\n+        io.envoyproxy.envoy.api.v2.core.CidrRange proto) {\n+      return new CidrRange(proto.getAddressPrefix(), proto.getPrefixLen().getValue());\n+    }\n+\n+    public String getAddressPrefix() {\n+      return addressPrefix;\n+    }\n+\n+    public int getPrefixLen() {\n+      return prefixLen;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      CidrRange cidrRange = (CidrRange) o;\n+      return prefixLen == cidrRange.prefixLen\n+          && java.util.Objects.equals(addressPrefix, cidrRange.addressPrefix);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(addressPrefix, prefixLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CidrRange{\"\n+          + \"addressPrefix='\" + addressPrefix + '\\''\n+          + \", prefixLen=\" + prefixLen\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message\n+   * {@link io.envoyproxy.envoy.api.v2.listener.FilterChainMatch}.\n+   */\n+  static final class FilterChainMatch {\n+    private final int destinationPort;\n+    private final List<CidrRange> prefixRanges;\n+    private final List<String> applicationProtocols;\n+\n+    private FilterChainMatch(int destinationPort,\n+        List<CidrRange> prefixRanges, List<String> applicationProtocols) {\n+      this.destinationPort = destinationPort;\n+      this.prefixRanges = prefixRanges;\n+      this.applicationProtocols = applicationProtocols;\n+    }\n+\n+    static FilterChainMatch fromEnvoyProtoFilterChainMatch(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChainMatch proto) {\n+      List<CidrRange> prefixRanges = new ArrayList<>();\n+      for (io.envoyproxy.envoy.api.v2.core.CidrRange range : proto.getPrefixRangesList()) {\n+        prefixRanges.add(CidrRange.fromEnvoyProtoCidrRange(range));\n+      }\n+      List<String> applicationProtocols = new ArrayList<>();\n+      for (String appProtocol  : proto.getApplicationProtocolsList()) {\n+        applicationProtocols.add(appProtocol);\n+      }\n+      return new FilterChainMatch(\n+          proto.getDestinationPort().getValue(),\n+          Collections.unmodifiableList(prefixRanges),\n+          Collections.unmodifiableList(applicationProtocols));\n+    }\n+\n+    public int getDestinationPort() {\n+      return destinationPort;\n+    }\n+\n+    public List<CidrRange> getPrefixRanges() {\n+      return prefixRanges;\n+    }\n+\n+    public List<String> getApplicationProtocols() {\n+      return applicationProtocols;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      FilterChainMatch that = (FilterChainMatch) o;\n+      return destinationPort == that.destinationPort\n+          && java.util.Objects.equals(prefixRanges, that.prefixRanges)\n+          && java.util.Objects.equals(applicationProtocols, that.applicationProtocols);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(destinationPort, prefixRanges, applicationProtocols);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"FilterChainMatch{\"\n+          + \"destinationPort=\" + destinationPort\n+          + \", prefixRanges=\" + prefixRanges\n+          + \", applicationProtocols=\" + applicationProtocols\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message {@link io.envoyproxy.envoy.api.v2.listener.FilterChain}.\n+   */\n+  static final class FilterChain {\n+    private final FilterChainMatch filterChainMatch;\n+    // TODO(sanjaypujare): remove dependency on envoy data type along with rest of the code.\n+    private final io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext;\n+\n+\n+    private FilterChain(FilterChainMatch filterChainMatch,\n+        io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext) {\n+      this.filterChainMatch = filterChainMatch;\n+      this.downstreamTlsContext = downstreamTlsContext;\n+    }\n+\n+    static FilterChain fromEnvoyProtoFilterChain(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChain proto) {\n+      return new FilterChain(\n+          FilterChainMatch.fromEnvoyProtoFilterChainMatch(proto.getFilterChainMatch()),\n+          proto.getTlsContext()\n+      );\n+    }\n+\n+    public FilterChainMatch getFilterChainMatch() {\n+      return filterChainMatch;\n+    }\n+\n+    public io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext getDownstreamTlsContext() {\n+      return downstreamTlsContext;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      FilterChain that = (FilterChain) o;\n+      return java.util.Objects.equals(filterChainMatch, that.filterChainMatch)\n+          && java.util.Objects.equals(downstreamTlsContext, that.downstreamTlsContext);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(filterChainMatch, downstreamTlsContext);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"FilterChain{\"\n+          + \"filterChainMatch=\" + filterChainMatch\n+          + \", downstreamTlsContext=\" + downstreamTlsContext\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message {@link io.envoyproxy.envoy.api.v2.Listener} & related\n+   * classes.\n+   */\n+  static final class Listener {\n+    private final String name;\n+    private final String address;", "originalCommit": "5b2f9b6b4607cfa969ca25ce3947d002310dccec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxODAyOA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381018028", "bodyText": "good point. fixed", "author": "sanjaypujare", "createdAt": "2020-02-19T00:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2MDE5OA=="}], "type": "inlineReview"}, {"oid": "a532b49c97f14e5a2cf06b320351904373762730", "url": "https://github.com/grpc/grpc-java/commit/a532b49c97f14e5a2cf06b320351904373762730", "message": "separate code into EnvoyServerProtoData as per review comment", "committedDate": "2020-02-18T22:25:11Z", "type": "commit"}, {"oid": "4e099d6ed93e14cf03584874b7120151855fce7d", "url": "https://github.com/grpc/grpc-java/commit/4e099d6ed93e14cf03584874b7120151855fce7d", "message": "nit: remove extra newline", "committedDate": "2020-02-18T22:29:58Z", "type": "commit"}, {"oid": "acc47093df2323bf188655777f541b31c8c60377", "url": "https://github.com/grpc/grpc-java/commit/acc47093df2323bf188655777f541b31c8c60377", "message": "mark nullable and rename method for clarity", "committedDate": "2020-02-19T00:41:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4MDUxOA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r380980518", "bodyText": "nit: remove extra line. also before FilterChain class.", "author": "creamsoup", "createdAt": "2020-02-18T22:44:52Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Defines gRPC data types for Envoy protobuf messages used in xDS protocol on the server side,\n+ * similar to how {@link EnvoyProtoData} defines it for the client side.\n+ */\n+final class EnvoyServerProtoData {\n+\n+  // Prevent instantiation.\n+  private EnvoyServerProtoData() {\n+  }\n+\n+  static final class CidrRange {\n+    private final String addressPrefix;\n+    private final int prefixLen;\n+\n+    @VisibleForTesting\n+    CidrRange(String addressPrefix, int prefixLen) {\n+      this.addressPrefix = addressPrefix;\n+      this.prefixLen = prefixLen;\n+    }\n+\n+    static CidrRange fromEnvoyProtoCidrRange(\n+        io.envoyproxy.envoy.api.v2.core.CidrRange proto) {\n+      return new CidrRange(proto.getAddressPrefix(), proto.getPrefixLen().getValue());\n+    }\n+\n+    public String getAddressPrefix() {\n+      return addressPrefix;\n+    }\n+\n+    public int getPrefixLen() {\n+      return prefixLen;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      CidrRange cidrRange = (CidrRange) o;\n+      return prefixLen == cidrRange.prefixLen\n+          && java.util.Objects.equals(addressPrefix, cidrRange.addressPrefix);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(addressPrefix, prefixLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CidrRange{\"\n+          + \"addressPrefix='\" + addressPrefix + '\\''\n+          + \", prefixLen=\" + prefixLen\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message\n+   * {@link io.envoyproxy.envoy.api.v2.listener.FilterChainMatch}.\n+   */\n+  static final class FilterChainMatch {\n+    private final int destinationPort;\n+    private final List<CidrRange> prefixRanges;\n+    private final List<String> applicationProtocols;\n+\n+    private FilterChainMatch(int destinationPort,\n+        List<CidrRange> prefixRanges, List<String> applicationProtocols) {\n+      this.destinationPort = destinationPort;\n+      this.prefixRanges = prefixRanges;\n+      this.applicationProtocols = applicationProtocols;\n+    }\n+\n+    static FilterChainMatch fromEnvoyProtoFilterChainMatch(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChainMatch proto) {\n+      List<CidrRange> prefixRanges = new ArrayList<>();\n+      for (io.envoyproxy.envoy.api.v2.core.CidrRange range : proto.getPrefixRangesList()) {\n+        prefixRanges.add(CidrRange.fromEnvoyProtoCidrRange(range));\n+      }\n+      List<String> applicationProtocols = new ArrayList<>();\n+      for (String appProtocol  : proto.getApplicationProtocolsList()) {\n+        applicationProtocols.add(appProtocol);\n+      }\n+      return new FilterChainMatch(\n+          proto.getDestinationPort().getValue(),\n+          Collections.unmodifiableList(prefixRanges),\n+          Collections.unmodifiableList(applicationProtocols));\n+    }\n+\n+    public int getDestinationPort() {\n+      return destinationPort;\n+    }\n+\n+    public List<CidrRange> getPrefixRanges() {\n+      return prefixRanges;\n+    }\n+\n+    public List<String> getApplicationProtocols() {\n+      return applicationProtocols;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      FilterChainMatch that = (FilterChainMatch) o;\n+      return destinationPort == that.destinationPort\n+          && java.util.Objects.equals(prefixRanges, that.prefixRanges)\n+          && java.util.Objects.equals(applicationProtocols, that.applicationProtocols);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(destinationPort, prefixRanges, applicationProtocols);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"FilterChainMatch{\"\n+          + \"destinationPort=\" + destinationPort\n+          + \", prefixRanges=\" + prefixRanges\n+          + \", applicationProtocols=\" + applicationProtocols\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message {@link io.envoyproxy.envoy.api.v2.listener.FilterChain}.\n+   */\n+  static final class FilterChain {\n+    private final FilterChainMatch filterChainMatch;\n+    // TODO(sanjaypujare): remove dependency on envoy data type along with rest of the code.\n+    private final io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext;\n+\n+\n+    private FilterChain(FilterChainMatch filterChainMatch,\n+        io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext downstreamTlsContext) {\n+      this.filterChainMatch = filterChainMatch;\n+      this.downstreamTlsContext = downstreamTlsContext;\n+    }\n+\n+    static FilterChain fromEnvoyProtoFilterChain(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChain proto) {\n+      return new FilterChain(\n+          FilterChainMatch.fromEnvoyProtoFilterChainMatch(proto.getFilterChainMatch()),\n+          proto.getTlsContext()\n+      );\n+    }\n+\n+    public FilterChainMatch getFilterChainMatch() {\n+      return filterChainMatch;\n+    }\n+\n+    public io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext getDownstreamTlsContext() {\n+      return downstreamTlsContext;\n+    }\n+", "originalCommit": "4e099d6ed93e14cf03584874b7120151855fce7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAyMjQyMQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381022421", "bodyText": "is this nullable?", "author": "creamsoup", "createdAt": "2020-02-19T00:57:48Z", "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -59,21 +60,28 @@\n    */\n   static final class ConfigUpdate {\n     private final String clusterName;\n+    private final Listener listener;\n \n-    private ConfigUpdate(String clusterName) {\n+    private ConfigUpdate(String clusterName, Listener listener) {\n       this.clusterName = clusterName;\n+      this.listener = listener;", "originalCommit": "acc47093df2323bf188655777f541b31c8c60377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAyNDQzMw==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381024433", "bodyText": "i expected to have it (unmodifiableList) in the constructor, just in case we have another factory method it can be missed.", "author": "creamsoup", "createdAt": "2020-02-19T01:04:49Z", "path": "xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Defines gRPC data types for Envoy protobuf messages used in xDS protocol on the server side,\n+ * similar to how {@link EnvoyProtoData} defines it for the client side.\n+ */\n+final class EnvoyServerProtoData {\n+\n+  // Prevent instantiation.\n+  private EnvoyServerProtoData() {\n+  }\n+\n+  static final class CidrRange {\n+    private final String addressPrefix;\n+    private final int prefixLen;\n+\n+    @VisibleForTesting\n+    CidrRange(String addressPrefix, int prefixLen) {\n+      this.addressPrefix = addressPrefix;\n+      this.prefixLen = prefixLen;\n+    }\n+\n+    static CidrRange fromEnvoyProtoCidrRange(\n+        io.envoyproxy.envoy.api.v2.core.CidrRange proto) {\n+      return new CidrRange(proto.getAddressPrefix(), proto.getPrefixLen().getValue());\n+    }\n+\n+    public String getAddressPrefix() {\n+      return addressPrefix;\n+    }\n+\n+    public int getPrefixLen() {\n+      return prefixLen;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      CidrRange cidrRange = (CidrRange) o;\n+      return prefixLen == cidrRange.prefixLen\n+          && java.util.Objects.equals(addressPrefix, cidrRange.addressPrefix);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return java.util.Objects.hash(addressPrefix, prefixLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CidrRange{\"\n+          + \"addressPrefix='\" + addressPrefix + '\\''\n+          + \", prefixLen=\" + prefixLen\n+          + '}';\n+    }\n+  }\n+\n+  /**\n+   * Corresponds to Envoy proto message\n+   * {@link io.envoyproxy.envoy.api.v2.listener.FilterChainMatch}.\n+   */\n+  static final class FilterChainMatch {\n+    private final int destinationPort;\n+    private final List<CidrRange> prefixRanges;\n+    private final List<String> applicationProtocols;\n+\n+    private FilterChainMatch(int destinationPort,\n+        List<CidrRange> prefixRanges, List<String> applicationProtocols) {\n+      this.destinationPort = destinationPort;\n+      this.prefixRanges = prefixRanges;\n+      this.applicationProtocols = applicationProtocols;\n+    }\n+\n+    static FilterChainMatch fromEnvoyProtoFilterChainMatch(\n+        io.envoyproxy.envoy.api.v2.listener.FilterChainMatch proto) {\n+      List<CidrRange> prefixRanges = new ArrayList<>();\n+      for (io.envoyproxy.envoy.api.v2.core.CidrRange range : proto.getPrefixRangesList()) {\n+        prefixRanges.add(CidrRange.fromEnvoyProtoCidrRange(range));\n+      }\n+      List<String> applicationProtocols = new ArrayList<>();\n+      for (String appProtocol  : proto.getApplicationProtocolsList()) {\n+        applicationProtocols.add(appProtocol);\n+      }\n+      return new FilterChainMatch(\n+          proto.getDestinationPort().getValue(),\n+          Collections.unmodifiableList(prefixRanges),", "originalCommit": "acc47093df2323bf188655777f541b31c8c60377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f89ed6db1722cd68643865515def09f04f56781", "url": "https://github.com/grpc/grpc-java/commit/1f89ed6db1722cd68643865515def09f04f56781", "message": "use unmodifiableList in ctor instead of factory method", "committedDate": "2020-02-19T05:44:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzA2NA==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381507064", "bodyText": "Proto fields will never be null.\nAnyway, it's not necessary to write tests for this data conversion class (unless there is some complex logic other than straightly populating data from proto messages).", "author": "voidzcy", "createdAt": "2020-02-19T19:50:40Z", "path": "xds/src/test/java/io/grpc/xds/EnvoyServerProtoDataTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.UInt32Value;\n+import io.envoyproxy.envoy.api.v2.auth.CommonTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.SdsSecretConfig;\n+import io.envoyproxy.envoy.api.v2.core.CidrRange;\n+import io.envoyproxy.envoy.api.v2.core.SocketAddress;\n+import io.envoyproxy.envoy.api.v2.listener.Filter;\n+import io.envoyproxy.envoy.api.v2.listener.FilterChain;\n+import io.envoyproxy.envoy.api.v2.listener.FilterChainMatch;\n+import io.grpc.xds.EnvoyServerProtoData.Listener;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link EnvoyServerProtoData}.\n+ */\n+@RunWith(JUnit4.class)\n+public class EnvoyServerProtoDataTest {\n+\n+  @Test\n+  public void listener_convertFromListenerProto() {\n+    io.envoyproxy.envoy.api.v2.core.Address address =\n+        io.envoyproxy.envoy.api.v2.core.Address.newBuilder()\n+            .setSocketAddress(SocketAddress.newBuilder()\n+                .setPortValue(8000)\n+                .setAddress(\"10.2.1.34\")\n+                .build())\n+            .build();\n+    io.envoyproxy.envoy.api.v2.Listener listener =\n+        io.envoyproxy.envoy.api.v2.Listener.newBuilder()\n+            .setName(\"8000\")\n+            .setAddress(address)\n+            .addFilterChains(createOutFilter())\n+            .addFilterChains(createInFilter())\n+            .build();\n+\n+    Listener xdsListener = Listener.fromEnvoyProtoListener(listener);\n+    assertThat(xdsListener.getName()).isEqualTo(\"8000\");\n+    assertThat(xdsListener.getAddress()).isEqualTo(\"10.2.1.34:8000\");\n+    List<EnvoyServerProtoData.FilterChain> filterChains = xdsListener.getFilterChains();\n+    assertThat(filterChains).isNotNull();\n+    assertThat(filterChains.size()).isEqualTo(2);\n+    EnvoyServerProtoData.FilterChain outFilter = filterChains.get(0);\n+    assertThat(outFilter).isNotNull();\n+    EnvoyServerProtoData.FilterChainMatch outFilterChainMatch = outFilter.getFilterChainMatch();\n+    assertThat(outFilterChainMatch).isNotNull();\n+    assertThat(outFilterChainMatch.getDestinationPort()).isEqualTo(8000);\n+    assertThat(outFilterChainMatch.getApplicationProtocols()).isEmpty();\n+    assertThat(outFilterChainMatch.getPrefixRanges()).isEmpty();\n+    assertThat(outFilter.getDownstreamTlsContext())\n+        .isEqualTo(DownstreamTlsContext.getDefaultInstance());\n+\n+    EnvoyServerProtoData.FilterChain inFilter = filterChains.get(1);\n+    assertThat(inFilter).isNotNull();\n+    EnvoyServerProtoData.FilterChainMatch inFilterChainMatch = inFilter.getFilterChainMatch();\n+    assertThat(inFilterChainMatch).isNotNull();\n+    assertThat(inFilterChainMatch.getDestinationPort()).isEqualTo(8000);\n+    assertThat(inFilterChainMatch.getApplicationProtocols()).containsExactly(\"managed-mtls\");\n+    assertThat(inFilterChainMatch.getPrefixRanges()).containsExactly(\n+        new EnvoyServerProtoData.CidrRange(\"10.20.0.15\", 32));\n+    DownstreamTlsContext inFilterTlsContext = inFilter.getDownstreamTlsContext();\n+    assertThat(inFilterTlsContext).isNotNull();\n+    CommonTlsContext commonTlsContext = inFilterTlsContext.getCommonTlsContext();\n+    assertThat(commonTlsContext).isNotNull();", "originalCommit": "1f89ed6db1722cd68643865515def09f04f56781", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyMzcwMg==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381523702", "bodyText": "Tests are meant to catch potential regressions in the future", "author": "sanjaypujare", "createdAt": "2020-02-19T20:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzODc4Mg==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381538782", "bodyText": "i agree the statement, but it doesn't apply to this case. just like we don't unittest standard library. we will probably have a fix from next import.", "author": "creamsoup", "createdAt": "2020-02-19T20:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2ODExMw==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381568113", "bodyText": "My comment was about \"not needing a test\" or \"test not being useful\". I agree that the \"NotNull\" checks can be (should be?) removed based on linter issues.", "author": "sanjaypujare", "createdAt": "2020-02-19T21:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2OTU5NQ==", "url": "https://github.com/grpc/grpc-java/pull/6718#discussion_r381569595", "bodyText": "oops, yes i believe the conversion tests are useful.\nother test will verify behavior using converted data class. without proto to converted verification, we can't trust other tests.", "author": "creamsoup", "createdAt": "2020-02-19T21:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzA2NA=="}], "type": "inlineReview"}]}