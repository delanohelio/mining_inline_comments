{"pr_number": 6749, "pr_title": "rls: adaptive throttler", "pr_createdAt": "2020-02-25T02:45:39Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6749", "timeline": [{"oid": "311289bc9bc88724e67954cae462f67cfe17d0a7", "url": "https://github.com/grpc/grpc-java/commit/311289bc9bc88724e67954cae462f67cfe17d0a7", "message": "rls: adaptive throttler", "committedDate": "2020-02-25T02:45:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MjQxOQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389182419", "bodyText": "s/Register/Registers", "author": "dapengzhang0", "createdAt": "2020-03-06T22:52:21Z", "path": "rls/src/main/java/io/grpc/rls/internal/Throttler.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A strategy for deciding when to throttle requests at the client.\n+ */\n+@ThreadSafe\n+public interface Throttler {\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  boolean shouldThrottle();\n+\n+  /**\n+   * Register a response received from the backend for a request allowed by shouldThrottle. This", "originalCommit": "311289bc9bc88724e67954cae462f67cfe17d0a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjM5Mw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389212393", "bodyText": "Done.", "author": "creamsoup", "createdAt": "2020-03-07T01:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MjQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NTQ2MQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389195461", "bodyText": "What about just a factory of status like the following? This will be much lighter than exception which always creates a stacktrace when you call the constructor.\nclass ThrottledStatus {\n  static Status withDescription(String s) {\n    return Status.RESOURCE_EXHAUSTED.withDescription(s);\n  }\n}", "author": "dapengzhang0", "createdAt": "2020-03-06T23:43:07Z", "path": "rls/src/main/java/io/grpc/rls/internal/Throttler.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A strategy for deciding when to throttle requests at the client.\n+ */\n+@ThreadSafe\n+public interface Throttler {\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  boolean shouldThrottle();\n+\n+  /**\n+   * Register a response received from the backend for a request allowed by shouldThrottle. This\n+   * should be called for every response received from the backend (i.e., once for each request for\n+   * which ShouldThrottle returned false). This updates the internal statistics used by\n+   * shouldThrottle.\n+   *\n+   * @param throttled specifies whether the request was throttled by the backend.\n+   */\n+  void registerBackendResponse(boolean throttled);\n+\n+  /**\n+   * A ThrottledException indicates the call is throttled. This exception is meant to be used by\n+   * caller of {@link Throttler}, the implementation of Throttler should <strong>not</strong> throw\n+   * this exception when {@link #shouldThrottle()} is called.\n+   */\n+  final class ThrottledException extends RuntimeException {", "originalCommit": "311289bc9bc88724e67954cae462f67cfe17d0a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjY4NQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389212685", "bodyText": "i made it stackless because the stack is useless as you pointed out. but this is more useful if it is actual exception in the later code. because this will be used in the control channel not data channel.", "author": "creamsoup", "createdAt": "2020-03-07T01:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5ODU3Nw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389198577", "bodyText": "You can reuse io.grpc.internal.TimeProvider", "author": "dapengzhang0", "createdAt": "2020-03-06T23:58:09Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final Ticker ticker;\n+  private final Random random;\n+  /**\n+   * The number of requests attempted by the client during the Adaptive Throttler instance's\n+   * history of calls. This includes requests throttled at the client. The history period defaults\n+   * to 30 seconds.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator requestStat;\n+  /**\n+   * Counter for the total number of requests that were throttled by either the client (this class)\n+   * or the backend in recent history.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator throttledStat;\n+\n+  private AdaptiveThrottler(Builder builder) {\n+    this.historySeconds = builder.historySeconds;\n+    this.requestsPadding = builder.requestsPadding;\n+    this.ratioForAccepts = builder.ratioForAccepts;\n+    this.ticker = builder.ticker;\n+    this.random = builder.random;\n+    long internalMillis = TimeUnit.SECONDS.toMillis(historySeconds);\n+    this.requestStat = new TimeBasedAccumulator(internalMillis, ticker);\n+    this.throttledStat = new TimeBasedAccumulator(internalMillis, ticker);\n+  }\n+\n+  @Override\n+  public boolean shouldThrottle() {\n+    return shouldThrottle(random.nextFloat());\n+  }\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  public boolean shouldThrottle(float random) {\n+    return shouldThrottle(random, ticker.nowInMillis());\n+  }\n+\n+  private boolean shouldThrottle(float random, long nowInMillis) {\n+    if (getThrottleProbability(nowInMillis) <= random) {\n+      return false;\n+    }\n+    requestStat.increment(nowInMillis);\n+    throttledStat.increment(nowInMillis);\n+    return true;\n+  }\n+\n+  /**\n+   * Calculates throttleProbability.\n+   * <pre>\n+   * throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+   * </pre>\n+   */\n+  @VisibleForTesting\n+  float getThrottleProbability(long nowInMillis) {\n+    long requests = this.requestStat.get(nowInMillis);\n+    long accepts = requests - throttledStat.get(nowInMillis);\n+    // It's possible that this probability will be negative, which means that no throttling should\n+    // take place.\n+    return (requests - ratioForAccepts * accepts) / (requests + requestsPadding);\n+  }\n+\n+  @Override\n+  public void registerBackendResponse(boolean throttled) {\n+    long now = ticker.nowInMillis();\n+    requestStat.increment(now);\n+    if (throttled) {\n+      throttledStat.increment(now);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"historySeconds\", historySeconds)\n+        .add(\"requestsPadding\", requestsPadding)\n+        .add(\"ratioForAccepts\", ratioForAccepts)\n+        .add(\"requestStat\", requestStat)\n+        .add(\"throttledStat\", throttledStat)\n+        .toString();\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder for {@link AdaptiveThrottler}. */\n+  public static final class Builder {\n+\n+    private float ratioForAccepts = DEFAULT_RATIO_FOR_ACCEPT;\n+    private int historySeconds = DEFAULT_HISTORY_SECONDS;\n+    private int requestsPadding = DEFAULT_REQUEST_PADDING;\n+    private Ticker ticker = new SystemTicker();\n+    private Random random = new Random();\n+\n+    public Builder setRatioForAccepts(float ratioForAccepts) {\n+      this.ratioForAccepts = ratioForAccepts;\n+      return this;\n+    }\n+\n+    public Builder setHistorySeconds(int historySeconds) {\n+      this.historySeconds = historySeconds;\n+      return this;\n+    }\n+\n+    public Builder setRequestsPadding(int requestsPadding) {\n+      this.requestsPadding = requestsPadding;\n+      return this;\n+    }\n+\n+    public Builder setTicker(Ticker ticker) {\n+      this.ticker = checkNotNull(ticker, \"ticker\");\n+      return this;\n+    }\n+\n+    public Builder setRandom(Random random) {\n+      this.random = checkNotNull(random, \"random\");\n+      return this;\n+    }\n+\n+    public AdaptiveThrottler build() {\n+      return new AdaptiveThrottler(this);\n+    }\n+  }\n+\n+  static final class TimeBasedAccumulator {\n+    /**\n+     * The number of slots. This value determines the accuracy of the get() method to interval /\n+     * NUM_SLOTS.\n+     */\n+    private static final int NUM_SLOTS = 50;\n+\n+    /** Holds the data for each slot (amount and end timestamp). */\n+    private static final class Slot {\n+      static final AtomicLongFieldUpdater<Slot> ATOMIC_COUNT =\n+          AtomicLongFieldUpdater.newUpdater(Slot.class, \"count\");\n+\n+      // The count of statistics for the time range represented by this slot.\n+      volatile long count;\n+      // The nearest 0 modulo slot boundary in milliseconds. The slot boundary\n+      // is exclusive. [previous_slot.end, end)\n+      final long endInMillis;\n+\n+      Slot(long endInMillis) {\n+        this.endInMillis = endInMillis;\n+        this.count = 0;\n+      }\n+\n+      void increment() {\n+        ATOMIC_COUNT.incrementAndGet(this);\n+      }\n+    }\n+\n+    // Represents a slot which is not initialized and is unusable.\n+    private static final Slot NULL_SLOT = new Slot(-1);\n+\n+    /** The array of slots. */\n+    private final AtomicReferenceArray<Slot> slots = new AtomicReferenceArray<>(NUM_SLOTS);\n+\n+    /** The time interval this statistic is concerned with. */\n+    private final long interval;\n+\n+    /** The number of milliseconds in each slot. */\n+    private final long slotMillis;\n+\n+    /**\n+     * The current index into the slot array. {@code currentIndex} may be safely read without\n+     * synchronization, but all writes must be performed inside of a {@code synchronized(this){}}\n+     * block.\n+     */\n+    private volatile int currentIndex;\n+\n+    private final Ticker ticker;\n+\n+    /**\n+     * Interval constructor.\n+     *\n+     * @param internalMillis is the stat interval in milliseconds\n+     * @throws IllegalArgumentException if the supplied interval is too small to be effective\n+     */\n+    TimeBasedAccumulator(long internalMillis, Ticker ticker) {\n+      checkArgument(\n+          internalMillis >= NUM_SLOTS,\n+          \"Interval must be greater than %s. Are you using milliseconds?\",\n+          NUM_SLOTS);\n+      this.interval = internalMillis;\n+      this.slotMillis = internalMillis / NUM_SLOTS;\n+      this.currentIndex = 0;\n+      for (int i = 0; i < NUM_SLOTS; i++) {\n+        slots.set(i, NULL_SLOT);\n+      }\n+      this.ticker = checkNotNull(ticker, \"ticker\");\n+    }\n+\n+    /** Gets the current slot. */\n+    private Slot getSlot(long now) {\n+      Slot currentSlot = slots.get(currentIndex);\n+      if (now < currentSlot.endInMillis) {\n+        return currentSlot;\n+      } else {\n+        long slotBoundary = getSlotEndTime(now);\n+        synchronized (this) {\n+          int index = currentIndex;\n+          currentSlot = slots.get(index);\n+          if (now < currentSlot.endInMillis) {\n+            return currentSlot;\n+          }\n+          int newIndex = (index == NUM_SLOTS - 1) ? 0 : index + 1;\n+          Slot nextSlot = new Slot(slotBoundary);\n+          slots.set(newIndex, nextSlot);\n+          // Set currentIndex only after assigning the new slot to slots, otherwise\n+          // racing readers will see NULL_SLOT or an old slot.\n+          currentIndex = newIndex;\n+          return nextSlot;\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Computes the nearest 0 modulo slot boundary in milliseconds.\n+     *\n+     * @param time the time for which to find the nearest slot boundary\n+     * @return the nearest slot boundary (in ms)\n+     */\n+    private long getSlotEndTime(long time) {\n+      return (time / slotMillis) * slotMillis + slotMillis;\n+    }\n+\n+    /**\n+     * Returns the interval used by this statistic.\n+     *\n+     * @return the interval\n+     */\n+    public long getInterval() {\n+      return this.interval;\n+    }\n+\n+    /** Increments the count of the statistic by the specified amount for the specified time. */\n+    final void increment() {\n+      increment(ticker.nowInMillis());\n+    }\n+\n+    /**\n+     * Increments the count of the statistic by the specified amount for the specified time.\n+     *\n+     * @param now is the time used to increment the count\n+     */\n+    final void increment(long now) {\n+      getSlot(now).increment();\n+    }\n+\n+    /**\n+     * Returns the count of the statistic over the statistic's configured time interval.\n+     *\n+     * @return the statistic count\n+     */\n+    final long get() {\n+      return get(ticker.nowInMillis());\n+    }\n+\n+    /**\n+     * Returns the count of the statistic using the specified time value as the current time.\n+     *\n+     * @param now the current time\n+     * @return the statistic count\n+     */\n+    public final long get(long now) {\n+      long intervalEnd = getSlotEndTime(now);\n+      long intervalStart = intervalEnd - interval;\n+      // This is the point at which increments to new slots will be ignored.\n+      int index = currentIndex;\n+\n+      long accumulated = 0L;\n+      long prevSlotEnd = Long.MAX_VALUE;\n+      for (int i = 0; i < NUM_SLOTS; i++) {\n+        if (index < 0) {\n+          index = NUM_SLOTS - 1;\n+        }\n+        Slot currentSlot = slots.get(index);\n+        index--;\n+        long currentSlotEnd = currentSlot.endInMillis;\n+\n+        if (currentSlotEnd <= intervalStart || currentSlotEnd > prevSlotEnd) {\n+          break;\n+        }\n+        prevSlotEnd = currentSlotEnd;\n+\n+        if (currentSlotEnd > intervalEnd) {\n+          continue;\n+        }\n+        accumulated = accumulated + currentSlot.count;\n+      }\n+      return accumulated;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"interval\", interval)\n+          .add(\"current_count\", get())\n+          .toString();\n+    }\n+  }\n+\n+  /** A Ticker keeps tracks of current time in milliseconds. */\n+  interface Ticker {", "originalCommit": "311289bc9bc88724e67954cae462f67cfe17d0a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjM3OA==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389212378", "bodyText": "Done.", "author": "creamsoup", "createdAt": "2020-03-07T01:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5ODU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5OTUzMQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389199531", "bodyText": "Append a newline", "author": "dapengzhang0", "createdAt": "2020-03-07T00:02:51Z", "path": "rls/src/test/java/io/grpc/rls/internal/AdaptiveThrottlerTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.rls.internal.AdaptiveThrottler.Ticker;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AdaptiveThrottlerTest {\n+  private static final float TOLERANCE = 0.0001f;\n+\n+  private final FakeTicker ticker = new FakeTicker();\n+  private final AdaptiveThrottler throttler =\n+      new AdaptiveThrottler.Builder()\n+          .setHistorySeconds(1)\n+          .setRatioForAccepts(1.0f)\n+          .setRequestsPadding(1)\n+          .setTicker(ticker)\n+          .build();\n+\n+  @Test\n+  public void shouldThrottle() {\n+    // initial states\n+    assertThat(throttler.requestStat.get(ticker.nowInMillis())).isEqualTo(0L);\n+    assertThat(throttler.throttledStat.get(ticker.nowInMillis())).isEqualTo(0L);\n+    assertThat(throttler.getThrottleProbability(ticker.nowInMillis())).isWithin(TOLERANCE).of(0.0f);\n+\n+    // Request 1, allowed by all.\n+    assertThat(throttler.shouldThrottle(0.4f)).isFalse();\n+    ticker.advance(1L);\n+    throttler.registerBackendResponse(false);\n+\n+    assertThat(throttler.requestStat.get(ticker.nowInMillis())).isEqualTo(1L);\n+    assertThat(throttler.throttledStat.get(ticker.nowInMillis())).isEqualTo(0L);\n+    assertThat(throttler.getThrottleProbability(ticker.nowInMillis())).isWithin(TOLERANCE).of(0.0f);\n+\n+    // Request 2, throttled by backend\n+    assertThat(throttler.shouldThrottle(0.4f)).isFalse();\n+    ticker.advance(1L);\n+    throttler.registerBackendResponse(true);\n+\n+    assertThat(throttler.requestStat.get(ticker.nowInMillis())).isEqualTo(2L);\n+    assertThat(throttler.throttledStat.get(ticker.nowInMillis())).isEqualTo(1L);\n+    assertThat(throttler.getThrottleProbability(ticker.nowInMillis()))\n+        .isWithin(TOLERANCE)\n+        .of(1.0f / 3.0f);\n+\n+    // Skip half a second (half the duration).\n+    ticker.setNow(500L);\n+\n+    // Request 3, throttled by backend\n+    assertThat(throttler.shouldThrottle(0.4f)).isFalse();\n+    ticker.advance(1L);\n+    throttler.registerBackendResponse(true);\n+\n+    assertThat(throttler.requestStat.get(ticker.nowInMillis())).isEqualTo(3L);\n+    assertThat(throttler.throttledStat.get(ticker.nowInMillis())).isEqualTo(2L);\n+    assertThat(throttler.getThrottleProbability(ticker.nowInMillis()))\n+        .isWithin(TOLERANCE)\n+        .of(2.0f / 4.0f);\n+\n+    // Request 4, throttled by client.\n+    assertThat(throttler.shouldThrottle(0.4f)).isTrue();\n+    ticker.advance(1L);\n+\n+    assertThat(throttler.requestStat.get(ticker.nowInMillis())).isEqualTo(4L);\n+    assertThat(throttler.throttledStat.get(ticker.nowInMillis())).isEqualTo(3L);\n+    assertThat(throttler.getThrottleProbability(ticker.nowInMillis()))\n+        .isWithin(TOLERANCE)\n+        .of(3.0f / 5.0f);\n+\n+    // Skip to the point where only requests 3 and 4 are visible.\n+    ticker.setNow(1250L);\n+\n+    assertThat(throttler.requestStat.get(ticker.nowInMillis())).isEqualTo(2L);\n+    assertThat(throttler.throttledStat.get(ticker.nowInMillis())).isEqualTo(2L);\n+    assertThat(throttler.getThrottleProbability(ticker.nowInMillis()))\n+        .isWithin(TOLERANCE)\n+        .of(2.0f / 3.0f);\n+  }\n+\n+  private static final class FakeTicker implements Ticker {\n+    private AtomicLong currentTimeInMillis = new AtomicLong();\n+\n+    FakeTicker() {}\n+\n+    @Override\n+    public long nowInMillis() {\n+      return currentTimeInMillis.get();\n+    }\n+\n+    long advance(long millis) {\n+      return currentTimeInMillis.addAndGet(millis);\n+    }\n+\n+    void setNow(long nowInMillis) {\n+      currentTimeInMillis.set(nowInMillis);\n+    }\n+  }\n+}", "originalCommit": "311289bc9bc88724e67954cae462f67cfe17d0a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjc3Nw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389212777", "bodyText": "um, actually i believe internal linter prefers no new line. but i am not sure i should remove from others. lol", "author": "creamsoup", "createdAt": "2020-03-07T01:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5OTUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY5NjI5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391696296", "bodyText": "I think it's better to be consistent across the project, not necessary the same as internal", "author": "dapengzhang0", "createdAt": "2020-03-12T15:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5OTUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5OTk1MQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389199951", "bodyText": "Random is not thread safe. You can refactor io.grpc.xds.ThreadSafeRandom to intenal or util.", "author": "dapengzhang0", "createdAt": "2020-03-07T00:05:05Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final Ticker ticker;\n+  private final Random random;", "originalCommit": "311289bc9bc88724e67954cae462f67cfe17d0a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjMxNA==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r389212314", "bodyText": "i just used the ThreadLocalRandom because the random doesn't need to be passed from builder.", "author": "creamsoup", "createdAt": "2020-03-07T01:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5OTk1MQ=="}], "type": "inlineReview"}, {"oid": "0048a725e2989533318a82c27f8cc264e6dbb6d6", "url": "https://github.com/grpc/grpc-java/commit/0048a725e2989533318a82c27f8cc264e6dbb6d6", "message": "Merge remote-tracking branch 'upstream/master' into rls_adaptive_throttler", "committedDate": "2020-03-07T00:09:50Z", "type": "commit"}, {"oid": "a8c39320fccff8b20b29f23782773a6805b98987", "url": "https://github.com/grpc/grpc-java/commit/a8c39320fccff8b20b29f23782773a6805b98987", "message": "address review comments", "committedDate": "2020-03-07T01:17:14Z", "type": "commit"}, {"oid": "e79447adc16e601fee528621e3a13fd051db4fa8", "url": "https://github.com/grpc/grpc-java/commit/e79447adc16e601fee528621e3a13fd051db4fa8", "message": "remove boundary", "committedDate": "2020-03-07T01:25:56Z", "type": "commit"}, {"oid": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "url": "https://github.com/grpc/grpc-java/commit/8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "message": "use float", "committedDate": "2020-03-07T01:51:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE3ODQ0Mg==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391178442", "bodyText": "This javadoc is redundant.", "author": "dapengzhang0", "createdAt": "2020-03-11T18:28:38Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final TimeProvider timeProvider;\n+  /**\n+   * The number of requests attempted by the client during the Adaptive Throttler instance's\n+   * history of calls. This includes requests throttled at the client. The history period defaults\n+   * to 30 seconds.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator requestStat;\n+  /**\n+   * Counter for the total number of requests that were throttled by either the client (this class)\n+   * or the backend in recent history.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator throttledStat;\n+\n+  private AdaptiveThrottler(Builder builder) {\n+    this.historySeconds = builder.historySeconds;\n+    this.requestsPadding = builder.requestsPadding;\n+    this.ratioForAccepts = builder.ratioForAccepts;\n+    this.timeProvider = builder.timeProvider;\n+    long internalNanos = TimeUnit.SECONDS.toNanos(historySeconds);\n+    this.requestStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+    this.throttledStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+  }\n+\n+  @Override\n+  public boolean shouldThrottle() {\n+    return shouldThrottle(randomFloat());\n+  }\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */", "originalCommit": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDg3Nw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391960877", "bodyText": "removed.", "author": "creamsoup", "createdAt": "2020-03-12T23:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE3ODQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE3OTMxNw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391179317", "bodyText": "This method can be inlined.", "author": "dapengzhang0", "createdAt": "2020-03-11T18:30:15Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final TimeProvider timeProvider;\n+  /**\n+   * The number of requests attempted by the client during the Adaptive Throttler instance's\n+   * history of calls. This includes requests throttled at the client. The history period defaults\n+   * to 30 seconds.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator requestStat;\n+  /**\n+   * Counter for the total number of requests that were throttled by either the client (this class)\n+   * or the backend in recent history.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator throttledStat;\n+\n+  private AdaptiveThrottler(Builder builder) {\n+    this.historySeconds = builder.historySeconds;\n+    this.requestsPadding = builder.requestsPadding;\n+    this.ratioForAccepts = builder.ratioForAccepts;\n+    this.timeProvider = builder.timeProvider;\n+    long internalNanos = TimeUnit.SECONDS.toNanos(historySeconds);\n+    this.requestStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+    this.throttledStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+  }\n+\n+  @Override\n+  public boolean shouldThrottle() {\n+    return shouldThrottle(randomFloat());\n+  }\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  @VisibleForTesting\n+  boolean shouldThrottle(float random) {\n+    return shouldThrottle(random, timeProvider.currentTimeNanos());\n+  }\n+\n+  private boolean shouldThrottle(float random, long nowNanos) {", "originalCommit": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODk4NA==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391318984", "bodyText": "Why is requestStat incremented twice?", "author": "dapengzhang0", "createdAt": "2020-03-11T23:03:54Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final TimeProvider timeProvider;\n+  /**\n+   * The number of requests attempted by the client during the Adaptive Throttler instance's\n+   * history of calls. This includes requests throttled at the client. The history period defaults\n+   * to 30 seconds.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator requestStat;\n+  /**\n+   * Counter for the total number of requests that were throttled by either the client (this class)\n+   * or the backend in recent history.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator throttledStat;\n+\n+  private AdaptiveThrottler(Builder builder) {\n+    this.historySeconds = builder.historySeconds;\n+    this.requestsPadding = builder.requestsPadding;\n+    this.ratioForAccepts = builder.ratioForAccepts;\n+    this.timeProvider = builder.timeProvider;\n+    long internalNanos = TimeUnit.SECONDS.toNanos(historySeconds);\n+    this.requestStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+    this.throttledStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+  }\n+\n+  @Override\n+  public boolean shouldThrottle() {\n+    return shouldThrottle(randomFloat());\n+  }\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  @VisibleForTesting\n+  boolean shouldThrottle(float random) {\n+    return shouldThrottle(random, timeProvider.currentTimeNanos());\n+  }\n+\n+  private boolean shouldThrottle(float random, long nowNanos) {\n+    if (getThrottleProbability(nowNanos) <= random) {\n+      return false;\n+    }\n+    requestStat.increment(nowNanos);\n+    throttledStat.increment(nowNanos);\n+    return true;\n+  }\n+\n+  /**\n+   * Calculates throttleProbability.\n+   * <pre>\n+   * throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+   * </pre>\n+   */\n+  @VisibleForTesting\n+  float getThrottleProbability(long nowNanos) {\n+    long requests = this.requestStat.get(nowNanos);\n+    long accepts = requests - throttledStat.get(nowNanos);\n+    // It's possible that this probability will be negative, which means that no throttling should\n+    // take place.\n+    return (requests - ratioForAccepts * accepts) / (requests + requestsPadding);\n+  }\n+\n+  @Override\n+  public void registerBackendResponse(boolean throttled) {\n+    long now = timeProvider.currentTimeNanos();\n+    requestStat.increment(now);", "originalCommit": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1NjU0OA==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391956548", "bodyText": "see the link i sent you before.", "author": "creamsoup", "createdAt": "2020-03-12T23:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1ODgyMg==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391958822", "bodyText": "Yeah, but that one has different description for each time.", "author": "dapengzhang0", "createdAt": "2020-03-12T23:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MjE2Nw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391962167", "bodyText": "not the requests, requestStat.", "author": "creamsoup", "createdAt": "2020-03-12T23:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MDg4Mw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391980883", "bodyText": "Now I understand. It's not incremented twice. If shouldThrottle() returns true, this won't happen.", "author": "dapengzhang0", "createdAt": "2020-03-13T01:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MDM4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391360387", "bodyText": "Not used?", "author": "dapengzhang0", "createdAt": "2020-03-12T01:43:22Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final TimeProvider timeProvider;\n+  /**\n+   * The number of requests attempted by the client during the Adaptive Throttler instance's\n+   * history of calls. This includes requests throttled at the client. The history period defaults\n+   * to 30 seconds.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator requestStat;\n+  /**\n+   * Counter for the total number of requests that were throttled by either the client (this class)\n+   * or the backend in recent history.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator throttledStat;\n+\n+  private AdaptiveThrottler(Builder builder) {\n+    this.historySeconds = builder.historySeconds;\n+    this.requestsPadding = builder.requestsPadding;\n+    this.ratioForAccepts = builder.ratioForAccepts;\n+    this.timeProvider = builder.timeProvider;\n+    long internalNanos = TimeUnit.SECONDS.toNanos(historySeconds);\n+    this.requestStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+    this.throttledStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+  }\n+\n+  @Override\n+  public boolean shouldThrottle() {\n+    return shouldThrottle(randomFloat());\n+  }\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  @VisibleForTesting\n+  boolean shouldThrottle(float random) {\n+    return shouldThrottle(random, timeProvider.currentTimeNanos());\n+  }\n+\n+  private boolean shouldThrottle(float random, long nowNanos) {\n+    if (getThrottleProbability(nowNanos) <= random) {\n+      return false;\n+    }\n+    requestStat.increment(nowNanos);\n+    throttledStat.increment(nowNanos);\n+    return true;\n+  }\n+\n+  /**\n+   * Calculates throttleProbability.\n+   * <pre>\n+   * throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+   * </pre>\n+   */\n+  @VisibleForTesting\n+  float getThrottleProbability(long nowNanos) {\n+    long requests = this.requestStat.get(nowNanos);\n+    long accepts = requests - throttledStat.get(nowNanos);\n+    // It's possible that this probability will be negative, which means that no throttling should\n+    // take place.\n+    return (requests - ratioForAccepts * accepts) / (requests + requestsPadding);\n+  }\n+\n+  @Override\n+  public void registerBackendResponse(boolean throttled) {\n+    long now = timeProvider.currentTimeNanos();\n+    requestStat.increment(now);\n+    if (throttled) {\n+      throttledStat.increment(now);\n+    }\n+  }\n+\n+  private static float randomFloat() {\n+    return ThreadLocalRandom.current().nextFloat();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"historySeconds\", historySeconds)\n+        .add(\"requestsPadding\", requestsPadding)\n+        .add(\"ratioForAccepts\", ratioForAccepts)\n+        .add(\"requestStat\", requestStat)\n+        .add(\"throttledStat\", throttledStat)\n+        .toString();\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder for {@link AdaptiveThrottler}. */\n+  public static final class Builder {\n+\n+    private float ratioForAccepts = DEFAULT_RATIO_FOR_ACCEPT;\n+    private int historySeconds = DEFAULT_HISTORY_SECONDS;\n+    private int requestsPadding = DEFAULT_REQUEST_PADDING;\n+    private TimeProvider timeProvider = TimeProvider.SYSTEM_TIME_PROVIDER;\n+\n+    public Builder setRatioForAccepts(float ratioForAccepts) {\n+      this.ratioForAccepts = ratioForAccepts;\n+      return this;\n+    }\n+\n+    public Builder setHistorySeconds(int historySeconds) {\n+      this.historySeconds = historySeconds;\n+      return this;\n+    }\n+\n+    public Builder setRequestsPadding(int requestsPadding) {\n+      this.requestsPadding = requestsPadding;\n+      return this;\n+    }\n+\n+    public Builder setTimeProvider(TimeProvider timeProvider) {\n+      this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+      return this;\n+    }\n+\n+    public AdaptiveThrottler build() {\n+      return new AdaptiveThrottler(this);\n+    }\n+  }\n+\n+  static final class TimeBasedAccumulator {\n+    /**\n+     * The number of slots. This value determines the accuracy of the get() method to interval /\n+     * NUM_SLOTS.\n+     */\n+    private static final int NUM_SLOTS = 50;\n+\n+    /** Holds the data for each slot (amount and end timestamp). */\n+    private static final class Slot {\n+      static final AtomicLongFieldUpdater<Slot> ATOMIC_COUNT =\n+          AtomicLongFieldUpdater.newUpdater(Slot.class, \"count\");\n+\n+      // The count of statistics for the time range represented by this slot.\n+      volatile long count;\n+      // The nearest 0 modulo slot boundary in nanoseconds. The slot boundary\n+      // is exclusive. [previous_slot.end, end)\n+      final long endNanos;\n+\n+      Slot(long endNanos) {\n+        this.endNanos = endNanos;\n+        this.count = 0;\n+      }\n+\n+      void increment() {\n+        ATOMIC_COUNT.incrementAndGet(this);\n+      }\n+    }\n+\n+    // Represents a slot which is not initialized and is unusable.\n+    private static final Slot NULL_SLOT = new Slot(-1);\n+\n+    /** The array of slots. */\n+    private final AtomicReferenceArray<Slot> slots = new AtomicReferenceArray<>(NUM_SLOTS);\n+\n+    /** The time interval this statistic is concerned with. */\n+    private final long interval;\n+\n+    /** The number of nanoseconds in each slot. */\n+    private final long slotNanos;\n+\n+    /**\n+     * The current index into the slot array. {@code currentIndex} may be safely read without\n+     * synchronization, but all writes must be performed inside of a {@code synchronized(this){}}\n+     * block.\n+     */\n+    private volatile int currentIndex;\n+\n+    private final TimeProvider timeProvider;\n+\n+    /**\n+     * Interval constructor.\n+     *\n+     * @param internalNanos is the stat interval in nanoseconds\n+     * @throws IllegalArgumentException if the supplied interval is too small to be effective\n+     */\n+    TimeBasedAccumulator(long internalNanos, TimeProvider timeProvider) {\n+      checkArgument(\n+          internalNanos >= NUM_SLOTS,\n+          \"Interval must be greater than %s\",\n+          NUM_SLOTS);\n+      this.interval = internalNanos;\n+      this.slotNanos = internalNanos / NUM_SLOTS;\n+      this.currentIndex = 0;\n+      for (int i = 0; i < NUM_SLOTS; i++) {\n+        slots.set(i, NULL_SLOT);\n+      }\n+      this.timeProvider = checkNotNull(timeProvider, \"ticker\");\n+    }\n+\n+    /** Gets the current slot. */\n+    private Slot getSlot(long now) {\n+      Slot currentSlot = slots.get(currentIndex);\n+      if (now < currentSlot.endNanos) {\n+        return currentSlot;\n+      } else {\n+        long slotBoundary = getSlotEndTime(now);\n+        synchronized (this) {\n+          int index = currentIndex;\n+          currentSlot = slots.get(index);\n+          if (now < currentSlot.endNanos) {\n+            return currentSlot;\n+          }\n+          int newIndex = (index == NUM_SLOTS - 1) ? 0 : index + 1;\n+          Slot nextSlot = new Slot(slotBoundary);\n+          slots.set(newIndex, nextSlot);\n+          // Set currentIndex only after assigning the new slot to slots, otherwise\n+          // racing readers will see NULL_SLOT or an old slot.\n+          currentIndex = newIndex;\n+          return nextSlot;\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Computes the end boundary since the last bucket can be partial size.\n+     *\n+     * @param time the time for which to find the nearest slot boundary\n+     * @return the nearest slot boundary (in ms)\n+     */\n+    private long getSlotEndTime(long time) {\n+      return (time / slotNanos + 1) * slotNanos;\n+    }\n+\n+    /**\n+     * Returns the interval used by this statistic.\n+     *\n+     * @return the interval\n+     */\n+    public long getInterval() {\n+      return this.interval;\n+    }\n+\n+    /** Increments the count of the statistic by the specified amount for the specified time. */\n+    final void increment() {", "originalCommit": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDk0NQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391960945", "bodyText": "removed", "author": "creamsoup", "createdAt": "2020-03-12T23:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MTc0Ng==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391361746", "bodyText": "Seems this can be inlined.", "author": "dapengzhang0", "createdAt": "2020-03-12T01:50:16Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final TimeProvider timeProvider;\n+  /**\n+   * The number of requests attempted by the client during the Adaptive Throttler instance's\n+   * history of calls. This includes requests throttled at the client. The history period defaults\n+   * to 30 seconds.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator requestStat;\n+  /**\n+   * Counter for the total number of requests that were throttled by either the client (this class)\n+   * or the backend in recent history.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator throttledStat;\n+\n+  private AdaptiveThrottler(Builder builder) {\n+    this.historySeconds = builder.historySeconds;\n+    this.requestsPadding = builder.requestsPadding;\n+    this.ratioForAccepts = builder.ratioForAccepts;\n+    this.timeProvider = builder.timeProvider;\n+    long internalNanos = TimeUnit.SECONDS.toNanos(historySeconds);\n+    this.requestStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+    this.throttledStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+  }\n+\n+  @Override\n+  public boolean shouldThrottle() {\n+    return shouldThrottle(randomFloat());\n+  }\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  @VisibleForTesting\n+  boolean shouldThrottle(float random) {\n+    return shouldThrottle(random, timeProvider.currentTimeNanos());\n+  }\n+\n+  private boolean shouldThrottle(float random, long nowNanos) {\n+    if (getThrottleProbability(nowNanos) <= random) {\n+      return false;\n+    }\n+    requestStat.increment(nowNanos);\n+    throttledStat.increment(nowNanos);\n+    return true;\n+  }\n+\n+  /**\n+   * Calculates throttleProbability.\n+   * <pre>\n+   * throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+   * </pre>\n+   */\n+  @VisibleForTesting\n+  float getThrottleProbability(long nowNanos) {\n+    long requests = this.requestStat.get(nowNanos);\n+    long accepts = requests - throttledStat.get(nowNanos);\n+    // It's possible that this probability will be negative, which means that no throttling should\n+    // take place.\n+    return (requests - ratioForAccepts * accepts) / (requests + requestsPadding);\n+  }\n+\n+  @Override\n+  public void registerBackendResponse(boolean throttled) {\n+    long now = timeProvider.currentTimeNanos();\n+    requestStat.increment(now);\n+    if (throttled) {\n+      throttledStat.increment(now);\n+    }\n+  }\n+\n+  private static float randomFloat() {\n+    return ThreadLocalRandom.current().nextFloat();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"historySeconds\", historySeconds)\n+        .add(\"requestsPadding\", requestsPadding)\n+        .add(\"ratioForAccepts\", ratioForAccepts)\n+        .add(\"requestStat\", requestStat)\n+        .add(\"throttledStat\", throttledStat)\n+        .toString();\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder for {@link AdaptiveThrottler}. */\n+  public static final class Builder {\n+\n+    private float ratioForAccepts = DEFAULT_RATIO_FOR_ACCEPT;\n+    private int historySeconds = DEFAULT_HISTORY_SECONDS;\n+    private int requestsPadding = DEFAULT_REQUEST_PADDING;\n+    private TimeProvider timeProvider = TimeProvider.SYSTEM_TIME_PROVIDER;\n+\n+    public Builder setRatioForAccepts(float ratioForAccepts) {\n+      this.ratioForAccepts = ratioForAccepts;\n+      return this;\n+    }\n+\n+    public Builder setHistorySeconds(int historySeconds) {\n+      this.historySeconds = historySeconds;\n+      return this;\n+    }\n+\n+    public Builder setRequestsPadding(int requestsPadding) {\n+      this.requestsPadding = requestsPadding;\n+      return this;\n+    }\n+\n+    public Builder setTimeProvider(TimeProvider timeProvider) {\n+      this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+      return this;\n+    }\n+\n+    public AdaptiveThrottler build() {\n+      return new AdaptiveThrottler(this);\n+    }\n+  }\n+\n+  static final class TimeBasedAccumulator {\n+    /**\n+     * The number of slots. This value determines the accuracy of the get() method to interval /\n+     * NUM_SLOTS.\n+     */\n+    private static final int NUM_SLOTS = 50;\n+\n+    /** Holds the data for each slot (amount and end timestamp). */\n+    private static final class Slot {\n+      static final AtomicLongFieldUpdater<Slot> ATOMIC_COUNT =\n+          AtomicLongFieldUpdater.newUpdater(Slot.class, \"count\");\n+\n+      // The count of statistics for the time range represented by this slot.\n+      volatile long count;\n+      // The nearest 0 modulo slot boundary in nanoseconds. The slot boundary\n+      // is exclusive. [previous_slot.end, end)\n+      final long endNanos;\n+\n+      Slot(long endNanos) {\n+        this.endNanos = endNanos;\n+        this.count = 0;\n+      }\n+\n+      void increment() {\n+        ATOMIC_COUNT.incrementAndGet(this);\n+      }\n+    }\n+\n+    // Represents a slot which is not initialized and is unusable.\n+    private static final Slot NULL_SLOT = new Slot(-1);\n+\n+    /** The array of slots. */\n+    private final AtomicReferenceArray<Slot> slots = new AtomicReferenceArray<>(NUM_SLOTS);\n+\n+    /** The time interval this statistic is concerned with. */\n+    private final long interval;\n+\n+    /** The number of nanoseconds in each slot. */\n+    private final long slotNanos;\n+\n+    /**\n+     * The current index into the slot array. {@code currentIndex} may be safely read without\n+     * synchronization, but all writes must be performed inside of a {@code synchronized(this){}}\n+     * block.\n+     */\n+    private volatile int currentIndex;\n+\n+    private final TimeProvider timeProvider;\n+\n+    /**\n+     * Interval constructor.\n+     *\n+     * @param internalNanos is the stat interval in nanoseconds\n+     * @throws IllegalArgumentException if the supplied interval is too small to be effective\n+     */\n+    TimeBasedAccumulator(long internalNanos, TimeProvider timeProvider) {\n+      checkArgument(\n+          internalNanos >= NUM_SLOTS,\n+          \"Interval must be greater than %s\",\n+          NUM_SLOTS);\n+      this.interval = internalNanos;\n+      this.slotNanos = internalNanos / NUM_SLOTS;\n+      this.currentIndex = 0;\n+      for (int i = 0; i < NUM_SLOTS; i++) {\n+        slots.set(i, NULL_SLOT);\n+      }\n+      this.timeProvider = checkNotNull(timeProvider, \"ticker\");\n+    }\n+\n+    /** Gets the current slot. */\n+    private Slot getSlot(long now) {\n+      Slot currentSlot = slots.get(currentIndex);\n+      if (now < currentSlot.endNanos) {\n+        return currentSlot;\n+      } else {\n+        long slotBoundary = getSlotEndTime(now);\n+        synchronized (this) {\n+          int index = currentIndex;\n+          currentSlot = slots.get(index);\n+          if (now < currentSlot.endNanos) {\n+            return currentSlot;\n+          }\n+          int newIndex = (index == NUM_SLOTS - 1) ? 0 : index + 1;\n+          Slot nextSlot = new Slot(slotBoundary);\n+          slots.set(newIndex, nextSlot);\n+          // Set currentIndex only after assigning the new slot to slots, otherwise\n+          // racing readers will see NULL_SLOT or an old slot.\n+          currentIndex = newIndex;\n+          return nextSlot;\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Computes the end boundary since the last bucket can be partial size.\n+     *\n+     * @param time the time for which to find the nearest slot boundary\n+     * @return the nearest slot boundary (in ms)\n+     */\n+    private long getSlotEndTime(long time) {\n+      return (time / slotNanos + 1) * slotNanos;\n+    }\n+\n+    /**\n+     * Returns the interval used by this statistic.\n+     *\n+     * @return the interval\n+     */\n+    public long getInterval() {\n+      return this.interval;\n+    }\n+\n+    /** Increments the count of the statistic by the specified amount for the specified time. */\n+    final void increment() {\n+      increment(timeProvider.currentTimeNanos());\n+    }\n+\n+    /**\n+     * Increments the count of the statistic by the specified amount for the specified time.\n+     *\n+     * @param now is the time used to increment the count\n+     */\n+    final void increment(long now) {\n+      getSlot(now).increment();\n+    }\n+\n+    /**\n+     * Returns the count of the statistic over the statistic's configured time interval.\n+     *\n+     * @return the statistic count\n+     */\n+    final long get() {\n+      return get(timeProvider.currentTimeNanos());", "originalCommit": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2Mjc0Ng==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391362746", "bodyText": "in nanos?", "author": "dapengzhang0", "createdAt": "2020-03-12T01:54:50Z", "path": "rls/src/main/java/io/grpc/rls/internal/AdaptiveThrottler.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+/**\n+ * Implementation of {@link Throttler} that keeps track of recent history (the duration of which is\n+ * specified to the constructor) and throttles requests at the client side based on the number of\n+ * requests that the\n+ * backend has accepted and the total number of requests generated. A given request will be\n+ * throttled with a probability\n+ * <pre>\n+ *   throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+ * </pre>\n+ * where requests is the total number of requests, accepts is the total number of requests that the\n+ * backend has accepted and ratio_for_accepts is just a constant multiplier passed to the\n+ * constructor (see the description of ratio_for_accepts for more information).\n+ */\n+public final class AdaptiveThrottler implements Throttler {\n+\n+  private static final int DEFAULT_HISTORY_SECONDS = 30;\n+  private static final int DEFAULT_REQUEST_PADDING = 8;\n+  private static final float DEFAULT_RATIO_FOR_ACCEPT = 1.2f;\n+\n+  /**\n+   * The duration of history of calls used by Adaptive Throttler.\n+   */\n+  private final int historySeconds;\n+  /**\n+   * A magic number to tune the aggressiveness of the throttling. High numbers throttle less. The\n+   * default is 8.\n+   */\n+  private final int requestsPadding;\n+  /**\n+   * The ratio by which the Adaptive Throttler will attempt to send requests above what the server\n+   * is currently accepting.\n+   */\n+  private final float ratioForAccepts;\n+  private final TimeProvider timeProvider;\n+  /**\n+   * The number of requests attempted by the client during the Adaptive Throttler instance's\n+   * history of calls. This includes requests throttled at the client. The history period defaults\n+   * to 30 seconds.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator requestStat;\n+  /**\n+   * Counter for the total number of requests that were throttled by either the client (this class)\n+   * or the backend in recent history.\n+   */\n+  @VisibleForTesting\n+  final TimeBasedAccumulator throttledStat;\n+\n+  private AdaptiveThrottler(Builder builder) {\n+    this.historySeconds = builder.historySeconds;\n+    this.requestsPadding = builder.requestsPadding;\n+    this.ratioForAccepts = builder.ratioForAccepts;\n+    this.timeProvider = builder.timeProvider;\n+    long internalNanos = TimeUnit.SECONDS.toNanos(historySeconds);\n+    this.requestStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+    this.throttledStat = new TimeBasedAccumulator(internalNanos, timeProvider);\n+  }\n+\n+  @Override\n+  public boolean shouldThrottle() {\n+    return shouldThrottle(randomFloat());\n+  }\n+\n+  /**\n+   * Checks if a given request should be throttled by the client. This should be called for every\n+   * request before allowing it to hit the network. If the returned value is true, the request\n+   * should be aborted immediately (as if it had been throttled by the server).\n+   *\n+   * <p>This updates internal state and should be called exactly once for each request.\n+   */\n+  @VisibleForTesting\n+  boolean shouldThrottle(float random) {\n+    return shouldThrottle(random, timeProvider.currentTimeNanos());\n+  }\n+\n+  private boolean shouldThrottle(float random, long nowNanos) {\n+    if (getThrottleProbability(nowNanos) <= random) {\n+      return false;\n+    }\n+    requestStat.increment(nowNanos);\n+    throttledStat.increment(nowNanos);\n+    return true;\n+  }\n+\n+  /**\n+   * Calculates throttleProbability.\n+   * <pre>\n+   * throttleProbability = (requests - ratio_for_accepts * accepts) / (requests + requests_padding)\n+   * </pre>\n+   */\n+  @VisibleForTesting\n+  float getThrottleProbability(long nowNanos) {\n+    long requests = this.requestStat.get(nowNanos);\n+    long accepts = requests - throttledStat.get(nowNanos);\n+    // It's possible that this probability will be negative, which means that no throttling should\n+    // take place.\n+    return (requests - ratioForAccepts * accepts) / (requests + requestsPadding);\n+  }\n+\n+  @Override\n+  public void registerBackendResponse(boolean throttled) {\n+    long now = timeProvider.currentTimeNanos();\n+    requestStat.increment(now);\n+    if (throttled) {\n+      throttledStat.increment(now);\n+    }\n+  }\n+\n+  private static float randomFloat() {\n+    return ThreadLocalRandom.current().nextFloat();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"historySeconds\", historySeconds)\n+        .add(\"requestsPadding\", requestsPadding)\n+        .add(\"ratioForAccepts\", ratioForAccepts)\n+        .add(\"requestStat\", requestStat)\n+        .add(\"throttledStat\", throttledStat)\n+        .toString();\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder for {@link AdaptiveThrottler}. */\n+  public static final class Builder {\n+\n+    private float ratioForAccepts = DEFAULT_RATIO_FOR_ACCEPT;\n+    private int historySeconds = DEFAULT_HISTORY_SECONDS;\n+    private int requestsPadding = DEFAULT_REQUEST_PADDING;\n+    private TimeProvider timeProvider = TimeProvider.SYSTEM_TIME_PROVIDER;\n+\n+    public Builder setRatioForAccepts(float ratioForAccepts) {\n+      this.ratioForAccepts = ratioForAccepts;\n+      return this;\n+    }\n+\n+    public Builder setHistorySeconds(int historySeconds) {\n+      this.historySeconds = historySeconds;\n+      return this;\n+    }\n+\n+    public Builder setRequestsPadding(int requestsPadding) {\n+      this.requestsPadding = requestsPadding;\n+      return this;\n+    }\n+\n+    public Builder setTimeProvider(TimeProvider timeProvider) {\n+      this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+      return this;\n+    }\n+\n+    public AdaptiveThrottler build() {\n+      return new AdaptiveThrottler(this);\n+    }\n+  }\n+\n+  static final class TimeBasedAccumulator {\n+    /**\n+     * The number of slots. This value determines the accuracy of the get() method to interval /\n+     * NUM_SLOTS.\n+     */\n+    private static final int NUM_SLOTS = 50;\n+\n+    /** Holds the data for each slot (amount and end timestamp). */\n+    private static final class Slot {\n+      static final AtomicLongFieldUpdater<Slot> ATOMIC_COUNT =\n+          AtomicLongFieldUpdater.newUpdater(Slot.class, \"count\");\n+\n+      // The count of statistics for the time range represented by this slot.\n+      volatile long count;\n+      // The nearest 0 modulo slot boundary in nanoseconds. The slot boundary\n+      // is exclusive. [previous_slot.end, end)\n+      final long endNanos;\n+\n+      Slot(long endNanos) {\n+        this.endNanos = endNanos;\n+        this.count = 0;\n+      }\n+\n+      void increment() {\n+        ATOMIC_COUNT.incrementAndGet(this);\n+      }\n+    }\n+\n+    // Represents a slot which is not initialized and is unusable.\n+    private static final Slot NULL_SLOT = new Slot(-1);\n+\n+    /** The array of slots. */\n+    private final AtomicReferenceArray<Slot> slots = new AtomicReferenceArray<>(NUM_SLOTS);\n+\n+    /** The time interval this statistic is concerned with. */\n+    private final long interval;\n+\n+    /** The number of nanoseconds in each slot. */\n+    private final long slotNanos;\n+\n+    /**\n+     * The current index into the slot array. {@code currentIndex} may be safely read without\n+     * synchronization, but all writes must be performed inside of a {@code synchronized(this){}}\n+     * block.\n+     */\n+    private volatile int currentIndex;\n+\n+    private final TimeProvider timeProvider;\n+\n+    /**\n+     * Interval constructor.\n+     *\n+     * @param internalNanos is the stat interval in nanoseconds\n+     * @throws IllegalArgumentException if the supplied interval is too small to be effective\n+     */\n+    TimeBasedAccumulator(long internalNanos, TimeProvider timeProvider) {\n+      checkArgument(\n+          internalNanos >= NUM_SLOTS,\n+          \"Interval must be greater than %s\",\n+          NUM_SLOTS);\n+      this.interval = internalNanos;\n+      this.slotNanos = internalNanos / NUM_SLOTS;\n+      this.currentIndex = 0;\n+      for (int i = 0; i < NUM_SLOTS; i++) {\n+        slots.set(i, NULL_SLOT);\n+      }\n+      this.timeProvider = checkNotNull(timeProvider, \"ticker\");\n+    }\n+\n+    /** Gets the current slot. */\n+    private Slot getSlot(long now) {\n+      Slot currentSlot = slots.get(currentIndex);\n+      if (now < currentSlot.endNanos) {\n+        return currentSlot;\n+      } else {\n+        long slotBoundary = getSlotEndTime(now);\n+        synchronized (this) {\n+          int index = currentIndex;\n+          currentSlot = slots.get(index);\n+          if (now < currentSlot.endNanos) {\n+            return currentSlot;\n+          }\n+          int newIndex = (index == NUM_SLOTS - 1) ? 0 : index + 1;\n+          Slot nextSlot = new Slot(slotBoundary);\n+          slots.set(newIndex, nextSlot);\n+          // Set currentIndex only after assigning the new slot to slots, otherwise\n+          // racing readers will see NULL_SLOT or an old slot.\n+          currentIndex = newIndex;\n+          return nextSlot;\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Computes the end boundary since the last bucket can be partial size.\n+     *\n+     * @param time the time for which to find the nearest slot boundary\n+     * @return the nearest slot boundary (in ms)", "originalCommit": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDk5Mw==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391960993", "bodyText": "done.", "author": "creamsoup", "createdAt": "2020-03-12T23:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2Mjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3OTA0OA==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391779048", "bodyText": "You can alternatively use FakeClock.getTimeProvider() (need testCompile project(':grpc-core').sourceSets.test.output though)", "author": "dapengzhang0", "createdAt": "2020-03-12T17:28:56Z", "path": "rls/src/test/java/io/grpc/rls/internal/AdaptiveThrottlerTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AdaptiveThrottlerTest {\n+  private static final float TOLERANCE = 0.0001f;\n+\n+  private final FakeTimeProvider fakeTimeProvider = new FakeTimeProvider();\n+  private final AdaptiveThrottler throttler =\n+      new AdaptiveThrottler.Builder()\n+          .setHistorySeconds(1)\n+          .setRatioForAccepts(1.0f)\n+          .setRequestsPadding(1)\n+          .setTimeProvider(fakeTimeProvider)\n+          .build();\n+\n+  @Test\n+  public void shouldThrottle() {\n+    // initial states\n+    assertThat(throttler.requestStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(0L);\n+    assertThat(throttler.throttledStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(0L);\n+    assertThat(throttler.getThrottleProbability(fakeTimeProvider.currentTimeNanos()))\n+        .isWithin(TOLERANCE).of(0.0f);\n+\n+    // Request 1, allowed by all.\n+    assertThat(throttler.shouldThrottle(0.4f)).isFalse();\n+    fakeTimeProvider.advance(1L, TimeUnit.MILLISECONDS);\n+    throttler.registerBackendResponse(false);\n+\n+    assertThat(throttler.requestStat.get(fakeTimeProvider.currentTimeNanos()))\n+        .isEqualTo(1L);\n+    assertThat(throttler.throttledStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(0L);\n+    assertThat(throttler.getThrottleProbability(fakeTimeProvider.currentTimeNanos()))\n+        .isWithin(TOLERANCE).of(0.0f);\n+\n+    // Request 2, throttled by backend\n+    assertThat(throttler.shouldThrottle(0.4f)).isFalse();\n+    fakeTimeProvider.advance(1L, TimeUnit.MILLISECONDS);\n+    throttler.registerBackendResponse(true);\n+\n+    assertThat(throttler.requestStat.get(fakeTimeProvider.currentTimeNanos()))\n+        .isEqualTo(2L);\n+    assertThat(throttler.throttledStat.get(fakeTimeProvider.currentTimeNanos()))\n+        .isEqualTo(1L);\n+    assertThat(throttler.getThrottleProbability(fakeTimeProvider.currentTimeNanos()))\n+        .isWithin(TOLERANCE)\n+        .of(1.0f / 3.0f);\n+\n+    // Skip half a second (half the duration).\n+    fakeTimeProvider.setNow(500L, TimeUnit.MILLISECONDS);\n+\n+    // Request 3, throttled by backend\n+    assertThat(throttler.shouldThrottle(0.4f)).isFalse();\n+    fakeTimeProvider.advance(1L, TimeUnit.MILLISECONDS);\n+    throttler.registerBackendResponse(true);\n+\n+    assertThat(throttler.requestStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(3L);\n+    assertThat(throttler.throttledStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(2L);\n+    assertThat(throttler.getThrottleProbability(fakeTimeProvider.currentTimeNanos()))\n+        .isWithin(TOLERANCE)\n+        .of(2.0f / 4.0f);\n+\n+    // Request 4, throttled by client.\n+    assertThat(throttler.shouldThrottle(0.4f)).isTrue();\n+    fakeTimeProvider.advance(1L, TimeUnit.MILLISECONDS);\n+\n+    assertThat(throttler.requestStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(4L);\n+    assertThat(throttler.throttledStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(3L);\n+    assertThat(throttler.getThrottleProbability(fakeTimeProvider.currentTimeNanos()))\n+        .isWithin(TOLERANCE)\n+        .of(3.0f / 5.0f);\n+\n+    // Skip to the point where only requests 3 and 4 are visible.\n+    fakeTimeProvider.setNow(1250L, TimeUnit.MILLISECONDS);\n+\n+    assertThat(throttler.requestStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(2L);\n+    assertThat(throttler.throttledStat.get(fakeTimeProvider.currentTimeNanos())).isEqualTo(2L);\n+    assertThat(throttler.getThrottleProbability(fakeTimeProvider.currentTimeNanos()))\n+        .isWithin(TOLERANCE)\n+        .of(2.0f / 3.0f);\n+  }\n+\n+  private static final class FakeTimeProvider implements TimeProvider {", "originalCommit": "8e8c10ab6e3c64f8a6bdce0f215c536b2e831aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1NjMxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391956311", "bodyText": "done.", "author": "creamsoup", "createdAt": "2020-03-12T23:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3OTA0OA=="}], "type": "inlineReview"}, {"oid": "b00871ff90e6b93b2f79915ca8518f35b81e0f7e", "url": "https://github.com/grpc/grpc-java/commit/b00871ff90e6b93b2f79915ca8518f35b81e0f7e", "message": "address review comments", "committedDate": "2020-03-12T23:24:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1OTE1MQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391959151", "bodyText": "fakeTimeProvider", "author": "dapengzhang0", "createdAt": "2020-03-12T23:35:46Z", "path": "rls/src/test/java/io/grpc/rls/internal/AdaptiveThrottlerTest.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.internal.FakeClock;\n+import io.grpc.internal.TimeProvider;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AdaptiveThrottlerTest {\n+  private static final float TOLERANCE = 0.0001f;\n+\n+  private final FakeClock fakeClock = new FakeClock();\n+  private final TimeProvider fakeTimeProvider = fakeClock.getTimeProvider();\n+  private final AdaptiveThrottler throttler =\n+      new AdaptiveThrottler.Builder()\n+          .setHistorySeconds(1)\n+          .setRatioForAccepts(1.0f)\n+          .setRequestsPadding(1)\n+          .setTimeProvider(fakeClock.getTimeProvider())", "originalCommit": "b00871ff90e6b93b2f79915ca8518f35b81e0f7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk4MTY4NQ==", "url": "https://github.com/grpc/grpc-java/pull/6749#discussion_r391981685", "bodyText": "oops thanks", "author": "creamsoup", "createdAt": "2020-03-13T01:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1OTE1MQ=="}], "type": "inlineReview"}, {"oid": "8313b77cbcb3b2171f1c70132103ea02803cb7d8", "url": "https://github.com/grpc/grpc-java/commit/8313b77cbcb3b2171f1c70132103ea02803cb7d8", "message": "use declared variable", "committedDate": "2020-03-13T01:12:42Z", "type": "commit"}]}