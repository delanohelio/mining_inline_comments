{"pr_number": 7391, "pr_title": "xds: reimplement EDS LB policy with downstream LB config generations that migrate to hierarchical LB tree codepath", "pr_createdAt": "2020-09-03T17:16:06Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7391", "timeline": [{"oid": "db94708e43152d2fa1c263a9ae7f3fb15012cf31", "url": "https://github.com/grpc/grpc-java/commit/db94708e43152d2fa1c263a9ae7f3fb15012cf31", "message": "Add locality_pickinig_policy field to EdsConfig.", "committedDate": "2020-09-03T17:11:19Z", "type": "commit"}, {"oid": "309a77908fb35e8b0151e8ade5d50d8997e7a381", "url": "https://github.com/grpc/grpc-java/commit/309a77908fb35e8b0151e8ade5d50d8997e7a381", "message": "Clean up EdsLoadBalancerProvider test.", "committedDate": "2020-09-03T17:11:47Z", "type": "commit"}, {"oid": "79b65a6c8754b8f6f3f05d5805db78784b2347f5", "url": "https://github.com/grpc/grpc-java/commit/79b65a6c8754b8f6f3f05d5805db78784b2347f5", "message": "Add missing LB policies for service loading.", "committedDate": "2020-09-03T17:13:31Z", "type": "commit"}, {"oid": "94feec55cba5fba25dfc4a647978356ba53d8ef1", "url": "https://github.com/grpc/grpc-java/commit/94feec55cba5fba25dfc4a647978356ba53d8ef1", "message": "Reimplement EDS LB policy with downstream LB policy config generations that migrates to hierarchical LB tree codepath.", "committedDate": "2020-09-03T17:14:26Z", "type": "commit"}, {"oid": "ae61247717b5289b9d11589a667b9ef9c9edada8", "url": "https://github.com/grpc/grpc-java/commit/ae61247717b5289b9d11589a667b9ef9c9edada8", "message": "Fix child balancer's helper not wrapped by GracefulSwitchLoadBalancer.", "committedDate": "2020-09-03T19:01:32Z", "type": "forcePushed"}, {"oid": "55606fc817c5b000d026b11743e42ff46792f0d9", "url": "https://github.com/grpc/grpc-java/commit/55606fc817c5b000d026b11743e42ff46792f0d9", "message": "Fix child balancer's helper not wrapped by GracefulSwitchLoadBalancer.", "committedDate": "2020-09-03T19:03:05Z", "type": "commit"}, {"oid": "a6b6206d9e4e9f1a16af6069b2784c93985b94a8", "url": "https://github.com/grpc/grpc-java/commit/a6b6206d9e4e9f1a16af6069b2784c93985b94a8", "message": "WIP: EDS LB policy tests.", "committedDate": "2020-09-03T19:03:05Z", "type": "forcePushed"}, {"oid": "19771099b520080050dc1ed8985b111e48bab003", "url": "https://github.com/grpc/grpc-java/commit/19771099b520080050dc1ed8985b111e48bab003", "message": "Add EDS LB policy tests.", "committedDate": "2020-09-03T19:25:17Z", "type": "forcePushed"}, {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773", "url": "https://github.com/grpc/grpc-java/commit/7286d5c5b7854d39fffc63af5a4279e84482b773", "message": "Add EDS LB policy tests.", "committedDate": "2020-09-03T19:32:00Z", "type": "commit"}, {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773", "url": "https://github.com/grpc/grpc-java/commit/7286d5c5b7854d39fffc63af5a4279e84482b773", "message": "Add EDS LB policy tests.", "committedDate": "2020-09-03T19:32:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MjkzNA==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486692934", "bodyText": "The comment is not necessary as with edsServiceName", "author": "dapengzhang0", "createdAt": "2020-09-10T23:45:16Z", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final LoadBalancer.Helper helper;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n+    logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;  // assume LRS server never change", "originalCommit": "7286d5c5b7854d39fffc63af5a4279e84482b773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTY2Nw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486729667", "bodyText": "Deleted.", "author": "voidzcy", "createdAt": "2020-09-11T02:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5NjI5NA==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486696294", "bodyText": "The attribute should be updated each time handleResolvedAddresses().", "author": "dapengzhang0", "createdAt": "2020-09-10T23:56:41Z", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final LoadBalancer.Helper helper;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n+    logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;  // assume LRS server never change\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(edsServiceName, lrsServerName);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (!(obj instanceof EdsLbState)) {\n+        return false;\n+      }\n+      EdsLbState that = (EdsLbState) obj;\n+      return Objects.equals(edsServiceName, that.edsServiceName)\n+          && Objects.equals(lrsServerName, that.lrsServerName);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final Attributes attributes;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+          attributes =", "originalCommit": "7286d5c5b7854d39fffc63af5a4279e84482b773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTYzNA==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486729634", "bodyText": "Okay, I removed the separate caching of attributes. Instead, always populate from the freshest ResolvedAddresses.", "author": "voidzcy", "createdAt": "2020-09-11T02:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5NjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwMDU1Mw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486700553", "bodyText": "This is the wrong helper. The right helper should be the helper from the constructor ChildLbState(Helper helper) that the GracefulSwitchingLoadBalancer passes to it, which could be a pendingHelper that does not propagate TRANSIENT_FAILURE upstream. Even forget about the above technical details, the right helper should still be the wrapped helper in the direct layer, and allow that layer to intercept update.\nSame for onResourceDoesNotExist() and onError().", "author": "dapengzhang0", "createdAt": "2020-09-11T00:12:17Z", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final LoadBalancer.Helper helper;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n+    logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;  // assume LRS server never change\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(edsServiceName, lrsServerName);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (!(obj instanceof EdsLbState)) {\n+        return false;\n+      }\n+      EdsLbState that = (EdsLbState) obj;\n+      return Objects.equals(edsServiceName, that.edsServiceName)\n+          && Objects.equals(lrsServerName, that.lrsServerName);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final Attributes attributes;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+          attributes =\n+              resolvedAddresses.getAttributes().toBuilder()\n+                  .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                  .build();\n+        } else {\n+          loadStatsStore = null;\n+          attributes = resolvedAddresses.getAttributes();\n+        }\n+        lbHelper = new DropHandlingLbHelper(helper);\n+      }\n+\n+      @Override\n+      public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+        EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+        if (lb != null) {\n+          if (!config.localityPickingPolicy.equals(localityPickingPolicy)\n+              || !config.endpointPickingPolicy.equals(endpointPickingPolicy)) {\n+            PriorityLbConfig childConfig =\n+                generatePriorityLbConfig(cluster, edsServiceName, lrsServerName,\n+                    config.localityPickingPolicy, config.endpointPickingPolicy, lbRegistry,\n+                    prioritizedLocalityWeights);\n+            lb.handleResolvedAddresses(\n+                resolvedAddresses.toBuilder()\n+                    .setAddresses(endpointAddresses)\n+                    .setAttributes(attributes)\n+                    .setLoadBalancingPolicyConfig(childConfig)\n+                    .build());\n+          }\n+        }\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+\n+      @Override\n+      public void handleNameResolutionError(Status error) {\n+        if (lb != null) {\n+          lb.handleNameResolutionError(error);\n+        } else {\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));", "originalCommit": "7286d5c5b7854d39fffc63af5a4279e84482b773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTM3NQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486729375", "bodyText": "Good catch. This is a subtle one. Fixed.", "author": "voidzcy", "createdAt": "2020-09-11T02:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwMDU1Mw=="}], "type": "inlineReview"}, {"oid": "ef67f6a8b5d64638695cb1df91054eb9f947d2c9", "url": "https://github.com/grpc/grpc-java/commit/ef67f6a8b5d64638695cb1df91054eb9f947d2c9", "message": "Delete unnecessary comment.", "committedDate": "2020-09-11T00:51:10Z", "type": "commit"}, {"oid": "c02bf061a2be8a329a7319d2b995f61e6c1a9920", "url": "https://github.com/grpc/grpc-java/commit/c02bf061a2be8a329a7319d2b995f61e6c1a9920", "message": "Fix to use a single reference of attributes and downstream policies should be initialized before watching the endpoint info.", "committedDate": "2020-09-11T01:45:24Z", "type": "commit"}, {"oid": "fe8372fdd21df6254d95494116e6baba83bd3ca1", "url": "https://github.com/grpc/grpc-java/commit/fe8372fdd21df6254d95494116e6baba83bd3ca1", "message": "Fix using the wrong helper.", "committedDate": "2020-09-11T02:05:12Z", "type": "commit"}, {"oid": "fe8372fdd21df6254d95494116e6baba83bd3ca1", "url": "https://github.com/grpc/grpc-java/commit/fe8372fdd21df6254d95494116e6baba83bd3ca1", "message": "Fix using the wrong helper.", "committedDate": "2020-09-11T02:05:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjE5OQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r488286199", "bodyText": "This looks more than a fix. You changed the definition of EdsLbState, why? But EdsLbState equals()andhashCode()` are not changed accordingly.", "author": "dapengzhang0", "createdAt": "2020-09-14T23:05:52Z", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -105,7 +105,9 @@ public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n     if (cluster == null) {\n       cluster = config.clusterName;\n     }\n-    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.switchTo(new EdsLbState(\n+        config.edsServiceName, config.lrsServerName, config.localityPickingPolicy,", "originalCommit": "c02bf061a2be8a329a7319d2b995f61e6c1a9920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4OTY2Nw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r488289667", "bodyText": "That's done purposely. EdsLbState is a LoadBalancer.Factory used for switching during the eds_service_name or lrs_server_name change (aka, replacing cluster). But we don't treat changing endpoint_picking_policy or locality_picking_policy as replacing cluster. So they are not part of equality of EdsLbState. These two fields are mutable and are moved to EdsLbState from ChildLbState to avoid the watcher reentrancy issue: ChildLbState is subscribing to some endpoint resource, while the addWatcher operation can invoke the callback inline (reentrant). So it is too late to set up ChildLbState's  endpoint_picking_policy and locality_picking_policy in its handleResolvedAddresses.", "author": "voidzcy", "createdAt": "2020-09-14T23:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5NDM0Mw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r488294343", "bodyText": "I'm not so comfortable having these mutable fields in a Factory. It looks not elegant. Is it possible to move xdsClient.watchEndpointData() in handleResolvedAddresses() to avoid reentrancy issue?", "author": "dapengzhang0", "createdAt": "2020-09-14T23:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3MzA4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r488873082", "bodyText": "I tried a couple of different approaches, none of them seems to be satisfactory. handleResolvedAddresses is called for multiple times while xdsClient.watchEndpointData() is only called once. Moving it into handleResolvedAddresses is cumbersome. From another aspect, EdsLbState is not just a LoadBalancer.Factory, it implements LoadBalancer.Factory because we have to (because of the usage of GracefulSwitchLoadBalancer API), but it's also representing the state of EdsLoadBalancer: a running instance for one EdsConfig (eds_service_name, lrs_server_name, locality_picking_policy, endpoint_picking_policy). From this perspective, it's not that weird to have endpoint_picking_policy and locality_picking_policy saved there.", "author": "voidzcy", "createdAt": "2020-09-15T18:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc3MjQwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489772401", "bodyText": "Moved endpoint_picking_policy and locality_picking_policy into ChildLbState. Delaying the execution of xdsClient.watchEndpointData() outside ChildLbState's constructor to avoid reentrancy may be problematic, as ChildLbState.shutdown() (which cancels the watcher) may happen before current task in the syncContext returns. So it'd be better to keep watcher addition/cancellation in place. Instead, we can just let onEndpointChanged callback not invoking child policy's handleResolvedAddresses() if such a reentrancy happens. After this callback returns, the following invocation of ChildLbState's handleResolvedAddresses() will get the endpoint_picking_policy and locality_picking_policy and it will invoke child policy's handleResolvedAddresses().", "author": "voidzcy", "createdAt": "2020-09-16T21:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjE5OQ=="}], "type": "inlineReview"}, {"oid": "59da20b9b7a4793a0e037ecf4cf42676d40a7a31", "url": "https://github.com/grpc/grpc-java/commit/59da20b9b7a4793a0e037ecf4cf42676d40a7a31", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/migrate_to_hierarchical_downstream_lb_tree", "committedDate": "2020-09-16T20:05:39Z", "type": "commit"}, {"oid": "ef13175023900a0170a5503aca9e953cddfad7bc", "url": "https://github.com/grpc/grpc-java/commit/ef13175023900a0170a5503aca9e953cddfad7bc", "message": "Save current endpoint_picking_policy and locality_picking_policy in ChildLbState.", "committedDate": "2020-09-16T21:08:34Z", "type": "commit"}, {"oid": "79b0c92cc2e78f2c704d8733786445dbc6ee7be0", "url": "https://github.com/grpc/grpc-java/commit/79b0c92cc2e78f2c704d8733786445dbc6ee7be0", "message": "Switch EDS instance only when eds_service_name changes, assuming the lrs server for the same cluster (eds_service_name) does not change.", "committedDate": "2020-09-16T21:32:43Z", "type": "commit"}, {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f", "url": "https://github.com/grpc/grpc-java/commit/f191f854e6b0a4fcfcc5a51f80af96addbab055f", "message": "Remove unnecessary field.", "committedDate": "2020-09-16T21:33:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjE3MQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489816171", "bodyText": "Does the order matter?", "author": "dapengzhang0", "createdAt": "2020-09-16T23:54:42Z", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+  private EdsLbState edsLbState;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(checkNotNull(helper, \"helper\"));\n+    InternalLogId logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    if (edsLbState == null || !Objects.equals(edsLbState.edsServiceName, config.edsServiceName)) {\n+      edsLbState = new EdsLbState(config.edsServiceName, config.lrsServerName);\n+      switchingLoadBalancer.switchTo(edsLbState);\n+    }\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();", "originalCommit": "f191f854e6b0a4fcfcc5a51f80af96addbab055f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg0MDczNg==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489840736", "bodyText": "Doesn't really matter. addClientStats creates the stats object for recording loads while reportClientStats creates the LRS RPC stream and performs load reporting. Since the LRS response handling is always serialized in the sync context, at the time sending the next load reporting request it always sees the newly created stats object for this cluster. So, the order of these two lines doesn't affect anything.", "author": "voidzcy", "createdAt": "2020-09-17T01:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjg2Mw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489816863", "bodyText": "Is this duplicate code?", "author": "dapengzhang0", "createdAt": "2020-09-16T23:56:59Z", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+  private EdsLbState edsLbState;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(checkNotNull(helper, \"helper\"));\n+    InternalLogId logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    if (edsLbState == null || !Objects.equals(edsLbState.edsServiceName, config.edsServiceName)) {\n+      edsLbState = new EdsLbState(config.edsServiceName, config.lrsServerName);\n+      switchingLoadBalancer.switchTo(edsLbState);\n+    }\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+        } else {\n+          loadStatsStore = null;\n+        }\n+        lbHelper = new DropHandlingLbHelper(helper);\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+      }\n+\n+      @Override\n+      public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+        EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+        if (lb != null) {\n+          if (!config.localityPickingPolicy.equals(localityPickingPolicy)\n+              || !config.endpointPickingPolicy.equals(endpointPickingPolicy)) {\n+            PriorityLbConfig childConfig =\n+                generatePriorityLbConfig(cluster, edsServiceName, lrsServerName,\n+                    config.localityPickingPolicy, config.endpointPickingPolicy, lbRegistry,\n+                    prioritizedLocalityWeights);\n+            // TODO(chengyuanzhang): to be deleted after migrating to use XdsClient API.\n+            Attributes attributes;\n+            if (lrsServerName != null) {\n+              attributes =\n+                  resolvedAddresses.getAttributes().toBuilder()\n+                      .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                      .build();\n+            } else {\n+              attributes = resolvedAddresses.getAttributes();\n+            }\n+            lb.handleResolvedAddresses(\n+                resolvedAddresses.toBuilder()\n+                    .setAddresses(endpointAddresses)\n+                    .setAttributes(attributes)\n+                    .setLoadBalancingPolicyConfig(childConfig)\n+                    .build());\n+          }\n+        }\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+\n+      @Override\n+      public void handleNameResolutionError(Status error) {\n+        if (lb != null) {\n+          lb.handleNameResolutionError(error);\n+        } else {\n+          lbHelper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+        }\n+      }\n+\n+      @Override\n+      public void shutdown() {\n+        if (lrsServerName != null) {\n+          xdsClient.cancelClientStatsReport();\n+          xdsClient.removeClientStats(cluster, edsServiceName);\n+        }\n+        xdsClient.cancelEndpointDataWatch(resourceName, this);\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Cancelled endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        if (lb != null) {\n+          lb.shutdown();\n+        }\n+      }\n+\n+      @Override\n+      public boolean canHandleEmptyAddressListFromNameResolution() {\n+        return true;\n+      }\n+\n+      @Override\n+      public void onEndpointChanged(EndpointUpdate update) {\n+        logger.log(XdsLogLevel.DEBUG,\n+            \"Received endpoint update from xDS client {0}: {1}\", xdsClient, update);\n+        if (logger.isLoggable(XdsLogLevel.INFO)) {\n+          logger.log(\n+              XdsLogLevel.INFO,\n+              \"Received endpoint update: cluster_name={0}, {1} localities, {2} drop categories\",\n+              update.getClusterName(), update.getLocalityLbEndpointsMap().size(),\n+              update.getDropPolicies().size());\n+        }\n+        lbHelper.updateDropPolicies(update.getDropPolicies());\n+        Map<Locality, LocalityLbEndpoints> localityLbEndpoints = update.getLocalityLbEndpointsMap();\n+        endpointAddresses = new ArrayList<>();\n+        prioritizedLocalityWeights = new HashMap<>();\n+        for (Locality locality : localityLbEndpoints.keySet()) {\n+          LocalityLbEndpoints localityLbInfo = localityLbEndpoints.get(locality);\n+          int priority = localityLbInfo.getPriority();\n+          for (LbEndpoint endpoint : localityLbInfo.getEndpoints()) {\n+            if (endpoint.isHealthy()) {\n+              EquivalentAddressGroup eag =\n+                  AddressFilter.setPathFilter(\n+                      endpoint.getAddress(),\n+                      Arrays.asList(priorityName(priority), localityName(locality)));\n+              endpointAddresses.add(eag);\n+            }\n+          }\n+          if (!prioritizedLocalityWeights.containsKey(priority)) {\n+            prioritizedLocalityWeights.put(priority, new HashMap<Locality, Integer>());\n+          }\n+          prioritizedLocalityWeights.get(priority).put(\n+              locality, localityLbInfo.getLocalityWeight());\n+        }\n+        if (lb == null) {\n+          lb = lbRegistry.getProvider(PRIORITY_POLICY_NAME).newLoadBalancer(lbHelper);\n+        }\n+        if (localityPickingPolicy != null && endpointPickingPolicy != null) {\n+          PriorityLbConfig config = generatePriorityLbConfig(cluster, edsServiceName,\n+              lrsServerName, localityPickingPolicy, endpointPickingPolicy, lbRegistry,\n+              prioritizedLocalityWeights);\n+          // TODO(chengyuanzhang): to be deleted after migrating to use XdsClient API.\n+          Attributes attributes;\n+          if (lrsServerName != null) {\n+            attributes =\n+                resolvedAddresses.getAttributes().toBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                    .build();\n+          } else {\n+            attributes = resolvedAddresses.getAttributes();\n+          }\n+          lb.handleResolvedAddresses(\n+              resolvedAddresses.toBuilder()\n+                  .setAddresses(endpointAddresses)\n+                  .setAttributes(attributes)\n+                  .setLoadBalancingPolicyConfig(config)\n+                  .build());\n+        }", "originalCommit": "f191f854e6b0a4fcfcc5a51f80af96addbab055f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA3NTc0OQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490075749", "bodyText": "Kind of yes. Lines for putting LoadStatsStore into the attribute is temporary and will be deleted after the XdsClient has API to directly access per-locality stats object. Also, there are really only a few statement, but just involving the verbose builder pattern.\nHowever, I also noticed that it would be better to make the latest ResolvedAddresses as a field in ChildLbState, as each ChildLbState instance operates according to a specific address update, so it should be bound with that ResolvedAddresses.", "author": "voidzcy", "createdAt": "2020-09-17T08:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxODM4NA==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489818384", "bodyText": "It shouldn't be this DropHandlingLbHelper  lbHelper either, that's for lb with dropping logic, it's too downstream. The right one should be the helper in ChildLbState(Helper helper).", "author": "dapengzhang0", "createdAt": "2020-09-17T00:02:16Z", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+  private EdsLbState edsLbState;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(checkNotNull(helper, \"helper\"));\n+    InternalLogId logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    if (edsLbState == null || !Objects.equals(edsLbState.edsServiceName, config.edsServiceName)) {\n+      edsLbState = new EdsLbState(config.edsServiceName, config.lrsServerName);\n+      switchingLoadBalancer.switchTo(edsLbState);\n+    }\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+        } else {\n+          loadStatsStore = null;\n+        }\n+        lbHelper = new DropHandlingLbHelper(helper);\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+      }\n+\n+      @Override\n+      public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+        EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+        if (lb != null) {\n+          if (!config.localityPickingPolicy.equals(localityPickingPolicy)\n+              || !config.endpointPickingPolicy.equals(endpointPickingPolicy)) {\n+            PriorityLbConfig childConfig =\n+                generatePriorityLbConfig(cluster, edsServiceName, lrsServerName,\n+                    config.localityPickingPolicy, config.endpointPickingPolicy, lbRegistry,\n+                    prioritizedLocalityWeights);\n+            // TODO(chengyuanzhang): to be deleted after migrating to use XdsClient API.\n+            Attributes attributes;\n+            if (lrsServerName != null) {\n+              attributes =\n+                  resolvedAddresses.getAttributes().toBuilder()\n+                      .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                      .build();\n+            } else {\n+              attributes = resolvedAddresses.getAttributes();\n+            }\n+            lb.handleResolvedAddresses(\n+                resolvedAddresses.toBuilder()\n+                    .setAddresses(endpointAddresses)\n+                    .setAttributes(attributes)\n+                    .setLoadBalancingPolicyConfig(childConfig)\n+                    .build());\n+          }\n+        }\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+\n+      @Override\n+      public void handleNameResolutionError(Status error) {\n+        if (lb != null) {\n+          lb.handleNameResolutionError(error);\n+        } else {\n+          lbHelper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));", "originalCommit": "f191f854e6b0a4fcfcc5a51f80af96addbab055f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgzNjcwMQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489836701", "bodyText": "Yeah, I know. It doesn't matter though. DropHandlingLbHelper is just a the helper received in ChildLbState(Helper helper) with a thin layer wrapped to record drops, which doesn't affect its error propagation functionality.", "author": "voidzcy", "createdAt": "2020-09-17T00:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxODM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg0MzE0MQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489843141", "bodyText": "From the API's perspective, your thought is legit. What about changing to lbHelper.delegate().updateBalancingState(...)? or lbHelper.helper.updateBalancingState(...)", "author": "voidzcy", "createdAt": "2020-09-17T01:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxODM4NA=="}], "type": "inlineReview"}, {"oid": "844488296215d11df28c0b0bf78c83e57fb253b7", "url": "https://github.com/grpc/grpc-java/commit/844488296215d11df28c0b0bf78c83e57fb253b7", "message": "Use the right Helper precisely.", "committedDate": "2020-09-17T08:41:23Z", "type": "commit"}, {"oid": "fb32bbebca81487e7235612b6e39817597c338b5", "url": "https://github.com/grpc/grpc-java/commit/fb32bbebca81487e7235612b6e39817597c338b5", "message": "Move ResolvedAddresses into each ChildLbState component.", "committedDate": "2020-09-17T08:46:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg5NzgzMQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489897831", "bodyText": "Can just return mock(Subchannel.class). The test does not depend on anything of Subchannel", "author": "dapengzhang0", "createdAt": "2020-09-17T02:36:22Z", "path": "xds/src/test/java/io/grpc/xds/EdsLoadBalancer2Test.java", "diffHunk": "@@ -0,0 +1,836 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.WEIGHTED_TARGET_POLICY_NAME;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.Status.Code;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.FakeClock;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Tests for {@link EdsLoadBalancer2}.\n+ */\n+@RunWith(JUnit4.class)\n+public class EdsLoadBalancer2Test {\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String EDS_SERVICE_NAME = \"service.googleapis.com\";\n+  private static final String LRS_SERVER_NAME = \"lrs.googleapis.com\";\n+  private final Locality locality1 =\n+      new Locality(\"test-region-1\", \"test-zone-1\", \"test-subzone-1\");\n+  private final Locality locality2 =\n+      new Locality(\"test-region-2\", \"test-zone-2\", \"test-subzone-2\");\n+  private final Locality locality3 =\n+      new Locality(\"test-region-3\", \"test-zone-3\", \"test-subzone-3\");\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n+        }\n+      });\n+\n+  private final FakeClock fakeClock = new FakeClock();\n+  private final LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+  private final PolicySelection roundRobin =\n+      new PolicySelection(new FakeLoadBalancerProvider(\"round_robin\"), null, null);\n+  private final PolicySelection weightedTarget =\n+      new PolicySelection(new FakeLoadBalancerProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);\n+  private final List<FakeLoadBalancer> downstreamBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+    @Override\n+    public XdsClient getObject() {\n+      xdsClientRefs++;\n+      return xdsClient;\n+    }\n+\n+    @Override\n+    public XdsClient returnObject(Object object) {\n+      xdsClientRefs--;\n+      return null;\n+    }\n+  };\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  @Mock\n+  private ThreadSafeRandom mockRandom;\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private EdsLoadBalancer2 loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    registry.register(new FakeLoadBalancerProvider(PRIORITY_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(LRS_POLICY_NAME));\n+    loadBalancer = new EdsLoadBalancer2(helper, registry, mockRandom);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watchers).isEmpty();\n+    assertThat(xdsClient.dropStats).isEmpty();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+    assertThat(downstreamBalancers).isEmpty();\n+  }\n+\n+  @Test\n+  public void receiveFirstEndpointResource() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    EquivalentAddressGroup endpoint3 = makeAddress(\"endpoint-addr-3\");\n+    EquivalentAddressGroup endpoint4 = makeAddress(\"endpoint-addr-4\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 70, Arrays.asList(endpoint1, endpoint2));\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint3));\n+    LocalityLbEndpoints localityLbEndpoints3 =\n+        buildLocalityLbEndpoints(2, 20, Collections.singletonList(endpoint4));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        ImmutableMap.of(\n+            locality1, localityLbEndpoints1,\n+            locality2, localityLbEndpoints2,\n+            locality3, localityLbEndpoints3));\n+    assertThat(downstreamBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(childConfig1.targets).hasSize(2);\n+    WeightedPolicySelection target1 = childConfig1.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(70);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection target2 = childConfig1.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(10);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(childConfig2.targets).hasSize(1);\n+    WeightedPolicySelection target3 = childConfig2.targets.get(locality3.toString());\n+    assertThat(target3.weight).isEqualTo(20);\n+    assertThat(target3.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target3.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality3, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr1 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr1).hasSize(3);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2, endpoint3),\n+        priorityAddr1);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2),\n+        AddressFilter.filter(priorityAddr1, locality1.toString()));\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint3),\n+        AddressFilter.filter(priorityAddr1, locality2.toString()));\n+\n+    List<EquivalentAddressGroup> priorityAddr2 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority2\");\n+    assertThat(priorityAddr2).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint4), priorityAddr2);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint4),\n+        AddressFilter.filter(priorityAddr2, locality3.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceUpdated() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality1, localityLbEndpoints1));\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    PolicySelection child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    WeightedPolicySelection target = childConfig.targets.get(locality1.toString());\n+    assertThat(target.weight).isEqualTo(10);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint1), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint1),\n+        AddressFilter.filter(priorityAddr, locality1.toString()));\n+\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 30, Collections.singletonList(endpoint2));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality2, localityLbEndpoints2));\n+\n+    config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    target = childConfig.targets.get(locality2.toString());\n+    assertThat(target.weight).isEqualTo(30);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    priorityAddr = AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint2), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint2),\n+        AddressFilter.filter(priorityAddr, locality2.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void endpointResourceRemoved() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void handleDrops() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    when(mockRandom.nextInt(anyInt())).thenReturn(499_999, 1_000_000);\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        Collections.singletonList(new DropOverload(\"throttle\", 500_000)),\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+    assertThat(downstreamBalancers).hasSize(1);  // one leaf balancer\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    assertAddressesEqual(Collections.singletonList(makeAddress(\"endpoint-addr-1\")),\n+        leafBalancer.addresses);\n+    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n+        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n+    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"Dropped: throttle\");\n+    assertThat(xdsClient.dropStats.get(EDS_SERVICE_NAME).get(\"throttle\").get()).isEqualTo(1);\n+\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEdsServiceName_afterChildPolicyReady_switchGracefully() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB polices instantiated\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    Subchannel subchannel1 = mock(Subchannel.class);\n+    childBalancer.deliverSubchannelState(subchannel1, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+\n+    String newEdsServiceName = \"service-foo.googleapis.com\";\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, newEdsServiceName, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+    deliverSimpleClusterLoadAssignment(newEdsServiceName);  // instantiate the new subtree\n+    assertThat(downstreamBalancers).hasSize(2);\n+    FakeLoadBalancer newChildBalancer = downstreamBalancers.get(1);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+    Subchannel subchannel2 = mock(Subchannel.class);\n+    newChildBalancer.deliverSubchannelState(subchannel2, ConnectivityState.READY);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel2);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEndpointPickingPolicy() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB policies instantiated\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    FakeLoadBalancerProvider fakePickFirstProvider = new FakeLoadBalancerProvider(\"pick_first\");\n+    PolicySelection fakePickFirstSelection =\n+        new PolicySelection(fakePickFirstProvider, null, null);\n+    loadBalancer.handleResolvedAddresses(ResolvedAddresses.newBuilder()\n+        .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+        .setAttributes(\n+            Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+        .setLoadBalancingPolicyConfig(\n+            new EdsConfig(\n+                CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, fakePickFirstSelection))\n+        .build());\n+    assertThat(leafBalancer.shutdown).isTrue();\n+    leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"pick_first\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_beforeChildPolicyInstantiated_propagateToUpstream() {\n+    xdsClient.deliverError(Status.UNAUTHENTICATED.withDescription(\"permission denied\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAUTHENTICATED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"permission denied\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_afterChildPolicyInstantiated_keepUsingCurrentEndpoints() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    xdsClient.deliverError(Status.UNAVAILABLE.withDescription(\"not found\"));\n+\n+    assertThat(currentState).isEqualTo(ConnectivityState.CONNECTING);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(childBalancer.shutdown).isFalse();\n+  }\n+\n+  @Test\n+  public void nameResolutionError_beforeChildPolicyInstantiated_returnErrorPickerToUpstream() {\n+    loadBalancer.handleNameResolutionError(Status.UNIMPLEMENTED.withDescription(\"not found\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNIMPLEMENTED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"not found\");\n+  }\n+\n+  @Test\n+  public void nameResolutionError_afterChildPolicyInstantiated_propagateToDownstream() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNAVAILABLE.withDescription(\"cannot reach server\"));\n+    assertThat(childBalancer.upstreamError.getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(childBalancer.upstreamError.getDescription())\n+        .isEqualTo(\"cannot reach server\");\n+  }\n+\n+  @Test\n+  public void generatePriorityLbConfig() {\n+    Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights = new HashMap<>();\n+    prioritizedLocalityWeights.put(1, ImmutableMap.of(locality1, 20, locality2, 50));\n+    prioritizedLocalityWeights.put(2, ImmutableMap.of(locality3, 30));\n+    PriorityLbConfig config =\n+        EdsLoadBalancer2.generatePriorityLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin, registry,\n+            prioritizedLocalityWeights);\n+    assertThat(config.childConfigs).hasSize(2);\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(weightedTargetConfig1.targets).hasSize(2);\n+    WeightedPolicySelection childTarget1 = weightedTargetConfig1.targets.get(locality1.toString());\n+    assertThat(childTarget1.weight).isEqualTo(20);\n+    assertThat(childTarget1.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget1.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection childTarget2 = weightedTargetConfig1.targets.get(locality2.toString());\n+    assertThat(childTarget2.weight).isEqualTo(50);\n+    assertThat(childTarget2.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget2.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(weightedTargetConfig2.targets).hasSize(1);\n+    WeightedPolicySelection childTarget3 = weightedTargetConfig2.targets.get(locality3.toString());\n+    assertThat(childTarget3.weight).isEqualTo(30);\n+    assertThat(childTarget3.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget3.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality3, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withoutLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, null, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+  }\n+\n+  private void deliverSimpleClusterLoadAssignment(String resourceName) {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        resourceName,\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+  }\n+\n+  /**\n+   * Recreate a new {@link EdsLoadBalancer2} that will instantiate its downstream LB policies with\n+   * real implementations, except the leaf policy is replaced with a fake implementation to avoid\n+   * creating connections.\n+   */\n+  private void recreateLoadBalancerWithRealDownstreamLbPolicies(\n+      FakeLoadBalancerProvider fakeLeafPolicyProvider) {\n+    LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+    lbRegistry.deregister(lbRegistry.getProvider(fakeLeafPolicyProvider.getPolicyName()));\n+    lbRegistry.register(fakeLeafPolicyProvider);\n+    loadBalancer.shutdown();\n+    loadBalancer = new EdsLoadBalancer2(helper, lbRegistry, mockRandom);\n+    PolicySelection weightedTargetSelection =\n+        new PolicySelection(lbRegistry.getProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);\n+    PolicySelection fakeLeafPolicySelection =\n+        new PolicySelection(fakeLeafPolicyProvider, null, null);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTargetSelection,\n+                    fakeLeafPolicySelection))\n+            .build());\n+  }\n+\n+  private static void assertLrsConfig(\n+      LrsConfig config, String cluster, String edsServiceName, String lrsServerName,\n+      Locality locality, String childPolicy) {\n+    assertThat(config.clusterName).isEqualTo(cluster);\n+    assertThat(config.edsServiceName).isEqualTo(edsServiceName);\n+    assertThat(config.lrsServerName).isEqualTo(lrsServerName);\n+    assertThat(config.locality).isEqualTo(locality);\n+    assertThat(config.childPolicy.getProvider().getPolicyName()).isEqualTo(childPolicy);\n+  }\n+\n+  /** Asserts two list of EAGs contains same addresses, regardless of attributes. */\n+  private static void assertAddressesEqual(\n+      List<EquivalentAddressGroup> expected, List<EquivalentAddressGroup> actual) {\n+    assertThat(actual.size()).isEqualTo(expected.size());\n+    for (int i = 0; i < actual.size(); i++) {\n+      assertThat(actual.get(i).getAddresses()).isEqualTo(expected.get(i).getAddresses());\n+    }\n+  }\n+\n+  private static LocalityLbEndpoints buildLocalityLbEndpoints(\n+      int priority, int localityWeight, List<EquivalentAddressGroup> endpointAddresses) {\n+    List<LbEndpoint> endpoints = new ArrayList<>();\n+    for (EquivalentAddressGroup addr : endpointAddresses) {\n+      endpoints.add(new LbEndpoint(addr, 100, true));\n+    }\n+    return new LocalityLbEndpoints(endpoints, localityWeight, priority);\n+  }\n+\n+  private static EquivalentAddressGroup makeAddress(final String name) {\n+    class FakeSocketAddress extends SocketAddress {\n+      private final String name;\n+\n+      private FakeSocketAddress(String name) {\n+        this.name = name;\n+      }\n+\n+      @Override\n+      public int hashCode() {\n+        return Objects.hash(name);\n+      }\n+\n+      @Override\n+      public boolean equals(Object o) {\n+        if (this == o) {\n+          return true;\n+        }\n+        if (!(o instanceof FakeSocketAddress)) {\n+          return false;\n+        }\n+        FakeSocketAddress that = (FakeSocketAddress) o;\n+        return Objects.equals(name, that.name);\n+      }\n+\n+      @Override\n+      public String toString() {\n+        return name;\n+      }\n+    }\n+\n+    return new EquivalentAddressGroup(new FakeSocketAddress(name));\n+  }\n+\n+  private final class FakeXdsClient extends XdsClient {\n+    private final Map<String, EndpointWatcher> watchers = new HashMap<>();\n+    private final Map<String, ConcurrentMap<String, AtomicLong>> dropStats = new HashMap<>();\n+\n+    @Override\n+    void shutdown() {\n+      // no-op\n+    }\n+\n+    @Override\n+    void watchEndpointData(String clusterName, EndpointWatcher watcher) {\n+      watchers.put(clusterName, watcher);\n+    }\n+\n+    @Override\n+    void cancelEndpointDataWatch(String clusterName, EndpointWatcher watcher) {\n+      watchers.remove(clusterName);\n+    }\n+\n+    @Override\n+    LoadStatsStore addClientStats(String clusterName, @Nullable String clusterServiceName) {\n+      ConcurrentMap<String, AtomicLong> dropCounters = new ConcurrentHashMap<>();\n+      dropStats.put(clusterServiceName, dropCounters);\n+      return new LoadStatsStoreImpl(clusterName, clusterServiceName,\n+          fakeClock.getStopwatchSupplier().get(), dropCounters);\n+    }\n+\n+    @Override\n+    void removeClientStats(String clusterName, @Nullable String clusterServiceName) {\n+      dropStats.remove(clusterServiceName);\n+    }\n+\n+    void deliverClusterLoadAssignment(\n+        String resource, Map<Locality, LocalityLbEndpoints> localityLbEndpointsMap) {\n+      deliverClusterLoadAssignment(\n+          resource, Collections.<DropOverload>emptyList(), localityLbEndpointsMap);\n+    }\n+\n+    void deliverClusterLoadAssignment(\n+        final String resource, final List<DropOverload> dropOverloads,\n+        final Map<Locality, LocalityLbEndpoints> localityLbEndpointsMap) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (watchers.containsKey(resource)) {\n+            EndpointUpdate.Builder builder  = EndpointUpdate.newBuilder().setClusterName(resource);\n+            for (DropOverload dropOverload : dropOverloads) {\n+              builder.addDropPolicy(dropOverload);\n+            }\n+            for (Locality locality : localityLbEndpointsMap.keySet()) {\n+              builder.addLocalityLbEndpoints(locality, localityLbEndpointsMap.get(locality));\n+            }\n+            watchers.get(resource).onEndpointChanged(builder.build());\n+          }\n+        }\n+      });\n+    }\n+\n+    void deliverResourceNotFound(final String resource) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (watchers.containsKey(resource)) {\n+            watchers.get(resource).onResourceDoesNotExist(resource);\n+          }\n+        }\n+      });\n+    }\n+\n+    void deliverError(final Status error) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          for (EndpointWatcher watcher : watchers.values()) {\n+            watcher.onError(error);\n+          }\n+        }\n+      });\n+    }\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      FakeLoadBalancer balancer = new FakeLoadBalancer(policyName, helper);\n+      downstreamBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private final class FakeLoadBalancer extends LoadBalancer {\n+    private final String name;\n+    private final Helper helper;\n+    private List<EquivalentAddressGroup> addresses;\n+    private Object config;\n+    private Status upstreamError;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(String name, Helper helper) {\n+      this.name = name;\n+      this.helper = helper;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      addresses = resolvedAddresses.getAddresses();\n+      config = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    }\n+\n+    @Override\n+    public void handleNameResolutionError(Status error) {\n+      upstreamError = error;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      shutdown = true;\n+      downstreamBalancers.remove(this);\n+    }\n+\n+    void deliverSubchannelState(final Subchannel subchannel, ConnectivityState state) {\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class FakeLbHelper extends LoadBalancer.Helper {\n+\n+    @Override\n+    public void updateBalancingState(\n+        @Nonnull ConnectivityState newState, @Nonnull SubchannelPicker newPicker) {\n+      currentState = newState;\n+      currentPicker = newPicker;\n+    }\n+\n+    @Override\n+    public Subchannel createSubchannel(CreateSubchannelArgs args) {\n+      return new FakeSubchannel(args.getAddresses());", "originalCommit": "f191f854e6b0a4fcfcc5a51f80af96addbab055f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1MjY4OQ==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490452689", "bodyText": "Yeah, right. Fixed.", "author": "voidzcy", "createdAt": "2020-09-17T17:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg5NzgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDQ5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490414496", "bodyText": "An alternative is: deregister all the fake providers in the setUp(), and re-register those policies with real providers. Then the benefit is you don't need to shutdown the balancer and create a new balancer.\n    registry.deregister(registry.getProvider(PRIORITY_POLICY_NAME));\n    registry.register(new PriorityLoadBalancerProvider());\n    registry.deregister(registry.getProvider(LRS_POLICY_NAME));\n    registry.register(new LrsLoadBalancerProvider());\n    registry.register(fakeLeafPolicyProvider);\n    PolicySelection weightedTargetSelection =\n        new PolicySelection(new WeightedTargetLoadBalancerProvider(), null, null);", "author": "dapengzhang0", "createdAt": "2020-09-17T16:54:21Z", "path": "xds/src/test/java/io/grpc/xds/EdsLoadBalancer2Test.java", "diffHunk": "@@ -0,0 +1,836 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.WEIGHTED_TARGET_POLICY_NAME;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.Status.Code;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.FakeClock;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Tests for {@link EdsLoadBalancer2}.\n+ */\n+@RunWith(JUnit4.class)\n+public class EdsLoadBalancer2Test {\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String EDS_SERVICE_NAME = \"service.googleapis.com\";\n+  private static final String LRS_SERVER_NAME = \"lrs.googleapis.com\";\n+  private final Locality locality1 =\n+      new Locality(\"test-region-1\", \"test-zone-1\", \"test-subzone-1\");\n+  private final Locality locality2 =\n+      new Locality(\"test-region-2\", \"test-zone-2\", \"test-subzone-2\");\n+  private final Locality locality3 =\n+      new Locality(\"test-region-3\", \"test-zone-3\", \"test-subzone-3\");\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n+        }\n+      });\n+\n+  private final FakeClock fakeClock = new FakeClock();\n+  private final LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+  private final PolicySelection roundRobin =\n+      new PolicySelection(new FakeLoadBalancerProvider(\"round_robin\"), null, null);\n+  private final PolicySelection weightedTarget =\n+      new PolicySelection(new FakeLoadBalancerProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);\n+  private final List<FakeLoadBalancer> downstreamBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+    @Override\n+    public XdsClient getObject() {\n+      xdsClientRefs++;\n+      return xdsClient;\n+    }\n+\n+    @Override\n+    public XdsClient returnObject(Object object) {\n+      xdsClientRefs--;\n+      return null;\n+    }\n+  };\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  @Mock\n+  private ThreadSafeRandom mockRandom;\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private EdsLoadBalancer2 loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    registry.register(new FakeLoadBalancerProvider(PRIORITY_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(LRS_POLICY_NAME));\n+    loadBalancer = new EdsLoadBalancer2(helper, registry, mockRandom);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watchers).isEmpty();\n+    assertThat(xdsClient.dropStats).isEmpty();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+    assertThat(downstreamBalancers).isEmpty();\n+  }\n+\n+  @Test\n+  public void receiveFirstEndpointResource() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    EquivalentAddressGroup endpoint3 = makeAddress(\"endpoint-addr-3\");\n+    EquivalentAddressGroup endpoint4 = makeAddress(\"endpoint-addr-4\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 70, Arrays.asList(endpoint1, endpoint2));\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint3));\n+    LocalityLbEndpoints localityLbEndpoints3 =\n+        buildLocalityLbEndpoints(2, 20, Collections.singletonList(endpoint4));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        ImmutableMap.of(\n+            locality1, localityLbEndpoints1,\n+            locality2, localityLbEndpoints2,\n+            locality3, localityLbEndpoints3));\n+    assertThat(downstreamBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(childConfig1.targets).hasSize(2);\n+    WeightedPolicySelection target1 = childConfig1.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(70);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection target2 = childConfig1.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(10);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(childConfig2.targets).hasSize(1);\n+    WeightedPolicySelection target3 = childConfig2.targets.get(locality3.toString());\n+    assertThat(target3.weight).isEqualTo(20);\n+    assertThat(target3.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target3.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality3, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr1 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr1).hasSize(3);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2, endpoint3),\n+        priorityAddr1);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2),\n+        AddressFilter.filter(priorityAddr1, locality1.toString()));\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint3),\n+        AddressFilter.filter(priorityAddr1, locality2.toString()));\n+\n+    List<EquivalentAddressGroup> priorityAddr2 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority2\");\n+    assertThat(priorityAddr2).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint4), priorityAddr2);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint4),\n+        AddressFilter.filter(priorityAddr2, locality3.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceUpdated() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality1, localityLbEndpoints1));\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    PolicySelection child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    WeightedPolicySelection target = childConfig.targets.get(locality1.toString());\n+    assertThat(target.weight).isEqualTo(10);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint1), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint1),\n+        AddressFilter.filter(priorityAddr, locality1.toString()));\n+\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 30, Collections.singletonList(endpoint2));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality2, localityLbEndpoints2));\n+\n+    config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    target = childConfig.targets.get(locality2.toString());\n+    assertThat(target.weight).isEqualTo(30);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    priorityAddr = AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint2), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint2),\n+        AddressFilter.filter(priorityAddr, locality2.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void endpointResourceRemoved() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void handleDrops() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    when(mockRandom.nextInt(anyInt())).thenReturn(499_999, 1_000_000);\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        Collections.singletonList(new DropOverload(\"throttle\", 500_000)),\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+    assertThat(downstreamBalancers).hasSize(1);  // one leaf balancer\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    assertAddressesEqual(Collections.singletonList(makeAddress(\"endpoint-addr-1\")),\n+        leafBalancer.addresses);\n+    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n+        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n+    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"Dropped: throttle\");\n+    assertThat(xdsClient.dropStats.get(EDS_SERVICE_NAME).get(\"throttle\").get()).isEqualTo(1);\n+\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEdsServiceName_afterChildPolicyReady_switchGracefully() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB polices instantiated\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    Subchannel subchannel1 = mock(Subchannel.class);\n+    childBalancer.deliverSubchannelState(subchannel1, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+\n+    String newEdsServiceName = \"service-foo.googleapis.com\";\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, newEdsServiceName, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+    deliverSimpleClusterLoadAssignment(newEdsServiceName);  // instantiate the new subtree\n+    assertThat(downstreamBalancers).hasSize(2);\n+    FakeLoadBalancer newChildBalancer = downstreamBalancers.get(1);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+    Subchannel subchannel2 = mock(Subchannel.class);\n+    newChildBalancer.deliverSubchannelState(subchannel2, ConnectivityState.READY);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel2);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEndpointPickingPolicy() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB policies instantiated\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    FakeLoadBalancerProvider fakePickFirstProvider = new FakeLoadBalancerProvider(\"pick_first\");\n+    PolicySelection fakePickFirstSelection =\n+        new PolicySelection(fakePickFirstProvider, null, null);\n+    loadBalancer.handleResolvedAddresses(ResolvedAddresses.newBuilder()\n+        .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+        .setAttributes(\n+            Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+        .setLoadBalancingPolicyConfig(\n+            new EdsConfig(\n+                CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, fakePickFirstSelection))\n+        .build());\n+    assertThat(leafBalancer.shutdown).isTrue();\n+    leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"pick_first\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_beforeChildPolicyInstantiated_propagateToUpstream() {\n+    xdsClient.deliverError(Status.UNAUTHENTICATED.withDescription(\"permission denied\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAUTHENTICATED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"permission denied\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_afterChildPolicyInstantiated_keepUsingCurrentEndpoints() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    xdsClient.deliverError(Status.UNAVAILABLE.withDescription(\"not found\"));\n+\n+    assertThat(currentState).isEqualTo(ConnectivityState.CONNECTING);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(childBalancer.shutdown).isFalse();\n+  }\n+\n+  @Test\n+  public void nameResolutionError_beforeChildPolicyInstantiated_returnErrorPickerToUpstream() {\n+    loadBalancer.handleNameResolutionError(Status.UNIMPLEMENTED.withDescription(\"not found\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNIMPLEMENTED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"not found\");\n+  }\n+\n+  @Test\n+  public void nameResolutionError_afterChildPolicyInstantiated_propagateToDownstream() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNAVAILABLE.withDescription(\"cannot reach server\"));\n+    assertThat(childBalancer.upstreamError.getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(childBalancer.upstreamError.getDescription())\n+        .isEqualTo(\"cannot reach server\");\n+  }\n+\n+  @Test\n+  public void generatePriorityLbConfig() {\n+    Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights = new HashMap<>();\n+    prioritizedLocalityWeights.put(1, ImmutableMap.of(locality1, 20, locality2, 50));\n+    prioritizedLocalityWeights.put(2, ImmutableMap.of(locality3, 30));\n+    PriorityLbConfig config =\n+        EdsLoadBalancer2.generatePriorityLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin, registry,\n+            prioritizedLocalityWeights);\n+    assertThat(config.childConfigs).hasSize(2);\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(weightedTargetConfig1.targets).hasSize(2);\n+    WeightedPolicySelection childTarget1 = weightedTargetConfig1.targets.get(locality1.toString());\n+    assertThat(childTarget1.weight).isEqualTo(20);\n+    assertThat(childTarget1.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget1.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection childTarget2 = weightedTargetConfig1.targets.get(locality2.toString());\n+    assertThat(childTarget2.weight).isEqualTo(50);\n+    assertThat(childTarget2.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget2.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(weightedTargetConfig2.targets).hasSize(1);\n+    WeightedPolicySelection childTarget3 = weightedTargetConfig2.targets.get(locality3.toString());\n+    assertThat(childTarget3.weight).isEqualTo(30);\n+    assertThat(childTarget3.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget3.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality3, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withoutLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, null, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+  }\n+\n+  private void deliverSimpleClusterLoadAssignment(String resourceName) {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        resourceName,\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+  }\n+\n+  /**\n+   * Recreate a new {@link EdsLoadBalancer2} that will instantiate its downstream LB policies with\n+   * real implementations, except the leaf policy is replaced with a fake implementation to avoid\n+   * creating connections.\n+   */\n+  private void recreateLoadBalancerWithRealDownstreamLbPolicies(\n+      FakeLoadBalancerProvider fakeLeafPolicyProvider) {\n+    LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+    lbRegistry.deregister(lbRegistry.getProvider(fakeLeafPolicyProvider.getPolicyName()));\n+    lbRegistry.register(fakeLeafPolicyProvider);\n+    loadBalancer.shutdown();\n+    loadBalancer = new EdsLoadBalancer2(helper, lbRegistry, mockRandom);\n+    PolicySelection weightedTargetSelection =\n+        new PolicySelection(lbRegistry.getProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);", "originalCommit": "f191f854e6b0a4fcfcc5a51f80af96addbab055f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjY3Mw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490422673", "bodyText": "If using real registry, you need clean up the real registry at the end of test.", "author": "dapengzhang0", "createdAt": "2020-09-17T17:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1MzAyMA==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490453020", "bodyText": "Fixed to reuse the existing registry with replaced LB providers.", "author": "voidzcy", "createdAt": "2020-09-17T17:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzNDkxMw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490534913", "bodyText": "Hmm... It turns out even without\nlbRegistry.register(fakeLeafPolicyProvider);\nthe test could still pass.", "author": "dapengzhang0", "createdAt": "2020-09-17T20:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzOTU3Mw==", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490539573", "bodyText": "Because the leaf policy provider (aka endpoint_picking_policy) is not obtained from the registry, it is obtained from the LB config. So the one in the registry is not used.", "author": "voidzcy", "createdAt": "2020-09-17T20:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDQ5Ng=="}], "type": "inlineReview"}, {"oid": "c2dae0f8154bccf7a56139aed54eb0d9247c433f", "url": "https://github.com/grpc/grpc-java/commit/c2dae0f8154bccf7a56139aed54eb0d9247c433f", "message": "Removed unused FakeSubchannel.", "committedDate": "2020-09-17T17:34:42Z", "type": "commit"}, {"oid": "11197c1821efba36bccf40e572b4542019963229", "url": "https://github.com/grpc/grpc-java/commit/11197c1821efba36bccf40e572b4542019963229", "message": "Reuse existing LoadBalancer registry with real LB policies.", "committedDate": "2020-09-17T17:58:14Z", "type": "commit"}, {"oid": "8dc07fb1ba6010109c1002d675383e20d97ac901", "url": "https://github.com/grpc/grpc-java/commit/8dc07fb1ba6010109c1002d675383e20d97ac901", "message": "Should throw away localities/priorities with no healthy endpoints, and turn into TF is no priority can be used.", "committedDate": "2020-09-18T00:12:45Z", "type": "commit"}, {"oid": "c574c5ddb8a73e3e82abc60bfe111777e6420dbb", "url": "https://github.com/grpc/grpc-java/commit/c574c5ddb8a73e3e82abc60bfe111777e6420dbb", "message": "Add tests to cover throwing away localities/priorities with no healthy endpoints.", "committedDate": "2020-09-18T00:13:21Z", "type": "commit"}]}