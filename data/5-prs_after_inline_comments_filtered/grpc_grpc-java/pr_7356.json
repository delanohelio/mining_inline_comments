{"pr_number": 7356, "pr_title": "xds: eliminate cluster name change logic in CDS LB policy and reimplement tests", "pr_createdAt": "2020-08-25T09:48:29Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7356", "timeline": [{"oid": "ec1422ea3f39708d50ef95ce63feebae2f251b76", "url": "https://github.com/grpc/grpc-java/commit/ec1422ea3f39708d50ef95ce63feebae2f251b76", "message": "Eliminate logic for receiving updated CDS config with cluster name changed. This should never be the use case.", "committedDate": "2020-08-25T09:46:22Z", "type": "commit"}, {"oid": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1", "url": "https://github.com/grpc/grpc-java/commit/f5abb04088d48b4fd8c9a9fa72465eef692ffdf1", "message": "Reimplement tests.", "committedDate": "2020-08-25T09:46:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc3ODg2NA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r476778864", "bodyText": "It looks strange to have lb field here, the whole class does not use lb at all. lb should be a field of ChildLbState.", "author": "dapengzhang0", "createdAt": "2020-08-25T22:00:01Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -125,124 +110,35 @@ public boolean canHandleEmptyAddressListFromNameResolution() {\n   @Override\n   public void shutdown() {\n     logger.log(XdsLogLevel.INFO, \"Shutdown\");\n-    switchingLoadBalancer.shutdown();\n+    if (childLbState != null) {\n+      childLbState.shutdown();\n+    }\n     if (xdsClientPool != null) {\n       xdsClientPool.returnObject(xdsClient);\n     }\n   }\n \n-  // TODO(sanjaypujare): remove once xDS security is released\n-  private boolean isXdsSecurityEnabled() {\n-    return enableXdsSecurity || Boolean.valueOf(System.getenv(XDS_SECURITY_ENV_VAR));\n-  }\n-\n-  // TODO(sanjaypujare): remove once xDS security is released\n-  @VisibleForTesting\n-  void setXdsSecurity(boolean enable) {\n-    enableXdsSecurity = enable;\n-  }\n-\n-  /**\n-   * A load balancer factory that provides a load balancer for a given cluster.\n-   */\n-  private final class ClusterBalancerFactory extends LoadBalancer.Factory {\n-\n-    final String clusterName;\n-\n-    ClusterBalancerFactory(String clusterName) {\n-      this.clusterName = clusterName;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (!(o instanceof ClusterBalancerFactory)) {\n-        return false;\n-      }\n-      ClusterBalancerFactory that = (ClusterBalancerFactory) o;\n-      return clusterName.equals(that.clusterName);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(super.hashCode(), clusterName);\n-    }\n-\n-    @Override\n-    public LoadBalancer newLoadBalancer(final Helper helper) {\n-      return new LoadBalancer() {\n-        // Becomes non-null once handleResolvedAddresses() successfully.\n-        // Assigned at most once.\n-        @Nullable\n-        ClusterWatcherImpl clusterWatcher;\n-\n-        @Override\n-        public void handleNameResolutionError(Status error) {\n-          if (clusterWatcher == null || clusterWatcher.edsBalancer == null) {\n-            // Go into TRANSIENT_FAILURE if we have not yet received any cluster resource.\n-            // Otherwise, we keep running with the data we had previously.\n-            helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n-          }\n-        }\n-\n-        @Override\n-        public boolean canHandleEmptyAddressListFromNameResolution() {\n-          return true;\n-        }\n-\n-        @Override\n-        public void shutdown() {\n-          if (clusterWatcher != null) {\n-            if (clusterWatcher.edsBalancer != null) {\n-              clusterWatcher.edsBalancer.shutdown();\n-            }\n-            xdsClient.cancelClusterDataWatch(clusterName, clusterWatcher);\n-            logger.log(\n-                XdsLogLevel.INFO,\n-                \"Cancelled cluster watcher on {0} with xDS client {1}\",\n-                clusterName, xdsClient);\n-          }\n-        }\n-\n-        @Override\n-        public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n-          if (clusterWatcher == null) {\n-            clusterWatcher = new ClusterWatcherImpl(helper, resolvedAddresses);\n-            logger.log(\n-                XdsLogLevel.INFO,\n-                \"Start cluster watcher on {0} with xDS client {1}\",\n-                clusterName, xdsClient);\n-            xdsClient.watchClusterData(clusterName, clusterWatcher);\n-          }\n-        }\n-      };\n-    }\n-  }\n-\n-  private static final class EdsLoadBalancingHelper extends ForwardingLoadBalancerHelper {\n-    private final Helper delegate;\n-    private final AtomicReference<SslContextProvider> sslContextProvider;\n-\n-    EdsLoadBalancingHelper(Helper helper,\n-        AtomicReference<SslContextProvider> sslContextProvider) {\n-      this.delegate = helper;\n-      this.sslContextProvider = sslContextProvider;\n-    }\n+  private final class ChannelSecurityLbHelper extends ForwardingLoadBalancerHelper {\n+    @Nullable\n+    private SslContextProvider sslContextProvider;\n+    @Nullable\n+    private LoadBalancer lb;", "originalCommit": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NjEwMA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477546100", "bodyText": "Sounds good. Changed.", "author": "voidzcy", "createdAt": "2020-08-26T19:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc3ODg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NDQ2OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r476784469", "bodyText": "This can be helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error)) because lbHelper is only for lb. If lb is null, you should use helper directly.", "author": "dapengzhang0", "createdAt": "2020-08-25T22:07:13Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -350,16 +230,33 @@ public void onResourceDoesNotExist(String resourceName) {\n \n     @Override\n     public void onError(Status error) {\n-      logger.log(\n-          XdsLogLevel.WARNING,\n-          \"Received error from xDS client {0}: {1}: {2}\",\n-          xdsClient,\n-          error.getCode(),\n-          error.getDescription());\n-      if (edsBalancer == null) {\n+      logger.log(XdsLogLevel.WARNING, \"Received error from xDS client {0}: {1}\", error);\n+      if (lbHelper.lb == null) {\n         helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n       }\n     }\n-  }\n \n+    void start() {\n+      xdsClient.watchClusterData(clusterName, this);\n+      logger.log(XdsLogLevel.INFO,\n+          \"Started watcher for cluster {0} with xDS client {1}\", clusterName, xdsClient);\n+    }\n+\n+    void shutdown() {\n+      xdsClient.cancelClusterDataWatch(clusterName, this);\n+      logger.log(XdsLogLevel.INFO,\n+          \"Cancelled watcher for cluster {0} with xDS client {1}\", clusterName, xdsClient);\n+      if (lbHelper.lb != null) {\n+        lbHelper.lb.shutdown();\n+      }\n+    }\n+\n+    void propagateError(Status error) {\n+      if (lbHelper.lb != null) {\n+        lbHelper.lb.handleNameResolutionError(error);\n+      } else {\n+        lbHelper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));", "originalCommit": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NjMyNQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477546325", "bodyText": "Yay, reasonable. Changed.", "author": "voidzcy", "createdAt": "2020-08-26T19:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NDQ2OQ=="}], "type": "inlineReview"}, {"oid": "8ee2592a72e030458dfd5bb5d1c600a8d851a1cd", "url": "https://github.com/grpc/grpc-java/commit/8ee2592a72e030458dfd5bb5d1c600a8d851a1cd", "message": "Improve class field composition.", "committedDate": "2020-08-26T19:42:20Z", "type": "commit"}, {"oid": "3e79c05ca7edb3171943a56d5ce2614a3a6b178d", "url": "https://github.com/grpc/grpc-java/commit/3e79c05ca7edb3171943a56d5ce2614a3a6b178d", "message": "CdsLoadBalancer should be package private.", "committedDate": "2020-08-26T20:35:02Z", "type": "commit"}, {"oid": "81e33e2db5c313093817c2efc3be6c4201b21604", "url": "https://github.com/grpc/grpc-java/commit/81e33e2db5c313093817c2efc3be6c4201b21604", "message": "Revert the year change in file header.", "committedDate": "2020-08-26T22:55:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477579266", "bodyText": "I think keeping checkNotNull(xdsClientPool, \"missing xDS client pool\"); provides better debug information than a plain NPE.", "author": "dapengzhang0", "createdAt": "2020-08-26T20:46:32Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -44,77 +41,65 @@\n import io.grpc.xds.internal.sds.TlsContextManager;\n import io.grpc.xds.internal.sds.TlsContextManagerImpl;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicReference;\n import javax.annotation.Nullable;\n \n /**\n- * Load balancer for cds_experimental LB policy.\n+ * Load balancer for cds_experimental LB policy. One instance per cluster.\n  */\n-public final class CdsLoadBalancer extends LoadBalancer {\n+final class CdsLoadBalancer extends LoadBalancer {\n+  // TODO(sanjaypujare): remove once xds security is released\n+  @VisibleForTesting\n+  static boolean enableSecurity =\n+      Boolean.parseBoolean(System.getenv(\"GRPC_XDS_EXPERIMENTAL_SECURITY_SUPPORT\"));\n   private final XdsLogger logger;\n+  private final LoadBalancer.Helper helper;\n   private final LoadBalancerRegistry lbRegistry;\n-  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n   private final TlsContextManager tlsContextManager;\n-  // TODO(sanjaypujare): remove once xds security is released\n-  private boolean enableXdsSecurity;\n-  private static final String XDS_SECURITY_ENV_VAR = \"GRPC_XDS_EXPERIMENTAL_SECURITY_SUPPORT\";\n-\n-  // The following fields become non-null once handleResolvedAddresses() successfully.\n-\n-  // Most recent cluster name.\n-  @Nullable\n   private String clusterName;\n-  @Nullable\n   private ObjectPool<XdsClient> xdsClientPool;\n-  @Nullable\n   private XdsClient xdsClient;\n+  private ChildLbState childLbState;\n \n-  CdsLoadBalancer(Helper helper) {\n+  CdsLoadBalancer(LoadBalancer.Helper helper) {\n     this(helper, LoadBalancerRegistry.getDefaultRegistry(), TlsContextManagerImpl.getInstance());\n   }\n \n   @VisibleForTesting\n-  CdsLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry,\n+  CdsLoadBalancer(LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry,\n       TlsContextManager tlsContextManager) {\n-    checkNotNull(helper, \"helper\");\n+    this.helper = checkNotNull(helper, \"helper\");\n     this.lbRegistry = lbRegistry;\n-    this.switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n     this.tlsContextManager = tlsContextManager;\n     logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n     logger.log(XdsLogLevel.INFO, \"Created\");\n   }\n \n   @Override\n   public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n-    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n-    if (xdsClientPool == null) {\n-      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n-      checkNotNull(xdsClientPool, \"missing xDS client pool\");\n-      xdsClient = xdsClientPool.getObject();\n+    if (clusterName != null) {\n+      return;\n     }\n-\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+    xdsClient = xdsClientPool.getObject();", "originalCommit": "3e79c05ca7edb3171943a56d5ce2614a3a6b178d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgxNjM4NQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477816385", "bodyText": "Hmm, I feel this very redundant and unnecessary. Behavior-wise, they are the same. Checking for null is more helpful for cases you received an argument and save it for later use (e.g., constructor arguments saved as fields and to be used later). Here we are accessing it in-place. If it breaks, it just breaks at the first place where we do not expect it to be null. Regarding the error message, I don't think that provides anything more helpful than the NPE stacktrace containing the line number that breaks it. It is good enough for debugging, which should be very very rare.", "author": "voidzcy", "createdAt": "2020-08-27T00:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA5NDUxOA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478094518", "bodyText": "You can't rely on the line number that breaks if you don't know which commit/version of grpc-java the user is running with.", "author": "dapengzhang0", "createdAt": "2020-08-27T04:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE4MjQ0OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478182449", "bodyText": "You can't rely on the line number that breaks if you don't know which commit/version of grpc-java the user is running with.\n\nThat is not the usage of checkNotNull. Would you put checkNotNull for every single variable that is not final? You only want to avoid losing track of the first place the unexpected null value occurs by using checkNotNull. Otherwise, its usages are redundant and only makes the program verbose without any benefit. Let it break immediately if it is a programmer error, that's good enough. Doing anything more is excessive.\nWhy would you want to debug some error without knowing the source code version (aka, what the source code is)?", "author": "voidzcy", "createdAt": "2020-08-27T06:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MjE3OA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478562178", "bodyText": "I'm not saying put checkNotNull for every single variable that is not final. The xdsClientPool is an input from an external component, it's out of the current component's control.\nSome times it's hard to know the grpc version from the user reporting issues. Even internally, sometimes you don't know the code was running at which CL or staging or production version.", "author": "dapengzhang0", "createdAt": "2020-08-27T16:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2NzQ5OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478567499", "bodyText": "The xdsClientPool is an input from an external component, it's out of the current component's control.\n\nThat's not the necessary reason to check for null. Check if it is null and panic is equivalent to let to throw NPE there.\n\nSome times it's hard to know the grpc version from the user reporting issues. Even internally, sometimes you don't know the code was running at which CL or staging or production version.\n\nAs I said, let it panic at the first place that is unexpected to be null is good enough. Excessive code only adds verbosity.", "author": "voidzcy", "createdAt": "2020-08-27T17:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU4NzMxOQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478587319", "bodyText": "That's not the necessary reason to check for null. Check if it is null and panic is equivalent to let to throw NPE there.\n\nI'm not saying the behavior is different. My point is helping debug when NPE does happen.\n\nExcessive code only adds verbosity.\n\nThe verbosity helps debug.", "author": "dapengzhang0", "createdAt": "2020-08-27T17:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NDQ3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478594477", "bodyText": "Let it panic at the line NPE is thrown is good enough for debugging. You do not need the excessive message to find where the exception is thrown. Trying to debug using a different version of source code other than the one the breakage is observed makes no sense.", "author": "voidzcy", "createdAt": "2020-08-27T17:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5OTY4OA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478599688", "bodyText": "You have little clue if you see NPE with a line number of unknown version. If you can see the string \"xdsClientPool\" in the message of NPE, you immediately know what's going on even you don't know the version.", "author": "dapengzhang0", "createdAt": "2020-08-27T18:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwMzAzNw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478603037", "bodyText": "This isn't a big gain while an excessive piece of code is added. If you do this for all null-possible variables for such reasons, excessive code spreads everywhere. You are trying to focus too much on handling every error cases gracefully, which is absolutely unnecessary or worse than just let it panic.", "author": "voidzcy", "createdAt": "2020-08-27T18:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYyMDY2Nw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478620667", "bodyText": "I agree it isn't a big gain. My point is verbosity does help debug, and we have consistently been using that style throughout the code for that purpose. This is not important though so I'm not blocking you on this.", "author": "dapengzhang0", "createdAt": "2020-08-27T18:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1NTgwNA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478655804", "bodyText": "I think the checkNotNull should remain where it was and not be changed. There was nothing wrong with it, and it isn't out-of-the-question that it could be null. You can't go around changing existing code based on your whim, because then you get exactly what is happening here: each author has a different approach and the code flip/flops and causes disagreements as to how it should be done.\nI'm very bothered about these changes being made in such a sweeping way. Why was all this unnecessary code changed? That just added disagreement opportunities during review and can cause an otherwise-okay change to be hung up on useless stuff.", "author": "ejona86", "createdAt": "2020-08-27T19:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3ODQ0NQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478678445", "bodyText": "I was cleaning up things alone the way, as we previously had multiple authors added/changed implementations in this class (each of them, as well as reviewers, has very different style and taste), which made the code quite messy. So in this refactoring work, I was trying to polish such things if it can look better (IMO).", "author": "voidzcy", "createdAt": "2020-08-27T20:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5MDMzOQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478690339", "bodyText": "So in this refactoring work, I was trying to polish such things if it can look better (IMO).\n\nThat's definitely a mistake in two regards: combining two unrelated sizable changes and \"IMO\".\nYou're wanting the reviewer to approve changing their code to your code, for no reason other than you think it looks better. And you're \"holding them hostage\" because they have to choose between the refactoring and having their style remain in-place. It seems it should be obvious why this would go poorly. You should start by assuming the reviewer will not adopt your coding style. Maybe bits and pieces you are able to influence, but y'all will remain different. And then you get to figure out how you work together to form one team.\nThis PR is sizable at +504 \u2212671. You should have tried to reduce its size in both actual lines changed and non-trivial lines. A small sampling of the non-test code makes it seem like there may be more style changes than refactoring changes. I don't understand why the tests are so dramatically different; I'd have to dig into that more. But just on a cursory glance without actually knowing enough about this code to make a real decision, if I were the reviewer I'd probably \"send it back\" and have you remove all the superfluous stuff.", "author": "ejona86", "createdAt": "2020-08-27T20:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5ODU1NA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478698554", "bodyText": "I don't understand why the tests are so dramatically different\n\nRewriting the tests is one of the major goals of this change. For historical reasons (design and implementations have been changing back and forth while each change tried to insert test code even if that made the overall tests worse, and reviewers did not care much about tests), those tests are poorly written if seeing from current's perspective. Really, if you read and try to understand the existing implementation and tests, I bet you would really hate it (e.g., a quick glance). It's so messy. But you aren't able to really feel it unless you really dig into it. \ud83d\ude22", "author": "voidzcy", "createdAt": "2020-08-27T21:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxNTU0OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478715549", "bodyText": "Rewriting the tests is one of the major goals of this change.\n\nOkay. I did notice they looked more regular. I don't really understand what \"eliminate cluster name change logic\" has to do with the tests, but that's fine. As long as you two know what's going on and are happy SGTM.", "author": "ejona86", "createdAt": "2020-08-27T21:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxNzQ2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478717465", "bodyText": "But I believe unrelated changes should be made in separate PRs.", "author": "sanjaypujare", "createdAt": "2020-08-27T21:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNDAzMw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478724033", "bodyText": "Ah, I can separate out the test class into a separate PR, that's a complete rewritten thing while github diff is just trying hard to retain the very little common code. I believe tests in this PR should also work for things before refactoring (maybe except the portion of security code) as it's blackbox. But reviewers will basically still see similar diffs, but mostly just contain the test class.\nRegardless the tests. Really this PR only refactors the implementation structure to get rid of some unnecessary logic. But since it's a structural refactoring (aka, reimplement the encapsulation of a couple of inner components), the change is inevitably big. But other than that, remaining is just cosmetic things (e.g., Sanjay's enableXdsSecurity flag), if you really think those are \"unrelated changes\".\nYou wouldn't feel how painful it was to deal with the existing code (that was not written by me), especially the test code. That's why rewriting is way better than trying to refactor while keep change minimal.", "author": "voidzcy", "createdAt": "2020-08-27T22:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNzg5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478737896", "bodyText": "I'm not bothered by the massive changes to the tests. That's not uncommon in tests. It was clear to me they were rewritten and the diff was unhelpful.\nI'm bothered by refactoring, API-unrelated test changes, and \"cosmetic\" changes done together. It sounds like the refactoring by itself would have been a small change to make and review (but yes, it'd have many changed lines). And testing changes may have been gladly received and reviewed. But it is clear that this PR description says it is for the refactoring. If the tests are so important, why weren't they called out at all?\nI'm actually not too bothered with sending this all out as a single PR. I think it was a clear mistake, but hey, it happens and I know others don't quite feel the same way I do about how to refactor. I think a better thing to realize is that when the review devolved, the approach should have changed to removing the contentious-changes-that-weren't-the-core-of-the-change and getting the \"eliminate cluster name change logic in CDS LB policy\" part merged. Digging your heals in and arguing the changes were good is unhelpful to the objective of the PR (as defined by its title and description). I can understand that these may have been long-standing disagreements, but we can make progress even with the disagreements.", "author": "ejona86", "createdAt": "2020-08-27T22:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477665669", "bodyText": "Why making this change? Should never remove any unrecognized attributes.", "author": "dapengzhang0", "createdAt": "2020-08-26T23:23:06Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -264,83 +158,68 @@ public Subchannel createSubchannel(CreateSubchannelArgs createSubchannelArgs) {\n \n     @Override\n     protected Helper delegate() {\n-      return delegate;\n+      return helper;\n     }\n   }\n \n-  private final class ClusterWatcherImpl implements ClusterWatcher {\n-\n-    final EdsLoadBalancingHelper helper;\n-    final ResolvedAddresses resolvedAddresses;\n-\n+  private final class ChildLbState implements ClusterWatcher {\n+    private final ChannelSecurityLbHelper lbHelper = new ChannelSecurityLbHelper();\n     @Nullable\n-    LoadBalancer edsBalancer;\n-\n-    ClusterWatcherImpl(Helper helper, ResolvedAddresses resolvedAddresses) {\n-      this.helper = new EdsLoadBalancingHelper(helper,\n-          new AtomicReference<SslContextProvider>());\n-      this.resolvedAddresses = resolvedAddresses;\n-    }\n+    private LoadBalancer lb;\n \n     @Override\n-    public void onClusterChanged(ClusterUpdate newUpdate) {\n+    public void onClusterChanged(ClusterUpdate update) {\n       if (logger.isLoggable(XdsLogLevel.INFO)) {\n-        logger.log(\n-            XdsLogLevel.INFO,\n-            \"Received cluster update from xDS client {0}: \"\n+        logger.log(XdsLogLevel.INFO, \"Received cluster update from xDS client {0}: \"\n                 + \"cluster_name={1}, eds_service_name={2}, lb_policy={3}, report_load={4}\",\n-            xdsClient, newUpdate.getClusterName(), newUpdate.getEdsServiceName(),\n-            newUpdate.getLbPolicy(), newUpdate.getLrsServerName() != null);\n+            xdsClient, update.getClusterName(), update.getEdsServiceName(),\n+            update.getLbPolicy(), update.getLrsServerName() != null);\n       }\n-      checkArgument(\n-          newUpdate.getLbPolicy().equals(\"round_robin\"), \"can only support round_robin policy\");\n-\n-      LoadBalancerProvider lbProvider = lbRegistry.getProvider(newUpdate.getLbPolicy());\n-      Object lbConfig =\n-          lbProvider.parseLoadBalancingPolicyConfig(ImmutableMap.<String, Object>of()).getConfig();\n+      LoadBalancerProvider lbProvider = lbRegistry.getProvider(update.getLbPolicy());\n       final EdsConfig edsConfig =\n-          new EdsConfig(\n-              /* clusterName = */ newUpdate.getClusterName(),\n-              /* edsServiceName = */ newUpdate.getEdsServiceName(),\n-              /* lrsServerName = */ newUpdate.getLrsServerName(),\n-              new PolicySelection(lbProvider, ImmutableMap.<String, Object>of(), lbConfig));\n-      if (isXdsSecurityEnabled()) {\n-        updateSslContextProvider(newUpdate.getUpstreamTlsContext());\n+          new EdsConfig(update.getClusterName(), update.getEdsServiceName(),\n+              update.getLrsServerName(), new PolicySelection(lbProvider, null, null));\n+      if (enableSecurity) {\n+        updateSslContextProvider(update.getUpstreamTlsContext());\n       }\n-      if (edsBalancer == null) {\n-        edsBalancer = lbRegistry.getProvider(EDS_POLICY_NAME).newLoadBalancer(helper);\n+      if (lb == null) {\n+        lb = lbRegistry.getProvider(XdsLbPolicies.EDS_POLICY_NAME).newLoadBalancer(lbHelper);\n       }\n-      edsBalancer.handleResolvedAddresses(\n-          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(edsConfig).build());\n+      lb.handleResolvedAddresses(\n+          ResolvedAddresses.newBuilder()\n+              .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+              .setAttributes(\n+                  Attributes.newBuilder()", "originalCommit": "81e33e2db5c313093817c2efc3be6c4201b21604", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgyMDkwMg==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477820902", "bodyText": "The xDS LB tree implementation is internal, so we know what attributes should be there. Keeping unused/unexpected blobs around just prevent them from being GCed.", "author": "voidzcy", "createdAt": "2020-08-27T00:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODExMDA1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478110056", "bodyText": "No. (1) Child LBs in the xDS LB tree are plugins, and in theory any LB can be replaced another LB/LB tree, e.g. RoundRobinLoadBalancer can be replaced by HealthCheckingRoundRobinLoadBalancer. (2) You don't know what child policies will be supported in the future, so it will be hard to maintain the whole LB tree if a new child policy need another attributes. (3) We should follow the same rule for hierarchical LB tree in general.\nGC is not a concern, they will be GCed when the whole LB tree is not referencing the attributes.", "author": "dapengzhang0", "createdAt": "2020-08-27T04:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI0MzIzNA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478243234", "bodyText": "(1) Child LBs in the xDS LB tree are plugins, and in theory any LB can be replaced another LB/LB tree, e.g. RoundRobinLoadBalancer can be replaced by HealthCheckingRoundRobinLoadBalancer. (2) You don't know what child policies will be supported in the future, so it will be hard to maintain the whole LB tree if a new child policy need another attributes.\n\nWhy add code and implement something undefined yet? Currently the only useful attribute is the XdsClientPool. What's the different between this code and pass down the ResolvedAddress blob? If more attributes are added from upstream and are used by downstreams, just implement that logic when needed. Why implement a placeholder for something that is currently undefined?\n\n(3) We should follow the same rule for hierarchical LB tree in general.\n\nWhy that is a rule? Such a rule does not make any sense. If I was the author of other LB policies, I would not write it in that existing way. The upstream just pass should just what's needed by downstream and nothing more. This is much more elegant than blindly cache a blob and pass it to another component. Much more compact logic and avoid spreading unused data everywhere. This is much easier to understand and reason about.", "author": "voidzcy", "createdAt": "2020-08-27T08:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1ODEwNA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478558104", "bodyText": "If the name resolver sends an attribute that the top-level LB does not recognize, it's supposed to be used for its grand children or transports. The name resolver should know what attributes it's adding. The name resolver should never add an attribute that is not used downstream. If the top-level LB does not recognize that attribute, it should still pass down to its children. Only when the top-level LB recognizes an attribute, and knows it is not needed for its children or grand children or transports, then it should not pass the attribute downstream.\nOne LB should never add a new attribute that is not used downstream. If one LB adds an attribute that its direct child does not recognize, it's supposed to be used for its grand children or transport. The LB should know what attributes it's adding. The LB should never add an attribute that is not used downstream. Only when the LB recognizes an attribute, and knows it is not needed for its children or grand children or transports, then it should not pass the attribute downstream.\nEvery layer knows what new attributes to add and knows what known attributes to be removed and should not remove attributes it does not recognize. So there is no chance unused attributes passed downstream.", "author": "dapengzhang0", "createdAt": "2020-08-27T16:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU3MDM5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478570393", "bodyText": "If the name resolver sends an attribute that the top-level LB does not recognize, it's supposed to be used for its grand children or transports. The name resolver should know what attributes it's adding. The name resolver should never add an attribute that is not used downstream. If the top-level LB does not recognize that attribute, it should still pass down to its children. Only when the top-level LB recognizes an attribute, and knows it is not needed for its children or grand children or transports, then it should not pass the attribute downstream.\n\nWhat is such an attribute here? Obviously no such a thing.\n\nOne LB should never add a new attribute that is not used downstream. If one LB adds an attribute that its direct child does not recognize, it's supposed to be used for its grand children or transport. The LB should know what attributes it's adding. The LB should never add an attribute that is not used downstream. Only when the LB recognizes an attribute, and knows it is not needed for its children or grand children or transports, then it should not pass the attribute downstream.\n\nI didn't add any new attribute here. CDS LB policy knows downstream needs the XdsClient, so it put that into the attribute. It doesn't put anything extra.\n\nEvery layer knows what new attributes to add and knows what known attributes to be removed and should not remove attributes it does not recognize. So there is no chance unused attributes passed downstream.\n\nAgain, what is the unrecognized attribute here? Not any right? What trying to worry about something that does not exist?", "author": "voidzcy", "createdAt": "2020-08-27T17:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU4ODAyOA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478588028", "bodyText": "Then what attribute is not GCed? Not any right? Why worry about something that does not exist?", "author": "dapengzhang0", "createdAt": "2020-08-27T17:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU4ODk1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478588956", "bodyText": "What attribute is not GCed?\n\nYeah, not any. So I am not saying that anymore.", "author": "voidzcy", "createdAt": "2020-08-27T17:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwMDgwNg==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478600806", "bodyText": "Maybe let's get a second opinion. + @ejona86", "author": "dapengzhang0", "createdAt": "2020-08-27T18:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYyNzU0MA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478627540", "bodyText": "I reordered the quotes a bit to fix things together a bit more.\n\nThe xDS LB tree implementation is internal, so we know what attributes should be there.\n\nThat's a very brittle view of a system. With that approach it is fine for any change to require auditing all the code (which means every change, since you don't when your change would impact other parts unless you audit).\nI agree we could live with such things, but they are technical debt and should be strongly discouraged for our sanity and velocity. (Note, on a small scale (e.g., a method) this is fine. But the larger the \"component\" impacted the greater the cost and thus the more frequently it should be avoided.)\n\nThe upstream just pass should just what's needed by downstream and nothing more.\n\nThat is a strongly incorrect argument. Upstream does not know what downstream needs.  We know downstream will be pluggable in the future. Upstream does not have a full view of the system and to assert it should is just silly. But also, this isn't really \"upstream\" this is \"midstream\" and we need upstream and downstream to be able to communicate without having midstream be aware of everything that's happening.\n\nThis is much more elegant than blindly cache a blob and pass it to another component.\n\nBut that's the hierarchical design with the attributes. That's the point.\n\nMuch more compact logic and avoid spreading unused data everywhere.\n\nI don't see what logic would be necessary. Could you point out what logic is removed? It seems any logic relating to this should be trivial.\n\nThis is much easier to understand and reason about.\n\nYes and no. It is easier to reason about a single component. It is harder to reason about the system. In both cases it may be harder to make changes in the future (it depends a lot on which types of changes whether it is a win or loss). Given that propagating the attributes here seems trivial for the component, it seems a very good tradeoff to benefit the system.\n\nKeeping unused/unexpected blobs around just prevent them from being GCed.\n\nWould they actually be GCed? I'd generally expect expensive things to be retained by the higher levels in order to re-use them across updates.\nIs there a specific object in particular or a reason to think this would be a problem? Optimizing for GC is optimizing and optimizing without a clear need is premature optimization. I could argue that we should optimize to reduce the allocation rate and so you should reuse the attributes. These attributes aren't all that heavily used, but where they are used it is important stuff and could significantly reduce overheads by sharing (e.g., health checks can be shared). So your microptimization here could have real-life negative consquences.\nI don't think \"optimization\" is the correct argument. The change discussed here has correctness/semantics implications. Unless one option is significantly worse, favoring correctness yields a much better system. So we really shouldn't bring up the GC argument at all unless there is a \"clear and present danger\" and there clearly is not such an issue here.\nI don't think you should make subtle behavior changes during a refactor like this. Do the change before or after, or have a really good reason why it has to be within the refactor. Refactors are risky and you should spend extra effort to avoid having behavior changes hidden within them. When a refactor has no behavior changes, it is much easier to review as well.\n\nWhy add code and implement something undefined yet?\n\nThis may be a valid argument. I don't know this code well enough to tell. It's a \"how much work would it take to plumb the attributes\" question. However, it was plumbed previously, so I would be doubtful that removing that plumbing makes sense.\n\nOne LB should never add a new attribute that is not used downstream.\n\nThat's not 100% true. There are some attributes that are added \"just in case.\" Health checking for example. But those attributes are needed by the LB adding them already, so there's no GC concern; the LB that added the attribute hangs on to that resource.\nConsider the xdsClient. That's \"big and expensive.\" But it doesn't help anyone to strip it from the attributes, because the NameResolver is going to use the xdsClient even if no LB does. It is a significant optimization to pass the xdsClient to child LB policies just in case they need it. And if they don't need it, no harm was done; it's relatively free. (Yes, we know xdsClient is used a lot; but it could make sense to do the same thing even if it was a rare benefit. Now, we don't do that for all resources simply because that would be premature optimization and a waste of our development energy. So we do it just for \"objects that make sense\".)", "author": "ejona86", "createdAt": "2020-08-27T18:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MDc0Mw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478650743", "bodyText": "Thanks for your dedicated explanation! I am considering this more from the cosmetic perspective. Mostly I hate the pattern of the code that turns a data blob into builder, swap out some parts and then build to be used for the next components. The blob may carry excessive data that intended to be consumed only at this components to other components. Instead, I prefer the pattern of rebuilding the data blob passed to next components by adding in pieces taken from the current blob explicitly. Building the blob explicitly makes the code cleaners to understand and semantically less error-prone by avoid leaking excessive data to other components.\n\n\nThis is much more elegant than blindly cache a blob and pass it to another component.\n\nBut that's the hierarchical design with the attributes. That's the point.\n\nAlright, what about we just plumb the attributes opaquely, but we would build the ResolvedAddresses by explicitly putting in the attributes. This seems to be a solution that is somewhat in the middle of what we are arguing (see the latest change).", "author": "voidzcy", "createdAt": "2020-08-27T19:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NTIyMw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478675223", "bodyText": "Mostly I hate the pattern of the code that turns a data blob into builder, swap out some parts and then build to be used for the next components.\n\nI'm sorry, but that's the design and pattern. Doing anything else is harmful.\n\nInstead, I prefer the pattern of rebuilding the data blob passed to next components by adding in pieces taken from the current blob explicitly.\n\nI don't really know what to say but \"too bad.\" I've discussed the problems with that approach and benefits to the add-to-the-blob approach. The design is already there and being used and to change it would mean a redesign; it's not just this one component your playing with, you're breaking the system it is apart of.\nWith the current approach the Attribute.Key may not even be publicly visible. So you many not be able to copy it to a new object. That's a nice feature as we can use Java visibility to limit access to data.\nThe approach you discuss could be another design approach, but it is clearly not the current design for the system. You could argue for us to change the current design due to problems X, Y, Z, but you can't change just this component without getting the worst of both approaches without any of the benefits. You should proceed with the current system's design and we only change code to a different \"style\" if we actually change the design of the system.\nYou can dislike the system, but that doesn't change \"we have to work within the system.\" Yes, the system can be changed, but not like this.\n\nBuilding the blob explicitly makes the code cleaners to understand and semantically less error-prone by avoid leaking excessive data to other components.\n\nThis seems pure personal preference or speculation compared to us knowing cases where we need to pass data through middle-men LB policies without their knowledge.\n\nAlright, what about we just plumb the attributes opaquely, but we would build the ResolvedAddresses by explicitly putting in the attributes.\n\nI'm fine with that. It's a bit of a toss-up which approach to go with. The two approaches are clearly not \"equivalent\" but deciding which is better is more an exercise of predicting the future (which fields will be added).", "author": "ejona86", "createdAt": "2020-08-27T20:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjI0NA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478676244", "bodyText": "I'm fine with that.\n\nActually, I'm not. If this was new code, sure. But changing this when changing everything else seems inappropriate.", "author": "ejona86", "createdAt": "2020-08-27T20:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY4NTM5OA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478685398", "bodyText": "Alright, alright. I surrender. Will just keep the old way.", "author": "voidzcy", "createdAt": "2020-08-27T20:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2ODU0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477668542", "bodyText": "What is {0}?", "author": "dapengzhang0", "createdAt": "2020-08-26T23:25:42Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -350,16 +229,33 @@ public void onResourceDoesNotExist(String resourceName) {\n \n     @Override\n     public void onError(Status error) {\n-      logger.log(\n-          XdsLogLevel.WARNING,\n-          \"Received error from xDS client {0}: {1}: {2}\",\n-          xdsClient,\n-          error.getCode(),\n-          error.getDescription());\n-      if (edsBalancer == null) {\n+      logger.log(XdsLogLevel.WARNING, \"Received error from xDS client {0}: {1}\", error);", "originalCommit": "81e33e2db5c313093817c2efc3be6c4201b21604", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgwMDI0OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477800249", "bodyText": "Oops, fixed. Btw, I started to think that including the XdsClient identity in the log is pretty useless..", "author": "voidzcy", "createdAt": "2020-08-27T00:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2ODU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwMzQ0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477703447", "bodyText": "Implementing a TlsContextManager seems simpler and more readable than the boilerplate of implementing new Answer().", "author": "dapengzhang0", "createdAt": "2020-08-26T23:49:39Z", "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -46,547 +31,485 @@\n import io.grpc.LoadBalancer.PickResult;\n import io.grpc.LoadBalancer.PickSubchannelArgs;\n import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n import io.grpc.LoadBalancer.SubchannelPicker;\n import io.grpc.LoadBalancerProvider;\n import io.grpc.LoadBalancerRegistry;\n-import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.SynchronizationContext;\n-import io.grpc.internal.FakeClock;\n-import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.internal.ObjectPool;\n import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n-import io.grpc.xds.XdsClient.ClusterUpdate;\n-import io.grpc.xds.XdsClient.ClusterWatcher;\n-import io.grpc.xds.XdsClient.RefCountedXdsClientObjectPool;\n-import io.grpc.xds.XdsClient.XdsClientFactory;\n import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n import io.grpc.xds.internal.sds.SslContextProvider;\n import io.grpc.xds.internal.sds.TlsContextManager;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayDeque;\n+import java.net.SocketAddress;\n import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.ArgumentCaptor;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n \n /**\n  * Tests for {@link CdsLoadBalancer}.\n  */\n @RunWith(JUnit4.class)\n public class CdsLoadBalancerTest {\n-\n-  private final RefCountedXdsClientObjectPool xdsClientPool = new RefCountedXdsClientObjectPool(\n-      new XdsClientFactory() {\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n         @Override\n-        XdsClient createXdsClient() {\n-          xdsClient = mock(XdsClient.class);\n-          return xdsClient;\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n         }\n+      });\n+  private final List<FakeLoadBalancer> childBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  @Mock\n+  private TlsContextManager tlsContextManager;\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private CdsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+    when(tlsContextManager.findOrCreateClientSslContextProvider(any(UpstreamTlsContext.class)))", "originalCommit": "81e33e2db5c313093817c2efc3be6c4201b21604", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgwNjIxOA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477806218", "bodyText": "Yay, it is more reasonable/correct to use a fake implementation here. But the reason is the stuff we want to test/verify more about the side effect (aka, attaching an EAG attribute) than just the interaction with something called a TlsContextManager. Fixed.", "author": "voidzcy", "createdAt": "2020-08-27T00:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwMzQ0Nw=="}], "type": "inlineReview"}, {"oid": "68aab1af647afcd43fa7a072c182c2490d51c2f5", "url": "https://github.com/grpc/grpc-java/commit/68aab1af647afcd43fa7a072c182c2490d51c2f5", "message": "Fix log typo.", "committedDate": "2020-08-27T00:32:46Z", "type": "commit"}, {"oid": "a7a5101f73ca29e2b2d3b13d499aed9429a8e4eb", "url": "https://github.com/grpc/grpc-java/commit/a7a5101f73ca29e2b2d3b13d499aed9429a8e4eb", "message": "Use a fake implementation for TlsContextManager for test.", "committedDate": "2020-08-27T00:42:32Z", "type": "commit"}, {"oid": "0d1ee05e4460963f29272bf93287571fb720e65f", "url": "https://github.com/grpc/grpc-java/commit/0d1ee05e4460963f29272bf93287571fb720e65f", "message": "Eliminated the unnecessary start() method.", "committedDate": "2020-08-27T18:29:24Z", "type": "commit"}, {"oid": "6585d3d7cb9afa7bde8f9ac94bf7028d29c49cab", "url": "https://github.com/grpc/grpc-java/commit/6585d3d7cb9afa7bde8f9ac94bf7028d29c49cab", "message": "Improve logging.", "committedDate": "2020-08-27T18:41:03Z", "type": "commit"}, {"oid": "1b9af1d4c4b8683bc2252a304e55236b779aaa2d", "url": "https://github.com/grpc/grpc-java/commit/1b9af1d4c4b8683bc2252a304e55236b779aaa2d", "message": "Pass the ResolvedAddress blob straightly down to the child balancer.", "committedDate": "2020-08-27T19:15:56Z", "type": "commit"}, {"oid": "d1e3d48f0c8570d246dc8761e9722ec7fdacda70", "url": "https://github.com/grpc/grpc-java/commit/d1e3d48f0c8570d246dc8761e9722ec7fdacda70", "message": "Pass the whole attributes to child balancer opaquely.", "committedDate": "2020-08-27T19:22:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjIwMg==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478676202", "bodyText": "This is also unrelated style change. I also liked @sanjaypujare 's style. Maybe\nreturn enableXdsSecurity || STATIC_VALUE\nfor isXdsSecurityEnabled() could improve it a bit. But the non-static setXdsSecurity() method for testing is better than modifing static value in test, in my opinion.\nAs pointed out by @ejona86 , we should not flip/flop unrelated lines in the PR. Just keeping as-is can make the diff of PR small. If you do want some improvement, make it a separate PR.", "author": "dapengzhang0", "createdAt": "2020-08-27T20:27:04Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -125,124 +111,33 @@ public boolean canHandleEmptyAddressListFromNameResolution() {\n   @Override\n   public void shutdown() {\n     logger.log(XdsLogLevel.INFO, \"Shutdown\");\n-    switchingLoadBalancer.shutdown();\n+    if (childLbState != null) {\n+      childLbState.shutdown();\n+    }\n     if (xdsClientPool != null) {\n       xdsClientPool.returnObject(xdsClient);\n     }\n   }\n \n-  // TODO(sanjaypujare): remove once xDS security is released\n-  private boolean isXdsSecurityEnabled() {\n-    return enableXdsSecurity || Boolean.valueOf(System.getenv(XDS_SECURITY_ENV_VAR));\n-  }\n-\n-  // TODO(sanjaypujare): remove once xDS security is released\n-  @VisibleForTesting\n-  void setXdsSecurity(boolean enable) {\n-    enableXdsSecurity = enable;\n-  }\n-", "originalCommit": "d1e3d48f0c8570d246dc8761e9722ec7fdacda70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY4MTEyMg==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478681122", "bodyText": "Reading the environment variable should be done statically, and the field enableXdsSecurity is redundant.\nThe problem is, there could be so many such improvements (especially some tests completely doesn't make any sense), if you do them separately, there will be a lot of steps. Now that this refactoring is an involved internal structural change, it's more-or-less a rewrite.", "author": "voidzcy", "createdAt": "2020-08-27T20:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY4MzY0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478683642", "bodyText": "This code is going to go away once security is released so it's not worth so much discussion. Especially when the discussion involves subjective viewpoints.", "author": "sanjaypujare", "createdAt": "2020-08-27T20:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjIwMg=="}], "type": "inlineReview"}, {"oid": "c29780907ad4f7997092684304988dcbf04eb7ce", "url": "https://github.com/grpc/grpc-java/commit/c29780907ad4f7997092684304988dcbf04eb7ce", "message": "Revert \"Pass the whole attributes to child balancer opaquely.\"\n\nThis reverts commit d1e3d48f0c8570d246dc8761e9722ec7fdacda70.", "committedDate": "2020-08-27T20:44:09Z", "type": "commit"}, {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348", "url": "https://github.com/grpc/grpc-java/commit/10880ec35423ed9e2c870fae797389bf4f6d2348", "message": "Revert non-crutial changes.", "committedDate": "2020-08-28T00:01:45Z", "type": "commit"}, {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348", "url": "https://github.com/grpc/grpc-java/commit/10880ec35423ed9e2c870fae797389bf4f6d2348", "message": "Revert non-crutial changes.", "committedDate": "2020-08-28T00:01:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1OTUzNA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478759534", "bodyText": "They are effectively final. Code explains itself, no need to comment.", "author": "voidzcy", "createdAt": "2020-08-28T00:03:25Z", "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -45,31 +44,24 @@\n import io.grpc.xds.internal.sds.TlsContextManagerImpl;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicReference;\n import javax.annotation.Nullable;\n \n /**\n- * Load balancer for cds_experimental LB policy.\n+ * Load balancer for cds_experimental LB policy. One instance per cluster.\n  */\n-public final class CdsLoadBalancer extends LoadBalancer {\n+final class CdsLoadBalancer extends LoadBalancer {\n   private final XdsLogger logger;\n+  private final Helper helper;\n   private final LoadBalancerRegistry lbRegistry;\n-  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n   private final TlsContextManager tlsContextManager;\n   // TODO(sanjaypujare): remove once xds security is released\n   private boolean enableXdsSecurity;\n   private static final String XDS_SECURITY_ENV_VAR = \"GRPC_XDS_EXPERIMENTAL_SECURITY_SUPPORT\";\n-\n-  // The following fields become non-null once handleResolvedAddresses() successfully.\n-\n-  // Most recent cluster name.\n-  @Nullable", "originalCommit": "10880ec35423ed9e2c870fae797389bf4f6d2348", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyNTgxMA==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r479425810", "bodyText": "an empty line here", "author": "dapengzhang0", "createdAt": "2020-08-28T16:57:02Z", "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -46,547 +30,498 @@\n import io.grpc.LoadBalancer.PickResult;\n import io.grpc.LoadBalancer.PickSubchannelArgs;\n import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n import io.grpc.LoadBalancer.SubchannelPicker;\n import io.grpc.LoadBalancerProvider;\n import io.grpc.LoadBalancerRegistry;\n-import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.SynchronizationContext;\n-import io.grpc.internal.FakeClock;\n-import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.internal.ObjectPool;\n import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyServerProtoData.DownstreamTlsContext;\n import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n-import io.grpc.xds.XdsClient.ClusterUpdate;\n-import io.grpc.xds.XdsClient.ClusterWatcher;\n-import io.grpc.xds.XdsClient.RefCountedXdsClientObjectPool;\n-import io.grpc.xds.XdsClient.XdsClientFactory;\n import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n import io.grpc.xds.internal.sds.SslContextProvider;\n import io.grpc.xds.internal.sds.TlsContextManager;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayDeque;\n+import java.net.SocketAddress;\n import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n /**\n  * Tests for {@link CdsLoadBalancer}.\n  */\n @RunWith(JUnit4.class)\n public class CdsLoadBalancerTest {\n-\n-  private final RefCountedXdsClientObjectPool xdsClientPool = new RefCountedXdsClientObjectPool(\n-      new XdsClientFactory() {\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n         @Override\n-        XdsClient createXdsClient() {\n-          xdsClient = mock(XdsClient.class);\n-          return xdsClient;\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n         }\n+      });\n+  private final List<FakeLoadBalancer> childBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final TlsContextManager tlsContextManager = new FakeTlsContextManager();\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private CdsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+    registry.register(new FakeLoadBalancerProvider(XdsLbPolicies.EDS_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(\"round_robin\"));\n+    ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+      @Override\n+      public XdsClient getObject() {\n+        xdsClientRefs++;\n+        return xdsClient;\n       }\n-  );\n \n-  private final LoadBalancerRegistry lbRegistry = new LoadBalancerRegistry();\n-  private final LoadBalancerProvider fakeEdsLoadBlancerProvider = new LoadBalancerProvider() {\n+      @Override\n+      public XdsClient returnObject(Object object) {\n+        assertThat(xdsClientRefs).isGreaterThan(0);\n+        xdsClientRefs--;\n+        return null;\n+      }\n+    };\n+    loadBalancer = new CdsLoadBalancer(helper, registry, tlsContextManager);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setLoadBalancingPolicyConfig(new CdsConfig(CLUSTER))\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .build());\n+    assertThat(xdsClient.watcher).isNotNull();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watcher).isNull();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+  }\n+\n+\n+  @Test\n+  public void receiveFirstClusterResourceInfo() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.name).isEqualTo(XdsLbPolicies.EDS_POLICY_NAME);\n+    assertThat(childBalancer.config).isNotNull();\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+  }\n+\n+  @Test\n+  public void clusterResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancers).isEmpty();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceRemoved() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceUpdated() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+\n+    String edsService = \"service-bar.googleapis.com\";\n+    String loadReportServer = \"lrs-server.googleapis.com\";\n+    xdsClient.deliverClusterInfo(edsService, loadReportServer);\n+    assertThat(childBalancers).containsExactly(childBalancer);\n+    edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isEqualTo(edsService);\n+    assertThat(edsConfig.lrsServerName).isEqualTo(loadReportServer);\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+", "originalCommit": "10880ec35423ed9e2c870fae797389bf4f6d2348", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MDQ3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r479460479", "bodyText": "Oops, fixed. Thanks.", "author": "voidzcy", "createdAt": "2020-08-28T18:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyNTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzMDU0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r479430542", "bodyText": "Normally if delivering a picker with a subchannel, the state is READY. If delivering IDLE or TRANSIENT_FAILURE, the picker is buffer picker or error picker.", "author": "dapengzhang0", "createdAt": "2020-08-28T17:06:16Z", "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -46,547 +30,498 @@\n import io.grpc.LoadBalancer.PickResult;\n import io.grpc.LoadBalancer.PickSubchannelArgs;\n import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n import io.grpc.LoadBalancer.SubchannelPicker;\n import io.grpc.LoadBalancerProvider;\n import io.grpc.LoadBalancerRegistry;\n-import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.SynchronizationContext;\n-import io.grpc.internal.FakeClock;\n-import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.internal.ObjectPool;\n import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyServerProtoData.DownstreamTlsContext;\n import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n-import io.grpc.xds.XdsClient.ClusterUpdate;\n-import io.grpc.xds.XdsClient.ClusterWatcher;\n-import io.grpc.xds.XdsClient.RefCountedXdsClientObjectPool;\n-import io.grpc.xds.XdsClient.XdsClientFactory;\n import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n import io.grpc.xds.internal.sds.SslContextProvider;\n import io.grpc.xds.internal.sds.TlsContextManager;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayDeque;\n+import java.net.SocketAddress;\n import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n /**\n  * Tests for {@link CdsLoadBalancer}.\n  */\n @RunWith(JUnit4.class)\n public class CdsLoadBalancerTest {\n-\n-  private final RefCountedXdsClientObjectPool xdsClientPool = new RefCountedXdsClientObjectPool(\n-      new XdsClientFactory() {\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n         @Override\n-        XdsClient createXdsClient() {\n-          xdsClient = mock(XdsClient.class);\n-          return xdsClient;\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n         }\n+      });\n+  private final List<FakeLoadBalancer> childBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final TlsContextManager tlsContextManager = new FakeTlsContextManager();\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private CdsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+    registry.register(new FakeLoadBalancerProvider(XdsLbPolicies.EDS_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(\"round_robin\"));\n+    ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+      @Override\n+      public XdsClient getObject() {\n+        xdsClientRefs++;\n+        return xdsClient;\n       }\n-  );\n \n-  private final LoadBalancerRegistry lbRegistry = new LoadBalancerRegistry();\n-  private final LoadBalancerProvider fakeEdsLoadBlancerProvider = new LoadBalancerProvider() {\n+      @Override\n+      public XdsClient returnObject(Object object) {\n+        assertThat(xdsClientRefs).isGreaterThan(0);\n+        xdsClientRefs--;\n+        return null;\n+      }\n+    };\n+    loadBalancer = new CdsLoadBalancer(helper, registry, tlsContextManager);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setLoadBalancingPolicyConfig(new CdsConfig(CLUSTER))\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .build());\n+    assertThat(xdsClient.watcher).isNotNull();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watcher).isNull();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+  }\n+\n+\n+  @Test\n+  public void receiveFirstClusterResourceInfo() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.name).isEqualTo(XdsLbPolicies.EDS_POLICY_NAME);\n+    assertThat(childBalancer.config).isNotNull();\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+  }\n+\n+  @Test\n+  public void clusterResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancers).isEmpty();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceRemoved() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceUpdated() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+\n+    String edsService = \"service-bar.googleapis.com\";\n+    String loadReportServer = \"lrs-server.googleapis.com\";\n+    xdsClient.deliverClusterInfo(edsService, loadReportServer);\n+    assertThat(childBalancers).containsExactly(childBalancer);\n+    edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isEqualTo(edsService);\n+    assertThat(edsConfig.lrsServerName).isEqualTo(loadReportServer);\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+\n+  }\n+\n+  @Test\n+  public void receiveClusterResourceInfoWithUpstreamTlsContext() {\n+    loadBalancer.setXdsSecurity(true);\n+    UpstreamTlsContext upstreamTlsContext =\n+        CommonTlsContextTestsUtil.buildUpstreamTlsContextFromFilenames(\n+            CommonTlsContextTestsUtil.CLIENT_KEY_FILE,\n+            CommonTlsContextTestsUtil.CLIENT_PEM_FILE,\n+            CommonTlsContextTestsUtil.CA_PEM_FILE);\n+    xdsClient.deliverClusterInfo(null, null, upstreamTlsContext);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    List<EquivalentAddressGroup> addresses = createEndpointAddresses(2);\n+    CreateSubchannelArgs args =\n+        CreateSubchannelArgs.newBuilder()\n+            .setAddresses(addresses)\n+            .build();\n+    Subchannel subchannel = childBalancer.helper.createSubchannel(args);\n+    for (EquivalentAddressGroup eag : subchannel.getAllAddresses()) {\n+      assertThat(eag.getAttributes().get(XdsAttributes.ATTR_UPSTREAM_TLS_CONTEXT))\n+          .isEqualTo(upstreamTlsContext);\n+    }\n+\n+    xdsClient.deliverClusterInfo(null, null);\n+    subchannel = childBalancer.helper.createSubchannel(args);\n+    for (EquivalentAddressGroup eag : subchannel.getAllAddresses()) {\n+      assertThat(eag.getAttributes().get(XdsAttributes.ATTR_UPSTREAM_TLS_CONTEXT)).isNull();\n+    }\n+\n+    upstreamTlsContext =\n+        CommonTlsContextTestsUtil.buildUpstreamTlsContextFromFilenames(\n+            CommonTlsContextTestsUtil.BAD_CLIENT_KEY_FILE,\n+            CommonTlsContextTestsUtil.BAD_CLIENT_PEM_FILE,\n+            CommonTlsContextTestsUtil.CA_PEM_FILE);\n+    xdsClient.deliverClusterInfo(null, null, upstreamTlsContext);\n+    subchannel = childBalancer.helper.createSubchannel(args);\n+    for (EquivalentAddressGroup eag : subchannel.getAllAddresses()) {\n+      assertThat(eag.getAttributes().get(XdsAttributes.ATTR_UPSTREAM_TLS_CONTEXT))\n+          .isEqualTo(upstreamTlsContext);\n+    }\n+  }\n+\n+  @Test\n+  public void subchannelStatePropagateFromDownstreamToUpstream() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    List<EquivalentAddressGroup> addresses = createEndpointAddresses(2);\n+    CreateSubchannelArgs args =\n+        CreateSubchannelArgs.newBuilder()\n+            .setAddresses(addresses)\n+            .build();\n+    Subchannel subchannel = childBalancer.helper.createSubchannel(args);\n+    childBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    assertThat(currentPicker.pickSubchannel(mock(PickSubchannelArgs.class)).getSubchannel())\n+        .isSameInstanceAs(subchannel);\n+  }\n+\n+  @Test\n+  public void clusterDiscoveryError_beforeChildPolicyInstantiated_propagateToUpstream() {\n+    xdsClient.deliverError(Status.UNAUTHENTICATED.withDescription(\"permission denied\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAUTHENTICATED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"permission denied\");\n+  }\n+\n+  @Test\n+  public void clusterDiscoveryError_afterChildPolicyInstantiated_keepUsingCurrentCluster() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    xdsClient.deliverError(Status.UNAVAILABLE.withDescription(\"unreachable\"));\n+    assertThat(currentState).isNull();\n+    assertThat(currentPicker).isNull();\n+    assertThat(childBalancer.shutdown).isFalse();\n+  }\n+\n+  @Test\n+  public void nameResolutionError_beforeChildPolicyInstantiated_returnErrorPickerToUpstream() {\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNIMPLEMENTED.withDescription(\"not found\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNIMPLEMENTED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"not found\");\n+  }\n+\n+  @Test\n+  public void nameResolutionError_afterChildPolicyInstantiated_propagateToDownstream() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNAVAILABLE.withDescription(\"cannot reach server\"));\n+    assertThat(childBalancer.upstreamError.getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(childBalancer.upstreamError.getDescription())\n+        .isEqualTo(\"cannot reach server\");\n+  }\n+\n+  private static List<EquivalentAddressGroup> createEndpointAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      list.add(new EquivalentAddressGroup(mock(SocketAddress.class)));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeXdsClient extends XdsClient {\n+    private ClusterWatcher watcher;\n+\n     @Override\n-    public boolean isAvailable() {\n-      return true;\n+    void watchClusterData(String clusterName, ClusterWatcher watcher) {\n+      assertThat(clusterName).isEqualTo(CLUSTER);\n+      this.watcher = watcher;\n     }\n \n     @Override\n-    public int getPriority() {\n-      return 5;\n+    void cancelClusterDataWatch(String clusterName, ClusterWatcher watcher) {\n+      assertThat(clusterName).isEqualTo(CLUSTER);\n+      assertThat(watcher).isSameInstanceAs(this.watcher);\n+      this.watcher = null;\n     }\n \n     @Override\n-    public String getPolicyName() {\n-      return EDS_POLICY_NAME;\n+    void shutdown() {\n+      // no-op\n+    }\n+\n+    void deliverClusterInfo(\n+        @Nullable final String edsServiceName, @Nullable final String lrsServerName) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onClusterChanged(\n+              ClusterUpdate.newBuilder()\n+                  .setClusterName(CLUSTER)\n+                  .setEdsServiceName(edsServiceName)\n+                  .setLbPolicy(\"round_robin\")  // only supported policy\n+                  .setLrsServerName(lrsServerName)\n+                  .build());\n+        }\n+      });\n+    }\n+\n+    void deliverClusterInfo(\n+        @Nullable final String edsServiceName, @Nullable final String lrsServerName,\n+        final UpstreamTlsContext tlsContext) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onClusterChanged(\n+              ClusterUpdate.newBuilder()\n+                  .setClusterName(CLUSTER)\n+                  .setEdsServiceName(edsServiceName)\n+                  .setLbPolicy(\"round_robin\")  // only supported policy\n+                  .setLrsServerName(lrsServerName)\n+                  .setUpstreamTlsContext(tlsContext)\n+                  .build());\n+        }\n+      });\n+    }\n+\n+    void deliverResourceNotFound() {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onResourceDoesNotExist(CLUSTER);\n+        }\n+      });\n+    }\n+\n+    void deliverError(final Status error) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onError(error);\n+        }\n+      });\n+    }\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n     }\n \n     @Override\n     public LoadBalancer newLoadBalancer(Helper helper) {\n-      edsLbHelpers.add(helper);\n-      LoadBalancer edsLoadBalancer = mock(LoadBalancer.class);\n-      edsLoadBalancers.add(edsLoadBalancer);\n-      return edsLoadBalancer;\n+      FakeLoadBalancer balancer = new FakeLoadBalancer(policyName, helper);\n+      childBalancers.add(balancer);\n+      return balancer;\n     }\n-  };\n \n-  private final LoadBalancerProvider fakeRoundRobinLbProvider = new LoadBalancerProvider() {\n     @Override\n     public boolean isAvailable() {\n       return true;\n     }\n \n     @Override\n     public int getPriority() {\n-      return 5;\n+      return 0;  // doesn't matter\n     }\n \n     @Override\n     public String getPolicyName() {\n-      return \"round_robin\";\n+      return policyName;\n+    }\n+  }\n+\n+  private final class FakeLoadBalancer extends LoadBalancer {\n+    private final String name;\n+    private final Helper helper;\n+    private Object config;\n+    private Status upstreamError;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(String name, Helper helper) {\n+      this.name = name;\n+      this.helper = helper;\n     }\n \n     @Override\n-    public LoadBalancer newLoadBalancer(Helper helper) {\n-      return mock(LoadBalancer.class);\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      config = resolvedAddresses.getLoadBalancingPolicyConfig();\n     }\n \n     @Override\n-    public ConfigOrError parseLoadBalancingPolicyConfig(\n-        Map<String, ?> rawLoadBalancingPolicyConfig) {\n-      return ConfigOrError.fromConfig(\"fake round robin config\");\n+    public void handleNameResolutionError(Status error) {\n+      upstreamError = error;\n     }\n-  };\n \n-  private final SynchronizationContext syncContext = new SynchronizationContext(\n-      new Thread.UncaughtExceptionHandler() {\n+    @Override\n+    public void shutdown() {\n+      shutdown = true;\n+      childBalancers.remove(this);\n+    }\n+\n+    void deliverSubchannelState(final Subchannel subchannel, ConnectivityState state) {", "originalCommit": "10880ec35423ed9e2c870fae797389bf4f6d2348", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MTE2OQ==", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r479461169", "bodyText": "That's fine, it doesn't violate the API spec. Also, there is only one usage here, which is delivering a READY state with a subchannel.", "author": "voidzcy", "createdAt": "2020-08-28T18:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzMDU0Mg=="}], "type": "inlineReview"}, {"oid": "a9a2c4c4882224a956a5c5124b803198ac9d76b3", "url": "https://github.com/grpc/grpc-java/commit/a9a2c4c4882224a956a5c5124b803198ac9d76b3", "message": "Delete empty line.", "committedDate": "2020-08-28T18:09:01Z", "type": "commit"}]}