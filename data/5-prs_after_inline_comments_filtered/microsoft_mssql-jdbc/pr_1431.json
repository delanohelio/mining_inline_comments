{"pr_number": 1431, "pr_title": "Add maxResultBuffer property", "pr_createdAt": "2020-09-17T11:16:58Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1431", "timeline": [{"oid": "af25295f63f109b865c6756b18a3988a568b15d0", "url": "https://github.com/microsoft/mssql-jdbc/commit/af25295f63f109b865c6756b18a3988a568b15d0", "message": "Added MaxResultBuffer property and added methods to handle it in driver", "committedDate": "2020-09-17T07:26:41Z", "type": "commit"}, {"oid": "363ed6591d44e60d56f77de1ecdd2aac4fec7ab3", "url": "https://github.com/microsoft/mssql-jdbc/commit/363ed6591d44e60d56f77de1ecdd2aac4fec7ab3", "message": "Added Counter Interface with basic implementation, added MaxResultBuffer with Tests", "committedDate": "2020-09-17T07:27:42Z", "type": "commit"}, {"oid": "ca8223a89d29a8d83d724d5d15fdb1aceb87e1a7", "url": "https://github.com/microsoft/mssql-jdbc/commit/ca8223a89d29a8d83d724d5d15fdb1aceb87e1a7", "message": "Added correct Project's Formatting and loggers", "committedDate": "2020-09-17T07:28:15Z", "type": "commit"}, {"oid": "e417451f9ecf9ced9df95d2ec656187a95b83779", "url": "https://github.com/microsoft/mssql-jdbc/commit/e417451f9ecf9ced9df95d2ec656187a95b83779", "message": "Fixed bug with MaxResultBuffer parsing, Tweak corresponding Test class", "committedDate": "2020-09-17T07:28:22Z", "type": "commit"}, {"oid": "33f1791c9d5ffd45255517f4a879d3414ee4ca79", "url": "https://github.com/microsoft/mssql-jdbc/commit/33f1791c9d5ffd45255517f4a879d3414ee4ca79", "message": "Implemented Counter's reset and increase methods", "committedDate": "2020-09-17T07:28:29Z", "type": "commit"}, {"oid": "e9db643b6a0572db0253f9713c0f7ac183368ba3", "url": "https://github.com/microsoft/mssql-jdbc/commit/e9db643b6a0572db0253f9713c0f7ac183368ba3", "message": "ResultSet tests added, added required Test Constant and Test Error Message, changed order of MaxResultBufferPropertyDescription Exception,", "committedDate": "2020-09-17T07:28:45Z", "type": "commit"}, {"oid": "460a829c5feb33e124963787aa9e89ea551d2531", "url": "https://github.com/microsoft/mssql-jdbc/commit/460a829c5feb33e124963787aa9e89ea551d2531", "message": "Fixed few misspellings in MaxResultBufferTest and reverted deleted space in ISQLServerDataSource", "committedDate": "2020-09-17T10:19:57Z", "type": "commit"}, {"oid": "52f069690c643d6f9bf40354c0ac62e396d869c2", "url": "https://github.com/microsoft/mssql-jdbc/commit/52f069690c643d6f9bf40354c0ac62e396d869c2", "message": "Added null and empty String validation to MaxResultBufferParser, made use of StringUtils in MaxResultBufferParser, replaced substring() with endsWith() and charAt(), extracted errorMessage to variable, fixed format of multipliers, added few test cases to MaxResultBufferParserTest, updated setting maxResultBuffer to activeConnectionProperties in SQLServerConnection", "committedDate": "2020-09-17T10:27:53Z", "type": "commit"}, {"oid": "290f031898f4febfdea88f8b31f5fc5e37bcfb24", "url": "https://github.com/microsoft/mssql-jdbc/commit/290f031898f4febfdea88f8b31f5fc5e37bcfb24", "message": "Added error message for maxResultBufferInvalidSyntax in SQLServerResource, corrected formatting in SQLServerConnection, extracted switch expression to method, reformatted code", "committedDate": "2020-09-17T11:08:19Z", "type": "commit"}, {"oid": "306f5ad46108200ae942e239cdcdcf2020a2a138", "url": "https://github.com/microsoft/mssql-jdbc/commit/306f5ad46108200ae942e239cdcdcf2020a2a138", "message": "Merge branch 'dev' into maxResultBuffer", "committedDate": "2020-10-15T09:45:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMzU3NQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r514433575", "bodyText": "Temporary solution would be to change this line to\nif (StringUtils.isEmpty(input) || \"-1\".equalsIgnoreCase(input)) {\nBut we should ask whether it makes sense to allow users to even input something like -1 at all. -1 is also used as a default value by XAConnection at times.", "author": "rene-ye", "createdAt": "2020-10-29T17:20:06Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"maxResultBuffer property is badly formatted: {0}\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1\n+        if (StringUtils.isEmpty(input)) {", "originalCommit": "306f5ad46108200ae942e239cdcdcf2020a2a138", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NzQ3MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r514447470", "bodyText": "This needs a break at the end of the case statement or it'll overflow into the next one.", "author": "rene-ye", "createdAt": "2020-10-29T17:41:05Z", "path": "src/test/java/com/microsoft/sqlserver/testframework/AbstractTest.java", "diffHunk": "@@ -355,6 +355,8 @@ protected static ISQLServerDataSource updateDataSource(String connectionString,\n                             break;\n                         case Constants.SEND_TEMPORAL_DATATYPES_AS_STRING_FOR_BULK_COPY:\n                             ds.setSendTemporalDataTypesAsStringForBulkCopy(Boolean.parseBoolean(value));", "originalCommit": "306f5ad46108200ae942e239cdcdcf2020a2a138", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NzU5OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r514447598", "bodyText": "Add a break to the end of the this so the above bug doesn't happen again.", "author": "rene-ye", "createdAt": "2020-10-29T17:41:18Z", "path": "src/test/java/com/microsoft/sqlserver/testframework/AbstractTest.java", "diffHunk": "@@ -355,6 +355,8 @@ protected static ISQLServerDataSource updateDataSource(String connectionString,\n                             break;\n                         case Constants.SEND_TEMPORAL_DATATYPES_AS_STRING_FOR_BULK_COPY:\n                             ds.setSendTemporalDataTypesAsStringForBulkCopy(Boolean.parseBoolean(value));\n+                        case Constants.MAX_RESULT_BUFFER:\n+                            ds.setMaxResultBuffer(value);", "originalCommit": "306f5ad46108200ae942e239cdcdcf2020a2a138", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5329a2be49b8a1a3577fb016fd7620fd6ef9a2ec", "url": "https://github.com/microsoft/mssql-jdbc/commit/5329a2be49b8a1a3577fb016fd7620fd6ef9a2ec", "message": "Added break statements to the AbstractTest.java, so cases would behave as expected", "committedDate": "2020-11-04T11:29:44Z", "type": "commit"}, {"oid": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "url": "https://github.com/microsoft/mssql-jdbc/commit/9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "message": "Refactored logic in validateMaxResultBuffer method in MaxResultBufferParser, added check for negative values supplied as maxResultBuffer parameter, they have their own exception, changed default value of MaxResultBuffer to \"-1\", addressed bad format of InvalidSyntaxException, added corresponding tests to MaxResultBufferParserTest.java", "committedDate": "2020-11-04T11:38:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNjY0MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519036641", "bodyText": "Please make this interface package-private.", "author": "ulvii", "createdAt": "2020-11-06T22:28:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ICounter.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+/**\n+ * Interface for MaxResultBufferCounter\n+ */\n+public interface ICounter {", "originalCommit": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzOTQ2OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519039469", "bodyText": "Package-private please.", "author": "ulvii", "createdAt": "2020-11-06T22:37:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -7344,6 +7364,23 @@ final boolean readingResponse() {\n \n     protected ArrayList<byte[]> enclaveCEKs;\n \n+    //Counter reference, so maxResultBuffer property can by acknowledged\n+    private ICounter counter;\n+\n+    public ICounter getCounter() {", "originalCommit": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MDkxOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519040918", "bodyText": "package-private", "author": "ulvii", "createdAt": "2020-11-06T22:41:22Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -7344,6 +7364,23 @@ final boolean readingResponse() {\n \n     protected ArrayList<byte[]> enclaveCEKs;\n \n+    //Counter reference, so maxResultBuffer property can by acknowledged\n+    private ICounter counter;\n+\n+    public ICounter getCounter() {\n+        return counter;\n+    }\n+\n+    public void createCounter(ICounter previousCounter, Properties activeConnectionProperties) {", "originalCommit": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0ODE5NQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519048195", "bodyText": "Because connectionString is defined in AbstractTest and is static, this line will change the connection string for all the tests. Please use a local connection string .", "author": "ulvii", "createdAt": "2020-11-06T23:05:35Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\n+import com.microsoft.sqlserver.testframework.AbstractTest;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.platform.runner.JUnitPlatform;\n+import org.junit.runner.RunWith;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Random;\n+\n+\n+/**\n+ * Class for testing maxResultBuffer property, all tests were performed on default connection settings\n+ * (defaultPacketLength = 8000), only changed were ResponsiveBuffering and MaxResultBuffer\n+ */\n+@RunWith(JUnitPlatform.class)\n+@DisplayName(\"maxResultBuffer Tests\")\n+public class MaxResultBufferTest extends AbstractTest {\n+\n+    @SuppressWarnings(\"SqlResolve\")\n+    private static final String TEST_TABLE_NAME = \"maxResultBufferTestTable\";\n+\n+    /**\n+     * This sets value of maxResultBuffer for each test\n+     */\n+    @BeforeEach\n+    void prepareMaxResultBuffer() {\n+        setMaxResultBuffer(\"10k\");\n+    }\n+\n+    /**\n+     * Create TEST_TABLE with 1 column nchar(precision) with numberOfRows. Let's calculate payload on example:\n+     * numberOfRows = 800 precision = 10\n+     *\n+     * Payload (in Bytes) = 49 (Header plus column metadata) + numberOfRows * (precision * 2 + 1 + 2) (3 extra bytes are\n+     * for column length and end of line character)\n+     *\n+     * So payload generated by this method = 49 + 800 * (10 * 2 + 2 + 1) = 49 + 800 * 23 = 18449\n+     *\n+     * Default packetLength = 8000, so payload is sent in 3 packets\n+     *\n+     * @throws SQLException\n+     *         Signalizes error when creating TEST_TABLE\n+     */\n+    @BeforeAll\n+    static void createAndPopulateNCharTestTable() throws SQLException {\n+        String insertSQL = \"INSERT INTO \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME) + \" VALUES (?)\";\n+        int numberOfRows = 800;\n+        int precision = 10;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement();\n+                PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {\n+\n+            // drop Table if exists and then create new one\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+            statement.execute(\"CREATE TABLE \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME)\n+                    + \" ( col1 nchar(\" + precision + \"))\");\n+\n+            // insert into Table\n+            for (int i = 0; i < numberOfRows; i++) {\n+                preparedStatement.setString(1, generateRandomString(precision));\n+                preparedStatement.addBatch();\n+            }\n+            preparedStatement.executeBatch();\n+        }\n+    }\n+\n+    @AfterAll\n+    static void teardownTestTable() throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithAdaptiveResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(false);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSet behave correctly when maxResultBuffer is set to 10000, it should throw Exception\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBufferingException() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class,\n+                () -> testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY));\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = adaptive)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithAdaptiveResponseBuffering() {\n+        setResponseBufferingAdaptive(true);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should work properly (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithAdaptiveResponseBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testTwoQueriesInOneStatement();\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should throw Exception (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testTwoQueriesInOneStatement);\n+    }\n+\n+    /**\n+     * This method tests if all packets from ResultSet are correctly retrieved\n+     *\n+     * @param resultSetType\n+     *        Result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n+     *        <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n+     * @param concurrencyMode\n+     *        Concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or\n+     *        <code>ResultSet.CONCUR_UPDATABLE</code>\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testResultSet(int resultSetType, int concurrencyMode) throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement(resultSetType, concurrencyMode)) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME);\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if Statements are detached properly, when first one hasn't been completely retrieved and second\n+     * one have been executed\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testPreparedStatementWithMultipleResultSets() throws SQLException {\n+        String selectSQL = \"SELECT * FROM \" + TEST_TABLE_NAME;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                PreparedStatement statement = connection.prepareStatement(selectSQL);\n+                ResultSet resultSet = statement.executeQuery()) {\n+\n+            try (PreparedStatement secondStatement = connection.prepareStatement(selectSQL);\n+                    ResultSet secondResultSet = secondStatement.executeQuery()) {\n+                while (resultSet.next()) {}\n+\n+                try (PreparedStatement thirdStatement = connection.prepareStatement(selectSQL);\n+                        ResultSet thirdResultSet = thirdStatement.executeQuery()) {\n+                    while (thirdResultSet.next()) {}\n+                    while (secondResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSet's are retrieved correctly, when more than one Query is executed inside single\n+     * statement\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testTwoQueriesInOneStatement() throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement()) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME + \";SELECT * FROM \" + TEST_TABLE_NAME);\n+\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+\n+            if (statement.getMoreResults()) {\n+                try (ResultSet totallyNewResultSet = statement.getResultSet()) {\n+                    while (totallyNewResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String generateRandomString(int precision) {\n+        int leftLimit = 33;\n+        int rightLimit = 126;\n+        Random random = new Random();\n+        return random.ints(leftLimit, rightLimit).limit(precision)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();\n+    }\n+\n+    private static void setResponseBufferingAdaptive(boolean adaptive) {\n+        String value = adaptive ? \"adaptive\" : \"full\";\n+        connectionString = TestUtils.addOrOverrideProperty(connectionString, \"responseBuffering\", value);\n+        AbstractTest.updateDataSource(connectionString, ds);\n+    }\n+\n+    private static void setMaxResultBuffer(String maxResultBuffer) {\n+        connectionString = TestUtils.addOrOverrideProperty(connectionString, \"maxResultBuffer\", maxResultBuffer);", "originalCommit": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0OTg5OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519049899", "bodyText": "Because connectionString is defined in AbstractTest and is static, this line will change the connection string for all the tests. Please use a local connection string .", "author": "ulvii", "createdAt": "2020-11-06T23:12:08Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\n+import com.microsoft.sqlserver.testframework.AbstractTest;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.platform.runner.JUnitPlatform;\n+import org.junit.runner.RunWith;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Random;\n+\n+\n+/**\n+ * Class for testing maxResultBuffer property, all tests were performed on default connection settings\n+ * (defaultPacketLength = 8000), only changed were ResponsiveBuffering and MaxResultBuffer\n+ */\n+@RunWith(JUnitPlatform.class)\n+@DisplayName(\"maxResultBuffer Tests\")\n+public class MaxResultBufferTest extends AbstractTest {\n+\n+    @SuppressWarnings(\"SqlResolve\")\n+    private static final String TEST_TABLE_NAME = \"maxResultBufferTestTable\";\n+\n+    /**\n+     * This sets value of maxResultBuffer for each test\n+     */\n+    @BeforeEach\n+    void prepareMaxResultBuffer() {\n+        setMaxResultBuffer(\"10k\");\n+    }\n+\n+    /**\n+     * Create TEST_TABLE with 1 column nchar(precision) with numberOfRows. Let's calculate payload on example:\n+     * numberOfRows = 800 precision = 10\n+     *\n+     * Payload (in Bytes) = 49 (Header plus column metadata) + numberOfRows * (precision * 2 + 1 + 2) (3 extra bytes are\n+     * for column length and end of line character)\n+     *\n+     * So payload generated by this method = 49 + 800 * (10 * 2 + 2 + 1) = 49 + 800 * 23 = 18449\n+     *\n+     * Default packetLength = 8000, so payload is sent in 3 packets\n+     *\n+     * @throws SQLException\n+     *         Signalizes error when creating TEST_TABLE\n+     */\n+    @BeforeAll\n+    static void createAndPopulateNCharTestTable() throws SQLException {\n+        String insertSQL = \"INSERT INTO \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME) + \" VALUES (?)\";\n+        int numberOfRows = 800;\n+        int precision = 10;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement();\n+                PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {\n+\n+            // drop Table if exists and then create new one\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+            statement.execute(\"CREATE TABLE \" + AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME)\n+                    + \" ( col1 nchar(\" + precision + \"))\");\n+\n+            // insert into Table\n+            for (int i = 0; i < numberOfRows; i++) {\n+                preparedStatement.setString(1, generateRandomString(precision));\n+                preparedStatement.addBatch();\n+            }\n+            preparedStatement.executeBatch();\n+        }\n+    }\n+\n+    @AfterAll\n+    static void teardownTestTable() throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            TestUtils.dropTableIfExists(AbstractSQLGenerator.escapeIdentifier(TEST_TABLE_NAME), statement);\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithAdaptiveResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSets behave correctly when maxResultBuffer is set to 10000, they all should pass\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(false);\n+\n+        testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n+        testResultSet(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n+        testResultSet(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    /**\n+     * This method tests if ResultSet behave correctly when maxResultBuffer is set to 10000, it should throw Exception\n+     * (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testResultSetLinearWithFullResponsiveBufferingException() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class,\n+                () -> testResultSet(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY));\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = adaptive)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithAdaptiveResponseBuffering() {\n+        setResponseBufferingAdaptive(true);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if when calling multiple PreparedStatements with their own ResultSet, JDBC driver would behave\n+     * appropriately, assuming maxResultBuffer is set to 10000, it should throw Exception (assuming default packetLength\n+     * = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testPreparedStatementMultipleResultSetsWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testPreparedStatementWithMultipleResultSets);\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should work properly (assuming default packetLength = 8000 and responsiveBuffering = adaptive)\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithAdaptiveResponseBuffering() throws SQLException {\n+        setResponseBufferingAdaptive(true);\n+\n+        testTwoQueriesInOneStatement();\n+    }\n+\n+    /**\n+     * This method tests if calling multiple Queries in one Statement works properly. When maxResultBuffer is set to\n+     * 10000, it should throw Exception (assuming default packetLength = 8000 and responsiveBuffering = full)\n+     */\n+    @Test\n+    public void testTwoQueriesInOneStatementWithFullResponseBuffering() {\n+        setResponseBufferingAdaptive(false);\n+\n+        Assertions.assertThrows(SQLServerException.class, this::testTwoQueriesInOneStatement);\n+    }\n+\n+    /**\n+     * This method tests if all packets from ResultSet are correctly retrieved\n+     *\n+     * @param resultSetType\n+     *        Result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n+     *        <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n+     * @param concurrencyMode\n+     *        Concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or\n+     *        <code>ResultSet.CONCUR_UPDATABLE</code>\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testResultSet(int resultSetType, int concurrencyMode) throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement(resultSetType, concurrencyMode)) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME);\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if Statements are detached properly, when first one hasn't been completely retrieved and second\n+     * one have been executed\n+     *\n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testPreparedStatementWithMultipleResultSets() throws SQLException {\n+        String selectSQL = \"SELECT * FROM \" + TEST_TABLE_NAME;\n+\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                PreparedStatement statement = connection.prepareStatement(selectSQL);\n+                ResultSet resultSet = statement.executeQuery()) {\n+\n+            try (PreparedStatement secondStatement = connection.prepareStatement(selectSQL);\n+                    ResultSet secondResultSet = secondStatement.executeQuery()) {\n+                while (resultSet.next()) {}\n+\n+                try (PreparedStatement thirdStatement = connection.prepareStatement(selectSQL);\n+                        ResultSet thirdResultSet = thirdStatement.executeQuery()) {\n+                    while (thirdResultSet.next()) {}\n+                    while (secondResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method tests if ResultSet's are retrieved correctly, when more than one Query is executed inside single\n+     * statement\n+     * \n+     * @throws SQLException\n+     *         Exception is thrown when maxResultBuffer is exceeded\n+     */\n+    private void testTwoQueriesInOneStatement() throws SQLException {\n+        try (Connection connection = DriverManager.getConnection(connectionString);\n+                Statement statement = connection.createStatement()) {\n+            statement.execute(\"SELECT * FROM \" + TEST_TABLE_NAME + \";SELECT * FROM \" + TEST_TABLE_NAME);\n+\n+            try (ResultSet resultSet = statement.getResultSet()) {\n+                while (resultSet.next()) {}\n+            }\n+\n+            if (statement.getMoreResults()) {\n+                try (ResultSet totallyNewResultSet = statement.getResultSet()) {\n+                    while (totallyNewResultSet.next()) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String generateRandomString(int precision) {\n+        int leftLimit = 33;\n+        int rightLimit = 126;\n+        Random random = new Random();\n+        return random.ints(leftLimit, rightLimit).limit(precision)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();\n+    }\n+\n+    private static void setResponseBufferingAdaptive(boolean adaptive) {\n+        String value = adaptive ? \"adaptive\" : \"full\";\n+        connectionString = TestUtils.addOrOverrideProperty(connectionString, \"responseBuffering\", value);", "originalCommit": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NDUwMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r519054500", "bodyText": "Please add more test for different possible values of the connection property, both valid and invalid cases.", "author": "ulvii", "createdAt": "2020-11-06T23:29:53Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/MaxResultBufferTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*", "originalCommit": "9f2706904fc349b95b40ed652357ad0a5fa2bcbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a86682036751475935147ef3d9c04b699eb3d40", "url": "https://github.com/microsoft/mssql-jdbc/commit/3a86682036751475935147ef3d9c04b699eb3d40", "message": "Changed modifier public to package-private of ICounter interface, getCounter and createCounter methods in IOBuffer.java", "committedDate": "2020-11-09T13:08:14Z", "type": "commit"}, {"oid": "0efd5dc3a194ea24b644aeb3671a8e6786d80fb0", "url": "https://github.com/microsoft/mssql-jdbc/commit/0efd5dc3a194ea24b644aeb3671a8e6786d80fb0", "message": "Replaced use of connectionString in MaxResultBufferTest.java with local copy of connectionString (named localConnectionString), so it won't affect connectionString for other tests", "committedDate": "2020-11-09T13:11:54Z", "type": "commit"}, {"oid": "b4ff616017eb8f072235e01d61349df3427d3f26", "url": "https://github.com/microsoft/mssql-jdbc/commit/b4ff616017eb8f072235e01d61349df3427d3f26", "message": "Added more test cases to MaxResultBufferParserTest.java, updated validateMaxResultBuffer method in MaxResultBufferParser.java accordingly", "committedDate": "2020-11-09T13:20:46Z", "type": "commit"}, {"oid": "989d3626b57be57c2711da3574e680e0318b1f2a", "url": "https://github.com/microsoft/mssql-jdbc/commit/989d3626b57be57c2711da3574e680e0318b1f2a", "message": "Refactored tests in MaxResultBufferTest.java, parameterized them, updated comments, added more test cases", "committedDate": "2020-11-10T14:07:37Z", "type": "commit"}, {"oid": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "url": "https://github.com/microsoft/mssql-jdbc/commit/8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "message": "Merge branch 'dev' into maxResultBuffer", "committedDate": "2020-11-23T09:55:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NTUyMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529875521", "bodyText": "Please change to :\nif (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, \"MaxResultBuffer exceeded: {0}. Property was set to {1}.\",\n            new Object[] {number, maxResultBuffer});\n}", "author": "ulvii", "createdAt": "2020-11-24T21:02:29Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferCounter.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Implementation of ICounter for 'maxResultBuffer' property.\n+ */\n+public class MaxResultBufferCounter implements ICounter {\n+\n+    private final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferCounter\");\n+\n+    private long counter = 0;\n+    private final long maxResultBuffer;\n+\n+    public MaxResultBufferCounter(long maxResultBuffer) {\n+        this.maxResultBuffer = maxResultBuffer;\n+    }\n+\n+    public void increaseCounter(long bytes) throws SQLServerException {\n+        if (maxResultBuffer > 0) {\n+            counter += bytes;\n+            checkForMaxResultBufferOverflow(counter);\n+        }\n+    }\n+\n+    public void resetCounter() {\n+        counter = 0;\n+    }\n+\n+    private void checkForMaxResultBufferOverflow(long number) throws SQLServerException {\n+        if (number > maxResultBuffer) {\n+            logger.log(Level.WARNING, \"MaxResultBuffer exceeded: {0}. Property was set to {1}.\",", "originalCommit": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NjMxOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529876318", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "author": "ulvii", "createdAt": "2020-11-24T21:04:09Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "originalCommit": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NjcwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529876701", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "author": "ulvii", "createdAt": "2020-11-24T21:04:54Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, input);\n+            }\n+            return adjustMemory(number, 1);\n+        } else {\n+            // check PERCENT_PHRASES\n+            for (String percentPhrase : PERCENT_PHRASES) {\n+                if (input.endsWith(percentPhrase)) {\n+                    numberString = input.substring(0, input.length() - percentPhrase.length());\n+                    try {\n+                        number = Long.parseLong(numberString);\n+                    } catch (NumberFormatException e) {\n+                        logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "originalCommit": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3Njg5OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529876898", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "author": "ulvii", "createdAt": "2020-11-24T21:05:13Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, input);\n+            }\n+            return adjustMemory(number, 1);\n+        } else {\n+            // check PERCENT_PHRASES\n+            for (String percentPhrase : PERCENT_PHRASES) {\n+                if (input.endsWith(percentPhrase)) {\n+                    numberString = input.substring(0, input.length() - percentPhrase.length());\n+                    try {\n+                        number = Long.parseLong(numberString);\n+                    } catch (NumberFormatException e) {\n+                        logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                        throwNewInvalidMaxResultBufferParameterException(e, numberString);\n+                    }\n+                    return adjustMemoryPercentage(number);\n+                }\n+            }\n+\n+            // check if prefix was supplied\n+            long multiplier = getMultiplier(input);\n+            numberString = input.substring(0, input.length() - 1);\n+\n+            try {\n+                number = Long.parseLong(numberString);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "originalCommit": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NzA3Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529877072", "bodyText": "if (logger.isLoggable(Level.SEVERE)) {\n    logger.log(Level.SEVERE, ERROR_MESSAGE, new Object[] {input});\n}", "author": "ulvii", "createdAt": "2020-11-24T21:05:31Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import java.lang.management.ManagementFactory;\n+import java.text.MessageFormat;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * Parser created to parse String value from Connection String to equivalent number of bytes for JDBC Driver to work on.\n+ */\n+public class MaxResultBufferParser {\n+\n+    private static final Logger logger = Logger.getLogger(\"com.microsoft.sqlserver.jdbc.MaxResultBufferParser\");\n+    private static final String[] PERCENT_PHRASES = {\"percent\", \"pct\", \"p\"};\n+    private static final String ERROR_MESSAGE = \"MaxResultBuffer property is badly formatted: {0}.\";\n+\n+    private MaxResultBufferParser() {}\n+\n+    /**\n+     *\n+     * Returns number of bytes for maxResultBuffer property\n+     *\n+     * @param input\n+     *        String value for maxResultProperty provided in Connection String\n+     * @return 'maxResultBuffer' property as number of bytes\n+     * @throws SQLServerException\n+     *         Is Thrown when maxResultProperty's syntax is wrong\n+     */\n+    public static long validateMaxResultBuffer(String input) throws SQLServerException {\n+        String numberString;\n+        long number = -1;\n+\n+        // check for null values and empty String \"\", if so return -1 (default value)\n+        if (StringUtils.isEmpty(input) || input.equals(\"-1\")) {\n+            return number;\n+        }\n+\n+        // check if input is number\n+        if (!StringUtils.isEmpty(input) && input.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")) {\n+            try {\n+                number = Long.parseLong(input);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, input);\n+            }\n+            return adjustMemory(number, 1);\n+        } else {\n+            // check PERCENT_PHRASES\n+            for (String percentPhrase : PERCENT_PHRASES) {\n+                if (input.endsWith(percentPhrase)) {\n+                    numberString = input.substring(0, input.length() - percentPhrase.length());\n+                    try {\n+                        number = Long.parseLong(numberString);\n+                    } catch (NumberFormatException e) {\n+                        logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                        throwNewInvalidMaxResultBufferParameterException(e, numberString);\n+                    }\n+                    return adjustMemoryPercentage(number);\n+                }\n+            }\n+\n+            // check if prefix was supplied\n+            long multiplier = getMultiplier(input);\n+            numberString = input.substring(0, input.length() - 1);\n+\n+            try {\n+                number = Long.parseLong(numberString);\n+            } catch (NumberFormatException e) {\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});\n+                throwNewInvalidMaxResultBufferParameterException(e, numberString);\n+            }\n+            return adjustMemory(number, multiplier);\n+        }\n+    }\n+\n+    private static void checkForNegativeValue(long value) throws SQLServerException {\n+        if (value <= 0) {\n+            Object[] objectToThrow = new Object[] {value};\n+            MessageFormat form = new MessageFormat(\n+                    SQLServerException.getErrString(\"R_maxResultBufferNegativeParameterValue\"));\n+            logger.log(Level.INFO, SQLServerException.getErrString(\"R_maxResultBufferNegativeParameterValue\"),\n+                    objectToThrow);\n+            throw new SQLServerException(form.format(objectToThrow), new Throwable());\n+        }\n+    }\n+\n+    private static long getMultiplier(String input) throws SQLServerException {\n+        long multiplier = 1;\n+        switch (Character.toUpperCase(input.charAt(input.length() - 1))) {\n+            case 'K':\n+                multiplier = 1_000L;\n+                break;\n+            case 'M':\n+                multiplier = 1_000_000L;\n+                break;\n+            case 'G':\n+                multiplier = 1_000_000_000L;\n+                break;\n+            case 'T':\n+                multiplier = 1_000_000_000_000L;\n+                break;\n+            default:\n+                logger.log(Level.INFO, ERROR_MESSAGE, new Object[] {input});", "originalCommit": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MTg0MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1431#discussion_r529881840", "bodyText": "R_maxResultBufferPropertyDescription should describe what maxResultBuffer connection property does, please check  R_useFmtOnlyPropertyDescription for reference.  I'd suggest to create another String resource for MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}. and use R_maxResultBufferPropertyDescription for the actual description of the connection property.", "author": "ulvii", "createdAt": "2020-11-24T21:14:37Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -652,5 +652,9 @@ static String getResource(String key) {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n-};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+            {\"R_maxResultBufferPropertyDescription\",", "originalCommit": "8f2336d33bcc48670b73fd53d376bd10aa7f3b9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e5a03e750242a00d60ef18bce8157a40537abd5", "url": "https://github.com/microsoft/mssql-jdbc/commit/2e5a03e750242a00d60ef18bce8157a40537abd5", "message": "Changed logger levels in MaxResultBufferCounter and in MaxResultBufferParser, added description to R_maxResultBufferPropertyDescription in SQLServerResource, added another string resource (R_maxResultBufferPropertyExceeded) in SQLServerResource", "committedDate": "2020-11-25T11:14:54Z", "type": "commit"}]}