{"pr_number": 1331, "pr_title": "Extended bulk copy support for Azure DW", "pr_createdAt": "2020-05-07T21:45:02Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1331", "timeline": [{"oid": "938499230ebc019f1ebcc8216043b5ff862de515", "url": "https://github.com/microsoft/mssql-jdbc/commit/938499230ebc019f1ebcc8216043b5ff862de515", "message": "first commit", "committedDate": "2020-05-07T04:31:59Z", "type": "commit"}, {"oid": "52ca698c08dc46d51b9f3f50e1bce5bee88aa327", "url": "https://github.com/microsoft/mssql-jdbc/commit/52ca698c08dc46d51b9f3f50e1bce5bee88aa327", "message": "Merge branch 'dev' of https://github.com/Microsoft/mssql-jdbc into bulkCopySupport", "committedDate": "2020-05-07T04:32:07Z", "type": "commit"}, {"oid": "ba4ac41a4826306566681d648eb3ea36954a6a0c", "url": "https://github.com/microsoft/mssql-jdbc/commit/ba4ac41a4826306566681d648eb3ea36954a6a0c", "message": "test changes", "committedDate": "2020-05-07T16:50:48Z", "type": "commit"}, {"oid": "7acedcf44b85a5590f5612d3424b5516dce80c98", "url": "https://github.com/microsoft/mssql-jdbc/commit/7acedcf44b85a5590f5612d3424b5516dce80c98", "message": "more tests", "committedDate": "2020-05-07T19:07:49Z", "type": "commit"}, {"oid": "ddfffcc161402ff52ba0206c118ae9fe5ca50286", "url": "https://github.com/microsoft/mssql-jdbc/commit/ddfffcc161402ff52ba0206c118ae9fe5ca50286", "message": "test changes", "committedDate": "2020-05-07T21:30:44Z", "type": "commit"}, {"oid": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "url": "https://github.com/microsoft/mssql-jdbc/commit/04c498f39f0f8b3bf69dfc42e619b76d03876a03", "message": "test changes", "committedDate": "2020-05-07T21:39:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMTI1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423331251", "bodyText": "Make sure to follow JUnit test name standards.", "author": "ulvii", "createdAt": "2020-05-11T21:29:56Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0NzQ2Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423347466", "bodyText": "Please use multi-line comments. Apply this to all the changes you made.", "author": "ulvii", "createdAt": "2020-05-11T22:06:42Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/DDC.java", "diffHunk": "@@ -323,6 +323,28 @@ static final Object convertDoubleToObject(double doubleVal, JDBCType jdbcType, S\n \n         return valueBytes;\n     }\n+    \n+    static final byte[] convertMoneyToBytes(BigDecimal bigDecimalVal, int bLength) {\n+        byte[] valueBytes = new byte[bLength];\n+        \n+        BigInteger bi = bigDecimalVal.unscaledValue();\n+        \n+        if (bLength == 8) {\n+            // money\n+            byte[] longbArray = new byte[bLength];\n+            Util.writeLong(bi.longValue(), longbArray, 0);\n+            // TDS 2.2.5.5.1.4 Fixed-Point Numbers\n+            // Money is represented as a 8 byte signed integer, with one 4-byte integer that represents", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDExNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354116", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "author": "ulvii", "createdAt": "2020-05-11T22:23:28Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsString.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsString extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            try (ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destTableName);\r\n+                    SQLServerBulkCopy bcOperation = new SQLServerBulkCopy(conn);) {\r\n+                bcOperation.setDestinationTableName(destTableName2);\r\n+                bcOperation.writeToServer(rs);\r\n+            }\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName2, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423354358", "bodyText": "This is assuming insertion order is the same as select order, which is not true. Make sure to have an ID column to be able to order the select result by ID.", "author": "ulvii", "createdAt": "2020-05-11T22:24:06Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAE.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+public class BulkCopySendTemporalDataTypesAsStringAE extends AESetup {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+    static String filePath = null;\r\n+\r\n+    static String destTableNameAE = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTableAE\"));\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, with AE enabled.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyAE() throws SQLException {\r\n+        beforeEachSetupAE();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(AETestConnectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\", AEInfo)) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord, destTableNameAE);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord, String tableName) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(2, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(3, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(4, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(5, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(6, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(7, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(8, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(tableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, tableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    static void validateValuesFromCSV(Statement stmt, String destinationTable, String inputFile) {\r\n+        try (BufferedReader br = new BufferedReader(\r\n+                new InputStreamReader(new FileInputStream(filePath + inputFile), encoding));\r\n+                ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + destinationTable)) {\r", "originalCommit": "04c498f39f0f8b3bf69dfc42e619b76d03876a03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2MjEwMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423962103", "bodyText": "This is still not fixed.", "author": "ulvii", "createdAt": "2020-05-12T18:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNDM5MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424014391", "bodyText": "Why is this not fixed? Doesn't specifying the column names individually guarantee order?", "author": "peterbae", "createdAt": "2020-05-12T20:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNTcwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424015701", "bodyText": "oh never mind, you meant the row order. I'll fix that.", "author": "peterbae", "createdAt": "2020-05-12T20:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMjUwNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424022505", "bodyText": "I have a similar test, you can refer to this PR: #1312", "author": "ulvii", "createdAt": "2020-05-12T20:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQ1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179451", "bodyText": "Thanks, done", "author": "peterbae", "createdAt": "2020-05-13T05:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDM1OA=="}], "type": "inlineReview"}, {"oid": "c167c6abd08a36724137f837b99ee166e7de6265", "url": "https://github.com/microsoft/mssql-jdbc/commit/c167c6abd08a36724137f837b99ee166e7de6265", "message": "review comments", "committedDate": "2020-05-12T01:01:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NDczOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423954739", "bodyText": "Please make javadoc consistent with other methods.", "author": "ulvii", "createdAt": "2020-05-12T18:44:28Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -991,4 +991,19 @@\n      */\n     void setClientKeyPassword(String password);\n \n+    /**", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQzMg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179432", "bodyText": "done", "author": "peterbae", "createdAt": "2020-05-13T05:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NDczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r423975860", "bodyText": "Shouldn't this be destSSType instead?", "author": "ulvii", "createdAt": "2020-05-12T19:20:48Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2122,6 +2163,25 @@ else if (null != sourceCryptoMeta) {\n \n                 case microsoft.sql.Types.MONEY:\n                 case microsoft.sql.Types.SMALLMONEY:\n+                    if (null == colValue) {\n+                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);\n+                    } else {\n+                        /*\n+                         * if the precision that user provides is smaller than the precision of the actual value, the\n+                         * driver assumes the precision that user provides is the correct precision, and throws\n+                         * exception\n+                         */\n+                        if (bulkPrecision < Util.getValueLengthBaseOnJavaType(colValue, JavaType.of(colValue), null,\n+                                null, JDBCType.of(bulkJdbcType))) {\n+                            MessageFormat form = new MessageFormat(\n+                                    SQLServerException.getErrString(\"R_valueOutOfRange\"));\n+                            Object[] msgArgs = {SSType.DECIMAL};", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTQxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424179410", "bodyText": "Sorry, which part of this code should be destSSType?", "author": "peterbae", "createdAt": "2020-05-13T05:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjEyNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424182127", "bodyText": "Actually, I understood. Yes, this should be destSSType instead. I've made similar changes to the decimal/numeric case as well because I think it applies there as well, too.", "author": "peterbae", "createdAt": "2020-05-13T05:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc5Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424054792", "bodyText": "I don't get this part of the changes.  So if destSSType is money and srcJdbcType is decimal, the code will write both DSType.MONEYN.byteValue() and TDSType.DECIMALN.byteValue(). Is this expected?", "author": "ulvii", "createdAt": "2020-05-12T21:51:11Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTQxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424181416", "bodyText": "No, if destSSType is money and srcJdbcType is decimal, the code will only write TDSType.MONEYN.byteValue() and break out of the switch statement.", "author": "peterbae", "createdAt": "2020-05-13T05:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NDMxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424064316", "bodyText": "suggest that we be consistent in how we describe our other sendBlahAsBlah properties, ie \"Determines whether the driver will send...\"", "author": "lilgreenbird", "createdAt": "2020-05-12T22:13:13Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -264,6 +264,8 @@ static String getResource(String key) {\n             {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n             {\"R_clientKeyPasswordPropertyDescription\",\n                     \"Password for private key if the private key is password protected.\"},\n+            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n+                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},", "originalCommit": "c167c6abd08a36724137f837b99ee166e7de6265", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2OTgzMg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424169832", "bodyText": "I don't think my new addition here is inconsistent because other descriptive properties don't follow the \"Determines whether...\" starters either. I think the suggestion is good though.", "author": "peterbae", "createdAt": "2020-05-13T04:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NDMxNg=="}], "type": "inlineReview"}, {"oid": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "url": "https://github.com/microsoft/mssql-jdbc/commit/0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "message": "comments", "committedDate": "2020-05-13T05:34:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTYwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424651601", "bodyText": "why define all these variables they're only used once below", "author": "lilgreenbird", "createdAt": "2020-05-13T18:38:54Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);\n+\n+            String timestampString = stringValue.substring(0, lastColon - 4);\n+            int year = Integer.valueOf(timestampString.substring(0, 4));\n+            int month = Integer.valueOf(timestampString.substring(5, 7));\n+            int day = Integer.valueOf(timestampString.substring(8, 10));\n+            int hour = Integer.valueOf(timestampString.substring(11, 13));\n+            int minute = Integer.valueOf(timestampString.substring(14, 16));\n+            int second = Integer.valueOf(timestampString.substring(17, 19));\n+", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NjE1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796158", "bodyText": "I think it's easier to see this way.", "author": "peterbae", "createdAt": "2020-05-13T23:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424660989", "bodyText": "this test doesn't actually test the datasource settings as updateDataSource hasn't been updated to include the new properties", "author": "lilgreenbird", "createdAt": "2020-05-13T18:54:31Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTcxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426041717", "bodyText": "I think it is testing the datasource, because I'm calling setSendTemporalDataTypesAsStringForBulkCopy instead of using updateDataSource. I just checked as well to make sure it is using the datasource with the connection property set to false.", "author": "peterbae", "createdAt": "2020-05-15T20:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MjgwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426192801", "bodyText": "sorry, you're right you are, as you're calling that explicitly after. But that's not how the other connection properties are handled. And updateDataSource needs to be updated to parse all the connection properties properly", "author": "lilgreenbird", "createdAt": "2020-05-16T21:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5OTYxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428799616", "bodyText": "sure, i'll add that to my tests too then.", "author": "peterbae", "createdAt": "2020-05-21T17:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzI1NA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424663254", "bodyText": "why not just use @beforeeach?", "author": "lilgreenbird", "createdAt": "2020-05-13T18:58:18Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MjMzNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426042334", "bodyText": "Sometimes beforeEach didn't work for me properly, so I just call beforeEachSetup. There shouldn't be any functional differences.", "author": "peterbae", "createdAt": "2020-05-15T20:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDE4MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424694181", "bodyText": "Need to handle indexoutofbounds here in case the input isn't in the format expected.", "author": "rene-ye", "createdAt": "2020-05-13T19:55:28Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTE5Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424795193", "bodyText": "Thanks, done.", "author": "peterbae", "createdAt": "2020-05-13T23:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTA1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424695058", "bodyText": "Doesn't this break if the user's locale isn't US?", "author": "rene-ye", "createdAt": "2020-05-13T19:57:09Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,81 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            String stringValue = (String) value;\n+            int lastColon = stringValue.lastIndexOf(':');\n+\n+            String offsetString = stringValue.substring(lastColon - 3);\n+            minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                    + Integer.valueOf(offsetString.substring(4, 6));\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+            if (offsetString.startsWith(\"-\"))\n+                minutesOffset = -minutesOffset;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+            /*\n+             * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+             * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+             * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+             * use a local time zone determined by the minutes offset of the value, since\n+             * the writers for those types expect local calendars.\n+             */\n+            timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                             : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+            calendar = new GregorianCalendar(timeZone, Locale.US);", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NjA5OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796099", "bodyText": "The locale doesn't matter. It's only used to determine what is the first day of the week (either saturday, sunday or monday) but that function isn't being used here, so I just put US locale (but anything works)", "author": "peterbae", "createdAt": "2020-05-13T23:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NzcyNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424697727", "bodyText": "byte byteType = (java.sql.Types.DECIMAL == srcJdbcType) ? TDSType.DECIMALN.byteValue() : TDSType.NUMERICN.byteValue();\ntdsWriter.writeByte(byteType);\nChange if block to above to shorten the code and make it more clear.", "author": "rene-ye", "createdAt": "2020-05-13T20:02:02Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -919,23 +919,37 @@ private void writeTypeInfo(TDSWriter tdsWriter, int srcJdbcType, int srcScale, i\n \n             case microsoft.sql.Types.MONEY:\n             case microsoft.sql.Types.SMALLMONEY:\n+                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n+                if (SSType.MONEY == destSSType)\n+                    tdsWriter.writeByte((byte) 8);\n+                else\n+                    tdsWriter.writeByte((byte) 4);\n+                break;\n             case java.sql.Types.NUMERIC:\n             case java.sql.Types.DECIMAL:\n-                if (isBaseType && ((SSType.MONEY == destSSType) || (SSType.SMALLMONEY == destSSType))) {\n-                    tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E\n-                    if (SSType.MONEY == destSSType)\n-                        tdsWriter.writeByte((byte) 8);\n-                    else\n-                        tdsWriter.writeByte((byte) 4);\n-                } else {\n-                    if (java.sql.Types.DECIMAL == srcJdbcType)\n-                        tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n-                    else\n-                        tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C\n-                    tdsWriter.writeByte((byte) TDSWriter.BIGDECIMAL_MAX_LENGTH); // maximum length\n-                    tdsWriter.writeByte((byte) srcPrecision); // unsigned byte\n-                    tdsWriter.writeByte((byte) srcScale); // unsigned byte\n+                /*\n+                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column,\n+                 * but Azure DW only accepts money types for money column.\n+                 * To make the code compatible against both SQL Server and Azure DW, always send decimal and\n+                 * numeric as money/smallmoney if the destination column is money/smallmoney\n+                 * and the source is decimal/numeric.\n+                 */\n+                if (destSSType == SSType.MONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 8);\n+                    break;\n+                } else if (destSSType == SSType.SMALLMONEY) {\n+                    tdsWriter.writeByte(TDSType.MONEYN.byteValue());\n+                    tdsWriter.writeByte((byte) 4);\n+                    break;\n                 }\n+                if (java.sql.Types.DECIMAL == srcJdbcType)\n+                    tdsWriter.writeByte(TDSType.DECIMALN.byteValue()); // 0x6A\n+                else\n+                    tdsWriter.writeByte(TDSType.NUMERICN.byteValue()); // 0x6C", "originalCommit": "0f53c2674f958cf92447bcf1d8567ec5ca8fda76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5Njk1Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r424796957", "bodyText": "done", "author": "peterbae", "createdAt": "2020-05-13T23:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NzcyNw=="}], "type": "inlineReview"}, {"oid": "f4ca3c0f14588634843fdd18d8033e8c71d911f1", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4ca3c0f14588634843fdd18d8033e8c71d911f1", "message": "destSSType", "committedDate": "2020-05-13T23:39:29Z", "type": "commit"}, {"oid": "42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "url": "https://github.com/microsoft/mssql-jdbc/commit/42c013ffbf51db58b1dbc9ab870dbed5f4270dc1", "message": "check for failure", "committedDate": "2020-05-13T23:56:32Z", "type": "commit"}, {"oid": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "url": "https://github.com/microsoft/mssql-jdbc/commit/90fae3649819fe2fab94cd227d2c7ae05711ab14", "message": "shorten if statement", "committedDate": "2020-05-13T23:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3MjI3Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r425972272", "bodyText": "Please add a comment which contains the format you are parsing.", "author": "ulvii", "createdAt": "2020-05-15T18:20:26Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,87 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            try {\n+                String stringValue = (String) value;", "originalCommit": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1OTkzNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426059937", "bodyText": "done.", "author": "peterbae", "createdAt": "2020-05-15T21:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3MjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426052947", "bodyText": "The test fails when I switch to:\nfileRecord.addColumnMetadata(7, \"c6\", microsoft.sql.Types.SMALLDATETIME, 0, 0); // with SmallDatetime", "author": "ulvii", "createdAt": "2020-05-15T21:21:28Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/bulkCopy/BulkCopySendTemporalDataTypesAsStringTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.bulkCopy;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileInputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+import java.util.Arrays;\r\n+\r\n+import org.junit.jupiter.api.AfterAll;\r\n+import org.junit.jupiter.api.BeforeAll;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.ComparisonUtil;\r\n+import com.microsoft.sqlserver.jdbc.RandomUtil;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerBulkCopy;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractSQLGenerator;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Test connection property sendTemporalDataTypesAsStringForBulkCopy\r\n+ * This connection string, when set to FALSE, will send DATE, DATETIME, DATIMETIME2 DATETIMEOFFSET, SMALLDATETIME, and\r\n+ * TIME\r\n+ * datatypes as their respective types instead of sending them as String.\r\n+ * Additionally, even without setting this connection string to FALSE, MONEY and SMALLMONEY datatypes will be\r\n+ * sent as MONEY / SMALLMONEY datatypes instead of DECIMAL after these changes.\r\n+ * \r\n+ * Note that with this connection property set to FALSE, the driver will only accept the default string literal format\r\n+ * of each temporal datatype, for example:\r\n+ * \r\n+ * DATE: YYYY-MM-DD\r\n+ * DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]\r\n+ * DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]\r\n+ * DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\r\n+ * SMALLDATETIME:YYYY-MM-DD hh:mm:ss\r\n+ * TIME: hh:mm:ss[.nnnnnnn]\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+public class BulkCopySendTemporalDataTypesAsStringTest extends AbstractTest {\r\n+    static String inputFile = \"BulkCopyCSVSendTemporalDataTypesAsStringForBulkCopy.csv\";\r\n+    static String encoding = \"UTF-8\";\r\n+    static String delimiter = \",\";\r\n+\r\n+    static String destTableName = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable\"));\r\n+    static String destTableName2 = AbstractSQLGenerator\r\n+            .escapeIdentifier(RandomUtil.getIdentifier(\"sendTemporalDataTypesAsStringForBulkCopyDestTable2\"));\r\n+    static String filePath = null;\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopy() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a resultset.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyRS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        try (Connection conn = PrepUtil\r\n+                .getConnection(connectionString + \";sendTemporalDataTypesAsStringForBulkCopy=false\")) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyResultSet(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test basic case with sendTemporalDataTypesAsStringForBulkCopy connection property, using a data source.\r\n+     * \r\n+     * @throws SQLException\r\n+     */\r\n+    @Test\r\n+    public void testSendTemporalDataTypesAsStringForBulkCopyDS() throws SQLException {\r\n+        beforeEachSetup();\r\n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\r\n+        dsLocal.setSendTemporalDataTypesAsStringForBulkCopy(false);\r\n+\r\n+        try (Connection conn = dsLocal.getConnection()) {\r\n+            SQLServerBulkCSVFileRecord fileRecord = new SQLServerBulkCSVFileRecord(filePath + inputFile, encoding,\r\n+                    delimiter, true);\r\n+\r\n+            testBulkCopyCSV(conn, fileRecord);\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyCSV(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r\n+            fileRecord.addColumnMetadata(8, \"c7\", java.sql.Types.DECIMAL, 19, 4); // with money\r\n+            fileRecord.addColumnMetadata(9, \"c8\", java.sql.Types.DECIMAL, 10, 4); // with smallmoney\r\n+\r\n+            bulkCopy.setDestinationTableName(destTableName);\r\n+            bulkCopy.writeToServer(fileRecord);\r\n+\r\n+            validateValuesFromCSV(stmt, destTableName, inputFile);\r\n+        } catch (Exception e) {\r\n+            fail(e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    private void testBulkCopyResultSet(Connection conn, SQLServerBulkCSVFileRecord fileRecord) {\r\n+        try (SQLServerBulkCopy bulkCopy = new SQLServerBulkCopy(conn); Statement stmt = conn.createStatement()) {\r\n+\r\n+            fileRecord.addColumnMetadata(1, \"id\", java.sql.Types.INTEGER, 0, 0);\r\n+            fileRecord.addColumnMetadata(2, \"c1\", java.sql.Types.DATE, 0, 0); // with Date\r\n+            fileRecord.addColumnMetadata(3, \"c2\", java.sql.Types.TIMESTAMP, 0, 0); // with Datetime\r\n+            fileRecord.addColumnMetadata(4, \"c3\", java.sql.Types.TIMESTAMP, 0, 7); // with Datetime2\r\n+            fileRecord.addColumnMetadata(5, \"c4\", java.sql.Types.TIME, 0, 7); // with time\r\n+            fileRecord.addColumnMetadata(6, \"c5\", microsoft.sql.Types.DATETIMEOFFSET, 0, 7); // with datetimeoffset\r\n+            fileRecord.addColumnMetadata(7, \"c6\", java.sql.Types.TIMESTAMP, 0, 0); // with SmallDatetime\r", "originalCommit": "90fae3649819fe2fab94cd227d2c7ae05711ab14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTgxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426061817", "bodyText": "It's supposed to fail. When performing bulk copy, the users are expected to provide the correct column type. The corresponding column type for smalldatetime is TIMESTAMP, and microsoft.sql.Types.SMALLDATETIME is not a supported column type. If you were to test that scenario without my changes, it will fail as well. The table that outlines which datatypes need to be specified for each datatype for bulk copy is outlined here: https://docs.microsoft.com/en-us/sql/connect/jdbc/using-basic-data-types?view=sql-server-2017", "author": "peterbae", "createdAt": "2020-05-15T21:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMDAwNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428910007", "bodyText": "Understood.", "author": "ulvii", "createdAt": "2020-05-21T20:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1Mjk0Nw=="}], "type": "inlineReview"}, {"oid": "3341bcbbb335812e5c648860d6831016112aaf5f", "url": "https://github.com/microsoft/mssql-jdbc/commit/3341bcbbb335812e5c648860d6831016112aaf5f", "message": "add comment / add test cases", "committedDate": "2020-05-15T21:41:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTEzMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426061130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            calendar = new GregorianCalendar(timeZone, Locale.CHINA);\n          \n          \n            \n                            calendar = new GregorianCalendar(timeZone);", "author": "ulvii", "createdAt": "2020-05-15T21:45:43Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {\n+            // expected format: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|-}hh:mm]\n+            try {\n+                String stringValue = (String) value;\n+                int lastColon = stringValue.lastIndexOf(':');\n+\n+                String offsetString = stringValue.substring(lastColon - 3);\n \n-        // If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n-        // will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n-        // Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n-        // use a local time zone determined by the minutes offset of the value, since\n-        // the writers for those types expect local calendars.\n-        timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n-                                                         : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+                /*\n+                 * At this point, offsetString should look like +hh:mm or -hh:mm. Otherwise, the optional offset\n+                 * value has not been provided. Parse accordingly.\n+                 */\n+                String timestampString;\n \n-        calendar = new GregorianCalendar(timeZone, Locale.US);\n-        calendar.setLenient(true);\n-        calendar.clear();\n-        calendar.setTimeInMillis(utcMillis);\n+                if (!offsetString.startsWith(\"+\") && !offsetString.startsWith(\"-\")) {\n+                    minutesOffset = 0;\n+                    timestampString = stringValue;\n+                } else {\n+                    minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))\n+                            + Integer.valueOf(offsetString.substring(4, 6));\n+                    timestampString = stringValue.substring(0, lastColon - 4);\n+\n+                    if (offsetString.startsWith(\"-\"))\n+                        minutesOffset = -minutesOffset;\n+                }\n+\n+                /*\n+                 * If the target data type is DATETIMEOFFSET, then use UTC for the calendar that\n+                 * will hold the value, since writeRPCDateTimeOffset expects a UTC calendar.\n+                 * Otherwise, when converting from DATETIMEOFFSET to other temporal data types,\n+                 * use a local time zone determined by the minutes offset of the value, since\n+                 * the writers for those types expect local calendars.\n+                 */\n+                timeZone = (SSType.DATETIMEOFFSET == destSSType) ? UTC.timeZone\n+                                                                 : new SimpleTimeZone(minutesOffset * 60 * 1000, \"\");\n+\n+                calendar = new GregorianCalendar(timeZone, Locale.CHINA);", "originalCommit": "3341bcbbb335812e5c648860d6831016112aaf5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ccf8b26fc83c212d84a1b93b03c09bf2e946c907", "url": "https://github.com/microsoft/mssql-jdbc/commit/ccf8b26fc83c212d84a1b93b03c09bf2e946c907", "message": "Update src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n\nCo-authored-by: ulvii <v-ulibra@microsoft.com>", "committedDate": "2020-05-15T21:49:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjY1MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426062650", "bodyText": "Can you explain this with code comments? Also why do we have to parse for TIME, not for other types?", "author": "ulvii", "createdAt": "2020-05-15T21:50:51Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,20 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "originalCommit": "3341bcbbb335812e5c648860d6831016112aaf5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2Njk0Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r426066942", "bodyText": "I added comments. Other datatypes are already handled as if the data was string (this is the case for date, datetime and smalldatetime), so there was no need for extra steps. Time was the only datatype (other than DTO) that the code was assuming was coming on the form of a timestamp, so I needed to adjust accordingly.", "author": "peterbae", "createdAt": "2020-05-15T22:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjY1MA=="}], "type": "inlineReview"}, {"oid": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "url": "https://github.com/microsoft/mssql-jdbc/commit/c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "message": "add comments", "committedDate": "2020-05-15T22:01:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODUwNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427578505", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "author": "ulvii", "createdAt": "2020-05-19T20:25:59Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -3574,27 +3596,100 @@ void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {\n     void writeDateTimeOffset(Object value, int scale, SSType destSSType) throws SQLServerException {\n         GregorianCalendar calendar;\n         TimeZone timeZone; // Time zone to associate with the value in the Gregorian calendar\n-        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)\n         int subSecondNanos;\n         int minutesOffset;\n \n-        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;\n-        utcMillis = dtoValue.getTimestamp().getTime();\n-        subSecondNanos = dtoValue.getTimestamp().getNanos();\n-        minutesOffset = dtoValue.getMinutesOffset();\n+        /*\n+         * Out of all the supported temporal datatypes, DateTimeOffset is the only datatype that doesn't\n+         * allow direct casting from java.sql.timestamp (which was created from a String).\n+         * DateTimeOffset was never required to be constructed from a String, but with the\n+         * introduction of extended bulk copy support for Azure DW, we now need to support this scenario.\n+         * Parse the DTO as string if it's coming from a CSV.\n+         */\n+        if (value instanceof String) {", "originalCommit": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzQ0Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428303442", "bodyText": "The check is done before this method is called. Checking for String guarantees that that connection property is set to false, and also that the data is coming from a CSV. Near the beginning of writeColumnToTdsWriter method in SQLServerBulkCopy, this line:\n       } else if (null != serverBulkData && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {\nensures that if getSendTemporalDataTypesAsStringForBulkCopy is true then bulkJdbcType will be varchar, which means that if getSendTemporalDataTypesAsStringForBulkCopy is false, we couldn't have come to this line.", "author": "peterbae", "createdAt": "2020-05-20T20:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3OTExMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427579113", "bodyText": "Need to check for connection.getSendTemporalDataTypesAsStringForBulkCopy() here too.", "author": "ulvii", "createdAt": "2020-05-19T20:27:12Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java", "diffHunk": "@@ -2397,8 +2468,30 @@ else if (4 >= bulkScale)\n                             tdsWriter.writeByte((byte) 0x04);\n                         else\n                             tdsWriter.writeByte((byte) 0x05);\n-\n-                        tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);\n+                        if (colValue instanceof String) {", "originalCommit": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzgyOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428303828", "bodyText": "Same logic applies here, but these are really good observations / questions.", "author": "peterbae", "createdAt": "2020-05-20T20:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3OTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r427618853", "bodyText": "Please format all the files.", "author": "ulvii", "createdAt": "2020-05-19T21:45:38Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/BulkCopySendTemporalDataTypesAsStringAETest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r", "originalCommit": "c58d6589fa1502fb99cf30f1ba0aa0a3419ee3b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjIwMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428306201", "bodyText": "This file is formatted. Do you see something that should've been formatted? My formatter doesn't change anything in this file.", "author": "peterbae", "createdAt": "2020-05-20T21:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMzMDU3MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428330571", "bodyText": "The comments seem to be off.", "author": "ulvii", "createdAt": "2020-05-20T21:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODMwNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1331#discussion_r428868305", "bodyText": "Which comment for example?", "author": "peterbae", "createdAt": "2020-05-21T19:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODg1Mw=="}], "type": "inlineReview"}, {"oid": "e2e3d031c439318848d39fefcbf497740f1dab8b", "url": "https://github.com/microsoft/mssql-jdbc/commit/e2e3d031c439318848d39fefcbf497740f1dab8b", "message": "update abstractTest", "committedDate": "2020-05-21T19:33:53Z", "type": "commit"}, {"oid": "b49865f8d5732a7bff83789939bf5edcd8395f5c", "url": "https://github.com/microsoft/mssql-jdbc/commit/b49865f8d5732a7bff83789939bf5edcd8395f5c", "message": "test modifications", "committedDate": "2020-05-21T21:42:34Z", "type": "commit"}]}