{"pr_number": 1400, "pr_title": "issue #1352 - introduce fhir-smart component", "pr_createdAt": "2020-08-04T15:22:55Z", "pr_url": "https://github.com/IBM/FHIR/pull/1400", "timeline": [{"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "url": "https://github.com/IBM/FHIR/commit/232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T15:24:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzU5Ng==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465137596", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-08-04T15:29:23Z", "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;", "originalCommit": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NzM5OA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465147398", "bodyText": "fixed", "author": "lmsurpre", "createdAt": "2020-08-04T15:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465137758", "bodyText": "Negative test too?", "author": "prb112", "createdAt": "2020-08-04T15:29:36Z", "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.smart.AuthzPolicyEnforcementPersistenceInterceptor;\n+\n+public class AuthzPolicyBackupEnforcementTest {\n+    AuthzPolicyEnforcementPersistenceInterceptor interceptor;\n+    Patient patient;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        interceptor = new AuthzPolicyEnforcementPersistenceInterceptor();\n+\n+        patient = TestUtil.readExampleResource(\"json/ibm/minimal/Patient-1.json\");\n+        patient = patient.toBuilder()\n+                .id(\"11111111-1111-1111-1111-111111111111\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testUserInfoHeader() throws Exception {", "originalCommit": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTU5OA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465149598", "bodyText": "yes, needs much more comprehensive tests in general I think", "author": "lmsurpre", "createdAt": "2020-08-04T15:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2MDQ2Nw==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465160467", "bodyText": "No problem - is this coming in a separate issue? Should we track an issue for it?", "author": "prb112", "createdAt": "2020-08-04T16:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzMTA0OA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465231048", "bodyText": "I just posted another commit here...can you please have a look?", "author": "lmsurpre", "createdAt": "2020-08-04T18:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDA5OA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465140098", "bodyText": "Given John's issues with streams, how does this perform?", "author": "prb112", "createdAt": "2020-08-04T15:32:52Z", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));", "originalCommit": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0ODIwNg==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465148206", "bodyText": "there will typically only be one or two scope strings in the JWT, so I'm really not worried about it", "author": "lmsurpre", "createdAt": "2020-08-04T15:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDY2NQ==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465140665", "bodyText": "FHIRSearchException... shouldn't this be an operation exception?", "author": "prb112", "createdAt": "2020-08-04T15:33:43Z", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {", "originalCommit": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NDE3Mg==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465154172", "bodyText": "this is whats thrown from CompartmentUtil.getCompartmentResourceTypeInclusionCriteria.  Potentially that could get refactored to throw something else, but I think its beyond the scope of this PR.  Please re-open if you disagree.", "author": "lmsurpre", "createdAt": "2020-08-04T15:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2MTQyNA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465161424", "bodyText": "this was more of a confirmation question.", "author": "prb112", "createdAt": "2020-08-04T16:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MTc2OA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465141768", "bodyText": "interesting check...", "author": "prb112", "createdAt": "2020-08-04T15:35:15Z", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");", "originalCommit": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NDYyMA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465154620", "bodyText": "just trying to be defensive there, not attached to it.  re-open if you think it should be changed.", "author": "lmsurpre", "createdAt": "2020-08-04T15:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MzQ3MA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465143470", "bodyText": "small set may be best to have a for loop.... same performance question", "author": "prb112", "createdAt": "2020-08-04T15:37:39Z", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());", "originalCommit": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDY1MA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465150650", "bodyText": "same response.  can change if needed, but I think its fine.", "author": "lmsurpre", "createdAt": "2020-08-04T15:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MzQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0Mzg4NQ==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465143885", "bodyText": "Are you anticipating more than one id?", "author": "prb112", "createdAt": "2020-08-04T15:38:16Z", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<String> getPatientIdFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"patient_id\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'patient_id' claim\");\n+        }\n+\n+        String patientId = claim.asString();\n+        if (patientId == null) {\n+            log.fine(\"Found patient_id claim was expected to be a string but is not; processing as a list\");\n+            return claim.asList(String.class);\n+        }\n+\n+        return Collections.singletonList(patientId);\n+    }", "originalCommit": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MTE1MA==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465151150", "bodyText": "Wanted to leave the door open for it, but could refactor to assume a single patientId is in-scope if desired.", "author": "lmsurpre", "createdAt": "2020-08-04T15:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0Mzg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1OTk4OQ==", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465159989", "bodyText": "No refactoring. This was a question given the multiple potential ids.", "author": "prb112", "createdAt": "2020-08-04T16:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0Mzg4NQ=="}], "type": "inlineReview"}, {"oid": "0871ded135dbfb16c71181c9381dec5ff746f63f", "url": "https://github.com/IBM/FHIR/commit/0871ded135dbfb16c71181c9381dec5ff746f63f", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T15:39:03Z", "type": "forcePushed"}, {"oid": "d0732a4f1f0c2ae50eb4a3a8c3eed867580dc51b", "url": "https://github.com/IBM/FHIR/commit/d0732a4f1f0c2ae50eb4a3a8c3eed867580dc51b", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T15:56:29Z", "type": "forcePushed"}, {"oid": "4fae3518085bfb79f24ec7276bd7b8003faeacc4", "url": "https://github.com/IBM/FHIR/commit/4fae3518085bfb79f24ec7276bd7b8003faeacc4", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T16:25:28Z", "type": "forcePushed"}, {"oid": "54d51ecb6515313278ed23cd9e68548aabe88609", "url": "https://github.com/IBM/FHIR/commit/54d51ecb6515313278ed23cd9e68548aabe88609", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T16:28:45Z", "type": "commit"}, {"oid": "54d51ecb6515313278ed23cd9e68548aabe88609", "url": "https://github.com/IBM/FHIR/commit/54d51ecb6515313278ed23cd9e68548aabe88609", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T16:28:45Z", "type": "forcePushed"}, {"oid": "5e6a838d9583189dea3c323cafe73890f620adad", "url": "https://github.com/IBM/FHIR/commit/5e6a838d9583189dea3c323cafe73890f620adad", "message": "issue #1352 - introduce parameterization for testing scopestring combos\n\nAlso fixed a NullPointerException found in FHIRConfigHelper when there\nis no tenantId present.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T18:06:54Z", "type": "commit"}, {"oid": "5e6a838d9583189dea3c323cafe73890f620adad", "url": "https://github.com/IBM/FHIR/commit/5e6a838d9583189dea3c323cafe73890f620adad", "message": "issue #1352 - introduce parameterization for testing scopestring combos\n\nAlso fixed a NullPointerException found in FHIRConfigHelper when there\nis no tenantId present.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-08-04T18:06:54Z", "type": "forcePushed"}]}