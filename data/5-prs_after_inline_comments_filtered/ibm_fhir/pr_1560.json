{"pr_number": 1560, "pr_title": "Issue #1504 - properly process local references in transaction bundles", "pr_createdAt": "2020-10-06T19:33:34Z", "pr_url": "https://github.com/IBM/FHIR/pull/1560", "timeline": [{"oid": "1e6123e2644bcc2d90b67321fd338bd893b11183", "url": "https://github.com/IBM/FHIR/commit/1e6123e2644bcc2d90b67321fd338bd893b11183", "message": "Issue #1504 - properly process local references in transaction bundles\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-10-06T19:31:38Z", "type": "commit"}, {"oid": "e04a4fd0571f5b706195d60592174d89aa19ed69", "url": "https://github.com/IBM/FHIR/commit/e04a4fd0571f5b706195d60592174d89aa19ed69", "message": "Issue #1504 - correct issues with failing testcases\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-10-07T02:23:32Z", "type": "commit"}, {"oid": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "url": "https://github.com/IBM/FHIR/commit/008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "message": "Issue #1504 - update local reference processing documentation\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-10-07T15:33:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MDc3MQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503260771", "bodyText": "there was strange logic there, generally when I see that I wonder why there were two, is newResource ever null? was the first check in case newResource was null?", "author": "prb112", "createdAt": "2020-10-12T12:28:05Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -326,8 +324,8 @@ private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPa\n                     ior.setPrevResource(null);\n \n                     // if no id provided, then generate an id for the input resource\n-                    if (newResource.getId() == null || newResource.getId() == null) {\n-                        id = UUID.randomUUID().toString();\n+                    if (newResource.getId() == null) {", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NTkxOA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503495918", "bodyText": "newResource should not be null at this point - it's checked during bundle validation (or resource validation if request is not a bundle request)", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MTEzOA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503261138", "bodyText": "I wonder if the method name should be generateResourceId() or some such to make it more clear that its no a logical id for the FHIRPersistence object but instead is used to generate resource ids.", "author": "lmsurpre", "createdAt": "2020-10-12T12:28:49Z", "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/FHIRPersistence.java", "diffHunk": "@@ -130,4 +132,13 @@\n     default boolean isDeleteSupported() {\n         return false;\n     }\n+\n+    /**\n+     * Generates a logical identity.\n+     * \n+     * @return logical identity\n+     */\n+    default String getLogicalId() {", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NjA3OA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503496078", "bodyText": "I renamed to generateResourceId()", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MTEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MTkxOQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503261919", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        HashMap<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();\n          \n          \n            \n                        Map<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();\n          \n      \n    \n    \n  \n\nShouldn't the interface be sufficient here?", "author": "prb112", "createdAt": "2020-10-12T12:30:13Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -1512,432 +1526,477 @@ private Bundle processBundleEntries(Bundle requestBundle, Bundle responseBundle,\n      *            the bundle containing the corresponding response entries\n      * @param httpMethod\n      *            the HTTP method (GET, POST, PUT, etc.) to be processed\n+     * @param failFast\n+     *            a boolean value indicating if processing should stop on first failure \n+     * @param localRefMap\n+     *            the map of local references to external references\n+     * @param bundleRequestProperties\n+     *            the bundle request properties\n+     * @param bundleRequestCorrelationId\n+     *            the bundle request correlation ID\n+     * @return\n+     *            the response bundle\n+     * @throws Exception\n      */\n     private Bundle processEntriesForMethod(Bundle requestBundle, Bundle responseBundle,\n-            HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n-            Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n-            throws Exception {\n-        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\n-                \"httpMethod\", httpMethod });\n+        HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n+        Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\"httpMethod\", httpMethod });\n+        \n         try {\n-            // First, obtain a list of request entry indices for the entries that we'll process.\n-            // This list will contain the indices associated with only the entries for the specified http method.\n-            List<Integer> entryIndices =\n-                    getBundleRequestIndicesForMethod(requestBundle, responseBundle, httpMethod);\n-            if (log.isLoggable(Level.FINER)) {\n-                log.finer(\"Bundle request indices to be processed: \" + entryIndices.toString());\n-            }\n-\n-            // Next, for PUT (update) requests, extract any local identifiers and resolve them ahead of time.\n-            // We do this to prevent any local reference problems from occurring due to our re-ordering\n-            // of the PUT request entries.\n-            if (httpMethod.equals(HTTPVerb.PUT)) {\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Pre-processing bundle request entries for PUT method...\");\n-                }\n-                for (Integer index : entryIndices) {\n-                    Bundle.Entry requestEntry = requestBundle.getEntry().get(index);\n-\n-                    // Retrieve the local identifier from the request entry (if present).\n-                    String localIdentifier = retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                    // Since this is for a PUT request (update) we should be able to resolve the local identifier\n-                    // prior to processing the request since the resource's id must already be contained in the resource\n-                    // within the request entry.\n-                    if (localIdentifier != null) {\n-                        Resource resource = requestEntry.getResource();\n-                        addLocalRefMapping(localRefMap, localIdentifier, resource);\n-                    }\n-                }\n-            }\n-\n-            // Next, for PUT and DELETE requests, we need to sort the indices by the request url path value.\n-            if (httpMethod.equals(HTTPVerb.PUT) || httpMethod.equals(HTTPVerb.DELETE)) {\n-                sortBundleRequestEntries(requestBundle, entryIndices);\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Sorted bundle request indices to be processed: \"\n-                            + entryIndices.toString());\n-                }\n-            }\n-\n-            // Now visit each of the request entries using the list of indices obtained above.\n-            // Use hashmap to store both the index and the according updated response bundle entry.\n-            HashMap<Integer, Bundle.Entry> responseIndexAndEntries =\n-                    new HashMap<Integer, Bundle.Entry>();\n-            for (Integer entryIndex : entryIndices) {\n+            // Visit each of the request entries, processing those with the specified request method.\n+            // Use hashmap to store both the index and the accordingly updated response bundle entry.\n+            HashMap<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NjIwMg==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503496202", "bodyText": "yes, fixed", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MjU2OQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503262569", "bodyText": "try using Entry<Integer,Bundle.Entry> entry : responseIndexAndEntries.entrySet() \nIt'll save the subsequent update", "author": "prb112", "createdAt": "2020-10-12T12:31:20Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -1512,432 +1526,477 @@ private Bundle processBundleEntries(Bundle requestBundle, Bundle responseBundle,\n      *            the bundle containing the corresponding response entries\n      * @param httpMethod\n      *            the HTTP method (GET, POST, PUT, etc.) to be processed\n+     * @param failFast\n+     *            a boolean value indicating if processing should stop on first failure \n+     * @param localRefMap\n+     *            the map of local references to external references\n+     * @param bundleRequestProperties\n+     *            the bundle request properties\n+     * @param bundleRequestCorrelationId\n+     *            the bundle request correlation ID\n+     * @return\n+     *            the response bundle\n+     * @throws Exception\n      */\n     private Bundle processEntriesForMethod(Bundle requestBundle, Bundle responseBundle,\n-            HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n-            Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n-            throws Exception {\n-        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\n-                \"httpMethod\", httpMethod });\n+        HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n+        Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\"httpMethod\", httpMethod });\n+        \n         try {\n-            // First, obtain a list of request entry indices for the entries that we'll process.\n-            // This list will contain the indices associated with only the entries for the specified http method.\n-            List<Integer> entryIndices =\n-                    getBundleRequestIndicesForMethod(requestBundle, responseBundle, httpMethod);\n-            if (log.isLoggable(Level.FINER)) {\n-                log.finer(\"Bundle request indices to be processed: \" + entryIndices.toString());\n-            }\n-\n-            // Next, for PUT (update) requests, extract any local identifiers and resolve them ahead of time.\n-            // We do this to prevent any local reference problems from occurring due to our re-ordering\n-            // of the PUT request entries.\n-            if (httpMethod.equals(HTTPVerb.PUT)) {\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Pre-processing bundle request entries for PUT method...\");\n-                }\n-                for (Integer index : entryIndices) {\n-                    Bundle.Entry requestEntry = requestBundle.getEntry().get(index);\n-\n-                    // Retrieve the local identifier from the request entry (if present).\n-                    String localIdentifier = retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                    // Since this is for a PUT request (update) we should be able to resolve the local identifier\n-                    // prior to processing the request since the resource's id must already be contained in the resource\n-                    // within the request entry.\n-                    if (localIdentifier != null) {\n-                        Resource resource = requestEntry.getResource();\n-                        addLocalRefMapping(localRefMap, localIdentifier, resource);\n-                    }\n-                }\n-            }\n-\n-            // Next, for PUT and DELETE requests, we need to sort the indices by the request url path value.\n-            if (httpMethod.equals(HTTPVerb.PUT) || httpMethod.equals(HTTPVerb.DELETE)) {\n-                sortBundleRequestEntries(requestBundle, entryIndices);\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Sorted bundle request indices to be processed: \"\n-                            + entryIndices.toString());\n-                }\n-            }\n-\n-            // Now visit each of the request entries using the list of indices obtained above.\n-            // Use hashmap to store both the index and the according updated response bundle entry.\n-            HashMap<Integer, Bundle.Entry> responseIndexAndEntries =\n-                    new HashMap<Integer, Bundle.Entry>();\n-            for (Integer entryIndex : entryIndices) {\n+            // Visit each of the request entries, processing those with the specified request method.\n+            // Use hashmap to store both the index and the accordingly updated response bundle entry.\n+            HashMap<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();\n+            for (int entryIndex=0; entryIndex<requestBundle.getEntry().size(); ++entryIndex) {", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5Njg5MQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503496891", "bodyText": "In this case, I'm looping through the requestBundle, not the responseIndexAndEntries hashmap. I used this form of the for loop because I also need to get the corresponding entry in the responseBundle.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MjU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzM2NQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503263365", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        log.finer(\"--> path: \" + requestURL.getPath());\n          \n          \n            \n                                        log.finer(\"--> path: '\" + requestURL.getPath() + \"'\");", "author": "prb112", "createdAt": "2020-10-12T12:32:49Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -1512,432 +1526,477 @@ private Bundle processBundleEntries(Bundle requestBundle, Bundle responseBundle,\n      *            the bundle containing the corresponding response entries\n      * @param httpMethod\n      *            the HTTP method (GET, POST, PUT, etc.) to be processed\n+     * @param failFast\n+     *            a boolean value indicating if processing should stop on first failure \n+     * @param localRefMap\n+     *            the map of local references to external references\n+     * @param bundleRequestProperties\n+     *            the bundle request properties\n+     * @param bundleRequestCorrelationId\n+     *            the bundle request correlation ID\n+     * @return\n+     *            the response bundle\n+     * @throws Exception\n      */\n     private Bundle processEntriesForMethod(Bundle requestBundle, Bundle responseBundle,\n-            HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n-            Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n-            throws Exception {\n-        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\n-                \"httpMethod\", httpMethod });\n+        HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n+        Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\"httpMethod\", httpMethod });\n+        \n         try {\n-            // First, obtain a list of request entry indices for the entries that we'll process.\n-            // This list will contain the indices associated with only the entries for the specified http method.\n-            List<Integer> entryIndices =\n-                    getBundleRequestIndicesForMethod(requestBundle, responseBundle, httpMethod);\n-            if (log.isLoggable(Level.FINER)) {\n-                log.finer(\"Bundle request indices to be processed: \" + entryIndices.toString());\n-            }\n-\n-            // Next, for PUT (update) requests, extract any local identifiers and resolve them ahead of time.\n-            // We do this to prevent any local reference problems from occurring due to our re-ordering\n-            // of the PUT request entries.\n-            if (httpMethod.equals(HTTPVerb.PUT)) {\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Pre-processing bundle request entries for PUT method...\");\n-                }\n-                for (Integer index : entryIndices) {\n-                    Bundle.Entry requestEntry = requestBundle.getEntry().get(index);\n-\n-                    // Retrieve the local identifier from the request entry (if present).\n-                    String localIdentifier = retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                    // Since this is for a PUT request (update) we should be able to resolve the local identifier\n-                    // prior to processing the request since the resource's id must already be contained in the resource\n-                    // within the request entry.\n-                    if (localIdentifier != null) {\n-                        Resource resource = requestEntry.getResource();\n-                        addLocalRefMapping(localRefMap, localIdentifier, resource);\n-                    }\n-                }\n-            }\n-\n-            // Next, for PUT and DELETE requests, we need to sort the indices by the request url path value.\n-            if (httpMethod.equals(HTTPVerb.PUT) || httpMethod.equals(HTTPVerb.DELETE)) {\n-                sortBundleRequestEntries(requestBundle, entryIndices);\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Sorted bundle request indices to be processed: \"\n-                            + entryIndices.toString());\n-                }\n-            }\n-\n-            // Now visit each of the request entries using the list of indices obtained above.\n-            // Use hashmap to store both the index and the according updated response bundle entry.\n-            HashMap<Integer, Bundle.Entry> responseIndexAndEntries =\n-                    new HashMap<Integer, Bundle.Entry>();\n-            for (Integer entryIndex : entryIndices) {\n+            // Visit each of the request entries, processing those with the specified request method.\n+            // Use hashmap to store both the index and the accordingly updated response bundle entry.\n+            HashMap<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();\n+            for (int entryIndex=0; entryIndex<requestBundle.getEntry().size(); ++entryIndex) {\n                 Bundle.Entry requestEntry = requestBundle.getEntry().get(entryIndex);\n-                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n-                Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n-\n                 Bundle.Entry.Request request = requestEntry.getRequest();\n+                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n                 Bundle.Entry.Response response = responseEntry.getResponse();\n+                if (response.getStatus().equals(string(Integer.toString(SC_OK))) && request.getMethod().equals(httpMethod)) {\n+                    // Process request entry.\n+                    Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n+                    StringBuffer requestDescription = new StringBuffer();\n+                    long initialTime = System.currentTimeMillis();\n+                    \n+                    try {\n+                        FHIRUrlParser requestURL = new FHIRUrlParser(request.getUrl().getValue());\n+\n+                        if (log.isLoggable(Level.FINER)) {\n+                            log.finer(\"Processing bundle request entry \" + entryIndex + \"; method=\"\n+                                    + request.getMethod().getValue() + \", url=\"\n+                                    + request.getUrl().getValue());\n+                            log.finer(\"--> path: \" + requestURL.getPath());", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzU0Ng==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503263546", "bodyText": "I suggest bracketing the log with a single quote as spaces are hard to see otherwise.", "author": "prb112", "createdAt": "2020-10-12T12:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NzAxNQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503497015", "bodyText": "Done.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzY2Nw==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503263667", "bodyText": "same with this line ---\nI suggest bracketing the log with a single quote as spaces are hard to see otherwise.", "author": "prb112", "createdAt": "2020-10-12T12:33:24Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -1512,432 +1526,477 @@ private Bundle processBundleEntries(Bundle requestBundle, Bundle responseBundle,\n      *            the bundle containing the corresponding response entries\n      * @param httpMethod\n      *            the HTTP method (GET, POST, PUT, etc.) to be processed\n+     * @param failFast\n+     *            a boolean value indicating if processing should stop on first failure \n+     * @param localRefMap\n+     *            the map of local references to external references\n+     * @param bundleRequestProperties\n+     *            the bundle request properties\n+     * @param bundleRequestCorrelationId\n+     *            the bundle request correlation ID\n+     * @return\n+     *            the response bundle\n+     * @throws Exception\n      */\n     private Bundle processEntriesForMethod(Bundle requestBundle, Bundle responseBundle,\n-            HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n-            Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n-            throws Exception {\n-        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\n-                \"httpMethod\", httpMethod });\n+        HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n+        Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\"httpMethod\", httpMethod });\n+        \n         try {\n-            // First, obtain a list of request entry indices for the entries that we'll process.\n-            // This list will contain the indices associated with only the entries for the specified http method.\n-            List<Integer> entryIndices =\n-                    getBundleRequestIndicesForMethod(requestBundle, responseBundle, httpMethod);\n-            if (log.isLoggable(Level.FINER)) {\n-                log.finer(\"Bundle request indices to be processed: \" + entryIndices.toString());\n-            }\n-\n-            // Next, for PUT (update) requests, extract any local identifiers and resolve them ahead of time.\n-            // We do this to prevent any local reference problems from occurring due to our re-ordering\n-            // of the PUT request entries.\n-            if (httpMethod.equals(HTTPVerb.PUT)) {\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Pre-processing bundle request entries for PUT method...\");\n-                }\n-                for (Integer index : entryIndices) {\n-                    Bundle.Entry requestEntry = requestBundle.getEntry().get(index);\n-\n-                    // Retrieve the local identifier from the request entry (if present).\n-                    String localIdentifier = retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                    // Since this is for a PUT request (update) we should be able to resolve the local identifier\n-                    // prior to processing the request since the resource's id must already be contained in the resource\n-                    // within the request entry.\n-                    if (localIdentifier != null) {\n-                        Resource resource = requestEntry.getResource();\n-                        addLocalRefMapping(localRefMap, localIdentifier, resource);\n-                    }\n-                }\n-            }\n-\n-            // Next, for PUT and DELETE requests, we need to sort the indices by the request url path value.\n-            if (httpMethod.equals(HTTPVerb.PUT) || httpMethod.equals(HTTPVerb.DELETE)) {\n-                sortBundleRequestEntries(requestBundle, entryIndices);\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Sorted bundle request indices to be processed: \"\n-                            + entryIndices.toString());\n-                }\n-            }\n-\n-            // Now visit each of the request entries using the list of indices obtained above.\n-            // Use hashmap to store both the index and the according updated response bundle entry.\n-            HashMap<Integer, Bundle.Entry> responseIndexAndEntries =\n-                    new HashMap<Integer, Bundle.Entry>();\n-            for (Integer entryIndex : entryIndices) {\n+            // Visit each of the request entries, processing those with the specified request method.\n+            // Use hashmap to store both the index and the accordingly updated response bundle entry.\n+            HashMap<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();\n+            for (int entryIndex=0; entryIndex<requestBundle.getEntry().size(); ++entryIndex) {\n                 Bundle.Entry requestEntry = requestBundle.getEntry().get(entryIndex);\n-                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n-                Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n-\n                 Bundle.Entry.Request request = requestEntry.getRequest();\n+                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n                 Bundle.Entry.Response response = responseEntry.getResponse();\n+                if (response.getStatus().equals(string(Integer.toString(SC_OK))) && request.getMethod().equals(httpMethod)) {\n+                    // Process request entry.\n+                    Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n+                    StringBuffer requestDescription = new StringBuffer();\n+                    long initialTime = System.currentTimeMillis();\n+                    \n+                    try {\n+                        FHIRUrlParser requestURL = new FHIRUrlParser(request.getUrl().getValue());\n+\n+                        if (log.isLoggable(Level.FINER)) {\n+                            log.finer(\"Processing bundle request entry \" + entryIndex + \"; method=\"\n+                                    + request.getMethod().getValue() + \", url=\"\n+                                    + request.getUrl().getValue());\n+                            log.finer(\"--> path: \" + requestURL.getPath());\n+                            log.finer(\"--> query: \" + requestURL.getQuery());", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NzEwNA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503497104", "bodyText": "Done.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzgxMA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503263810", "bodyText": "this style is totally fine, but often times we'll prefer a style with more whitespace like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Encounter encounter = Encounter.builder().status(EncounterStatus.FINISHED).clazz(Coding.builder().code(Code.of(\"AMB\")).build())\n          \n          \n            \n                            .reasonReference(Reference.builder().reference(com.ibm.fhir.model.type.String.of(\"urn:2\")).build()).build();\n          \n          \n            \n                    Encounter encounter = Encounter.builder()\n          \n          \n            \n                            .status(EncounterStatus.FINISHED)\n          \n          \n            \n                            .clazz(Coding.builder()\n          \n          \n            \n                                .code(Code.of(\"AMB\"))\n          \n          \n            \n                                .build())\n          \n          \n            \n                            .reasonReference(Reference.builder()\n          \n          \n            \n                                .reference(com.ibm.fhir.model.type.String.of(\"urn:2\"))\n          \n          \n            \n                                .build())\n          \n          \n            \n                            .build();", "author": "lmsurpre", "createdAt": "2020-10-12T12:33:42Z", "path": "fhir-server/src/test/java/com/ibm/fhir/server/test/FHIRRestHelperTest.java", "diffHunk": "@@ -0,0 +1,987 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.fail;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Condition;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Practitioner;\n+import com.ibm.fhir.model.resource.Practitioner.Qualification;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.server.util.FHIRRestHelper;\n+\n+public class FHIRRestHelperTest {\n+\n+    /**\n+     * Test transaction bundle post single.\n+     */\n+    @Test\n+    public void testTransactionBundlePostSingle() throws Exception {\n+        FHIRPersistence persistence = new MockPersistenceImpl();\n+        FHIRRestHelper helper = new FHIRRestHelper(persistence);\n+        \n+        Patient patient = Patient.builder().id(\"1\").build();\n+        Bundle.Entry.Request bundleEntryRequest = Bundle.Entry.Request.builder().method(HTTPVerb.POST).url(Uri.of(\"Patient\")).build();\n+        Bundle.Entry bundleEntry = Bundle.Entry.builder().resource(patient).request(bundleEntryRequest).build();\n+        \n+        Bundle requestBundle = Bundle.builder().id(\"bundle1\").type(BundleType.TRANSACTION).entry(bundleEntry).build();\n+\n+        // Process bundle\n+        FHIRRequestContext.get().setOriginalRequestUri(\"test\");\n+        Bundle responseBundle = helper.doBundle(requestBundle, null);\n+        \n+        // Validate results\n+        assertNotNull(responseBundle);\n+        assertEquals(1, responseBundle.getEntry().size());\n+        Bundle.Entry entry = responseBundle.getEntry().get(0);\n+        Bundle.Entry.Response response = entry.getResponse();\n+        assertEquals(\"Patient/generated-0/_history/1\", response.getLocation().getValue());\n+        assertEquals(Integer.toString(Response.Status.CREATED.getStatusCode()), response.getStatus().getValue());\n+    }\n+\n+    /**\n+     * Test transaction bundle post with local reference dependency.\n+     * Procedure has local reference to Patient.\n+     */\n+    @Test\n+    public void testTransactionBundlePostWithDependency() throws Exception {\n+        FHIRPersistence persistence = new MockPersistenceImpl();\n+        FHIRRestHelper helper = new FHIRRestHelper(persistence);\n+        \n+        Patient patient = Patient.builder().id(\"1\").build();\n+        Bundle.Entry.Request bundleEntryRequest = Bundle.Entry.Request.builder().method(HTTPVerb.POST).url(Uri.of(\"Patient\")).build();\n+        Bundle.Entry bundleEntry = Bundle.Entry.builder().fullUrl(Uri.of(\"urn:1\")).resource(patient).request(bundleEntryRequest).build();\n+        \n+        Procedure procedure = Procedure.builder().status(ProcedureStatus.COMPLETED).subject(Reference.builder().reference(com.ibm.fhir.model.type.String.of(\"urn:1\")).build()).build();\n+        Bundle.Entry.Request bundleEntryRequest2 = Bundle.Entry.Request.builder().method(HTTPVerb.POST).url(Uri.of(\"Procedure\")).build();\n+        Bundle.Entry bundleEntry2 = Bundle.Entry.builder().resource(procedure).request(bundleEntryRequest2).build();\n+        \n+        Bundle requestBundle = Bundle.builder().id(\"bundle1\").type(BundleType.TRANSACTION).entry(bundleEntry, bundleEntry2).build();\n+\n+        // Process bundle\n+        FHIRRequestContext.get().setOriginalRequestUri(\"test\");\n+        FHIRRequestContext.get().setReturnPreference(HTTPReturnPreference.REPRESENTATION);\n+        Bundle responseBundle = helper.doBundle(requestBundle, null);\n+        \n+        // Validate results\n+        assertNotNull(responseBundle);\n+        assertEquals(2, responseBundle.getEntry().size());\n+        for (Bundle.Entry entry : responseBundle.getEntry()) {\n+            Bundle.Entry.Response response = entry.getResponse();\n+            if (response.getLocation().getValue().startsWith(\"Patient\")) {\n+                assertEquals(\"Patient/generated-0/_history/1\", response.getLocation().getValue());\n+                assertEquals(Integer.toString(Response.Status.CREATED.getStatusCode()), response.getStatus().getValue());\n+            } else if (response.getLocation().getValue().startsWith(\"Procedure\")) {\n+                assertEquals(\"Procedure/generated-1/_history/1\", response.getLocation().getValue());\n+                assertEquals(Integer.toString(Response.Status.CREATED.getStatusCode()), response.getStatus().getValue());\n+                Procedure returnedProcedure = (Procedure) entry.getResource();\n+                assertEquals(\"Patient/generated-0\", returnedProcedure.getSubject().getReference().getValue());\n+            } else {\n+                fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test transaction bundle post with backward local reference dependency.\n+     * Procedure has local reference to Patient, but Procedure is first in bundle.\n+     */\n+    @Test\n+    public void testTransactionBundlePostWithBackwardDependency() throws Exception {\n+        FHIRPersistence persistence = new MockPersistenceImpl();\n+        FHIRRestHelper helper = new FHIRRestHelper(persistence);\n+        \n+        Patient patient = Patient.builder().id(\"1\").build();\n+        Bundle.Entry.Request bundleEntryRequest = Bundle.Entry.Request.builder().method(HTTPVerb.POST).url(Uri.of(\"Patient\")).build();\n+        Bundle.Entry bundleEntry = Bundle.Entry.builder().fullUrl(Uri.of(\"urn:1\")).resource(patient).request(bundleEntryRequest).build();\n+        \n+        Procedure procedure = Procedure.builder().status(ProcedureStatus.COMPLETED).subject(Reference.builder().reference(com.ibm.fhir.model.type.String.of(\"urn:1\")).build()).build();\n+        Bundle.Entry.Request bundleEntryRequest2 = Bundle.Entry.Request.builder().method(HTTPVerb.POST).url(Uri.of(\"Procedure\")).build();\n+        Bundle.Entry bundleEntry2 = Bundle.Entry.builder().resource(procedure).request(bundleEntryRequest2).build();\n+        \n+        Bundle requestBundle = Bundle.builder().id(\"bundle1\").type(BundleType.TRANSACTION).entry(bundleEntry2, bundleEntry).build();\n+\n+        // Process bundle\n+        FHIRRequestContext.get().setOriginalRequestUri(\"test\");\n+        FHIRRequestContext.get().setReturnPreference(HTTPReturnPreference.REPRESENTATION);\n+        Bundle responseBundle = helper.doBundle(requestBundle, null);\n+        \n+        // Validate results\n+        assertNotNull(responseBundle);\n+        assertEquals(2, responseBundle.getEntry().size());\n+        for (Bundle.Entry entry : responseBundle.getEntry()) {\n+            Bundle.Entry.Response response = entry.getResponse();\n+            if (response.getLocation().getValue().startsWith(\"Patient\")) {\n+                assertEquals(\"Patient/generated-0/_history/1\", response.getLocation().getValue());\n+                assertEquals(Integer.toString(Response.Status.CREATED.getStatusCode()), response.getStatus().getValue());\n+            } else if (response.getLocation().getValue().startsWith(\"Procedure\")) {\n+                assertEquals(\"Procedure/generated-1/_history/1\", response.getLocation().getValue());\n+                assertEquals(Integer.toString(Response.Status.CREATED.getStatusCode()), response.getStatus().getValue());\n+                Procedure returnedProcedure = (Procedure) entry.getResource();\n+                assertEquals(\"Patient/generated-0\", returnedProcedure.getSubject().getReference().getValue());\n+            } else {\n+                fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test transaction bundle post with circular local reference dependency.\n+     * Procedure has local reference to Encounter and Encounter has local reference to Procedure.\n+     */\n+    @Test\n+    public void testTransactionBundlePostWithCircularDependency() throws Exception {\n+        FHIRPersistence persistence = new MockPersistenceImpl();\n+        FHIRRestHelper helper = new FHIRRestHelper(persistence);\n+        \n+        Encounter encounter = Encounter.builder().status(EncounterStatus.FINISHED).clazz(Coding.builder().code(Code.of(\"AMB\")).build())\n+                .reasonReference(Reference.builder().reference(com.ibm.fhir.model.type.String.of(\"urn:2\")).build()).build();", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2NTA1Mg==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503265052", "bodyText": "additionally, we'll often statically import the com.ibm.fhir.model.type.String.string factory method so that we don't need to fully quality com.ibm.fhir.model.type.String for each usage.", "author": "lmsurpre", "createdAt": "2020-10-12T12:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2OTAwMw==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503269003", "bodyText": "these style comments apply to many of the tests in this class...not planning to repeat it for each instance", "author": "lmsurpre", "createdAt": "2020-10-12T12:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NzU5NA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503497594", "bodyText": "I updated the testcases to use the style suggested, as well as importing com.ibm.fhir.model.type.String.string", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2NDE0OQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503264149", "bodyText": "since this if fixed, it may be great to make that string value a static final string(Integer.toString(SC_NOT_FOUND))", "author": "prb112", "createdAt": "2020-10-12T12:34:18Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -1512,432 +1526,477 @@ private Bundle processBundleEntries(Bundle requestBundle, Bundle responseBundle,\n      *            the bundle containing the corresponding response entries\n      * @param httpMethod\n      *            the HTTP method (GET, POST, PUT, etc.) to be processed\n+     * @param failFast\n+     *            a boolean value indicating if processing should stop on first failure \n+     * @param localRefMap\n+     *            the map of local references to external references\n+     * @param bundleRequestProperties\n+     *            the bundle request properties\n+     * @param bundleRequestCorrelationId\n+     *            the bundle request correlation ID\n+     * @return\n+     *            the response bundle\n+     * @throws Exception\n      */\n     private Bundle processEntriesForMethod(Bundle requestBundle, Bundle responseBundle,\n-            HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n-            Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n-            throws Exception {\n-        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\n-                \"httpMethod\", httpMethod });\n+        HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n+        Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\"httpMethod\", httpMethod });\n+        \n         try {\n-            // First, obtain a list of request entry indices for the entries that we'll process.\n-            // This list will contain the indices associated with only the entries for the specified http method.\n-            List<Integer> entryIndices =\n-                    getBundleRequestIndicesForMethod(requestBundle, responseBundle, httpMethod);\n-            if (log.isLoggable(Level.FINER)) {\n-                log.finer(\"Bundle request indices to be processed: \" + entryIndices.toString());\n-            }\n-\n-            // Next, for PUT (update) requests, extract any local identifiers and resolve them ahead of time.\n-            // We do this to prevent any local reference problems from occurring due to our re-ordering\n-            // of the PUT request entries.\n-            if (httpMethod.equals(HTTPVerb.PUT)) {\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Pre-processing bundle request entries for PUT method...\");\n-                }\n-                for (Integer index : entryIndices) {\n-                    Bundle.Entry requestEntry = requestBundle.getEntry().get(index);\n-\n-                    // Retrieve the local identifier from the request entry (if present).\n-                    String localIdentifier = retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                    // Since this is for a PUT request (update) we should be able to resolve the local identifier\n-                    // prior to processing the request since the resource's id must already be contained in the resource\n-                    // within the request entry.\n-                    if (localIdentifier != null) {\n-                        Resource resource = requestEntry.getResource();\n-                        addLocalRefMapping(localRefMap, localIdentifier, resource);\n-                    }\n-                }\n-            }\n-\n-            // Next, for PUT and DELETE requests, we need to sort the indices by the request url path value.\n-            if (httpMethod.equals(HTTPVerb.PUT) || httpMethod.equals(HTTPVerb.DELETE)) {\n-                sortBundleRequestEntries(requestBundle, entryIndices);\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Sorted bundle request indices to be processed: \"\n-                            + entryIndices.toString());\n-                }\n-            }\n-\n-            // Now visit each of the request entries using the list of indices obtained above.\n-            // Use hashmap to store both the index and the according updated response bundle entry.\n-            HashMap<Integer, Bundle.Entry> responseIndexAndEntries =\n-                    new HashMap<Integer, Bundle.Entry>();\n-            for (Integer entryIndex : entryIndices) {\n+            // Visit each of the request entries, processing those with the specified request method.\n+            // Use hashmap to store both the index and the accordingly updated response bundle entry.\n+            HashMap<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();\n+            for (int entryIndex=0; entryIndex<requestBundle.getEntry().size(); ++entryIndex) {\n                 Bundle.Entry requestEntry = requestBundle.getEntry().get(entryIndex);\n-                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n-                Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n-\n                 Bundle.Entry.Request request = requestEntry.getRequest();\n+                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n                 Bundle.Entry.Response response = responseEntry.getResponse();\n+                if (response.getStatus().equals(string(Integer.toString(SC_OK))) && request.getMethod().equals(httpMethod)) {\n+                    // Process request entry.\n+                    Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n+                    StringBuffer requestDescription = new StringBuffer();\n+                    long initialTime = System.currentTimeMillis();\n+                    \n+                    try {\n+                        FHIRUrlParser requestURL = new FHIRUrlParser(request.getUrl().getValue());\n+\n+                        if (log.isLoggable(Level.FINER)) {\n+                            log.finer(\"Processing bundle request entry \" + entryIndex + \"; method=\"\n+                                    + request.getMethod().getValue() + \", url=\"\n+                                    + request.getUrl().getValue());\n+                            log.finer(\"--> path: \" + requestURL.getPath());\n+                            log.finer(\"--> query: \" + requestURL.getQuery());\n+                        }\n \n-                StringBuffer requestDescription = new StringBuffer();\n-                long initialTime = System.currentTimeMillis();\n-                try {\n-                    FHIRUrlParser requestURL = new FHIRUrlParser(request.getUrl().getValue());\n-\n-                    String path = requestURL.getPath();\n-                    String query = requestURL.getQuery();\n-                    if (log.isLoggable(Level.FINER)) {\n-                        log.finer(\"Processing bundle request entry \" + entryIndex + \"; method=\"\n-                                + request.getMethod().getValue() + \", url=\"\n-                                + request.getUrl().getValue());\n-                        log.finer(\"--> path: \" + path);\n-                        log.finer(\"--> query: \" + query);\n-                    }\n-\n-                    // Log our initial info message for this request.\n-                    requestDescription.append(\"entryIndex:[\");\n-                    requestDescription.append(entryIndex);\n-                    requestDescription.append(\"] correlationId:[\");\n-                    requestDescription.append(bundleRequestCorrelationId);\n-                    requestDescription.append(\"] method:[\");\n-                    requestDescription.append(request.getMethod().getValue());\n-                    requestDescription.append(\"] uri:[\");\n-                    requestDescription.append(request.getUrl().getValue());\n-                    requestDescription.append(\"]\");\n-                    log.info(\"Received bundle request: \" + requestDescription.toString());\n-\n-                    String[] pathTokens = requestURL.getPathTokens();\n-                    MultivaluedMap<String, String> queryParams = requestURL.getQueryParameters();\n-\n-                    // Construct the absolute requestUri to be used for any response bundles associated\n-                    // with history and search requests.\n-                    String absoluteUri =\n-                            getAbsoluteUri(getRequestUri(), request.getUrl().getValue());\n-\n-                    if (request.getMethod().equals(HTTPVerb.GET)) {\n-                        Resource resource = null;\n-                        int httpStatus = SC_OK;\n-\n-                        // Process a GET (read, vread, history, search, etc.).\n-                        // Determine the type of request from the path tokens.\n-                        if (pathTokens.length > 0\n-                                && pathTokens[pathTokens.length - 1].startsWith(\"$\")) {\n-                            // This is a custom operation request\n-\n-                            // Chop off the '$' and save the name\n-                            String operationName = pathTokens[pathTokens.length - 1].substring(1);\n-\n-                            // FHIROperationContext operationContext;\n-                            switch (pathTokens.length) {\n-                            case 1: {\n-                                FHIROperationContext operationContext =\n-                                        FHIROperationContext.createSystemOperationContext();\n-                                resource =\n-                                        doInvoke(operationContext, null, null, null, operationName, null, queryParams, null);\n-                            }\n-                                break;\n-                            case 2: {\n-                                FHIROperationContext operationContext =\n-                                        FHIROperationContext.createResourceTypeOperationContext();\n-                                resource =\n-                                        doInvoke(operationContext, pathTokens[0], null, null, operationName, null, queryParams, null);\n-                            }\n-                                break;\n-                            case 3: {\n-                                FHIROperationContext operationContext =\n-                                        FHIROperationContext.createInstanceOperationContext();\n-                                resource =\n-                                        doInvoke(operationContext, pathTokens[0], pathTokens[1], null, operationName, null, queryParams, null);\n-                            }\n-                                break;\n-                            default:\n-                                String msg = \"Invalid URL for custom operation '\"\n-                                        + pathTokens[pathTokens.length - 1] + \"'\";\n-                                throw buildRestException(msg, IssueType.NOT_FOUND);\n-                            }\n-                        } else if (pathTokens.length == 1) {\n-                            // This is a 'search' request.\n-                            if (\"_search\".equals(pathTokens[0])) {\n-                                resource =\n-                                        doSearch(\"Resource\", null, null, queryParams, absoluteUri, null, null);\n-                            } else {\n-                                resource =\n-                                        doSearch(pathTokens[0], null, null, queryParams, absoluteUri, null, null);\n-                            }\n-                        } else if (pathTokens.length == 2) {\n-                            // This is a 'read' request.\n-                            resource =\n-                                    doRead(pathTokens[0], pathTokens[1], true, false, null, null);\n-                        } else if (pathTokens.length == 3) {\n-                            if (\"_history\".equals(pathTokens[2])) {\n-                                // This is a 'history' request.\n-                                resource =\n-                                        doHistory(pathTokens[0], pathTokens[1], queryParams, absoluteUri, null);\n-                            } else {\n-                                // This is a compartment based search\n-                                resource =\n-                                        doSearch(pathTokens[2], pathTokens[0], pathTokens[1], queryParams, absoluteUri, null, null);\n-                            }\n-                        } else if (pathTokens.length == 4 && pathTokens[2].equals(\"_history\")) {\n-                            // This is a 'vread' request.\n-                            resource = doVRead(pathTokens[0], pathTokens[1], pathTokens[3], null);\n+                        // Log our initial info message for this request.\n+                        requestDescription.append(\"entryIndex:[\");\n+                        requestDescription.append(entryIndex);\n+                        requestDescription.append(\"] correlationId:[\");\n+                        requestDescription.append(bundleRequestCorrelationId);\n+                        requestDescription.append(\"] method:[\");\n+                        requestDescription.append(request.getMethod().getValue());\n+                        requestDescription.append(\"] uri:[\");\n+                        requestDescription.append(request.getUrl().getValue());\n+                        requestDescription.append(\"]\");\n+                        log.info(\"Received bundle request: \" + requestDescription.toString());\n+\n+                        // Construct the absolute requestUri to be used for any response bundles associated\n+                        // with history and search requests.\n+                        String absoluteUri = getAbsoluteUri(getRequestUri(), request.getUrl().getValue());\n+\n+                        if (request.getMethod().equals(HTTPVerb.GET)) {\n+                            processEntryForGet(responseEntry, responseIndexAndEntries, entryIndex, requestURL, absoluteUri, requestDescription.toString(), initialTime);\n+                        } else if (request.getMethod().equals(HTTPVerb.POST)) {\n+                            processEntryForPost(requestEntry, responseEntry, responseIndexAndEntries, entryIndex, localRefMap, requestURL, absoluteUri, requestDescription.toString(), initialTime);\n+                        } else if (request.getMethod().equals(HTTPVerb.PUT)) {\n+                            processEntryForPut(requestEntry, responseEntry, responseIndexAndEntries, entryIndex, localRefMap, requestURL, absoluteUri, requestDescription.toString(), initialTime);\n+                        } else if (request.getMethod().equals(HTTPVerb.DELETE)) {\n+                            processEntryForDelete(responseEntry, responseIndexAndEntries, entryIndex, requestURL, requestDescription.toString(), initialTime);\n                         } else {\n-                            String msg = \"Unrecognized path in request URL: \" + path;\n-                            throw buildRestException(msg, IssueType.NOT_FOUND);\n+                            // Internal error, should not get here!\n+                            throw new IllegalStateException(\"Internal Server Error: reached an unexpected code location.\");\n                         }\n-\n-                        // Save the results of the operation in the bundle response field.\n+                    } catch (FHIRPersistenceResourceNotFoundException e) {\n+                        if (failFast) {\n+                            String msg = \"Error while processing request bundle.\";\n+                            throw new FHIRRestBundledRequestException(msg).withIssue(e.getIssues());\n+                        }\n+                        \n                         Bundle.Entry.Response.Builder responseBuilder = response.toBuilder();\n-                        responseBuilder.status(string(Integer.toString(httpStatus)));\n-                        setBundleResponseStatus(response, httpStatus, requestDescription.toString(), initialTime);\n-\n-                        responseIndexAndEntries.put(entryIndex, responseEntryBuilder.resource(resource).response(responseBuilder.build()).build());\n-                    } else if (request.getMethod().equals(HTTPVerb.POST)) {\n-                        // Process a POST (create or search, or custom operation).\n-                        if (pathTokens.length > 0\n-                                && pathTokens[pathTokens.length - 1].startsWith(\"$\")) {\n-                            // This is a custom operation request\n-\n-                            // Chop off the '$' and save the name\n-                            String operationName = pathTokens[pathTokens.length - 1].substring(1);\n-\n-                            // Retrieve the resource from the request entry.\n-                            Resource resource = requestEntry.getResource();\n-\n-                            FHIROperationContext operationContext;\n-                            Resource result;\n-                            switch (pathTokens.length) {\n-                            case 1:\n-                                operationContext =\n-                                        FHIROperationContext.createSystemOperationContext();\n-                                result = doInvoke(operationContext, null, null, null, operationName, resource, queryParams, null);\n-                                break;\n-                            case 2:\n-                                operationContext =\n-                                        FHIROperationContext.createResourceTypeOperationContext();\n-                                result = doInvoke(operationContext, pathTokens[0], null, null, operationName, resource, queryParams, null);\n-                                break;\n-                            case 3:\n-                                operationContext =\n-                                        FHIROperationContext.createInstanceOperationContext();\n-                                result = doInvoke(operationContext, pathTokens[0], pathTokens[1], null, operationName, resource, queryParams, null);\n-                                break;\n-                            default:\n-                                String msg = \"Invalid URL for custom operation '\"\n-                                        + pathTokens[pathTokens.length - 1] + \"'\";\n-                                throw buildRestException(msg, IssueType.NOT_FOUND);\n-                            }\n-\n-                            Bundle.Entry.Response.Builder responseBuilder = response.toBuilder();\n-                            // Add warning and hint issues to response outcome if any.\n-                            if (result instanceof OperationOutcome) {\n-                                if (((OperationOutcome) result).getIssue() != null) {\n-                                    responseBuilder.outcome(result);\n-                                }\n-                            }\n-\n-                            responseBuilder.status(string(Integer.toString(SC_OK)));\n-                            responseIndexAndEntries.put(entryIndex, responseEntryBuilder\n-                                    .resource(result)\n-                                    .response(responseBuilder.build())\n-                                    .build());\n-                            setBundleResponseStatus(response, SC_OK, requestDescription.toString(), initialTime);\n-\n-                        } else if (pathTokens.length == 2 && \"_search\".equals(pathTokens[1])) {\n-                            // This is a 'search' request.\n-                            Bundle searchResults =\n-                                    doSearch(pathTokens[0], null, null, queryParams, absoluteUri, null, null);\n-\n-                            // Save the results of the operation in the bundle response field.\n-                            Bundle.Entry.Response.Builder responseBuilder = response.toBuilder();\n-                            responseBuilder.status(string(Integer.toString(SC_OK)));\n-\n-                            responseIndexAndEntries.put(entryIndex, responseEntryBuilder\n-                                    .resource(searchResults)\n-                                    .response(responseBuilder.build())\n-                                    .build());\n-\n-                            setBundleResponseStatus(response, SC_OK, requestDescription.toString(), initialTime);\n-                        } else if (pathTokens.length == 1) {\n-                            // This is a 'create' request.\n-\n-                            // Retrieve the local identifier from the request entry (if present).\n-                            String localIdentifier =\n-                                    retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                            // Retrieve the resource from the request entry.\n-                            Resource resource = requestEntry.getResource();\n-                            if (resource == null) {\n-                                String msg =\n-                                        \"BundleEntry.resource is required for bundled create requests.\";\n-                                throw buildRestException(msg, IssueType.NOT_FOUND);\n-                            }\n-\n-                            // Convert any local references found within the resource to their\n-                            // corresponding external reference.\n+                        responseBuilder.status(string(Integer.toString(SC_NOT_FOUND)));", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NzczOA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503497738", "bodyText": "Done.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2NDE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2NDI4OA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503264288", "bodyText": "since this if fixed, it may be great to make that string value a static final string(Integer.toString(SC_GONE))", "author": "prb112", "createdAt": "2020-10-12T12:34:33Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -1512,432 +1526,477 @@ private Bundle processBundleEntries(Bundle requestBundle, Bundle responseBundle,\n      *            the bundle containing the corresponding response entries\n      * @param httpMethod\n      *            the HTTP method (GET, POST, PUT, etc.) to be processed\n+     * @param failFast\n+     *            a boolean value indicating if processing should stop on first failure \n+     * @param localRefMap\n+     *            the map of local references to external references\n+     * @param bundleRequestProperties\n+     *            the bundle request properties\n+     * @param bundleRequestCorrelationId\n+     *            the bundle request correlation ID\n+     * @return\n+     *            the response bundle\n+     * @throws Exception\n      */\n     private Bundle processEntriesForMethod(Bundle requestBundle, Bundle responseBundle,\n-            HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n-            Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n-            throws Exception {\n-        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\n-                \"httpMethod\", httpMethod });\n+        HTTPVerb httpMethod, boolean failFast, Map<String, String> localRefMap,\n+        Map<String, String> bundleRequestProperties, String bundleRequestCorrelationId)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"processEntriesForMethod\", new Object[] {\"httpMethod\", httpMethod });\n+        \n         try {\n-            // First, obtain a list of request entry indices for the entries that we'll process.\n-            // This list will contain the indices associated with only the entries for the specified http method.\n-            List<Integer> entryIndices =\n-                    getBundleRequestIndicesForMethod(requestBundle, responseBundle, httpMethod);\n-            if (log.isLoggable(Level.FINER)) {\n-                log.finer(\"Bundle request indices to be processed: \" + entryIndices.toString());\n-            }\n-\n-            // Next, for PUT (update) requests, extract any local identifiers and resolve them ahead of time.\n-            // We do this to prevent any local reference problems from occurring due to our re-ordering\n-            // of the PUT request entries.\n-            if (httpMethod.equals(HTTPVerb.PUT)) {\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Pre-processing bundle request entries for PUT method...\");\n-                }\n-                for (Integer index : entryIndices) {\n-                    Bundle.Entry requestEntry = requestBundle.getEntry().get(index);\n-\n-                    // Retrieve the local identifier from the request entry (if present).\n-                    String localIdentifier = retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                    // Since this is for a PUT request (update) we should be able to resolve the local identifier\n-                    // prior to processing the request since the resource's id must already be contained in the resource\n-                    // within the request entry.\n-                    if (localIdentifier != null) {\n-                        Resource resource = requestEntry.getResource();\n-                        addLocalRefMapping(localRefMap, localIdentifier, resource);\n-                    }\n-                }\n-            }\n-\n-            // Next, for PUT and DELETE requests, we need to sort the indices by the request url path value.\n-            if (httpMethod.equals(HTTPVerb.PUT) || httpMethod.equals(HTTPVerb.DELETE)) {\n-                sortBundleRequestEntries(requestBundle, entryIndices);\n-                if (log.isLoggable(Level.FINER)) {\n-                    log.finer(\"Sorted bundle request indices to be processed: \"\n-                            + entryIndices.toString());\n-                }\n-            }\n-\n-            // Now visit each of the request entries using the list of indices obtained above.\n-            // Use hashmap to store both the index and the according updated response bundle entry.\n-            HashMap<Integer, Bundle.Entry> responseIndexAndEntries =\n-                    new HashMap<Integer, Bundle.Entry>();\n-            for (Integer entryIndex : entryIndices) {\n+            // Visit each of the request entries, processing those with the specified request method.\n+            // Use hashmap to store both the index and the accordingly updated response bundle entry.\n+            HashMap<Integer, Bundle.Entry> responseIndexAndEntries = new HashMap<Integer, Bundle.Entry>();\n+            for (int entryIndex=0; entryIndex<requestBundle.getEntry().size(); ++entryIndex) {\n                 Bundle.Entry requestEntry = requestBundle.getEntry().get(entryIndex);\n-                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n-                Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n-\n                 Bundle.Entry.Request request = requestEntry.getRequest();\n+                Bundle.Entry responseEntry = responseBundle.getEntry().get(entryIndex);\n                 Bundle.Entry.Response response = responseEntry.getResponse();\n+                if (response.getStatus().equals(string(Integer.toString(SC_OK))) && request.getMethod().equals(httpMethod)) {\n+                    // Process request entry.\n+                    Bundle.Entry.Builder responseEntryBuilder = responseEntry.toBuilder();\n+                    StringBuffer requestDescription = new StringBuffer();\n+                    long initialTime = System.currentTimeMillis();\n+                    \n+                    try {\n+                        FHIRUrlParser requestURL = new FHIRUrlParser(request.getUrl().getValue());\n+\n+                        if (log.isLoggable(Level.FINER)) {\n+                            log.finer(\"Processing bundle request entry \" + entryIndex + \"; method=\"\n+                                    + request.getMethod().getValue() + \", url=\"\n+                                    + request.getUrl().getValue());\n+                            log.finer(\"--> path: \" + requestURL.getPath());\n+                            log.finer(\"--> query: \" + requestURL.getQuery());\n+                        }\n \n-                StringBuffer requestDescription = new StringBuffer();\n-                long initialTime = System.currentTimeMillis();\n-                try {\n-                    FHIRUrlParser requestURL = new FHIRUrlParser(request.getUrl().getValue());\n-\n-                    String path = requestURL.getPath();\n-                    String query = requestURL.getQuery();\n-                    if (log.isLoggable(Level.FINER)) {\n-                        log.finer(\"Processing bundle request entry \" + entryIndex + \"; method=\"\n-                                + request.getMethod().getValue() + \", url=\"\n-                                + request.getUrl().getValue());\n-                        log.finer(\"--> path: \" + path);\n-                        log.finer(\"--> query: \" + query);\n-                    }\n-\n-                    // Log our initial info message for this request.\n-                    requestDescription.append(\"entryIndex:[\");\n-                    requestDescription.append(entryIndex);\n-                    requestDescription.append(\"] correlationId:[\");\n-                    requestDescription.append(bundleRequestCorrelationId);\n-                    requestDescription.append(\"] method:[\");\n-                    requestDescription.append(request.getMethod().getValue());\n-                    requestDescription.append(\"] uri:[\");\n-                    requestDescription.append(request.getUrl().getValue());\n-                    requestDescription.append(\"]\");\n-                    log.info(\"Received bundle request: \" + requestDescription.toString());\n-\n-                    String[] pathTokens = requestURL.getPathTokens();\n-                    MultivaluedMap<String, String> queryParams = requestURL.getQueryParameters();\n-\n-                    // Construct the absolute requestUri to be used for any response bundles associated\n-                    // with history and search requests.\n-                    String absoluteUri =\n-                            getAbsoluteUri(getRequestUri(), request.getUrl().getValue());\n-\n-                    if (request.getMethod().equals(HTTPVerb.GET)) {\n-                        Resource resource = null;\n-                        int httpStatus = SC_OK;\n-\n-                        // Process a GET (read, vread, history, search, etc.).\n-                        // Determine the type of request from the path tokens.\n-                        if (pathTokens.length > 0\n-                                && pathTokens[pathTokens.length - 1].startsWith(\"$\")) {\n-                            // This is a custom operation request\n-\n-                            // Chop off the '$' and save the name\n-                            String operationName = pathTokens[pathTokens.length - 1].substring(1);\n-\n-                            // FHIROperationContext operationContext;\n-                            switch (pathTokens.length) {\n-                            case 1: {\n-                                FHIROperationContext operationContext =\n-                                        FHIROperationContext.createSystemOperationContext();\n-                                resource =\n-                                        doInvoke(operationContext, null, null, null, operationName, null, queryParams, null);\n-                            }\n-                                break;\n-                            case 2: {\n-                                FHIROperationContext operationContext =\n-                                        FHIROperationContext.createResourceTypeOperationContext();\n-                                resource =\n-                                        doInvoke(operationContext, pathTokens[0], null, null, operationName, null, queryParams, null);\n-                            }\n-                                break;\n-                            case 3: {\n-                                FHIROperationContext operationContext =\n-                                        FHIROperationContext.createInstanceOperationContext();\n-                                resource =\n-                                        doInvoke(operationContext, pathTokens[0], pathTokens[1], null, operationName, null, queryParams, null);\n-                            }\n-                                break;\n-                            default:\n-                                String msg = \"Invalid URL for custom operation '\"\n-                                        + pathTokens[pathTokens.length - 1] + \"'\";\n-                                throw buildRestException(msg, IssueType.NOT_FOUND);\n-                            }\n-                        } else if (pathTokens.length == 1) {\n-                            // This is a 'search' request.\n-                            if (\"_search\".equals(pathTokens[0])) {\n-                                resource =\n-                                        doSearch(\"Resource\", null, null, queryParams, absoluteUri, null, null);\n-                            } else {\n-                                resource =\n-                                        doSearch(pathTokens[0], null, null, queryParams, absoluteUri, null, null);\n-                            }\n-                        } else if (pathTokens.length == 2) {\n-                            // This is a 'read' request.\n-                            resource =\n-                                    doRead(pathTokens[0], pathTokens[1], true, false, null, null);\n-                        } else if (pathTokens.length == 3) {\n-                            if (\"_history\".equals(pathTokens[2])) {\n-                                // This is a 'history' request.\n-                                resource =\n-                                        doHistory(pathTokens[0], pathTokens[1], queryParams, absoluteUri, null);\n-                            } else {\n-                                // This is a compartment based search\n-                                resource =\n-                                        doSearch(pathTokens[2], pathTokens[0], pathTokens[1], queryParams, absoluteUri, null, null);\n-                            }\n-                        } else if (pathTokens.length == 4 && pathTokens[2].equals(\"_history\")) {\n-                            // This is a 'vread' request.\n-                            resource = doVRead(pathTokens[0], pathTokens[1], pathTokens[3], null);\n+                        // Log our initial info message for this request.\n+                        requestDescription.append(\"entryIndex:[\");\n+                        requestDescription.append(entryIndex);\n+                        requestDescription.append(\"] correlationId:[\");\n+                        requestDescription.append(bundleRequestCorrelationId);\n+                        requestDescription.append(\"] method:[\");\n+                        requestDescription.append(request.getMethod().getValue());\n+                        requestDescription.append(\"] uri:[\");\n+                        requestDescription.append(request.getUrl().getValue());\n+                        requestDescription.append(\"]\");\n+                        log.info(\"Received bundle request: \" + requestDescription.toString());\n+\n+                        // Construct the absolute requestUri to be used for any response bundles associated\n+                        // with history and search requests.\n+                        String absoluteUri = getAbsoluteUri(getRequestUri(), request.getUrl().getValue());\n+\n+                        if (request.getMethod().equals(HTTPVerb.GET)) {\n+                            processEntryForGet(responseEntry, responseIndexAndEntries, entryIndex, requestURL, absoluteUri, requestDescription.toString(), initialTime);\n+                        } else if (request.getMethod().equals(HTTPVerb.POST)) {\n+                            processEntryForPost(requestEntry, responseEntry, responseIndexAndEntries, entryIndex, localRefMap, requestURL, absoluteUri, requestDescription.toString(), initialTime);\n+                        } else if (request.getMethod().equals(HTTPVerb.PUT)) {\n+                            processEntryForPut(requestEntry, responseEntry, responseIndexAndEntries, entryIndex, localRefMap, requestURL, absoluteUri, requestDescription.toString(), initialTime);\n+                        } else if (request.getMethod().equals(HTTPVerb.DELETE)) {\n+                            processEntryForDelete(responseEntry, responseIndexAndEntries, entryIndex, requestURL, requestDescription.toString(), initialTime);\n                         } else {\n-                            String msg = \"Unrecognized path in request URL: \" + path;\n-                            throw buildRestException(msg, IssueType.NOT_FOUND);\n+                            // Internal error, should not get here!\n+                            throw new IllegalStateException(\"Internal Server Error: reached an unexpected code location.\");\n                         }\n-\n-                        // Save the results of the operation in the bundle response field.\n+                    } catch (FHIRPersistenceResourceNotFoundException e) {\n+                        if (failFast) {\n+                            String msg = \"Error while processing request bundle.\";\n+                            throw new FHIRRestBundledRequestException(msg).withIssue(e.getIssues());\n+                        }\n+                        \n                         Bundle.Entry.Response.Builder responseBuilder = response.toBuilder();\n-                        responseBuilder.status(string(Integer.toString(httpStatus)));\n-                        setBundleResponseStatus(response, httpStatus, requestDescription.toString(), initialTime);\n-\n-                        responseIndexAndEntries.put(entryIndex, responseEntryBuilder.resource(resource).response(responseBuilder.build()).build());\n-                    } else if (request.getMethod().equals(HTTPVerb.POST)) {\n-                        // Process a POST (create or search, or custom operation).\n-                        if (pathTokens.length > 0\n-                                && pathTokens[pathTokens.length - 1].startsWith(\"$\")) {\n-                            // This is a custom operation request\n-\n-                            // Chop off the '$' and save the name\n-                            String operationName = pathTokens[pathTokens.length - 1].substring(1);\n-\n-                            // Retrieve the resource from the request entry.\n-                            Resource resource = requestEntry.getResource();\n-\n-                            FHIROperationContext operationContext;\n-                            Resource result;\n-                            switch (pathTokens.length) {\n-                            case 1:\n-                                operationContext =\n-                                        FHIROperationContext.createSystemOperationContext();\n-                                result = doInvoke(operationContext, null, null, null, operationName, resource, queryParams, null);\n-                                break;\n-                            case 2:\n-                                operationContext =\n-                                        FHIROperationContext.createResourceTypeOperationContext();\n-                                result = doInvoke(operationContext, pathTokens[0], null, null, operationName, resource, queryParams, null);\n-                                break;\n-                            case 3:\n-                                operationContext =\n-                                        FHIROperationContext.createInstanceOperationContext();\n-                                result = doInvoke(operationContext, pathTokens[0], pathTokens[1], null, operationName, resource, queryParams, null);\n-                                break;\n-                            default:\n-                                String msg = \"Invalid URL for custom operation '\"\n-                                        + pathTokens[pathTokens.length - 1] + \"'\";\n-                                throw buildRestException(msg, IssueType.NOT_FOUND);\n-                            }\n-\n-                            Bundle.Entry.Response.Builder responseBuilder = response.toBuilder();\n-                            // Add warning and hint issues to response outcome if any.\n-                            if (result instanceof OperationOutcome) {\n-                                if (((OperationOutcome) result).getIssue() != null) {\n-                                    responseBuilder.outcome(result);\n-                                }\n-                            }\n-\n-                            responseBuilder.status(string(Integer.toString(SC_OK)));\n-                            responseIndexAndEntries.put(entryIndex, responseEntryBuilder\n-                                    .resource(result)\n-                                    .response(responseBuilder.build())\n-                                    .build());\n-                            setBundleResponseStatus(response, SC_OK, requestDescription.toString(), initialTime);\n-\n-                        } else if (pathTokens.length == 2 && \"_search\".equals(pathTokens[1])) {\n-                            // This is a 'search' request.\n-                            Bundle searchResults =\n-                                    doSearch(pathTokens[0], null, null, queryParams, absoluteUri, null, null);\n-\n-                            // Save the results of the operation in the bundle response field.\n-                            Bundle.Entry.Response.Builder responseBuilder = response.toBuilder();\n-                            responseBuilder.status(string(Integer.toString(SC_OK)));\n-\n-                            responseIndexAndEntries.put(entryIndex, responseEntryBuilder\n-                                    .resource(searchResults)\n-                                    .response(responseBuilder.build())\n-                                    .build());\n-\n-                            setBundleResponseStatus(response, SC_OK, requestDescription.toString(), initialTime);\n-                        } else if (pathTokens.length == 1) {\n-                            // This is a 'create' request.\n-\n-                            // Retrieve the local identifier from the request entry (if present).\n-                            String localIdentifier =\n-                                    retrieveLocalIdentifier(requestEntry, localRefMap);\n-\n-                            // Retrieve the resource from the request entry.\n-                            Resource resource = requestEntry.getResource();\n-                            if (resource == null) {\n-                                String msg =\n-                                        \"BundleEntry.resource is required for bundled create requests.\";\n-                                throw buildRestException(msg, IssueType.NOT_FOUND);\n-                            }\n-\n-                            // Convert any local references found within the resource to their\n-                            // corresponding external reference.\n+                        responseBuilder.status(string(Integer.toString(SC_NOT_FOUND)));\n+                        responseIndexAndEntries.put(entryIndex, responseEntryBuilder.resource(FHIRUtil.buildOperationOutcome(e, false)).response(responseBuilder.build()).build());\n+                        logBundleRequestCompletedMsg(requestDescription.toString(), initialTime, SC_NOT_FOUND);\n+                    } catch (FHIRPersistenceResourceDeletedException e) {\n+                        if (failFast) {\n+                            String msg = \"Error while processing request bundle.\";\n+                            throw new FHIRRestBundledRequestException(msg).withIssue(e.getIssues());\n+                        }\n+                        \n+                        Bundle.Entry.Response.Builder responseBuilder = response.toBuilder();\n+                        responseBuilder.status(string(Integer.toString(SC_GONE)));", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5Nzc4MQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503497781", "bodyText": "Done.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2NDI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2OTI3MQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503269271", "bodyText": "It'd be great to have an integration test in fhir-server-test.", "author": "prb112", "createdAt": "2020-10-12T12:43:09Z", "path": "fhir-server/src/test/java/com/ibm/fhir/server/test/FHIRRestHelperTest.java", "diffHunk": "@@ -0,0 +1,987 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NDQwNg==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503284406", "bodyText": "@prb112  Are the tests in com.ibm.fhir.server.test.BundleTest not sufficient?\nAny particular cases you think it should cover which it isn't?\nI was thinking whatever we cover there is fine (testBatchLocalRefs1, testBatchLocalRefs2, and testBatchLocalRefs3) and that the units tests Mike developed would be where we do the more exhaustive testing.", "author": "lmsurpre", "createdAt": "2020-10-12T13:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2OTI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3ODIyNA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503478224", "bodyText": "sounds fair Lee", "author": "prb112", "createdAt": "2020-10-12T18:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2OTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MDc3OQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503270779", "bodyText": "use an entryset", "author": "prb112", "createdAt": "2020-10-12T12:45:46Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -2048,23 +2035,56 @@ public int compare(Integer indexA, Integer indexB) {\n     }\n \n     /**\n-     * Returns the specified BundleEntry's path component of the 'url' field.\n+     * This method will build a mapping of local identifiers to external identifiers for bundle entries\n+     * which specify local identifiers and which have a request method of POST or PUT.\n      *\n-     * @param entry\n-     *            the bundle entry\n-     * @return the bundle entry's 'url' field's path component\n+     * @param requestBundle\n+     *            the bundle containing the requests\n+     *            \n+     * @return local reference map\n      */\n-    private static String getUrlPath(Bundle.Entry entry) {\n-        String path = null;\n-        Bundle.Entry.Request request = entry.getRequest();\n-        if (request != null) {\n-            if (request.getUrl() != null && request.getUrl().getValue() != null) {\n-                FHIRUrlParser requestURL = new FHIRUrlParser(request.getUrl().getValue());\n-                path = requestURL.getPath();\n+    private Map<String, String> buildLocalRefMap(Bundle requestBundle, Bundle responseBundle) throws Exception {\n+        Map<String, String> localRefMap = new HashMap<>();\n+\n+        for (int entryIndex=0; entryIndex<requestBundle.getEntry().size(); ++entryIndex) {\n+            Bundle.Entry requestEntry = requestBundle.getEntry().get(entryIndex);", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5ODEyMA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503498120", "bodyText": "Used this form of the for loop because I need to get both the requestBundle entry and the corresponding responseBundle entry.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MDc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MzI4MA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503273280", "bodyText": "I think because this is in FHIRPersistence this is OK.... but it seems like something we shouldn't have as a default.", "author": "prb112", "createdAt": "2020-10-12T12:49:59Z", "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/FHIRPersistence.java", "diffHunk": "@@ -130,4 +132,13 @@\n     default boolean isDeleteSupported() {\n         return false;\n     }\n+\n+    /**\n+     * Generates a logical identity.\n+     * \n+     * @return logical identity\n+     */\n+    default String getLogicalId() {\n+        return UUID.randomUUID().toString();\n+    }", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3Mzc0NQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503273745", "bodyText": "also the @OverRide declares it as public.  best to mark this as Public in the interface (rather than the default package)", "author": "prb112", "createdAt": "2020-10-12T12:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MzI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5ODkyMQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503498921", "bodyText": "I removed the default impl and updated the implementing classes to provide a generateResourceId() method. I also explicitly declared all methods in the interface public.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MzI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NDE1Nw==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503274157", "bodyText": "What does this change get us?", "author": "prb112", "createdAt": "2020-10-12T12:51:25Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -289,7 +289,7 @@ protected Action buildActionChain() {\n             // system-generated value. For the update-or-create scenario, see update().\n             // Default version is 1 for a brand new FHIR Resource.\n             int newVersionNumber = 1;\n-            logicalId = logicalIdentityProvider.createNewIdentityValue();\n+            logicalId = getLogicalId();", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2MzUyMQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503463521", "bodyText": "getLogicalId was added to the FHIRPersistence interface, so that it can be called from outside the PL.  basically, he made that piece of it public.\nso now the FHIRRestHelper can delegate to the FHIRPersistence to have it generate a resource id (separate from actually creating a resource)", "author": "lmsurpre", "createdAt": "2020-10-12T18:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3ODAwMw==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503478003", "bodyText": "a-ok", "author": "prb112", "createdAt": "2020-10-12T18:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NTQ2OQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503275469", "bodyText": "Building these test resources programmatically is totally fine, but an alternative you can use is to import a \"minimal\" example via code like this:\nProcedure procedure = TestUtil.readExampleResource(\"json/ibm/minimal/Procedure-1.json\")\nprocedure = procedure.toBuilder().\n        subject(Reference.builder()\n            .reference(com.ibm.fhir.model.type.String.of(\"urn:1\"))\n            .build())\n        .build()\n\nIts most useful if you have resource types with a lot of required fields.", "author": "lmsurpre", "createdAt": "2020-10-12T12:53:45Z", "path": "fhir-server/src/test/java/com/ibm/fhir/server/test/FHIRRestHelperTest.java", "diffHunk": "@@ -0,0 +1,987 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.fail;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Condition;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Practitioner;\n+import com.ibm.fhir.model.resource.Practitioner.Qualification;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.server.util.FHIRRestHelper;\n+\n+public class FHIRRestHelperTest {\n+\n+    /**\n+     * Test transaction bundle post single.\n+     */\n+    @Test\n+    public void testTransactionBundlePostSingle() throws Exception {\n+        FHIRPersistence persistence = new MockPersistenceImpl();\n+        FHIRRestHelper helper = new FHIRRestHelper(persistence);\n+        \n+        Patient patient = Patient.builder().id(\"1\").build();\n+        Bundle.Entry.Request bundleEntryRequest = Bundle.Entry.Request.builder().method(HTTPVerb.POST).url(Uri.of(\"Patient\")).build();\n+        Bundle.Entry bundleEntry = Bundle.Entry.builder().resource(patient).request(bundleEntryRequest).build();\n+        \n+        Bundle requestBundle = Bundle.builder().id(\"bundle1\").type(BundleType.TRANSACTION).entry(bundleEntry).build();\n+\n+        // Process bundle\n+        FHIRRequestContext.get().setOriginalRequestUri(\"test\");\n+        Bundle responseBundle = helper.doBundle(requestBundle, null);\n+        \n+        // Validate results\n+        assertNotNull(responseBundle);\n+        assertEquals(1, responseBundle.getEntry().size());\n+        Bundle.Entry entry = responseBundle.getEntry().get(0);\n+        Bundle.Entry.Response response = entry.getResponse();\n+        assertEquals(\"Patient/generated-0/_history/1\", response.getLocation().getValue());\n+        assertEquals(Integer.toString(Response.Status.CREATED.getStatusCode()), response.getStatus().getValue());\n+    }\n+\n+    /**\n+     * Test transaction bundle post with local reference dependency.\n+     * Procedure has local reference to Patient.\n+     */\n+    @Test\n+    public void testTransactionBundlePostWithDependency() throws Exception {\n+        FHIRPersistence persistence = new MockPersistenceImpl();\n+        FHIRRestHelper helper = new FHIRRestHelper(persistence);\n+        \n+        Patient patient = Patient.builder().id(\"1\").build();\n+        Bundle.Entry.Request bundleEntryRequest = Bundle.Entry.Request.builder().method(HTTPVerb.POST).url(Uri.of(\"Patient\")).build();\n+        Bundle.Entry bundleEntry = Bundle.Entry.builder().fullUrl(Uri.of(\"urn:1\")).resource(patient).request(bundleEntryRequest).build();\n+        \n+        Procedure procedure = Procedure.builder().status(ProcedureStatus.COMPLETED).subject(Reference.builder().reference(com.ibm.fhir.model.type.String.of(\"urn:1\")).build()).build();", "originalCommit": "008e34e27bb1ac44a53af16bbbcc2fbcddb3ef62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NTUxOQ==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503275519", "bodyText": "It might even be worth wrapping that pattern is a new helper method like TestUtil.minimal(Procedure.class) (which would return a new Builder for the passed resource type class, which has just the required fields populated).  Thoughts?", "author": "lmsurpre", "createdAt": "2020-10-12T12:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUwMjIwOA==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503502208", "bodyText": "I did create a new TestUtil.getMinimalResource() method, per your suggestion. However, fhir-server does not currently pull in the fhir-model test-jar, and when I tried updating the pom to do so, I was getting some 'class not found' exceptions, so decided to just go with what I have. We can revisit if you think it's important.", "author": "michaelwschroeder", "createdAt": "2020-10-12T19:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NjU3Mg==", "url": "https://github.com/IBM/FHIR/pull/1560#discussion_r503586572", "bodyText": "not important.  will be interested to see if we can make use of this new method over time...it seems generally useful to me; like a cleaner version of the pattern I described above", "author": "lmsurpre", "createdAt": "2020-10-12T23:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3NTQ2OQ=="}], "type": "inlineReview"}, {"oid": "d9d91346d8390b9342620806b3121cfb00e4b197", "url": "https://github.com/IBM/FHIR/commit/d9d91346d8390b9342620806b3121cfb00e4b197", "message": "Issue #1504 - address review comments\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-10-12T19:39:44Z", "type": "commit"}]}