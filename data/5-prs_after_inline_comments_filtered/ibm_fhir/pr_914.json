{"pr_number": 914, "pr_title": "issue #877 postgresql support ", "pr_createdAt": "2020-04-08T23:45:23Z", "pr_url": "https://github.com/IBM/FHIR/pull/914", "timeline": [{"oid": "2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "url": "https://github.com/IBM/FHIR/commit/2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "62a4402385b0d704c273738bbb03b4531211292e", "url": "https://github.com/IBM/FHIR/commit/62a4402385b0d704c273738bbb03b4531211292e", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "url": "https://github.com/IBM/FHIR/commit/f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "b650b7ded3d70427488aefb0bb060b03c5c77716", "url": "https://github.com/IBM/FHIR/commit/b650b7ded3d70427488aefb0bb060b03c5c77716", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "61446b4c970f123bb5500bb891ead756bd07cb6e", "url": "https://github.com/IBM/FHIR/commit/61446b4c970f123bb5500bb891ead756bd07cb6e", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "592103135de8d5a5cdd1685ba20ba06211ec3295", "url": "https://github.com/IBM/FHIR/commit/592103135de8d5a5cdd1685ba20ba06211ec3295", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "a5cc2af5fc4f1046a8331becb351c8062c88725f", "url": "https://github.com/IBM/FHIR/commit/a5cc2af5fc4f1046a8331becb351c8062c88725f", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "97c4e2fee2028d09575a51ed5898dab5f8eae1cb", "url": "https://github.com/IBM/FHIR/commit/97c4e2fee2028d09575a51ed5898dab5f8eae1cb", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "c280bd8ed0950dd464dc14ef0e3beb78c22c77bb", "url": "https://github.com/IBM/FHIR/commit/c280bd8ed0950dd464dc14ef0e3beb78c22c77bb", "message": "Update fhir-persistence-jdbc/src/test/resources/test.jdbc-perform.properties\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "75d04d67a2e098ae1cb811ffde26af6b4cf3d589", "url": "https://github.com/IBM/FHIR/commit/75d04d67a2e098ae1cb811ffde26af6b4cf3d589", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "3cf72cbfe657b9aff8b9dd3dbbffcfdea32c4c8e", "url": "https://github.com/IBM/FHIR/commit/3cf72cbfe657b9aff8b9dd3dbbffcfdea32c4c8e", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "f021e7b72a9c6c5bc2cf0474af8ea56692adf606", "url": "https://github.com/IBM/FHIR/commit/f021e7b72a9c6c5bc2cf0474af8ea56692adf606", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "3f2f785b68901d83d48871dc637d82a66f784dd9", "url": "https://github.com/IBM/FHIR/commit/3f2f785b68901d83d48871dc637d82a66f784dd9", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "ee91af8d86efc412ce04953b13a53fcf9ae812b7", "url": "https://github.com/IBM/FHIR/commit/ee91af8d86efc412ce04953b13a53fcf9ae812b7", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "96988ad195592e7383ca3448776b7af618dbd508", "url": "https://github.com/IBM/FHIR/commit/96988ad195592e7383ca3448776b7af618dbd508", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "7847fb0d46a21c6b74875df02b4e37630f58e3b7", "url": "https://github.com/IBM/FHIR/commit/7847fb0d46a21c6b74875df02b4e37630f58e3b7", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "dabff61587dff093180804802ba09d7a3fafc683", "url": "https://github.com/IBM/FHIR/commit/dabff61587dff093180804802ba09d7a3fafc683", "message": "Update fhir-persistence-schema/README.md\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "7f8c98e914b9f456b973be3e5ccc383048299754", "url": "https://github.com/IBM/FHIR/commit/7f8c98e914b9f456b973be3e5ccc383048299754", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "949e44de878c7cc7e20afcafc1297bdb640a6317", "url": "https://github.com/IBM/FHIR/commit/949e44de878c7cc7e20afcafc1297bdb640a6317", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "12126fb06f285521180681126d77efbd05aecbfa", "url": "https://github.com/IBM/FHIR/commit/12126fb06f285521180681126d77efbd05aecbfa", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "79f706c179f934c4382d611a16e9d5fe40ed3549", "url": "https://github.com/IBM/FHIR/commit/79f706c179f934c4382d611a16e9d5fe40ed3549", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "8ec4828123b18300d77a17cfc397de50758bd9d9", "url": "https://github.com/IBM/FHIR/commit/8ec4828123b18300d77a17cfc397de50758bd9d9", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "cfd4e260a392bc7ec138c2ae2d2fcca95995de9b", "url": "https://github.com/IBM/FHIR/commit/cfd4e260a392bc7ec138c2ae2d2fcca95995de9b", "message": "issue #877 keep index name unchanged for db2 and derby\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "ccd160ddb04985c7132e495cf2893a3bd4751c33", "url": "https://github.com/IBM/FHIR/commit/ccd160ddb04985c7132e495cf2893a3bd4751c33", "message": "issue #877 minor update to readme of schema tool\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "ccd160ddb04985c7132e495cf2893a3bd4751c33", "url": "https://github.com/IBM/FHIR/commit/ccd160ddb04985c7132e495cf2893a3bd4751c33", "message": "issue #877 minor update to readme of schema tool\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "forcePushed"}, {"oid": "2b4f5788096d92f88828cc8010cc76f42b33f6c1", "url": "https://github.com/IBM/FHIR/commit/2b4f5788096d92f88828cc8010cc76f42b33f6c1", "message": "Merge pull request #912 from IBM/issue-877\n\nIssue 877", "committedDate": "2020-04-08T22:34:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409606111", "bodyText": "Default is recommended to come second...\nhttps://stackoverflow.com/a/16732059/1873438", "author": "prb112", "createdAt": "2020-04-16T14:34:01Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTypeAdapter.java", "diffHunk": "@@ -27,6 +27,14 @@\n      */\n     public String blobClause(long size, int inlineSize);\n \n+    /**\n+     * Generate a clause for double data type\n+     * @return\n+     */\n+    default public String doubleClause() {", "originalCommit": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxODIwMw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409618203", "bodyText": "good to know this, was just thinking to align with existing codes. let me fix them", "author": "albertwang-ibm", "createdAt": "2020-04-16T14:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYzODg2MA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409638860", "bodyText": "I saw this warning in SonarLint", "author": "prb112", "createdAt": "2020-04-16T15:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2MjMzOA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409962338", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-17T02:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409606923", "bodyText": "why is a null being cast?", "author": "prb112", "createdAt": "2020-04-16T14:35:04Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +43,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.\n+        IDatabaseTypeAdapter dbAdapter = null;\n+        String driveClassName = translator.getDriverClassName();\n+        if (driveClassName.contains(\"db2\")) {\n+            dbAdapter = new Db2Adapter((IConnectionProvider)null);", "originalCommit": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNzQ3NQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409607475", "bodyText": "this code doesn't really fit the pattern.", "author": "prb112", "createdAt": "2020-04-16T14:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxNjA2MA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409616060", "bodyText": "yeah, I hate this also, more like a hack, but this is the easy way to pass a suitable IDatabaseTypeAdapter to allow the codes work correctly, the old code doesn't work properly...", "author": "albertwang-ibm", "createdAt": "2020-04-16T14:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4MjE3OA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r410182178", "bodyText": "added new constructor for the db adapters to make the codes better.", "author": "albertwang-ibm", "createdAt": "2020-04-17T12:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NjU0Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409686543", "bodyText": "throw UnsupportedOperation", "author": "prb112", "createdAt": "2020-04-16T16:23:13Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql, so return null\n+        return null;", "originalCommit": "c3ea7ce045570353246610b88513f4f19c17f134", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2MjM3Nw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409962377", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-17T02:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NjU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMTA3Nw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411411077", "bodyText": "I suggest putting this in CommonDatabaseAdapter as a common method", "author": "prb112", "createdAt": "2020-04-20T14:12:17Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +42,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4MzIyMw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411483223", "bodyText": "because this is used by AddColumn only, so let's keep it here for now, if we can move whenever we need in the future.", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMTA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMjQ4Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411412483", "bodyText": "This is good defensive programming.  it's actually checking against a whitelist, and prevents any injection, since this is bundled/shipped, it's worth keeping, and adding a postgres branching logic.", "author": "prb112", "createdAt": "2020-04-20T14:13:59Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY0NDUwNg==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411644506", "bodyText": "good idea. added logic to do this for postgresql only.", "author": "albertwang-ibm", "createdAt": "2020-04-20T19:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMjQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMzE5Nw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411413197", "bodyText": "This is good defensive programming. it's actually checking against a whitelist, and prevents any injection, since this is bundled/shipped, it's worth keeping, and adding a postgres branching logic.", "author": "prb112", "createdAt": "2020-04-20T14:14:52Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));\n+        // Postgresql doesn't support index name prefixed with the schema name.\n+        result.append(indexName);\n         result.append(\" ON \");\n         result.append(getQualifiedName(schemaName, tableName));\n         result.append(\"(\");\n         result.append(join(indexColumns));\n         result.append(\")\");\n-                \n+\n         return result.toString();\n     }\n \n \n     /**\n      * Create the DDL for a plain old index\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-                \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY0NDYwNw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411644607", "bodyText": "good idea. added logic to do this for postgresql only.", "author": "albertwang-ibm", "createdAt": "2020-04-20T19:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMzE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDAwMQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414001", "bodyText": "extra line.", "author": "prb112", "createdAt": "2020-04-20T14:15:55Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NjI5Nw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411486297", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDIzNA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414234", "bodyText": "best to have each entry on a single line", "author": "prb112", "createdAt": "2020-04-20T14:16:09Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NzAxNg==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411487016", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDc2Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414763", "bodyText": "Extra line", "author": "prb112", "createdAt": "2020-04-20T14:16:47Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NzM4Ng==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411487386", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTE2OA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415168", "bodyText": "line space is not needed", "author": "prb112", "createdAt": "2020-04-20T14:17:17Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";\n+        runStatement(ddl);\n+", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4Nzk2OQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411487969", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTg2NA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415864", "bodyText": "start at 1000 always.  it give space to use the ID with specific mappings. for instance RESOURCE_TYPE are hard coded, and we don't want it to client.", "author": "prb112", "createdAt": "2020-04-20T14:18:10Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MjMxMA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411492310", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTk3MQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415971", "bodyText": "Remove cache line", "author": "prb112", "createdAt": "2020-04-20T14:18:18Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MzA4Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411493083", "bodyText": "added cache support to the sql. done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNjE1Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411416153", "bodyText": "move to 1000  per following comments", "author": "prb112", "createdAt": "2020-04-20T14:18:30Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MzUxOQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411493519", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNjE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNzM4MA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411417380", "bodyText": "remove line\n\n  \n    \n      \n        Suggested change", "author": "prb112", "createdAt": "2020-04-20T14:20:03Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODE1MA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418150", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "prb112", "createdAt": "2020-04-20T14:21:04Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+\n+        try (PreparedStatement ps = c.prepareStatement(sql)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getBoolean(1);\n+            }\n+            else {\n+                result = false;\n+            }\n+        }\n+        catch (SQLException x) {\n+            if (translator.isConnectionError(x)) {\n+                throw translator.translate(x);\n+            }\n+            else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODMzNw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418337", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                            result = false;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = false;", "author": "prb112", "createdAt": "2020-04-20T14:21:16Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+\n+        try (PreparedStatement ps = c.prepareStatement(sql)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getBoolean(1);\n+            }\n+            else {\n+                result = false;", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxOTQ5Ng==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411419496", "bodyText": "this else is the one which can be avoided with a declaration of a default outcome to Boolean result;", "author": "prb112", "createdAt": "2020-04-20T14:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODk4Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418983", "bodyText": "you can set to Boolean.False here, and avoid an extra branch down below.", "author": "prb112", "createdAt": "2020-04-20T14:21:57Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjE2Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411496163", "bodyText": "just followed the old codes pattern, make sense to change. done", "author": "albertwang-ibm", "createdAt": "2020-04-20T15:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMDc5NA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411420794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Class Code 23: Constraint Violation\n          \n          \n            \n                    // Class Code 23: Constraint Violation\n          \n          \n            \n                    // Refer to https://www.postgresql.org/docs/12/errcodes-appendix.html for more detail\n          \n      \n    \n    \n  \n\nI always want to know more, the link will help me (since I'm new )", "author": "prb112", "createdAt": "2020-04-20T14:24:18Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTExOA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411421118", "bodyText": "It could be referenced at the top of the class.", "author": "prb112", "createdAt": "2020-04-20T14:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMDc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTgyNg==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411421826", "bodyText": "do we ever need to pass other properties in? How do we handle in Derby and Db2?", "author": "prb112", "createdAt": "2020-04-20T14:25:33Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql\n+        throw new UnsupportedOperationException(\"reorg table is not supported!\");\n+    }\n+\n+    @Override\n+    public String getDriverClassName() {\n+        return \"org.postgresql.Driver\";\n+    }\n+\n+    @Override\n+    public String getUrl(Properties connectionProperties) {\n+        PostgreSqlPropertyAdapter adapter = new PostgreSqlPropertyAdapter(connectionProperties);\n+\n+        return \"jdbc:postgresql://\" + adapter.getHost() + \":\" + adapter.getPort() + \"/\" + adapter.getDatabase();", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNTk5Ng==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411435996", "bodyText": "similar in derby and db2, for db2, it uses more properties to support dashdb.", "author": "albertwang-ibm", "createdAt": "2020-04-20T14:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzOTEzMw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411439133", "bodyText": "OK, this was a curiosity question.  NO worries", "author": "prb112", "createdAt": "2020-04-20T14:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMzIzMA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411423230", "bodyText": "If I could suggest a flip of the code here.  if-then-else can come before, and be assigned to a value.\nthen the builder can be automatically assigned to the InsertStatement", "author": "prb112", "createdAt": "2020-04-20T14:27:21Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/version/AddVersionDAO.java", "diffHunk": "@@ -38,14 +38,18 @@ public AddVersionDAO(String adminSchemaName, String schemaName, String type, Str\n \n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n-\n-        final InsertStatement ins = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n+        InsertStatement.Builder insBuilder = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n                 .addColumn(SchemaConstants.SCHEMA_NAME)\n                 .addColumn(SchemaConstants.OBJECT_TYPE)\n                 .addColumn(SchemaConstants.OBJECT_NAME)\n-                .addColumn(SchemaConstants.VERSION)\n-                .addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\")\n-                .build();\n+                .addColumn(SchemaConstants.VERSION);\n+        if (translator.getDriverClassName().contains(\"postgresql\")) {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT_TIMESTAMP\");\n+        } else {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\");\n+        }\n+\n+        final InsertStatement ins = insBuilder.build();", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwMjM1NA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411502354", "bodyText": "make sense, done", "author": "albertwang-ibm", "createdAt": "2020-04-20T16:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMzIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNDA0Nw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411424047", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public enum FHIRResourceDAOType {\n          \n          \n            \n                // The various DAO Types that are used in the JDBC Persistence layer. \n          \n          \n            \n                public enum DAOType {", "author": "prb112", "createdAt": "2020-04-20T14:28:28Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNDU4MQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411424581", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n      \n    \n    \n  \n\nextra line", "author": "prb112", "createdAt": "2020-04-20T14:29:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTQ3Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411425473", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n          \n          \n            \n               public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n          \n      \n    \n    \n  \n\nI was advised this a long time ago. don't use con.  Con is actually a reserved word on windows.  And a swear in another language.  Search con french. use conn", "author": "prb112", "createdAt": "2020-04-20T14:30:11Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTY4Mg==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411425682", "bodyText": "same comment as above", "author": "prb112", "createdAt": "2020-04-20T14:30:27Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+\n+    public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwNjcwMA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411506700", "bodyText": "done", "author": "albertwang-ibm", "createdAt": "2020-04-20T16:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNjk2OA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411426968", "bodyText": "This feels like it should go into the another class", "author": "prb112", "createdAt": "2020-04-20T14:32:03Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceDAOImpl.java", "diffHunk": "@@ -459,40 +461,19 @@ public void addResourceTypeCacheCandidate(String resourceType, Integer resourceT\n \n     }\n \n-    @Override\n-    public Resource insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n-            throws FHIRPersistenceException {\n-        final String METHODNAME = \"insert(Resource, List<ExtractedParameterValue>\";\n-        log.entering(CLASSNAME, METHODNAME);\n+    public boolean isPostgreSqlDatabase() throws FHIRPersistenceDBConnectException, SQLException {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwODIxNA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411508214", "bodyText": "good catch, I forgot to remove it. it should have been dropped in my refactoring. done", "author": "albertwang-ibm", "createdAt": "2020-04-20T16:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNjk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyODMyOQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411428329", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "prb112", "createdAt": "2020-04-20T14:33:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirRefSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_REF_SEQUENCE\n+ *\n+ */\n+public class FhirRefSequenceDAOImpl implements FhirRefSequenceDAO {\n+    private final Connection conn;\n+\n+    /**\n+     * Public constructor\n+     */\n+    public FhirRefSequenceDAOImpl(Connection c) {\n+        this.conn = c;\n+    }\n+\n+    @Override\n+    public int nextValue() throws SQLException {\n+        int result;\n+        final String SEQ = \"select nextval('fhir_ref_sequence')\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(SEQ)) {\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyODU2OQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411428569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "author": "prb112", "createdAt": "2020-04-20T14:34:03Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_SEQUENCE\n+ *", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyOTgwOQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411429809", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-04-20T14:35:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDM3MA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430370", "bodyText": "is sql1 special ? just curious about sql1 meaning.", "author": "prb112", "createdAt": "2020-04-20T14:36:26Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwOTA4OA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411509088", "bodyText": "not really, let me change to sql. done", "author": "albertwang-ibm", "createdAt": "2020-04-20T16:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDQ4Ng==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430486", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-04-20T14:36:36Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+\n+        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n+            stmt.setString(1, parameterName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {\n+                result = null;\n+            }\n+        }\n+        catch (SQLException x) {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDY3OA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        }  else {", "author": "prb112", "createdAt": "2020-04-20T14:36:50Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+\n+        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n+            stmt.setString(1, parameterName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTMxOQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411431319", "bodyText": "Do we want to use DSTU2 reference? I think we should remove.", "author": "prb112", "createdAt": "2020-04-20T14:37:45Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMjE5OQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411432199", "bodyText": "Also we probably just want to reference db2, we haven't used GTTs recently.", "author": "prb112", "createdAt": "2020-04-20T14:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxMTA4OA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411511088", "bodyText": "updated the comments, done", "author": "albertwang-ibm", "createdAt": "2020-04-20T16:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTkyNQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411431925", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Data access object for writing FHIR resources to an Apache PostgreSql database.\n          \n          \n            \n             * Data access object for writing FHIR resources to an PostgreSql database.", "author": "prb112", "createdAt": "2020-04-20T14:38:30Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMjQzOA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411432438", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-04-20T14:39:10Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzE2MA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433160", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "prb112", "createdAt": "2020-04-20T14:40:03Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzMyNQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433325", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "author": "prb112", "createdAt": "2020-04-20T14:40:14Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzYwOA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            }  else {", "author": "prb112", "createdAt": "2020-04-20T14:40:34Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzc2OA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433768", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                }\n          \n          \n            \n                                else {\n          \n          \n            \n                                    // Extremely unlikely as we should never delete logical resource records\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    // Extremely unlikely as we should never delete logical resource records", "author": "prb112", "createdAt": "2020-04-20T14:40:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzk0NQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "prb112", "createdAt": "2020-04-20T14:40:58Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDE5MQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434191", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "author": "prb112", "createdAt": "2020-04-20T14:41:15Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDQwMw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "author": "prb112", "createdAt": "2020-04-20T14:41:30Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDUyMQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434521", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                    } else {", "author": "prb112", "createdAt": "2020-04-20T14:41:40Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDY2Nw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "prb112", "createdAt": "2020-04-20T14:41:49Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            }\n+            else {", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDgxMQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434811", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                            result = null;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = null;", "author": "prb112", "createdAt": "2020-04-20T14:42:03Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            }\n+            else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;\n+\n+        final String sql1 = \"SELECT resource_type_id FROM resource_types WHERE resource_type = ?\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(sql1)) {\n+            stmt.setString(1, resourceTypeName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {\n+                result = null;", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjMzMw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411436333", "bodyText": "no grants?\nIf we are not implementing here, we should create a backlog issue.", "author": "prb112", "createdAt": "2020-04-20T14:43:57Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -765,7 +778,7 @@ protected void process() {\n      * @param groupName\n      */\n     protected void grantPrivileges(String groupName) {\n-        if (dbType == DbType.DERBY) {\n+        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n             return;", "originalCommit": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0NDY0NQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411444645", "bodyText": "yes, not needed in my test for the postgresql support.\naccording to my instruction, fhirserver user is grant full access to the database, and also create/update schema uses fhirserver user. so seems no access issue for postgresql so far.", "author": "albertwang-ibm", "createdAt": "2020-04-20T14:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3ODgxOA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411578818", "bodyText": "added issue #946 for this", "author": "albertwang-ibm", "createdAt": "2020-04-20T17:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MDAxNg==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411440016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n          \n          \n            \n                        String dbUrl = con.getMetaData().getURL();\n          \n          \n            \n                        dbUrl = dbUrl.toLowerCase();\n          \n          \n            \n                        if (dbUrl.contains(DB2.value)) {\n          \n          \n            \n                            return DB2;\n          \n          \n            \n                        } else if (dbUrl.contains(DERBY.value)) {\n          \n          \n            \n                            return DERBY;\n          \n          \n            \n                        } else if (dbUrl.contains(POSTGRESQL.value)) {\n          \n          \n            \n                            return POSTGRESQL;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            throw new IllegalArgumentException(dbUrl);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                    public static FHIRResourceDAOType of(Connection conn) throws SQLException, IllegalArgumentException {\n          \n          \n            \n                        String dbUrl = conn.getMetaData().getURL();\n          \n          \n            \n                        dbUrl = dbUrl.toLowerCase();\n          \n          \n            \n                        if (dbUrl.contains(DB2.value)) {\n          \n          \n            \n                            return DB2;\n          \n          \n            \n                        } else if (dbUrl.contains(DERBY.value)) {\n          \n          \n            \n                            return DERBY;\n          \n          \n            \n                        } else if (dbUrl.contains(POSTGRESQL.value)) {\n          \n          \n            \n                            return POSTGRESQL;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            throw new IllegalArgumentException(dbUrl);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-04-20T14:48:38Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    // The various DAO Types that are used in the JDBC Persistence layer. \n+    public enum DAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }", "originalCommit": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MDQ4Mw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411440483", "bodyText": "might be worthwhile to have a null check at the very beginning.", "author": "prb112", "createdAt": "2020-04-20T14:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MDAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MTExMw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411441113", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {\n          \n          \n            \n                    ResourceDAO resourceDAO = null;\n          \n          \n            \n                    switch (FHIRResourceDAOType.of(con)) {\n          \n          \n            \n                        case DB2:\n          \n          \n            \n                            resourceDAO = new ResourceDAOImpl(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case DERBY:\n          \n          \n            \n                            resourceDAO = new DerbyResourceDAO(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case POSTGRESQL:\n          \n          \n            \n                            resourceDAO = new PostgreSqlResourceDAO(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                    }\n          \n          \n            \n                    return resourceDAO;\n          \n          \n            \n                }\n          \n          \n            \n                public static ResourceDAO getResourceDAO (Connection conn) throws IllegalArgumentException, SQLException {\n          \n          \n            \n                    ResourceDAO resourceDAO = null;\n          \n          \n            \n                    switch (FHIRResourceDAOType.of(conn)) {\n          \n          \n            \n                        case DB2:\n          \n          \n            \n                            resourceDAO = new ResourceDAOImpl(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case DERBY:\n          \n          \n            \n                            resourceDAO = new DerbyResourceDAO(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case POSTGRESQL:\n          \n          \n            \n                            resourceDAO = new PostgreSqlResourceDAO(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                    }\n          \n          \n            \n                    return resourceDAO;\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-04-20T14:50:00Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    // The various DAO Types that are used in the JDBC Persistence layer. \n+    public enum DAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+    public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(con);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(con);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(con);\n+                break;\n+        }\n+        return resourceDAO;\n+    }", "originalCommit": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MTkwMA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411441900", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "prb112", "createdAt": "2020-04-20T14:50:58Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_SEQUENCE\n+ */\n+public class FhirSequenceDAOImpl implements FhirSequenceDAO {\n+    private final Connection conn;\n+\n+    /**\n+     * Public constructor\n+     */\n+    public FhirSequenceDAOImpl(Connection c) {\n+        this.conn = c;\n+    }\n+\n+    @Override\n+    public long nextValue() throws SQLException {\n+        long result;\n+        final String SEQ = \"select nextval('fhir_sequence')\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(SEQ)) {\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getLong(1);\n+            }\n+            else {", "originalCommit": "861db13b68349b21a0bfcaff0945ee48d74fde2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MTI4OQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411451289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n      \n    \n    \n  \n\nunneeded line", "author": "prb112", "createdAt": "2020-04-20T15:02:36Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+", "originalCommit": "861db13b68349b21a0bfcaff0945ee48d74fde2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MzMyOA==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453328", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Alpha version uses last_updated time from the app-server, so we keep that here\n          \n          \n            \n                     * uses last_updated time from the app-server, so we have consistency between the various DAOs", "author": "prb112", "createdAt": "2020-04-20T15:05:02Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here", "originalCommit": "861db13b68349b21a0bfcaff0945ee48d74fde2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1Mzc2Nw==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453767", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-04-20T15:05:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+", "originalCommit": "861db13b68349b21a0bfcaff0945ee48d74fde2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1Mzk3MQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453971", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Integer result;\n          \n          \n            \n                    Integer result = null;", "author": "prb112", "createdAt": "2020-04-20T15:05:49Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;", "originalCommit": "861db13b68349b21a0bfcaff0945ee48d74fde2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1NDE5MQ==", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411454191", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            result = rs.getInt(1);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = null;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                            result = rs.getInt(1);\n          \n          \n            \n                        }\n          \n          \n            \n                    }", "author": "prb112", "createdAt": "2020-04-20T15:06:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;\n+\n+        final String sql1 = \"SELECT resource_type_id FROM resource_types WHERE resource_type = ?\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(sql1)) {\n+            stmt.setString(1, resourceTypeName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            } else {\n+                result = null;\n+            }\n+        }\n+", "originalCommit": "861db13b68349b21a0bfcaff0945ee48d74fde2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b1a390133d862dde7ce3bee1b89162a7c86236d", "url": "https://github.com/IBM/FHIR/commit/8b1a390133d862dde7ce3bee1b89162a7c86236d", "message": "issue #913 isExportPublic setting is not per-tenant\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "d963a109e28bec0a42a6b27d3ab7e1ffa7380687", "url": "https://github.com/IBM/FHIR/commit/d963a109e28bec0a42a6b27d3ab7e1ffa7380687", "message": "issue #877 initial code drop for postgresql support\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "e41222ced416f81baf5cd2b6f020a4bf9daae435", "url": "https://github.com/IBM/FHIR/commit/e41222ced416f81baf5cd2b6f020a4bf9daae435", "message": "issue #877 properties files for postgresql test\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "8f6810da67d43c8ea279775fdb2c5a2d555176a6", "url": "https://github.com/IBM/FHIR/commit/8f6810da67d43c8ea279775fdb2c5a2d555176a6", "message": "issue #877 update jdbc test properties files and document\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "18a7f0197b4d168ca4d095260d5834514cf764ea", "url": "https://github.com/IBM/FHIR/commit/18a7f0197b4d168ca4d095260d5834514cf764ea", "message": "issue #877 add postgresql to server configure\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "26a853a034db321fcfa9f92682bf2bce6f94cab8", "url": "https://github.com/IBM/FHIR/commit/26a853a034db321fcfa9f92682bf2bce6f94cab8", "message": "issue #877 add postgresql to schema management readme.\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "3cdb2a88d5ad3762b6298414adfe75e826b132cb", "url": "https://github.com/IBM/FHIR/commit/3cdb2a88d5ad3762b6298414adfe75e826b132cb", "message": "issue #877 add postgresql driver dir in server.xml\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "d69aabb19d79832220c793d401b3c406505148ed", "url": "https://github.com/IBM/FHIR/commit/d69aabb19d79832220c793d401b3c406505148ed", "message": "issue #877 code refactor\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "f91ce0d77d237a0ffa6911eb5786fde1039eb1ae", "url": "https://github.com/IBM/FHIR/commit/f91ce0d77d237a0ffa6911eb5786fde1039eb1ae", "message": "issue #877 change server.xml per review comments\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "4c4f876169d14d17c54c18a6b64325f0edc9d29c", "url": "https://github.com/IBM/FHIR/commit/4c4f876169d14d17c54c18a6b64325f0edc9d29c", "message": "issue #877 minor document update\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "ee000cc54b9d48050c345b498da8a100bef611f0", "url": "https://github.com/IBM/FHIR/commit/ee000cc54b9d48050c345b498da8a100bef611f0", "message": "issue #877 Enable postgresql as javabatch job repo\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "63b42efb9b160491ebc4eca57972c8e9cfbcc4d9", "url": "https://github.com/IBM/FHIR/commit/63b42efb9b160491ebc4eca57972c8e9cfbcc4d9", "message": "issue #877 minor update to instruction\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "ce5b2bb2590650023867ea2579e8cdf23cb1f848", "url": "https://github.com/IBM/FHIR/commit/ce5b2bb2590650023867ea2579e8cdf23cb1f848", "message": "issue #877 updates per review comments\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "0fd1ad735a810d16db7a331650026f8a73d7941f", "url": "https://github.com/IBM/FHIR/commit/0fd1ad735a810d16db7a331650026f8a73d7941f", "message": "issue #877 minor update to comments of postgresql batch ddl\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "e2904dd442454b102bdc9525e91cb4ec388f1d4b", "url": "https://github.com/IBM/FHIR/commit/e2904dd442454b102bdc9525e91cb4ec388f1d4b", "message": "issue #877 update codes for addcolum\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "2043f180e5c68366e3ad19fb5cf2f515b8a36dd5", "url": "https://github.com/IBM/FHIR/commit/2043f180e5c68366e3ad19fb5cf2f515b8a36dd5", "message": "issue #877 minor update to force a rebuild\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "815f16890dd6300107f4d503bb11ab93fb6e1f7b", "url": "https://github.com/IBM/FHIR/commit/815f16890dd6300107f4d503bb11ab93fb6e1f7b", "message": "Update docs/src/pages/guides/FHIRServerUsersGuide.md\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "19dee0b948c58336d34fbda5f357640318d222dc", "url": "https://github.com/IBM/FHIR/commit/19dee0b948c58336d34fbda5f357640318d222dc", "message": "Update docs/src/pages/guides/FHIRServerUsersGuide.md\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "e98dabddc63da6676e4d67c78db617c7f48852e3", "url": "https://github.com/IBM/FHIR/commit/e98dabddc63da6676e4d67c78db617c7f48852e3", "message": "Update fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "aa8a6b8a72f6509d7a32bca329258c93317391d3", "url": "https://github.com/IBM/FHIR/commit/aa8a6b8a72f6509d7a32bca329258c93317391d3", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "116f282fbac23c9c22e7d77226db17a9b08a28d8", "url": "https://github.com/IBM/FHIR/commit/116f282fbac23c9c22e7d77226db17a9b08a28d8", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "5c59d7bd49a0beed125c2a08fd5d90228715c304", "url": "https://github.com/IBM/FHIR/commit/5c59d7bd49a0beed125c2a08fd5d90228715c304", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "d5260182f56b12f18c9ec8b6b6cfe0a3d0c5f68b", "url": "https://github.com/IBM/FHIR/commit/d5260182f56b12f18c9ec8b6b6cfe0a3d0c5f68b", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "9f7d98d771c0964c47ce5b8d11f9c59c2a37b060", "url": "https://github.com/IBM/FHIR/commit/9f7d98d771c0964c47ce5b8d11f9c59c2a37b060", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "fec6c21810781939d263dd5345b3507318550658", "url": "https://github.com/IBM/FHIR/commit/fec6c21810781939d263dd5345b3507318550658", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirRefSequenceDAOImpl.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "c8cd6ad205d2fa92c6c6d980f3f6a43f66e0fb88", "url": "https://github.com/IBM/FHIR/commit/c8cd6ad205d2fa92c6c6d980f3f6a43f66e0fb88", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "7689d34718edde99c337c4760f14a456bd80e2dd", "url": "https://github.com/IBM/FHIR/commit/7689d34718edde99c337c4760f14a456bd80e2dd", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "48a79eb2b71f7fb1f12a279ede1bf3958f92b9b5", "url": "https://github.com/IBM/FHIR/commit/48a79eb2b71f7fb1f12a279ede1bf3958f92b9b5", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "22da532b8134a6c2d123bee531373c774529ec00", "url": "https://github.com/IBM/FHIR/commit/22da532b8134a6c2d123bee531373c774529ec00", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:26Z", "type": "commit"}, {"oid": "2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "url": "https://github.com/IBM/FHIR/commit/2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "62a4402385b0d704c273738bbb03b4531211292e", "url": "https://github.com/IBM/FHIR/commit/62a4402385b0d704c273738bbb03b4531211292e", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "url": "https://github.com/IBM/FHIR/commit/f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "b650b7ded3d70427488aefb0bb060b03c5c77716", "url": "https://github.com/IBM/FHIR/commit/b650b7ded3d70427488aefb0bb060b03c5c77716", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "61446b4c970f123bb5500bb891ead756bd07cb6e", "url": "https://github.com/IBM/FHIR/commit/61446b4c970f123bb5500bb891ead756bd07cb6e", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}, {"oid": "0acd7d043ee0b0c028a595af3a4ef35b05f3ad7a", "url": "https://github.com/IBM/FHIR/commit/0acd7d043ee0b0c028a595af3a4ef35b05f3ad7a", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-04-20T19:39:27Z", "type": "commit"}]}