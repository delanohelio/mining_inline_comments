{"pr_number": 1666, "pr_title": "Issue #1218 - enable reverse chain (_has) search", "pr_createdAt": "2020-11-03T22:16:47Z", "pr_url": "https://github.com/IBM/FHIR/pull/1666", "timeline": [{"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "url": "https://github.com/IBM/FHIR/commit/902162ddb39a92a6bd334e2dc3bfc6e856125125", "message": "Issue #1218 - enable reverse chain (_has) search\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-11-03T22:14:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTUzMQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517335531", "bodyText": "Just as a form, since we are using a StringBuilder let's build the string with it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                    .append(\" AS \" + paramTableAlias)\n          \n          \n            \n                                                    .append(\" AS \").append(paramTableAlias)", "author": "prb112", "createdAt": "2020-11-04T13:18:22Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/QuerySegmentAggregator.java", "diffHunk": "@@ -555,20 +555,35 @@ protected void buildWhereClause(StringBuilder whereClause, String overrideType)\n                     whereClause.append(whereClauseSegment);\n                 } else {\n                     if (!Type.COMPOSITE.equals(param.getType())) {\n-                        // Join a standard parameter table\n-                        //   JOIN Observation_TOKEN_VALUES AS param0\n-                        //     ON param0.PARAMETER_NAME_ID=1191 AND param0.TOKEN_VALUE = :p1\n-                        //    AND param0.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n-\n                         final String paramTableAlias = \"param\" + i;\n-                        final String onFilter = querySegment.getQueryString().replaceAll(PARAMETER_TABLE_ALIAS + \"\\\\.\", paramTableAlias + \".\");\n-\n-                        whereClause.append(JOIN);\n-                        whereClause.append(tableName(overrideType, param));\n-                        whereClause.append(\" AS \" + paramTableAlias);\n-                        whereClause.append(ON);\n-                        whereClause.append(onFilter);\n-                        whereClause.append(\" AND LR.LOGICAL_RESOURCE_ID = \" + paramTableAlias + \".LOGICAL_RESOURCE_ID\");\n+                        if (param.isReverseChained()) {\n+                            // Join on a select from logical resource table\n+                            //   JOIN (\n+                            //     SELECT CLR0.LOGICAL_ID FROM Observation_LOGICAL_RESOURCES AS CLR0\n+                            //       ...\n+                            //   ) AS param0 ON LR.LOGICAL_ID = param0.LOGICAL_ID\n+                            whereClause.append(JOIN)\n+                                        .append(LEFT_PAREN);\n+                            whereClause.append(querySegment.getQueryString());\n+                            whereClause.append(RIGHT_PAREN)\n+                                        .append(\" AS \" + paramTableAlias)", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNTIzOQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517615239", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTY4Ng==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517335686", "bodyText": "Just as a form, since we are using a StringBuilder let's build the string with it.", "author": "prb112", "createdAt": "2020-11-04T13:18:40Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/QuerySegmentAggregator.java", "diffHunk": "@@ -555,20 +555,35 @@ protected void buildWhereClause(StringBuilder whereClause, String overrideType)\n                     whereClause.append(whereClauseSegment);\n                 } else {\n                     if (!Type.COMPOSITE.equals(param.getType())) {\n-                        // Join a standard parameter table\n-                        //   JOIN Observation_TOKEN_VALUES AS param0\n-                        //     ON param0.PARAMETER_NAME_ID=1191 AND param0.TOKEN_VALUE = :p1\n-                        //    AND param0.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n-\n                         final String paramTableAlias = \"param\" + i;\n-                        final String onFilter = querySegment.getQueryString().replaceAll(PARAMETER_TABLE_ALIAS + \"\\\\.\", paramTableAlias + \".\");\n-\n-                        whereClause.append(JOIN);\n-                        whereClause.append(tableName(overrideType, param));\n-                        whereClause.append(\" AS \" + paramTableAlias);\n-                        whereClause.append(ON);\n-                        whereClause.append(onFilter);\n-                        whereClause.append(\" AND LR.LOGICAL_RESOURCE_ID = \" + paramTableAlias + \".LOGICAL_RESOURCE_ID\");\n+                        if (param.isReverseChained()) {\n+                            // Join on a select from logical resource table\n+                            //   JOIN (\n+                            //     SELECT CLR0.LOGICAL_ID FROM Observation_LOGICAL_RESOURCES AS CLR0\n+                            //       ...\n+                            //   ) AS param0 ON LR.LOGICAL_ID = param0.LOGICAL_ID\n+                            whereClause.append(JOIN)\n+                                        .append(LEFT_PAREN);\n+                            whereClause.append(querySegment.getQueryString());\n+                            whereClause.append(RIGHT_PAREN)\n+                                        .append(\" AS \" + paramTableAlias)\n+                                        .append(ON)\n+                                        .append(\"LR.LOGICAL_ID = \" + paramTableAlias + \".LOGICAL_ID\");", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNTM0Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517615343", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzOTc3Ng==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517339776", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testDeleteResources() {\n          \n          \n            \n                public void testDeleteResources() {\n          \n      \n    \n    \n  \n\nnot a test per say?", "author": "prb112", "createdAt": "2020-11-04T13:25:23Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNTczMw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517615733", "bodyText": "correct, just following pattern of one of the other tests to cleanup resources", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzOTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI3Nw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517342277", "bodyText": "If I follow...\n1st part\n_has:Patient:patient:\nIt's always going to run the param.getChain (it'll have at least one entry)\nThen loops...\nOK - this makes sense to me - I just needed to write this out, leaving here for others as they review.", "author": "prb112", "createdAt": "2020-11-04T13:29:30Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/uri/UriBuilder.java", "diffHunk": "@@ -279,4 +281,38 @@ private void appendChainedParm(QueryParameter param, StringBuilder returnString)\n         }\n     }\n \n+    /*\n+     * creates a reverse chained parameter\n+     *\n+     * @param param\n+     *\n+     * @param returnString\n+     */\n+    private void appendReverseChainedParm(QueryParameter param, StringBuilder returnString) {\n+        // Build initial string: \"_has:<reference-resource-type>:<refernece-search-parm>:\n+        returnString.append(SearchConstants.HAS)\n+                    .append(SearchConstants.COLON_DELIMITER)\n+                    .append(param.getModifierResourceTypeName())\n+                    .append(SearchConstants.COLON_DELIMITER)\n+                    .append(param.getCode())\n+                    .append(SearchConstants.COLON_DELIMITER);\n+\n+        // Loop through chained parms to build chained strings\n+        for (QueryParameter revChainParam : param.getChain()) {\n+            if (revChainParam.isReverseChained()) {\n+                returnString.append(SearchConstants.HAS)\n+                            .append(SearchConstants.COLON_DELIMITER)\n+                            .append(revChainParam.getModifierResourceTypeName())\n+                            .append(SearchConstants.COLON_DELIMITER)\n+                            .append(revChainParam.getCode())\n+                            .append(SearchConstants.COLON_DELIMITER);\n+            } else if (revChainParam.isChained()) {\n+                appendChainedParm(revChainParam, returnString);\n+                returnString.append(SearchConstants.CHAINED_PARAMETER_CHARACTER);\n+            } else {\n+                appendNormalParameter(revChainParam, returnString);", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk1NQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517342955", "bodyText": "good test", "author": "prb112", "createdAt": "2020-11-04T13:30:35Z", "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/RevChainParameterParseTest.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.search.test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.search.SearchConstants.Modifier;\n+import com.ibm.fhir.search.SearchConstants.Type;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.parameters.QueryParameter;\n+import com.ibm.fhir.search.parameters.QueryParameterValue;\n+import com.ibm.fhir.search.util.SearchUtil;\n+\n+/**\n+ * This TestNG test class contains methods that test the parsing of reverse chain search parameters\n+ * (_has) in the SearchUtil class.\n+ */\n+public class RevChainParameterParseTest extends BaseSearchTest {\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainWithTypeException() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Resource> resourceType = Resource.class;\n+\n+        queryParameters.put(\"_type\", Collections.singletonList(\"Patient\"));\n+        queryParameters.put(\"_has:Observation:subject:code\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainParseException1() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainParseException2() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:Observation\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainParseException3() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainBadReferenceTypeException() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:BadType:subject:code\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainBadReferenceSearchParmException() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:Procedure:badSearchParm:code\", Collections.singletonList(\"xxx\"));", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NDY2MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517344661", "bodyText": "slight comment\nIn Exception cases String.format, we as a team deem it to be OK, but it is actually slower than assembling a string.  (I mention this as John and I had a deep discussion about StringBuilding performance when I made a similar change in this class).", "author": "prb112", "createdAt": "2020-11-04T13:33:24Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -756,20 +772,16 @@ public static FHIRSearchContext parseQueryParameters(Class<?> resourceType,\n                           // Get the search parameter from our filtered set of applicable SPs for this resource type.\n                           searchParameter = getSearchParameter(resType, parameterCode);\n                           if (searchParameter == null) {\n-                              String msg =\n-                                      \"Search parameter '\" + parameterCode + \"' for resource type '\"\n-                                              + resType + \"' was not found.\";\n-                              throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                              throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                                  String.format(SEARCH_PARAMETER_NOT_FOUND, parameterCode, resType));", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA5ODE4NQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518098185", "bodyText": "+1. And to add to this, although it's not the case here it's important exceptions are never used for flow control in the \"happy path\" case because they are expensive to build.", "author": "punktilious", "createdAt": "2020-11-05T14:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NDY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NTgxOQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517345819", "bodyText": "mentioning this as it's the Eclipse Formatter control (turns on/off)\n@formatter:off \n@formatter:on", "author": "prb112", "createdAt": "2020-11-04T13:35:13Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNjE1MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517616151", "bodyText": "added annotations", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NTgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NjQzMQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517346431", "bodyText": "It's actually a code.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static boolean isReverseChainedParameter(String name) {\n          \n          \n            \n                public static boolean isReverseChainedParameter(String code) {", "author": "prb112", "createdAt": "2020-11-04T13:36:07Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1370,6 +1382,10 @@ public static boolean isChainedParameter(String name) {\n         return name.contains(SearchConstants.CHAINED_PARAMETER_CHARACTER);\n     }\n \n+    public static boolean isReverseChainedParameter(String name) {", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNjMyOA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517616328", "bodyText": "renamed to code", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NjQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NjUyMg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517346522", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return name.startsWith(SearchConstants.HAS);\n          \n          \n            \n                    return code.startsWith(SearchConstants.HAS);", "author": "prb112", "createdAt": "2020-11-04T13:36:16Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1370,6 +1382,10 @@ public static boolean isChainedParameter(String name) {\n         return name.contains(SearchConstants.CHAINED_PARAMETER_CHARACTER);\n     }\n \n+    public static boolean isReverseChainedParameter(String name) {\n+        return name.startsWith(SearchConstants.HAS);", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNjQxMw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517616413", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NjUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NzQzMQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517347431", "bodyText": "I think substring might be preferred here instead of replaceFirst. it'll always be a fixed length.", "author": "prb112", "createdAt": "2020-11-04T13:37:35Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNjU4MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517616581", "bodyText": "changed to use substring", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NzQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0OTAwNQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517649005", "bodyText": "fyi, changed back to using replaceFirst to handle case where the reverseChainParameterString might just be '_has'. If using substring, I'd have to first check the length of reverseChainParameterString before substringing past the expected initial '_has:' string.", "author": "michaelwschroeder", "createdAt": "2020-11-04T21:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NzQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NzkxMA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517347910", "bodyText": "I'm almost positive in modern compilers this ends up getting inlined, however, it's worth making your own static final constant.", "author": "prb112", "createdAt": "2020-11-04T13:38:25Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNjc1MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517616751", "bodyText": "created constant", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MDY3OA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517350678", "bodyText": "at this point in the code would referenceSearchParameter.getType ever be null?\nI don't think so at this point in the model this will be null as the type | \u03a3 | 1..1 | code\nThis is good.  Leaving my note here.", "author": "prb112", "createdAt": "2020-11-04T13:42:35Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTEyNw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517351127", "bodyText": "This can only be an emptyList in the worst case.  I think this is good.", "author": "prb112", "createdAt": "2020-11-04T13:43:14Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTM1Nw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517351357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else {\n          \n          \n            \n                                if (rootParameter.getChain().isEmpty()) {\n          \n          \n            \n                            } else if (rootParameter.getChain().isEmpty()) {", "author": "prb112", "createdAt": "2020-11-04T13:43:35Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(TARGET_TYPE_OF_REFERENCE_PARAMETER_NOT_VALID_FOR_REVERSE_CHAIN_SEARCH,\n+                            referenceSearchParameterName, resourceType.getSimpleName()));\n+                }\n+\n+                // Create new QueryParameter\n+                QueryParameter parameter = new QueryParameter(Type.REFERENCE, referenceSearchParameterName, Modifier.TYPE, referencedByResourceTypeName, false, true);\n+                if (rootParameter == null) {\n+                    rootParameter = parameter;\n+                } else {\n+                    if (rootParameter.getChain().isEmpty()) {", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTU4Mg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517351582", "bodyText": "The Else if / Else seems like it could be reduced one level", "author": "prb112", "createdAt": "2020-11-04T13:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzA1Ng==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517617056", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MjQ2OA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517352468", "bodyText": "we should probably surround the modifierName with single quotes\nWe might want to URL encode it as well", "author": "prb112", "createdAt": "2020-11-04T13:45:21Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(TARGET_TYPE_OF_REFERENCE_PARAMETER_NOT_VALID_FOR_REVERSE_CHAIN_SEARCH,\n+                            referenceSearchParameterName, resourceType.getSimpleName()));\n+                }\n+\n+                // Create new QueryParameter\n+                QueryParameter parameter = new QueryParameter(Type.REFERENCE, referenceSearchParameterName, Modifier.TYPE, referencedByResourceTypeName, false, true);\n+                if (rootParameter == null) {\n+                    rootParameter = parameter;\n+                } else {\n+                    if (rootParameter.getChain().isEmpty()) {\n+                        rootParameter.setNextParameter(parameter);\n+                    } else {\n+                        rootParameter.getChain().getLast().setNextParameter(parameter);\n+                    }\n+                }\n+\n+                if (currentIndex == lastIndex) {\n+                    // Add last search parameter\n+                    String parameterName = subcomponents.get(2);\n+                    if (isChainedParameter(parameterName)) {\n+                        QueryParameter lastParameter = parseChainedParameter(referencedByResourceType, parameterName, valuesString);\n+                        if (rootParameter.getChain().isEmpty()) {\n+                            rootParameter.setNextParameter(lastParameter);\n+                        } else {\n+                            rootParameter.getChain().getLast().setNextParameter(lastParameter);\n+                        }\n+                    } else {\n+                        String modifierName = null;\n+                        Modifier modifier = null;\n+                        String modifierResourceTypeName = null;\n+\n+                        // Check if modifier is specified\n+                        int index = parameterName.indexOf(\":\");\n+                        if (index != -1) {\n+                            modifierName = parameterName.substring(index + 1);\n+                            parameterName = parameterName.substring(0, index);\n+                        }\n+\n+                        SearchParameter searchParameter = getSearchParameter(referencedByResourceType, parameterName);\n+                        if (searchParameter == null) {\n+                            throw SearchExceptionUtil.buildNewInvalidSearchException(String.format(SEARCH_PARAMETER_NOT_FOUND, parameterName, referencedByResourceTypeName));\n+                        }\n+                        Type type = Type.fromValue(searchParameter.getType().getValue());\n+\n+                        if (modifierName != null) {\n+                            if (ModelSupport.isResourceType(modifierName)) {\n+                                modifier = Modifier.TYPE;\n+                                modifierResourceTypeName = modifierName;\n+                            } else {\n+                                try {\n+                                    modifier = Modifier.fromValue(modifierName);\n+                                } catch (IllegalArgumentException e) {\n+                                    String msg = \"Undefined Modifier: \" + modifierName;", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzE3MA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517617170", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MjQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MjgyNA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517352824", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            String msg = \"Unsupported type/modifier combination: \" + type.value() + \"/\" + modifier.value();\n          \n          \n            \n                                            String msg = \"Unsupported type/modifier combination: '\" + type.value() + \"/\" + modifier.value() +\"'\";\n          \n      \n    \n    \n  \n\nAdd single quotes", "author": "prb112", "createdAt": "2020-11-04T13:45:54Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(TARGET_TYPE_OF_REFERENCE_PARAMETER_NOT_VALID_FOR_REVERSE_CHAIN_SEARCH,\n+                            referenceSearchParameterName, resourceType.getSimpleName()));\n+                }\n+\n+                // Create new QueryParameter\n+                QueryParameter parameter = new QueryParameter(Type.REFERENCE, referenceSearchParameterName, Modifier.TYPE, referencedByResourceTypeName, false, true);\n+                if (rootParameter == null) {\n+                    rootParameter = parameter;\n+                } else {\n+                    if (rootParameter.getChain().isEmpty()) {\n+                        rootParameter.setNextParameter(parameter);\n+                    } else {\n+                        rootParameter.getChain().getLast().setNextParameter(parameter);\n+                    }\n+                }\n+\n+                if (currentIndex == lastIndex) {\n+                    // Add last search parameter\n+                    String parameterName = subcomponents.get(2);\n+                    if (isChainedParameter(parameterName)) {\n+                        QueryParameter lastParameter = parseChainedParameter(referencedByResourceType, parameterName, valuesString);\n+                        if (rootParameter.getChain().isEmpty()) {\n+                            rootParameter.setNextParameter(lastParameter);\n+                        } else {\n+                            rootParameter.getChain().getLast().setNextParameter(lastParameter);\n+                        }\n+                    } else {\n+                        String modifierName = null;\n+                        Modifier modifier = null;\n+                        String modifierResourceTypeName = null;\n+\n+                        // Check if modifier is specified\n+                        int index = parameterName.indexOf(\":\");\n+                        if (index != -1) {\n+                            modifierName = parameterName.substring(index + 1);\n+                            parameterName = parameterName.substring(0, index);\n+                        }\n+\n+                        SearchParameter searchParameter = getSearchParameter(referencedByResourceType, parameterName);\n+                        if (searchParameter == null) {\n+                            throw SearchExceptionUtil.buildNewInvalidSearchException(String.format(SEARCH_PARAMETER_NOT_FOUND, parameterName, referencedByResourceTypeName));\n+                        }\n+                        Type type = Type.fromValue(searchParameter.getType().getValue());\n+\n+                        if (modifierName != null) {\n+                            if (ModelSupport.isResourceType(modifierName)) {\n+                                modifier = Modifier.TYPE;\n+                                modifierResourceTypeName = modifierName;\n+                            } else {\n+                                try {\n+                                    modifier = Modifier.fromValue(modifierName);\n+                                } catch (IllegalArgumentException e) {\n+                                    String msg = \"Undefined Modifier: \" + modifierName;\n+                                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                                }\n+                            }\n+                            if (!isAllowed(type, modifier)) {\n+                                String msg = \"Unsupported type/modifier combination: \" + type.value() + \"/\" + modifier.value();", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzI0OA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517617248", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MjgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MzQ4Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517353483", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            whereClauseSegment.append(AND).append(chainedParmVar + DOT).append(CODE_SYSTEM_ID).append(EQ)\n          \n          \n            \n                            whereClauseSegment.append(AND).append(chainedParmVar).append(DOT).append(CODE_SYSTEM_ID).append(EQ)", "author": "prb112", "createdAt": "2020-11-04T13:46:56Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -772,7 +774,7 @@ private void appendMidChainParm(StringBuilder whereClauseSegment, QueryParameter\n         if (codeSystemName != null && !codeSystemName.equals(\"*\")) {\n             Integer codeSystemId = identityCache.getCodeSystemId(codeSystemName);\n             if (codeSystemId != null) {\n-                whereClauseSegment.append(AND).append(PARAMETER_TABLE_ALIAS + DOT).append(CODE_SYSTEM_ID).append(EQ)\n+                whereClauseSegment.append(AND).append(chainedParmVar + DOT).append(CODE_SYSTEM_ID).append(EQ)", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzM3NQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517617375", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MzQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDA2Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517354063", "bodyText": "I'm almost positive these are repeated constants, maybe they should be top level constants for consistency?", "author": "prb112", "createdAt": "2020-11-04T13:47:50Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxNzkzNA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517617934", "bodyText": "moved out of this method and processChainedReferenceParm() and made them global", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:39:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDYyNg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517354626", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // BUild outer select: SELECT CLR0.LOGICAL_ID\n          \n          \n            \n                            //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n          \n          \n            \n            \n          \n          \n            \n                            // Builds outer select: \n          \n          \n            \n                            // @formatter:off\n          \n          \n            \n                            // SELECT CLR0.LOGICAL_ID\n          \n          \n            \n                            //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0", "author": "prb112", "createdAt": "2020-11-04T13:48:40Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxODI2Nw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517618267", "bodyText": "added formatter annotations", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDc0OQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517354749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            //                       WHERE\n          \n          \n            \n                            //                       WHERE\n          \n          \n            \n                            // @formatter:on", "author": "prb112", "createdAt": "2020-11-04T13:48:51Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxODQyOQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517618429", "bodyText": "added formatter annotations", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTE0OQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517355149", "bodyText": "let's break these into individual appends\nAlso SELECT and I think LogicalId are already in JDBCConstants", "author": "prb112", "createdAt": "2020-11-04T13:49:26Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTI2Nw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517619267", "bodyText": "broke into individual appends, also added several constants to JDBCConstants that were not there, and replaced string literals in this class with the new constants", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTUyMA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517355520", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n          \n          \n            \n                                //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n          \n          \n            \n                                //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n          \n          \n            \n                                // @formatter:off\n          \n          \n            \n                                //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n          \n          \n            \n                                //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n          \n          \n            \n                                //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n          \n          \n            \n                                // @formatter:on", "author": "prb112", "createdAt": "2020-11-04T13:49:58Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTM4MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517619381", "bodyText": "formatter annotations added", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTg4MA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517355880", "bodyText": "same comment about appends and the EXISTS I think is already in the JDBCConstants\nsame with RESOURCE_ID and IS_DELETED", "author": "prb112", "createdAt": "2020-11-04T13:50:32Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTQ3NQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517619475", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NjQxNw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517356417", "bodyText": "Where you have the nice format, we can add the @formatter:on and off", "author": "prb112", "createdAt": "2020-11-04T13:51:18Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTU5NA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517619594", "bodyText": "added formatter annotations", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NjQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NjcxOA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517356718", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n          \n          \n            \n                                    // Builds ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID", "author": "prb112", "createdAt": "2020-11-04T13:51:47Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxOTczMQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517619731", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NjcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDA0Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517360043", "bodyText": "You could embed the !chainedParmProcessed block down here, and only test this branch at most once\nNet, I'm suggesting a logic change where the test if (!\"_id\".equals(currentParm.getCode())) {  is not in some circumstances twice, and branching of !chainedParmProcessed is done here before the existing code in this branch\nP.S. I think this works, please validate.", "author": "prb112", "createdAt": "2020-11-04T13:56:47Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN + \" AS \" + chainedParmVar + ON)\n+                                            .append(chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                if (!chainedParmProcessed) {\n+                    if (!\"_id\".equals(currentParm.getCode())) {\n+                        // Build this join: JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //                    ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(\" AS \" + chainedParmVar + ON + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    } else {\n+                        // Build this join: JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //                    ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + previousParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES\")\n+                                            .append(\" AS \" + chainedLogicalResourceVar + ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                    whereClauseSegment.append(EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + AND);\n+                }\n+\n+                // Build the rest\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDEwMA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517620100", "bodyText": "I think I did what you were suggesting here - please verify", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MzA3NQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518453075", "bodyText": "looks great - thanks Mike", "author": "prb112", "createdAt": "2020-11-06T00:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDczNA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517360734", "bodyText": "Not to change too much, but please note we use code not names. I think for consistency, we probably leave as name here.", "author": "prb112", "createdAt": "2020-11-04T13:57:50Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN + \" AS \" + chainedParmVar + ON)\n+                                            .append(chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                if (!chainedParmProcessed) {\n+                    if (!\"_id\".equals(currentParm.getCode())) {\n+                        // Build this join: JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //                    ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(\" AS \" + chainedParmVar + ON + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    } else {\n+                        // Build this join: JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //                    ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + previousParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES\")\n+                                            .append(\" AS \" + chainedLogicalResourceVar + ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                    whereClauseSegment.append(EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + AND);\n+                }\n+\n+                // Build the rest\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {\n+                    // (CPx.PARAMETER_NAME_ID=<code-id> AND (CPx.<type>_VALUE=<valueCode>))\n+                    sqlQueryData = buildQueryParm(ModelSupport.getResourceType(previousParm.getModifierResourceTypeName()), currentParm, chainedParmVar);\n+                } else {\n+                    // CLRx.LOGICAL_ID IN (?)\n+                    sqlQueryData = buildChainedIdClause(currentParm, chainedParmVar);\n+                }\n+\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"chained sqlQueryData[\" + chainedParmVar + \"] = \" + sqlQueryData.getQueryString());\n+                }\n+                whereClauseSegment.append(sqlQueryData.getQueryString());\n+                bindVariables.addAll(sqlQueryData.getBindVariables());\n+           }\n+\n+            // Insert where clause segment in whole\n+            whereClauseSegments.insert(0, whereClauseSegment.toString());\n+\n+            previousParm = currentParm;\n+            parmIndex++;\n+        }\n+\n+        SqlQueryData queryData = new SqlQueryData(whereClauseSegments.insert(0, selectSegments.toString()).toString(), bindVariables);\n+        log.exiting(CLASSNAME, METHODNAME, queryData.getQueryString());\n+        return queryData;\n+    }\n+\n+    /**\n+     * Populates the reference parameter name ID and code system ID sub-segment of the passed where clause segment.\n+     *\n+     * @param whereClauseSegment - the segment to which the sub-segment will be added\n+     * @param queryParmName - the search parameter name\n+     * @param resourceTypeName - the resource type of the reference being followed", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDIzNA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517620234", "bodyText": "noted.", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MTEzMw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517361133", "bodyText": "candidate for breaking into individual appends.", "author": "prb112", "createdAt": "2020-11-04T13:58:29Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN + \" AS \" + chainedParmVar + ON)\n+                                            .append(chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                if (!chainedParmProcessed) {\n+                    if (!\"_id\".equals(currentParm.getCode())) {\n+                        // Build this join: JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //                    ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(\" AS \" + chainedParmVar + ON + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    } else {\n+                        // Build this join: JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //                    ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + previousParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES\")\n+                                            .append(\" AS \" + chainedLogicalResourceVar + ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                    whereClauseSegment.append(EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + AND);\n+                }\n+\n+                // Build the rest\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {\n+                    // (CPx.PARAMETER_NAME_ID=<code-id> AND (CPx.<type>_VALUE=<valueCode>))\n+                    sqlQueryData = buildQueryParm(ModelSupport.getResourceType(previousParm.getModifierResourceTypeName()), currentParm, chainedParmVar);\n+                } else {\n+                    // CLRx.LOGICAL_ID IN (?)\n+                    sqlQueryData = buildChainedIdClause(currentParm, chainedParmVar);\n+                }\n+\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"chained sqlQueryData[\" + chainedParmVar + \"] = \" + sqlQueryData.getQueryString());\n+                }\n+                whereClauseSegment.append(sqlQueryData.getQueryString());\n+                bindVariables.addAll(sqlQueryData.getBindVariables());\n+           }\n+\n+            // Insert where clause segment in whole\n+            whereClauseSegments.insert(0, whereClauseSegment.toString());\n+\n+            previousParm = currentParm;\n+            parmIndex++;\n+        }\n+\n+        SqlQueryData queryData = new SqlQueryData(whereClauseSegments.insert(0, selectSegments.toString()).toString(), bindVariables);\n+        log.exiting(CLASSNAME, METHODNAME, queryData.getQueryString());\n+        return queryData;\n+    }\n+\n+    /**\n+     * Populates the reference parameter name ID and code system ID sub-segment of the passed where clause segment.\n+     *\n+     * @param whereClauseSegment - the segment to which the sub-segment will be added\n+     * @param queryParmName - the search parameter name\n+     * @param resourceTypeName - the resource type of the reference being followed\n+     * @param parameterTableAlias - the alias for the parameter table e.g. CPx\n+     * @throws FHIRPersistenceException\n+     */\n+    private void populateReferenceNameAndCodeSystemIdSubSegment(StringBuilder whereClauseSegment, String queryParmName,\n+            String resourceTypeName, String parameterTableAlias) throws FHIRPersistenceException {\n+        final String METHODNAME = \"populateReferenceNameAndCodeSystemIdSubSegment\";\n+        log.entering(CLASSNAME, METHODNAME, queryParmName);\n+\n+        Integer parameterNameId = identityCache.getParameterNameId(queryParmName);\n+        Integer codeSystemId = getCodeSystemId(resourceTypeName);\n+\n+        // Build the segment:\n+        // CPx.PARAMETER_NAME_ID = <parameter-name-id> AND CPx.CODE_SYSTEM_ID = <code-system_id>\n+        whereClauseSegment.append(parameterTableAlias + DOT + \"PARAMETER_NAME_ID=\")\n+                .append(nullCheck(parameterNameId))\n+                .append(AND)\n+                .append(parameterTableAlias + DOT + \"CODE_SYSTEM_ID=\")", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDMyMw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517620323", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MjI0MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517362241", "bodyText": "Random comment, you pick up the style of the code/section very quickly.  Thanks for matching the styles seemingly effortlessly.", "author": "prb112", "createdAt": "2020-11-04T13:59:52Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractReverseChainTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.test.common;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNotNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Device;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Observation;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.ObservationStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ *  This class tests the persistence layer support for the FHIR _has search parameter.\n+ *  @see https://www.hl7.org/fhir/R4/search.html#has\n+ */\n+public abstract class AbstractReverseChainTest extends AbstractPersistenceTest {\n+    private static Patient savedPatient1;\n+    private static Patient savedPatient2;\n+    private static Patient savedPatient3;\n+    private static Patient savedPatient4;\n+    private static Observation savedObservation1;\n+    private static Observation savedObservation2;\n+    private static Observation savedObservation3;\n+    private static Observation savedObservation4;\n+    private static Observation savedObservation5;\n+    private static Encounter savedEncounter1;\n+    private static Device savedDevice1;\n+    private static Organization savedOrg1;\n+    private static Organization savedOrg2;\n+    private static Organization savedOrg3;\n+\n+    /**\n+     * Loads up and saves a bunch of resources with various references to one another\n+     */\n+    @BeforeClass\n+    public void createResources() throws Exception {\n+        Organization org = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        Observation observation = TestUtil.getMinimalResource(ResourceType.OBSERVATION, Format.JSON);\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        Device device = TestUtil.getMinimalResource(ResourceType.DEVICE, Format.JSON);\n+\n+        // Organizations that will be referenced by a Patient\n+        savedOrg1 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg2 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg3 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+\n+        // an Encounter that will be referenced by Observations\n+        savedEncounter1 = persistence.create(getDefaultPersistenceContext(), encounter).getResource();\n+\n+        // an Observation that has no references to any other resource types\n+        savedObservation1 = persistence.create(getDefaultPersistenceContext(), observation).getResource();\n+\n+        // a Patient that will be referenced by Observations and references an Organization\n+        savedPatient1 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg2.getId())).build();\n+        savedPatient1 = persistence.create(getDefaultPersistenceContext(), savedPatient1).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation2 = observation.toBuilder().subject(reference(\"Patient/\" + savedPatient1.getId())).build();\n+        savedObservation2 = persistence.create(getDefaultPersistenceContext(), savedObservation2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation3 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient1.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .build();\n+        savedObservation3 = persistence.create(getDefaultPersistenceContext(), savedObservation3).getResource();\n+\n+        // a Patient that will be referenced by an Observation and references an Organization\n+        savedPatient2 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg3.getId())).build();\n+        savedPatient2 = persistence.create(getDefaultPersistenceContext(), savedPatient2).getResource();\n+        savedPatient2 = savedPatient2.toBuilder().name(humanName(\"Vito\", \"Corleone\")).build();\n+        savedPatient2 = persistence.update(getDefaultPersistenceContext(), savedPatient2.getId(), savedPatient2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation4 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient2.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .value(com.ibm.fhir.model.type.String.of(\"test\"))\n+                                       .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"code\")).build()).build())\n+                                       .build();\n+        savedObservation4 = persistence.create(getDefaultPersistenceContext(), savedObservation4).getResource();\n+\n+        // a Patient that references an Organization and is referenced by an Observation and a Device\n+        savedPatient3 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg1.getId())).build();\n+        savedPatient3 = persistence.create(getDefaultPersistenceContext(), savedPatient3).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation5 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient3.getId()))\n+                                       .status(ObservationStatus.FINAL)\n+                                       .build();\n+        savedObservation5 = persistence.create(getDefaultPersistenceContext(), savedObservation5).getResource();\n+\n+        // a Device with a reference to a Patient\n+        savedDevice1 = device.toBuilder().patient(reference(\"Patient/\" + savedPatient3.getId())).build();\n+        savedDevice1 = persistence.create(getDefaultPersistenceContext(), savedDevice1).getResource();\n+        savedDevice1 = savedDevice1.toBuilder().manufacturer(string(\"Updated Manufacturer\")).build();\n+        savedDevice1 = persistence.update(getDefaultPersistenceContext(), savedDevice1.getId(), savedDevice1).getResource();\n+\n+        // a Patient that will have no other resources referencing it\n+        savedPatient4 = persistence.create(getDefaultPersistenceContext(), patient).getResource();\n+    }\n+\n+    @AfterClass\n+    public void deleteResources() throws Exception {", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDcwNw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517620707", "bodyText": "you're welcome!", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MjI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA5MTU5Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518091593", "bodyText": "agreed", "author": "punktilious", "createdAt": "2020-11-05T14:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MjI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MzEzNA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517363134", "bodyText": "Maybe comment why this commented out?", "author": "prb112", "createdAt": "2020-11-04T14:01:07Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractReverseChainTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.test.common;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNotNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Device;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Observation;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.ObservationStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ *  This class tests the persistence layer support for the FHIR _has search parameter.\n+ *  @see https://www.hl7.org/fhir/R4/search.html#has\n+ */\n+public abstract class AbstractReverseChainTest extends AbstractPersistenceTest {\n+    private static Patient savedPatient1;\n+    private static Patient savedPatient2;\n+    private static Patient savedPatient3;\n+    private static Patient savedPatient4;\n+    private static Observation savedObservation1;\n+    private static Observation savedObservation2;\n+    private static Observation savedObservation3;\n+    private static Observation savedObservation4;\n+    private static Observation savedObservation5;\n+    private static Encounter savedEncounter1;\n+    private static Device savedDevice1;\n+    private static Organization savedOrg1;\n+    private static Organization savedOrg2;\n+    private static Organization savedOrg3;\n+\n+    /**\n+     * Loads up and saves a bunch of resources with various references to one another\n+     */\n+    @BeforeClass\n+    public void createResources() throws Exception {\n+        Organization org = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        Observation observation = TestUtil.getMinimalResource(ResourceType.OBSERVATION, Format.JSON);\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        Device device = TestUtil.getMinimalResource(ResourceType.DEVICE, Format.JSON);\n+\n+        // Organizations that will be referenced by a Patient\n+        savedOrg1 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg2 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg3 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+\n+        // an Encounter that will be referenced by Observations\n+        savedEncounter1 = persistence.create(getDefaultPersistenceContext(), encounter).getResource();\n+\n+        // an Observation that has no references to any other resource types\n+        savedObservation1 = persistence.create(getDefaultPersistenceContext(), observation).getResource();\n+\n+        // a Patient that will be referenced by Observations and references an Organization\n+        savedPatient1 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg2.getId())).build();\n+        savedPatient1 = persistence.create(getDefaultPersistenceContext(), savedPatient1).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation2 = observation.toBuilder().subject(reference(\"Patient/\" + savedPatient1.getId())).build();\n+        savedObservation2 = persistence.create(getDefaultPersistenceContext(), savedObservation2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation3 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient1.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .build();\n+        savedObservation3 = persistence.create(getDefaultPersistenceContext(), savedObservation3).getResource();\n+\n+        // a Patient that will be referenced by an Observation and references an Organization\n+        savedPatient2 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg3.getId())).build();\n+        savedPatient2 = persistence.create(getDefaultPersistenceContext(), savedPatient2).getResource();\n+        savedPatient2 = savedPatient2.toBuilder().name(humanName(\"Vito\", \"Corleone\")).build();\n+        savedPatient2 = persistence.update(getDefaultPersistenceContext(), savedPatient2.getId(), savedPatient2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation4 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient2.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .value(com.ibm.fhir.model.type.String.of(\"test\"))\n+                                       .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"code\")).build()).build())\n+                                       .build();\n+        savedObservation4 = persistence.create(getDefaultPersistenceContext(), savedObservation4).getResource();\n+\n+        // a Patient that references an Organization and is referenced by an Observation and a Device\n+        savedPatient3 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg1.getId())).build();\n+        savedPatient3 = persistence.create(getDefaultPersistenceContext(), savedPatient3).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation5 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient3.getId()))\n+                                       .status(ObservationStatus.FINAL)\n+                                       .build();\n+        savedObservation5 = persistence.create(getDefaultPersistenceContext(), savedObservation5).getResource();\n+\n+        // a Device with a reference to a Patient\n+        savedDevice1 = device.toBuilder().patient(reference(\"Patient/\" + savedPatient3.getId())).build();\n+        savedDevice1 = persistence.create(getDefaultPersistenceContext(), savedDevice1).getResource();\n+        savedDevice1 = savedDevice1.toBuilder().manufacturer(string(\"Updated Manufacturer\")).build();\n+        savedDevice1 = persistence.update(getDefaultPersistenceContext(), savedDevice1.getId(), savedDevice1).getResource();\n+\n+        // a Patient that will have no other resources referencing it\n+        savedPatient4 = persistence.create(getDefaultPersistenceContext(), patient).getResource();\n+    }\n+\n+    @AfterClass\n+    public void deleteResources() throws Exception {\n+        Resource[] resources = {savedPatient1, savedPatient2, savedPatient3, savedPatient4,\n+                savedObservation1, savedObservation2, savedObservation3, savedObservation4, savedObservation5,\n+                savedEncounter1, savedDevice1, savedOrg1};\n+\n+        if (persistence.isDeleteSupported()) {\n+            if (persistence.isTransactional()) {\n+                persistence.getTransaction().begin();\n+            }\n+\n+            try {\n+                for (Resource resource : resources) {\n+                    persistence.delete(getDefaultPersistenceContext(), resource.getClass(), resource.getId());\n+                }\n+            } catch (Throwable t) {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().setRollbackOnly();\n+                }\n+                throw t;\n+            } finally {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().end();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified code.\n+     * No Observations are found containing the code, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:code\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Patient\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedPatient3.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter reference, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations which in turn are\n+     * referenced by Encounters with a specific status.\n+     * No Encounters are found, thus no Observations are found, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_has:Encounter:reason-reference:status\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is found, thus one\n+     * Organization is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Organization\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedOrg1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter, thus two Patients are found, thus two\n+     * Organizations are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedOrg2.getId()));\n+        assertTrue(resourceIds.contains(savedOrg3.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResultsFromMultipleValues() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_id\", Collections.singletonList(savedObservation2.getId() + \",\" + savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found. both referencing the same encounter, thus one Encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultsFromMultipleQueries() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:_id\", Arrays.asList(savedObservation3.getId(), savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with a\n+     * reference to Patients with a specified name.\n+     * One patient is found, thus one observation, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithChainedParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:subject:Patient.name\", Collections.singletonList(\"Vito\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a string type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithStringParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:value-string\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a composite type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+//    @Test\n+//    public void testReverseChainSingleResultWithCompositeParm() throws Exception {\n+//        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+//        queryParms.put(\"_has:Observation:encounter:code-value-string\", Collections.singletonList(\"code$test\"));\n+//         List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+//        assertNotNull(resources);\n+//        assertEquals(1, resources.size());\n+//        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+//        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+//    }", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMTAxMw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517621013", "bodyText": "added TODO indicating this should be uncommented when issue #1669 is resolved", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MzEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MzQ3Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517363473", "bodyText": "Is it plausible / possible to have more than one _has on a reverse chain?\nDo we support it from the REST layer?\nWhat type of error do we throw?", "author": "prb112", "createdAt": "2020-11-04T14:01:40Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractReverseChainTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.test.common;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNotNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Device;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Observation;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.ObservationStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ *  This class tests the persistence layer support for the FHIR _has search parameter.\n+ *  @see https://www.hl7.org/fhir/R4/search.html#has\n+ */\n+public abstract class AbstractReverseChainTest extends AbstractPersistenceTest {\n+    private static Patient savedPatient1;\n+    private static Patient savedPatient2;\n+    private static Patient savedPatient3;\n+    private static Patient savedPatient4;\n+    private static Observation savedObservation1;\n+    private static Observation savedObservation2;\n+    private static Observation savedObservation3;\n+    private static Observation savedObservation4;\n+    private static Observation savedObservation5;\n+    private static Encounter savedEncounter1;\n+    private static Device savedDevice1;\n+    private static Organization savedOrg1;\n+    private static Organization savedOrg2;\n+    private static Organization savedOrg3;\n+\n+    /**\n+     * Loads up and saves a bunch of resources with various references to one another\n+     */\n+    @BeforeClass\n+    public void createResources() throws Exception {\n+        Organization org = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        Observation observation = TestUtil.getMinimalResource(ResourceType.OBSERVATION, Format.JSON);\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        Device device = TestUtil.getMinimalResource(ResourceType.DEVICE, Format.JSON);\n+\n+        // Organizations that will be referenced by a Patient\n+        savedOrg1 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg2 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg3 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+\n+        // an Encounter that will be referenced by Observations\n+        savedEncounter1 = persistence.create(getDefaultPersistenceContext(), encounter).getResource();\n+\n+        // an Observation that has no references to any other resource types\n+        savedObservation1 = persistence.create(getDefaultPersistenceContext(), observation).getResource();\n+\n+        // a Patient that will be referenced by Observations and references an Organization\n+        savedPatient1 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg2.getId())).build();\n+        savedPatient1 = persistence.create(getDefaultPersistenceContext(), savedPatient1).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation2 = observation.toBuilder().subject(reference(\"Patient/\" + savedPatient1.getId())).build();\n+        savedObservation2 = persistence.create(getDefaultPersistenceContext(), savedObservation2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation3 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient1.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .build();\n+        savedObservation3 = persistence.create(getDefaultPersistenceContext(), savedObservation3).getResource();\n+\n+        // a Patient that will be referenced by an Observation and references an Organization\n+        savedPatient2 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg3.getId())).build();\n+        savedPatient2 = persistence.create(getDefaultPersistenceContext(), savedPatient2).getResource();\n+        savedPatient2 = savedPatient2.toBuilder().name(humanName(\"Vito\", \"Corleone\")).build();\n+        savedPatient2 = persistence.update(getDefaultPersistenceContext(), savedPatient2.getId(), savedPatient2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation4 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient2.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .value(com.ibm.fhir.model.type.String.of(\"test\"))\n+                                       .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"code\")).build()).build())\n+                                       .build();\n+        savedObservation4 = persistence.create(getDefaultPersistenceContext(), savedObservation4).getResource();\n+\n+        // a Patient that references an Organization and is referenced by an Observation and a Device\n+        savedPatient3 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg1.getId())).build();\n+        savedPatient3 = persistence.create(getDefaultPersistenceContext(), savedPatient3).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation5 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient3.getId()))\n+                                       .status(ObservationStatus.FINAL)\n+                                       .build();\n+        savedObservation5 = persistence.create(getDefaultPersistenceContext(), savedObservation5).getResource();\n+\n+        // a Device with a reference to a Patient\n+        savedDevice1 = device.toBuilder().patient(reference(\"Patient/\" + savedPatient3.getId())).build();\n+        savedDevice1 = persistence.create(getDefaultPersistenceContext(), savedDevice1).getResource();\n+        savedDevice1 = savedDevice1.toBuilder().manufacturer(string(\"Updated Manufacturer\")).build();\n+        savedDevice1 = persistence.update(getDefaultPersistenceContext(), savedDevice1.getId(), savedDevice1).getResource();\n+\n+        // a Patient that will have no other resources referencing it\n+        savedPatient4 = persistence.create(getDefaultPersistenceContext(), patient).getResource();\n+    }\n+\n+    @AfterClass\n+    public void deleteResources() throws Exception {\n+        Resource[] resources = {savedPatient1, savedPatient2, savedPatient3, savedPatient4,\n+                savedObservation1, savedObservation2, savedObservation3, savedObservation4, savedObservation5,\n+                savedEncounter1, savedDevice1, savedOrg1};\n+\n+        if (persistence.isDeleteSupported()) {\n+            if (persistence.isTransactional()) {\n+                persistence.getTransaction().begin();\n+            }\n+\n+            try {\n+                for (Resource resource : resources) {\n+                    persistence.delete(getDefaultPersistenceContext(), resource.getClass(), resource.getId());\n+                }\n+            } catch (Throwable t) {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().setRollbackOnly();\n+                }\n+                throw t;\n+            } finally {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().end();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified code.\n+     * No Observations are found containing the code, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:code\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Patient\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedPatient3.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter reference, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations which in turn are\n+     * referenced by Encounters with a specific status.\n+     * No Encounters are found, thus no Observations are found, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_has:Encounter:reason-reference:status\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is found, thus one\n+     * Organization is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Organization\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedOrg1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter, thus two Patients are found, thus two\n+     * Organizations are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedOrg2.getId()));\n+        assertTrue(resourceIds.contains(savedOrg3.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResultsFromMultipleValues() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_id\", Collections.singletonList(savedObservation2.getId() + \",\" + savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found. both referencing the same encounter, thus one Encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultsFromMultipleQueries() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:_id\", Arrays.asList(savedObservation3.getId(), savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with a\n+     * reference to Patients with a specified name.\n+     * One patient is found, thus one observation, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithChainedParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:subject:Patient.name\", Collections.singletonList(\"Vito\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a string type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithStringParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:value-string\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a composite type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+//    @Test\n+//    public void testReverseChainSingleResultWithCompositeParm() throws Exception {\n+//        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+//        queryParms.put(\"_has:Observation:encounter:code-value-string\", Collections.singletonList(\"code$test\"));\n+//         List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+//        assertNotNull(resources);\n+//        assertEquals(1, resources.size());\n+//        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+//        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+//    }\n+\n+    private Reference reference(String reference) {\n+        return Reference.builder().reference(string(reference)).build();\n+    }\n+\n+    private HumanName humanName(String firstName, String lastName) {\n+        return HumanName.builder().given(string(firstName)).family(string(lastName)).build();\n+    }", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMTkwOA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517621908", "bodyText": "yes, _has can be chained - the testcases starting with testMultiReverseChain... test this", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MzQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MzU3Mg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518453572", "bodyText": "Thanks Mike", "author": "prb112", "createdAt": "2020-11-06T00:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDg1MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517364851", "bodyText": "above is a good candidate for the formatter:off comment and end with formatter on", "author": "prb112", "createdAt": "2020-11-04T14:03:39Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMjMyNA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517622324", "bodyText": "not clear on this - just add a comment before and after with the annotation?", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NDE3NA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518454174", "bodyText": "That's right.  This was more of a heads up.\nIt keeps it from getting reformatted accidently", "author": "prb112", "createdAt": "2020-11-06T00:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDk2Nw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517364967", "bodyText": "same formatter comment", "author": "prb112", "createdAt": "2020-11-04T14:03:50Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NTM4MA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517365380", "bodyText": "I'll leave you to decide to use it in the rest of the class (treat the formatter comments as FYI)", "author": "prb112", "createdAt": "2020-11-04T14:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjQwNg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517366406", "bodyText": "Refer to corresponding comment in SearchUtil (this response should have 'badModifier' and possibly be URL Encoded.", "author": "prb112", "createdAt": "2020-11-04T14:05:52Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMjUxNg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517622516", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Nzc4Ng==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517367786", "bodyText": "Why does this become uppercase, should we upper case it?", "author": "prb112", "createdAt": "2020-11-04T14:07:41Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMzIzMA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517623230", "bodyText": "changed the code in SearchUtil that constructs the exception to use Modifier.value() so we get the natural value", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Nzc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2ODMxOQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517368319", "bodyText": "Why does this become uppercase? I think it's from the fhir-search Type enum, and we should probably use the natural value of lower case token which is what's read fromt he Parameter", "author": "prb112", "createdAt": "2020-11-04T14:08:26Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Type: 'TOKEN' not allowed on chained parameter\");", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMzQ1Ng==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517623456", "bodyText": "changed the code in SearchUtil that constructs the exception to use Token.value() so we get the natural value", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2ODMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MTQzMA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517371430", "bodyText": "I've seen this a couple of times.\n1 - assertEquals is probably preferred when doing the equals (that way you can see what the size value is\n2 - If the delete fails for any reason, it leaves dirty data, so we typically do >= 1\nIf the delete fails, does it impact this test in any way?", "author": "prb112", "createdAt": "2020-11-04T14:12:23Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Type: 'TOKEN' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of:Condition.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier resource type [Condition] is not allowed for search parameter [part-of] of resource type [Procedure].\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotSpecifiedError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter: 'part-of' must have resource type name modifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_id\", procedure1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:status\", EncounterStatus.FINISHED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainORSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id + \",\" + encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainANDSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id, encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 0);\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParmOfId() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider._id\", organization1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithMultipleChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.endpoint.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithStringParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"given\", \"1\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNTEzMw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517625133", "bodyText": "Updated to use assertEquals. As far as the delete issue, I use a generated tag based on Instant.now() in all the resources and any fields that are searched contain some form of this value. So even if delete fails, these testcases should not find any dirty data.", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MTQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MjEzNw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517372137", "bodyText": "even if this fails, let's have a multiple _has test and capture the failure.\nAlso probably should update conformance to state if multiple has is supported or not.", "author": "prb112", "createdAt": "2020-11-04T14:13:23Z", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Type: 'TOKEN' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of:Condition.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier resource type [Condition] is not allowed for search parameter [part-of] of resource type [Procedure].\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotSpecifiedError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter: 'part-of' must have resource type name modifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_id\", procedure1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:status\", EncounterStatus.FINISHED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainORSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id + \",\" + encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainANDSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id, encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 0);\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParmOfId() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider._id\", organization1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithMultipleChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.endpoint.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithStringParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"given\", \"1\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithTokenParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"telecom\", \"1\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithReferenceParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"general-practitioner\", \"Practitioner/\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithDateParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"birthdate\", now.minus(1, ChronoUnit.DAYS).toString().substring(0,10))\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithUriParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:instantiates-uri\", \"1\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithDateTimeParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:date\", now.minus(1, ChronoUnit.DAYS).toString())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithReferenceParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:based-on\", \"CarePlan/\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithTokenParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code\", \"2\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithTokenParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:type\", \"1\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithReferenceParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider\", \"Organization/\" + organization2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithDateTimeParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:date\", now.toString())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithQuantityParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:length\", \"2\" + tag + \"|http://unitsofmeasure.org|s\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = { \"testCreateLocation\" })\n+    public void SearchMultipleReverseChainWithLocationNear() throws Exception {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Endpoint\")\n+                .queryParam(\"_has:Organization:endpoint:_has:Location:organization:near\", \"42.256500|-83.694810|11.20|km\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(endpointId, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithInclude() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:instantiates-uri\", \"1\" + tag)\n+                .queryParam(\"_include\", \"Patient:organization\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(organization1Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithRevInclude() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:instantiates-uri\", \"1\" + tag)\n+                .queryParam(\"_revinclude\", \"Procedure:patient\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(procedure1Id));\n+    }\n+", "originalCommit": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNjIxNQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517626215", "bodyText": "Multiples are supported. The testcases starting with testSearchMultipleReverseChain... test this. It is stated in the FHIR spec that this is supported, but I can add a blurb to the conformance doc if you think I need to.", "author": "michaelwschroeder", "createdAt": "2020-11-04T20:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MjEzNw=="}], "type": "inlineReview"}, {"oid": "3b12d338ae7e53c778d5a5f7ac499d9f172baf24", "url": "https://github.com/IBM/FHIR/commit/3b12d338ae7e53c778d5a5f7ac499d9f172baf24", "message": "Issue #1218 - address review comments\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-11-04T20:31:47Z", "type": "commit"}, {"oid": "112012e066c3c60b64d1484a3fe4f1d7f28fefd2", "url": "https://github.com/IBM/FHIR/commit/112012e066c3c60b64d1484a3fe4f1d7f28fefd2", "message": "Issue #1218 - update doc\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-11-04T20:33:29Z", "type": "commit"}, {"oid": "4e8e0dd80b23d9bbb8caff8eaf5ba00ee5b9e4e2", "url": "https://github.com/IBM/FHIR/commit/4e8e0dd80b23d9bbb8caff8eaf5ba00ee5b9e4e2", "message": "Issue #1218 - fix bad substring\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-11-04T21:14:09Z", "type": "commit"}, {"oid": "82b998e84662a4311af57bf161c282f476463a04", "url": "https://github.com/IBM/FHIR/commit/82b998e84662a4311af57bf161c282f476463a04", "message": "Issue #1218 - fix testcase dateTime precision issue\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-11-04T21:41:03Z", "type": "commit"}, {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021", "url": "https://github.com/IBM/FHIR/commit/7cf5dad7cb56ff76579a60579b11cc834f380021", "message": "Issue #1218 - additional dateTime precision fix\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-11-04T22:01:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDUzNg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518070536", "bodyText": "I've been trying to keep the constant names identical to the string value for sanity. I don't really want to deviate from this. I think we should use a slightly different convention for prefix/postfix strings. Perhaps something as simple as _RESOURCES = \"_RESOURCES\"", "author": "punktilious", "createdAt": "2020-11-05T13:59:09Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/JDBCConstants.java", "diffHunk": "@@ -36,6 +36,14 @@\n     public static final String DATE_END = \"DATE_END\";\n     public static final String LATITUDE_VALUE = \"LATITUDE_VALUE\";\n     public static final String LONGITUDE_VALUE = \"LONGITUDE_VALUE\";\n+    public static final String RESOURCES = \"_RESOURCES\";", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNzMxMQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518207311", "bodyText": "done - used your suggestion", "author": "michaelwschroeder", "createdAt": "2020-11-05T16:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDk4Ng==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518070986", "bodyText": "Good idea.", "author": "punktilious", "createdAt": "2020-11-05T13:59:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/JDBCConstants.java", "diffHunk": "@@ -36,6 +36,14 @@\n     public static final String DATE_END = \"DATE_END\";\n     public static final String LATITUDE_VALUE = \"LATITUDE_VALUE\";\n     public static final String LONGITUDE_VALUE = \"LONGITUDE_VALUE\";\n+    public static final String RESOURCES = \"_RESOURCES\";\n+    public static final String LOGICAL_RESOURCES = \"_LOGICAL_RESOURCES\";\n+    public static final String RESOURCE_ID = \"RESOURCE_ID\";\n+    public static final String LOGICAL_ID = \"LOGICAL_ID\";\n+    public static final String LOGICAL_RESOURCE_ID = \"LOGICAL_RESOURCE_ID\";\n+    public static final String CURRENT_RESOURCE_ID = \"CURRENT_RESOURCE_ID\";\n+    public static final String PARAMETER_NAME_ID = \"PARAMETER_NAME_ID\";\n+    public static final String IS_DELETED_NO = \"IS_DELETED = 'N'\";", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3OTE2Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518079163", "bodyText": "I don't think we should use parens unless required to control precedence.", "author": "punktilious", "createdAt": "2020-11-05T14:11:16Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwOTgzNQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518209835", "bodyText": "Agreed. Unfortunately in this case they're generated by the populateNameIdSubSegment() method, which gets called by many other methods - didn't want to take on making a change there and having to validate all of those existing cases.", "author": "michaelwschroeder", "createdAt": "2020-11-05T17:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3OTE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3OTcxMQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518079711", "bodyText": "Build", "author": "punktilious", "createdAt": "2020-11-05T14:11:49Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwOTk2OQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518209969", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-05T17:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3OTcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4MDkzMw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518080933", "bodyText": "CODE_SYSTEM_ID", "author": "punktilious", "createdAt": "2020-11-05T14:13:35Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:\n+                // @formatter:off\n+                //   SELECT CLR0.LOGICAL_ID\n+                //     FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //     JOIN <resource-type>_RESOURCES AS CR0\n+                //       ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //     WHERE\n+                // @formatter:on\n+                selectSegments.append(SELECT).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID)\n+                                .append(FROM).append(resourceType.getSimpleName()).append(LOGICAL_RESOURCES).append(AS).append(prevChainedLogicalResourceVar)\n+                                .append(JOIN).append(resourceType.getSimpleName()).append(RESOURCES).append(AS).append(prevChainedResourceVar)\n+                                .append(ON).append(prevChainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                .append(prevChainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                .append(AND).append(prevChainedResourceVar).append(DOT ).append(IS_DELETED_NO)\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins:\n+                    // @formatter:off\n+                    //   EXISTS (SELECT 1\n+                    //     FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //     JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //       ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //     JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //       ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    // @formatter:on\n+                    selectSegments.append(EXISTS).append(LEFT_PAREN).append(\"SELECT 1\")\n+                                    .append(FROM).append(currentParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V\").append(AS).append(chainedParmVar)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES).append(AS).append(chainedLogicalResourceVar)\n+                                    .append(ON).append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                    .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(RESOURCES).append(AS).append(chainedResourceVar)\n+                                    .append(ON).append(chainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                    .append(chainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                    .append(AND).append(chainedResourceVar).append(DOT).append(IS_DELETED_NO);\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMDA3Nw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518210077", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-05T17:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4MDkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4MTQ1MQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518081451", "bodyText": "CODE_SYSTEM_ID", "author": "punktilious", "createdAt": "2020-11-05T14:14:20Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:\n+                // @formatter:off\n+                //   SELECT CLR0.LOGICAL_ID\n+                //     FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //     JOIN <resource-type>_RESOURCES AS CR0\n+                //       ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //     WHERE\n+                // @formatter:on\n+                selectSegments.append(SELECT).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID)\n+                                .append(FROM).append(resourceType.getSimpleName()).append(LOGICAL_RESOURCES).append(AS).append(prevChainedLogicalResourceVar)\n+                                .append(JOIN).append(resourceType.getSimpleName()).append(RESOURCES).append(AS).append(prevChainedResourceVar)\n+                                .append(ON).append(prevChainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                .append(prevChainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                .append(AND).append(prevChainedResourceVar).append(DOT ).append(IS_DELETED_NO)\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins:\n+                    // @formatter:off\n+                    //   EXISTS (SELECT 1\n+                    //     FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //     JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //       ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //     JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //       ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    // @formatter:on\n+                    selectSegments.append(EXISTS).append(LEFT_PAREN).append(\"SELECT 1\")\n+                                    .append(FROM).append(currentParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V\").append(AS).append(chainedParmVar)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES).append(AS).append(chainedLogicalResourceVar)\n+                                    .append(ON).append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                    .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(RESOURCES).append(AS).append(chainedResourceVar)\n+                                    .append(ON).append(chainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                    .append(chainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                    .append(AND).append(chainedResourceVar).append(DOT).append(IS_DELETED_NO);\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //     AND\n+                        // @formatter:on\n+                        selectSegments.append(WHERE).append(chainedParmVar).append(DOT).append(TOKEN_VALUE).append(EQ)\n+                                        .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID).append(AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMDE2MA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518210160", "bodyText": "done", "author": "michaelwschroeder", "createdAt": "2020-11-05T17:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4MTQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4NjMxNA==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518086314", "bodyText": "nullCheck is redundant here. getParameterNameId will never return null, although I know it's used in a few places. Just fyi, doesn't need to be changed.", "author": "punktilious", "createdAt": "2020-11-05T14:20:47Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:\n+                // @formatter:off\n+                //   SELECT CLR0.LOGICAL_ID\n+                //     FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //     JOIN <resource-type>_RESOURCES AS CR0\n+                //       ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //     WHERE\n+                // @formatter:on\n+                selectSegments.append(SELECT).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID)\n+                                .append(FROM).append(resourceType.getSimpleName()).append(LOGICAL_RESOURCES).append(AS).append(prevChainedLogicalResourceVar)\n+                                .append(JOIN).append(resourceType.getSimpleName()).append(RESOURCES).append(AS).append(prevChainedResourceVar)\n+                                .append(ON).append(prevChainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                .append(prevChainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                .append(AND).append(prevChainedResourceVar).append(DOT ).append(IS_DELETED_NO)\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins:\n+                    // @formatter:off\n+                    //   EXISTS (SELECT 1\n+                    //     FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //     JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //       ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //     JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //       ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    // @formatter:on\n+                    selectSegments.append(EXISTS).append(LEFT_PAREN).append(\"SELECT 1\")\n+                                    .append(FROM).append(currentParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V\").append(AS).append(chainedParmVar)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES).append(AS).append(chainedLogicalResourceVar)\n+                                    .append(ON).append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                    .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(RESOURCES).append(AS).append(chainedResourceVar)\n+                                    .append(ON).append(chainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                    .append(chainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                    .append(AND).append(chainedResourceVar).append(DOT).append(IS_DELETED_NO);\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //     AND\n+                        // @formatter:on\n+                        selectSegments.append(WHERE).append(chainedParmVar).append(DOT).append(TOKEN_VALUE).append(EQ)\n+                                        .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID).append(AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        // @formatter:on\n+                        whereClauseSegment.append(WHERE).append(chainedParmVar).append(DOT).append(TOKEN_VALUE).append(EQ)\n+                                            .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID).append(AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        //   SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN ).append(LEFT_PAREN)\n+                                        .append(SELECT).append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(FROM)\n+                                        .append(previousParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V AS \").append(chainedParmVar)\n+                                        .append(WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // Builds ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN).append(AS).append(chainedParmVar).append(ON)\n+                                            .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                            .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID);\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {\n+                    if (!chainedParmProcessed) {\n+                        // Build this join:\n+                        // @formatter:off\n+                        //   JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //     ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //     AND\n+                        // @formatter:on\n+                        whereClauseSegment.append(JOIN).append(QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(AS).append(chainedParmVar).append(ON).append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                            .append(EQ).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(AND);\n+                    }\n+                    // Build the rest: (CPx.PARAMETER_NAME_ID=<code-id> AND (CPx.<type>_VALUE=<valueCode>))\n+                    sqlQueryData = buildQueryParm(ModelSupport.getResourceType(previousParm.getModifierResourceTypeName()), currentParm, chainedParmVar);\n+                } else {\n+                    if (!chainedParmProcessed) {\n+                        // Build this join:\n+                        // @formatter:off\n+                        //   JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //     ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //     AND\n+                        // @formatter:on\n+                        whereClauseSegment.append(JOIN).append(previousParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES)\n+                                            .append(AS).append(chainedLogicalResourceVar).append(ON)\n+                                            .append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                            .append(EQ).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(AND);\n+                    }\n+                    // Build the rest: CLRx.LOGICAL_ID IN (?)\n+                    sqlQueryData = buildChainedIdClause(currentParm, chainedParmVar);\n+                }\n+\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"chained sqlQueryData[\" + chainedParmVar + \"] = \" + sqlQueryData.getQueryString());\n+                }\n+                whereClauseSegment.append(sqlQueryData.getQueryString());\n+                bindVariables.addAll(sqlQueryData.getBindVariables());\n+           }\n+\n+            // Insert where clause segment in whole\n+            whereClauseSegments.insert(0, whereClauseSegment.toString());\n+\n+            previousParm = currentParm;\n+            parmIndex++;\n+        }\n+\n+        SqlQueryData queryData = new SqlQueryData(whereClauseSegments.insert(0, selectSegments.toString()).toString(), bindVariables);\n+        log.exiting(CLASSNAME, METHODNAME, queryData.getQueryString());\n+        return queryData;\n+    }\n+\n+    /**\n+     * Populates the reference parameter name ID and code system ID sub-segment of the passed where clause segment.\n+     *\n+     * @param whereClauseSegment - the segment to which the sub-segment will be added\n+     * @param queryParmName - the search parameter name\n+     * @param resourceTypeName - the resource type of the reference being followed\n+     * @param parameterTableAlias - the alias for the parameter table e.g. CPx\n+     * @throws FHIRPersistenceException\n+     */\n+    private void populateReferenceNameAndCodeSystemIdSubSegment(StringBuilder whereClauseSegment, String queryParmName,\n+            String resourceTypeName, String parameterTableAlias) throws FHIRPersistenceException {\n+        final String METHODNAME = \"populateReferenceNameAndCodeSystemIdSubSegment\";\n+        log.entering(CLASSNAME, METHODNAME, queryParmName);\n+\n+        Integer parameterNameId = identityCache.getParameterNameId(queryParmName);\n+        Integer codeSystemId = getCodeSystemId(resourceTypeName);\n+\n+        // Build the segment:\n+        // CPx.PARAMETER_NAME_ID = <parameter-name-id> AND CPx.CODE_SYSTEM_ID = <code-system_id>\n+        whereClauseSegment.append(parameterTableAlias).append(DOT).append(PARAMETER_NAME_ID).append(EQ).append(nullCheck(parameterNameId))", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMDMwOQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518210309", "bodyText": "noted", "author": "michaelwschroeder", "createdAt": "2020-11-05T17:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4NjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4OTk3Mw==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518089973", "bodyText": "from Observation logical resources table. There's also a global (all resources) logical_resources table. Good to distinguish, because the join predicate would be slightly different", "author": "punktilious", "createdAt": "2020-11-05T14:25:19Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/QuerySegmentAggregator.java", "diffHunk": "@@ -555,20 +556,41 @@ protected void buildWhereClause(StringBuilder whereClause, String overrideType)\n                     whereClause.append(whereClauseSegment);\n                 } else {\n                     if (!Type.COMPOSITE.equals(param.getType())) {\n-                        // Join a standard parameter table\n-                        //   JOIN Observation_TOKEN_VALUES AS param0\n-                        //     ON param0.PARAMETER_NAME_ID=1191 AND param0.TOKEN_VALUE = :p1\n-                        //    AND param0.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n-\n                         final String paramTableAlias = \"param\" + i;\n-                        final String onFilter = querySegment.getQueryString().replaceAll(PARAMETER_TABLE_ALIAS + \"\\\\.\", paramTableAlias + \".\");\n-\n-                        whereClause.append(JOIN);\n-                        whereClause.append(tableName(overrideType, param));\n-                        whereClause.append(\" AS \" + paramTableAlias);\n-                        whereClause.append(ON);\n-                        whereClause.append(onFilter);\n-                        whereClause.append(\" AND LR.LOGICAL_RESOURCE_ID = \" + paramTableAlias + \".LOGICAL_RESOURCE_ID\");\n+                        if (param.isReverseChained()) {\n+                            // Join on a select from logical resource table", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMDQ1NQ==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518210455", "bodyText": "comment updated", "author": "michaelwschroeder", "createdAt": "2020-11-05T17:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4OTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA5NDcwMg==", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518094702", "bodyText": "I'll raise a backlog issue. QueryParameter could use some Javadoc love.", "author": "punktilious", "createdAt": "2020-11-05T14:31:47Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/parameters/QueryParameter.java", "diffHunk": "@@ -44,6 +45,11 @@ public QueryParameter(Type type, String code, Modifier modifier, String modifier\n         this.isInclusionCriteria = isInclusionCriteria;\n     }\n \n+    public QueryParameter(Type type, String code, Modifier modifier, String modifierResourceTypeName, boolean isInclusionCriteria, boolean isReverseChained) {", "originalCommit": "7cf5dad7cb56ff76579a60579b11cc834f380021", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "160a708b5acef30c4bd468a5239d152c4fba137d", "url": "https://github.com/IBM/FHIR/commit/160a708b5acef30c4bd468a5239d152c4fba137d", "message": "Issue #1218 - updates after review comments\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-11-05T16:51:29Z", "type": "commit"}, {"oid": "8de7c691542d7272cd364472a55166863650086a", "url": "https://github.com/IBM/FHIR/commit/8de7c691542d7272cd364472a55166863650086a", "message": "issue #1673 - change default ordering\n\nPreviously, we used a default sort of RESOURCE_ID ASC (the row identifier of the resource version being returned).\nWhile investigating #1673, I noticed that removing this sort took this query from 10 seconds down to 3-4 seconds.\n\nHowever, having *some* sort order is important, so that we get consistent page results.\nUpon further inspection, I found that changing the default sort to LOGICAL_RESOURCE_ID (the row identifier of the logical resource row being returned)\nyielded a similar performance boost and so this is the proposed change.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-11-09T03:52:27Z", "type": "commit"}, {"oid": "9e38e6a395e6c6dd163a773d4c13a6748a719ec1", "url": "https://github.com/IBM/FHIR/commit/9e38e6a395e6c6dd163a773d4c13a6748a719ec1", "message": "Merge pull request #1678 from IBM/lee-master\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-11-09T20:14:32Z", "type": "commit"}]}