{"pr_number": 1486, "pr_title": "Issue #1262 - enable wildcard search for _include, _revinclude", "pr_createdAt": "2020-09-08T14:40:49Z", "pr_url": "https://github.com/IBM/FHIR/pull/1486", "timeline": [{"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "url": "https://github.com/IBM/FHIR/commit/8b32bd572f29429d86f9b80ce874cf041332dbc9", "message": "Issue #1262 - enable wildcard search for _include, _revinclude\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-09-08T14:39:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4OTg1MA==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484989850", "bodyText": "Update Copyright please ,2020", "author": "prb112", "createdAt": "2020-09-08T14:59:34Z", "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -20,9 +20,12 @@\n \n import org.testng.annotations.Test;\n \n+import com.ibm.fhir.model.resource.Condition;", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODI5OQ==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198299", "bodyText": "Fixed.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4OTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjczNw==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484992737", "bodyText": "Having an integration test in SearchTest.java in fhir-server-test would be ideal.   And include a test with Provenance.target which is a reference to Any FHIR Resource", "author": "prb112", "createdAt": "2020-09-08T15:03:35Z", "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_revinclude=Procedure:patient:Patient\";\n+        String include2 = \"&_revinclude=Procedure:performer:Patient\";\n+        String include3 = \"&_revinclude=Procedure:subject:Patient\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"patient\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"performer\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"subject\", \"Patient\"));\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Procedure:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getRevIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+    }\n+", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODQ2OQ==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198469", "bodyText": "Test added.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MzgyMw==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484993823", "bodyText": "Looks like SearchParamType.REFERENCE.equals(...) could be done instead against \"reference\".  Same comment on line 1485.", "author": "tbieste", "createdAt": "2020-09-08T15:05:07Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODU2Mw==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198563", "bodyText": "Fixed.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MzgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NDE3MQ==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484994171", "bodyText": "Typo in word \"already\".", "author": "tbieste", "createdAt": "2020-09-08T15:05:36Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODY1Mw==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198653", "bodyText": "Fixed.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484996065", "bodyText": "Why would there be two search parameters of the same code already in the map?\nThe word already is misspelled", "author": "prb112", "createdAt": "2020-09-08T15:08:31Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map\n+                inclusionSearchParameters.remove(searchParameter.getCode().getValue());", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MTU4NQ==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485041585", "bodyText": "This is covering a case where there's a built-in search parm of type 'reference', but there's a tenant-specific search parm of the same name and the type is not 'reference'. I thought the tenant-specific parm should win.", "author": "michaelwschroeder", "createdAt": "2020-09-08T16:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MDM1MQ==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485050351", "bodyText": "so this is an error condition.  I think we should log, and not remove.  Generally it's not accepted to mutate, as it changes the values table for the search value.", "author": "prb112", "createdAt": "2020-09-08T16:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODkyNw==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198927", "bodyText": "Added log message and did not remove existing map entry.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NzEyMg==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484997122", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Parses _include and _revinclude search result parameters contained in the query string, and produces\n          \n          \n            \n                 * Parses _include and _revinclude search parameters contained in the query string, and produces", "author": "prb112", "createdAt": "2020-09-08T15:10:08Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1373,17 +1414,25 @@ public static String normalizeForSearch(String value) {\n     }\n \n     /**\n-     * Parses _include and _revinclude search result parameters contained in the\n-     * query string, and produces\n-     * InclusionParameter objects to represent those parameters. The\n-     * InclusionParameter objects are included in the\n-     * appropriate collections encapsulated in the passed FHIRSearchContext.\n+     * Parses _include and _revinclude search result parameters contained in the query string, and produces", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTAwMA==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485199000", "bodyText": "Fixed.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NzEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485005466", "bodyText": "What happens when it's set to lenient? e.g. do we fail it? look at the behavior on line 1477", "author": "prb112", "createdAt": "2020-09-08T15:22:02Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzOTIyMA==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485039220", "bodyText": "In the case of a wildcard search, if no valid matching search parameters are found, then we simply don't generate an _include or _revinclude clause - no exception is thrown. Should an exception be thrown in that case (if non-lenient)? I can certainly add a log entry indicating no valid search parms were found.", "author": "michaelwschroeder", "createdAt": "2020-09-08T16:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0Mjc0NQ==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485042745", "bodyText": "Maybe we just log out, if it is set to not lenient?", "author": "prb112", "createdAt": "2020-09-08T16:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0NzAyNg==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485047026", "bodyText": "Yeah, will just log it.", "author": "michaelwschroeder", "createdAt": "2020-09-08T16:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNjM3Nw==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485006377", "bodyText": "single quotes around the value.  it shows better in the logs", "author": "prb112", "createdAt": "2020-09-08T15:23:20Z", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);\n             } else {\n-                newInclusionParm =\n-                        buildRevIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getRevIncludeParameters().add(newInclusionParm);\n+                searchParm = getSearchParameter(joinResourceType, searchParameterName);\n+                if (searchParm == null) {\n+                    String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n+                    if (lenient) {\n+                        // TODO add this to the list of supplemental warnings?\n+                        log.fine(msg);\n+                        continue;\n+                    } else {\n+                        throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                    }\n+                }\n+                if (!searchParm.getType().getValue().equals(\"reference\")) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n+                            + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTA4Ng==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485199086", "bodyText": "Fixed.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNjM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwODYwNA==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485008604", "bodyText": "Let's add a set of extra tests. That has two _include search parameters on Patient and Provenance.  we want to double check that it works across multiple resources.", "author": "prb112", "createdAt": "2020-09-08T15:26:23Z", "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test", "originalCommit": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTIyNw==", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485199227", "bodyText": "Added new unit tests.", "author": "michaelwschroeder", "createdAt": "2020-09-08T21:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwODYwNA=="}], "type": "inlineReview"}, {"oid": "44188619282c7e61b8ecb13e935132ba168401d4", "url": "https://github.com/IBM/FHIR/commit/44188619282c7e61b8ecb13e935132ba168401d4", "message": "Issue #1262 - address review comments, add tests\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>", "committedDate": "2020-09-08T21:10:28Z", "type": "commit"}, {"oid": "3e85a6064ae12aacf54e2c0d14898928e00873d4", "url": "https://github.com/IBM/FHIR/commit/3e85a6064ae12aacf54e2c0d14898928e00873d4", "message": "fix: double practitioner in SearchTest #1262\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-09-09T00:32:16Z", "type": "commit"}, {"oid": "f8164760f9300611ac93b3edf25107e652f39d02", "url": "https://github.com/IBM/FHIR/commit/f8164760f9300611ac93b3edf25107e652f39d02", "message": "Merge pull request #1492 from IBM/issue-1262-pbastide\n\nfix: double practitioner in SearchTest #1262", "committedDate": "2020-09-09T11:40:55Z", "type": "commit"}]}