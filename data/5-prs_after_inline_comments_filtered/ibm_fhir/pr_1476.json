{"pr_number": 1476, "pr_title": "fhir-bucket bulk loader initial merge", "pr_createdAt": "2020-09-04T13:23:02Z", "pr_url": "https://github.com/IBM/FHIR/pull/1476", "timeline": [{"oid": "321fbf0df215f8863263a3dff98d8c262ebef990", "url": "https://github.com/IBM/FHIR/commit/321fbf0df215f8863263a3dff98d8c262ebef990", "message": "issue #1402 bulk loading of resources for performance\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-13T15:01:24Z", "type": "commit"}, {"oid": "403a77e29aec945fb5b692d113eed591e2d00c19", "url": "https://github.com/IBM/FHIR/commit/403a77e29aec945fb5b692d113eed591e2d00c19", "message": "issue #1402 preliminary support for both json and ndjson\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-14T03:43:45Z", "type": "commit"}, {"oid": "7d88db8afbb53f7fec9fe824c15cb40bf56f244c", "url": "https://github.com/IBM/FHIR/commit/7d88db8afbb53f7fec9fe824c15cb40bf56f244c", "message": "issue #1402 handle loader instance failure and restart and store generated ids\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-14T21:47:26Z", "type": "commit"}, {"oid": "c9bd8ca0128179734378bdb6efc902d3f197a5ec", "url": "https://github.com/IBM/FHIR/commit/c9bd8ca0128179734378bdb6efc902d3f197a5ec", "message": "issue #1402 correctly record number of errors for each bundle/object\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-16T04:06:48Z", "type": "commit"}, {"oid": "2db4b5498bef7aaa721870a4078ac3a7db58ba45", "url": "https://github.com/IBM/FHIR/commit/2db4b5498bef7aaa721870a4078ac3a7db58ba45", "message": "issue 1424 start investigation of scale out persistence layers\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-18T21:03:10Z", "type": "commit"}, {"oid": "40c2a2cab380b18ea4ffaf8132807594814c5b86", "url": "https://github.com/IBM/FHIR/commit/40c2a2cab380b18ea4ffaf8132807594814c5b86", "message": "issue #1402 save logical ids from bundles and better tracking of stats\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-23T18:27:16Z", "type": "commit"}, {"oid": "508ebc5b2d3cc84a610e86314357d7a0065f582c", "url": "https://github.com/IBM/FHIR/commit/508ebc5b2d3cc84a610e86314357d7a0065f582c", "message": "issue #1402 fixed PostgreSQL support for FHIRBUCKET schema\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-24T04:08:17Z", "type": "commit"}, {"oid": "aadee881fe987ebb71fa6a76023ef63488362785", "url": "https://github.com/IBM/FHIR/commit/aadee881fe987ebb71fa6a76023ef63488362785", "message": "issue #1402 fixed timestampdiff for postgres, and capture and record operational outcome errors from FHIR\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-24T21:51:36Z", "type": "commit"}, {"oid": "11484ecb9c9414273e7fb2070f7b557749791bcb", "url": "https://github.com/IBM/FHIR/commit/11484ecb9c9414273e7fb2070f7b557749791bcb", "message": "issue #1402 better tracking of individual load attempts and new incremental-exact mode\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-26T15:43:53Z", "type": "commit"}, {"oid": "6b192a17af4efdcb920dd5e8839f69372b13c5c9", "url": "https://github.com/IBM/FHIR/commit/6b192a17af4efdcb920dd5e8839f69372b13c5c9", "message": "issue #1402 prototype for scale-out persistence with cassandra\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-27T18:19:00Z", "type": "commit"}, {"oid": "bc83587eab152190df654d3ac145f6ecb4ecd085", "url": "https://github.com/IBM/FHIR/commit/bc83587eab152190df654d3ac145f6ecb4ecd085", "message": "issue #1402 use deterministic order for job allocation\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-28T20:34:27Z", "type": "commit"}, {"oid": "9698b69a71dea1bb6b76fd1eb267ce9a0207c7fa", "url": "https://github.com/IBM/FHIR/commit/9698b69a71dea1bb6b76fd1eb267ce9a0207c7fa", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-08-29T03:21:07Z", "type": "commit"}, {"oid": "c14662b54f64be2b0bad6712b66bfbc5cfe7ef01", "url": "https://github.com/IBM/FHIR/commit/c14662b54f64be2b0bad6712b66bfbc5cfe7ef01", "message": "issue #1402 improved concurrency model for JSON and NDJSON files together\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T03:57:30Z", "type": "commit"}, {"oid": "edb7aca256b9eb567457264d4f66117aefbf11ff", "url": "https://github.com/IBM/FHIR/commit/edb7aca256b9eb567457264d4f66117aefbf11ff", "message": "issue #1402 prototype work for cassandra persistence store\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T03:59:41Z", "type": "commit"}, {"oid": "8a448b8b089a44dd362694f5028c5b315589f6dc", "url": "https://github.com/IBM/FHIR/commit/8a448b8b089a44dd362694f5028c5b315589f6dc", "message": "issue #1402 README cleanup\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T04:06:02Z", "type": "commit"}, {"oid": "e3c19573021dde1f8342d7e69ea8e4586912a54b", "url": "https://github.com/IBM/FHIR/commit/e3c19573021dde1f8342d7e69ea8e4586912a54b", "message": "issue #1402 Use logging.properties configuration\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T15:02:43Z", "type": "commit"}, {"oid": "f087bc13f2f0a99a96524081ff12aa71daeb8d3a", "url": "https://github.com/IBM/FHIR/commit/f087bc13f2f0a99a96524081ff12aa71daeb8d3a", "message": "issue #1402 support no hostname verification for cloud envs\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-01T17:36:09Z", "type": "commit"}, {"oid": "bb1d616d41ed3209c0809cb0921c829a045acae6", "url": "https://github.com/IBM/FHIR/commit/bb1d616d41ed3209c0809cb0921c829a045acae6", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-09-01T17:37:56Z", "type": "commit"}, {"oid": "fef6d10ef68b6c35f9d3a7b8afa219e8eace26bd", "url": "https://github.com/IBM/FHIR/commit/fef6d10ef68b6c35f9d3a7b8afa219e8eace26bd", "message": "issue #1402 improved load management of large bundles and httpclient version now 4.5.12\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T12:57:33Z", "type": "commit"}, {"oid": "7e19b5c10a1f3f53a5d033079def9c91999d75b5", "url": "https://github.com/IBM/FHIR/commit/7e19b5c10a1f3f53a5d033079def9c91999d75b5", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-09-04T12:59:19Z", "type": "commit"}, {"oid": "4bf31ea191348ce301e977956918a4d20a1a07e8", "url": "https://github.com/IBM/FHIR/commit/4bf31ea191348ce301e977956918a4d20a1a07e8", "message": "issue #1402 fhir-persistence-scout is experimental so removed from modules\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T13:07:57Z", "type": "commit"}, {"oid": "05b27fd00a2f45cd469c0fa570707d273be46cb9", "url": "https://github.com/IBM/FHIR/commit/05b27fd00a2f45cd469c0fa570707d273be46cb9", "message": "issue #1402 fixed Charset handling for Java 8\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T13:57:43Z", "type": "commit"}, {"oid": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "url": "https://github.com/IBM/FHIR/commit/d049d1228b4a41e37360ff28da2a2168f3df0e0f", "message": "issue #1402 fixed Charset handling for Java 8/11\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T14:56:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTU3Ng==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483701576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Constants for BulkExportImport.\n          \n          \n            \n             * Constants for FHIR Bucket.", "author": "prb112", "createdAt": "2020-09-04T15:40:59Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/Constants.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.api;\n+\n+/**\n+ * Constants for BulkExportImport.", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0NjA5Ng==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483746096", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T16:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTgwMw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483701803", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String DEFAULT_COS_BUCKETNAME = \"fhir-bulkImExport-Connectathon\";\n          \n          \n            \n                public static final String DEFAULT_COS_BUCKETNAME = \"fhir-bulkImExport-Connectathon\";\n          \n      \n    \n    \n  \n\nmaybe we drop this?", "author": "prb112", "createdAt": "2020-09-04T15:41:15Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/Constants.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.api;\n+\n+/**\n+ * Constants for BulkExportImport.\n+ *\n+ */\n+public class Constants {\n+\n+    public static final String DEFAULT_FHIR_TENANT = \"default\";\n+    public static final String DEFAULT_COS_BUCKETNAME = \"fhir-bulkImExport-Connectathon\";", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0NjM0NQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483746345", "bodyText": "definitely", "author": "punktilious", "createdAt": "2020-09-04T16:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMzI0MQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483703241", "bodyText": "smart addition", "author": "prb112", "createdAt": "2020-09-04T15:42:56Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/client/FhirClient.java", "diffHunk": "@@ -0,0 +1,504 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.client;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.NoHttpResponseException;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.UserTokenHandler;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpRequestBase;\n+import org.apache.http.config.Registry;\n+import org.apache.http.config.RegistryBuilder;\n+import org.apache.http.config.SocketConfig;\n+import org.apache.http.conn.ConnectionKeepAliveStrategy;\n+import org.apache.http.conn.socket.ConnectionSocketFactory;\n+import org.apache.http.conn.socket.PlainConnectionSocketFactory;\n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.DefaultConnectionReuseStrategy;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.pool.PoolStats;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.ssl.SSLContextBuilder;\n+import org.apache.http.util.EntityUtils;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.parser.FHIRParser;\n+import com.ibm.fhir.model.parser.exception.FHIRParserException;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Handles pooled HTTP/S connections to a FHIR server. Derived from the\n+ * former High Volume Ingestion Tool (HVIT) which is known to scale to\n+ * a large number of client connections.\n+ */\n+public class FhirClient {\n+\n+    private static final Logger logger = Logger.getLogger(FhirClient.class.getName());\n+    private static final String USER_AGENT = \"FHIR_BUCKET_LOADER\";", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNDkwMg==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483704902", "bodyText": "I think we have a setting that we can flip between FHIR and the RFC lastmodified.  In case you hit an issue with the format.", "author": "prb112", "createdAt": "2020-09-04T15:44:47Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/client/FhirClient.java", "diffHunk": "@@ -0,0 +1,504 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.client;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.NoHttpResponseException;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.UserTokenHandler;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpRequestBase;\n+import org.apache.http.config.Registry;\n+import org.apache.http.config.RegistryBuilder;\n+import org.apache.http.config.SocketConfig;\n+import org.apache.http.conn.ConnectionKeepAliveStrategy;\n+import org.apache.http.conn.socket.ConnectionSocketFactory;\n+import org.apache.http.conn.socket.PlainConnectionSocketFactory;\n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.DefaultConnectionReuseStrategy;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.pool.PoolStats;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.ssl.SSLContextBuilder;\n+import org.apache.http.util.EntityUtils;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.parser.FHIRParser;\n+import com.ibm.fhir.model.parser.exception.FHIRParserException;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Handles pooled HTTP/S connections to a FHIR server. Derived from the\n+ * former High Volume Ingestion Tool (HVIT) which is known to scale to\n+ * a large number of client connections.\n+ */\n+public class FhirClient {\n+\n+    private static final Logger logger = Logger.getLogger(FhirClient.class.getName());\n+    private static final String USER_AGENT = \"FHIR_BUCKET_LOADER\";\n+\n+    // Connection pool managing FHIR server HTTPS connections\n+    private PoolingHttpClientConnectionManager connManager;\n+    \n+    // HTTP client used to POST/PUT/GET FHIR server requests\n+    private CloseableHttpClient client;\n+    private String[] enabledCiphers;\n+\n+    // connection properties encapsulated in an adapter for easy access\n+    private final ClientPropertyAdapter propertyAdapter;\n+\n+    // The common headers we use which are shared across all threads\n+    private final Map<String,String> headers = new ConcurrentHashMap<String, String>();\n+    \n+    /**\n+     * Public constructor\n+     * @param cpa\n+     */\n+    public FhirClient(ClientPropertyAdapter cpa) {\n+        this.propertyAdapter = cpa;\n+    }\n+\n+    /**\n+     * Add the given key/value as a header\n+     * @param key\n+     * @param value\n+     */\n+    public void addHeader(String key, String value) {\n+        this.headers.put(key, value);\n+    }\n+    \n+    /**\n+     * Initialize the SSL connection pool after all the required field values have been injected\n+     */\n+    public void init(String tenantName) {\n+        if (connManager != null) {\n+            throw new IllegalStateException(\"Already initialied\");\n+        }\n+\n+        \n+        String enabledCiphersValue = propertyAdapter.getEnabledCiphers();\n+        if (enabledCiphersValue != null && !enabledCiphersValue.isEmpty()) {\n+            enabledCiphers = enabledCiphersValue.split(\",\");\n+        }\n+\n+        ConnectionKeepAliveStrategy connKeepAliveStrategy = new ConnectionKeepAliveStrategy() {\n+\n+            @Override\n+            public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n+                return 60000*60;\n+            }\n+        };\n+        \n+        try {\n+            // SSLContext sslContext = SSLContexts.custom().build();\n+            \n+            SSLContextBuilder sslContextBuilder = SSLContextBuilder.create();\n+            // sslContextBuilder.loadKeyMaterial(new File(keystoreFilename), keystorePass.toCharArray(), keyPass.toCharArray());\n+            sslContextBuilder.loadTrustMaterial(new File(propertyAdapter.getTruststore()), propertyAdapter.getTruststorePass().toCharArray());\n+            SSLContext sslContext = sslContextBuilder.build();\n+\n+            // For dev/test setups, allow connections to a FHIR server using a hostname\n+            // other than localhost\n+            HostnameVerifier hnv;\n+            if (propertyAdapter.isDisableHostnameVerification()) {\n+                hnv = new NoopHostnameVerifier();\n+            } else {\n+                hnv = SSLConnectionSocketFactory.getDefaultHostnameVerifier();\n+            }\n+            SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslContext, new String[]{\"TLSv1.2\"}, enabledCiphers, hnv);\n+\n+            Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()\n+                    .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n+                    .register(\"https\",factory).build();\n+\n+            connManager = new PoolingHttpClientConnectionManager(registry);\n+            connManager.setMaxTotal(propertyAdapter.getPoolConnectionsMax());\n+            connManager.setDefaultMaxPerRoute(propertyAdapter.getPoolConnectionsMax());\n+            connManager.setValidateAfterInactivity(60000);\n+            connManager.setDefaultSocketConfig(SocketConfig.custom().build());\n+            \n+            client = obtainCloseableHttpClient(connKeepAliveStrategy);\n+        } \n+        catch (KeyManagementException e) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", e);\n+        } \n+        catch (NoSuchAlgorithmException e) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", e);\n+        }        \n+        catch (IOException x) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", x);\n+        }\n+        catch (CertificateException x) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", x);\n+        }\n+        catch (KeyStoreException x) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", x);\n+        }\n+\n+        if (tenantName != null) {\n+            this.headers.put(Headers.TENANT_HEADER, tenantName);\n+        }\n+\n+        // For now, we only talk JSON with the FHIR server\n+        this.headers.put(Headers.ACCEPT_HEADER, ContentType.APPLICATION_JSON.getMimeType());\n+        this.headers.put(Headers.CONTENT_TYPE_HEADER, ContentType.APPLICATION_JSON.getMimeType());\n+        this.headers.put(\"Prefer\", \"return=representation\");\n+\n+        String user = propertyAdapter.getFhirServerUser();\n+        String pass = propertyAdapter.getFhirServerPass();\n+        if (user != null && pass != null) {\n+            // Set up basic auth\n+            String b64 = Base64.getEncoder().encodeToString(user.concat(\":\").concat(pass).getBytes());\n+            headers.put(Headers.AUTH_HEADER, \"Basic \".concat(b64));\n+        }\n+    }\n+    \n+    /**\n+     * Add our headers to the request\n+     * @param request\n+     */\n+    private void addHeadersTo(final HttpRequestBase request) {\n+        // inject each header into the request\n+        headers.entrySet().stream().forEach(e -> request.addHeader(e.getKey(), e.getValue())); \n+    }\n+    \n+    private String buildTargetPath(String resourceName) {\n+        StringBuilder result = new StringBuilder();\n+\n+        result.append(\"https://\");\n+        result.append(propertyAdapter.fhirServerHost());\n+        result.append(\":\");\n+        result.append(propertyAdapter.fhirServerPort());\n+        result.append(propertyAdapter.fhirServerEndpoint());\n+        \n+        if (resourceName != null) {\n+            result.append(resourceName);\n+        }\n+        \n+        return result.toString();\n+    }\n+    \n+    public FhirServerResponse get(String url, Function<Reader, Resource> fn) {\n+        \n+        String target = buildTargetPath(url);\n+        if (logger.isLoggable(Level.FINE)){\n+            logger.fine(\"REQUEST GET \"+ target);\n+        }\n+\n+        HttpGet getRequest = new HttpGet(target);\n+        addHeadersTo(getRequest);\n+        \n+        for (int i = 1; ; i++) {\n+            try {\n+                long startTime = System.nanoTime();\n+                HttpResponse response = client.execute(getRequest);\n+                if(logger.isLoggable(Level.FINE)){\n+                    Header responseHeaders[] = response.getAllHeaders();\n+                    \n+                    StringBuilder msg = new StringBuilder();\n+                    msg.append(\"Response HTTP Headers: \");\n+                    for (Header responseHeader : responseHeaders) {\n+                        msg.append(System.lineSeparator());\n+                        msg.append(\"\\t\" + responseHeader.getName() + \": \" + responseHeader.getValue());\n+                    }\n+                    logger.fine(msg.toString());\n+                }\n+                return buildResponse(response, startTime, true);\n+            } catch (NoHttpResponseException e) {\n+                logger.warning(\"Encountered an org.apache.http.NoHttpResponseException during GET request. \" + e);\n+                logger.warning(\"GET URL: \"+target);\n+                logger.warning(\"Will retry this request for the Nth time. N = \" + i);\n+            } catch (IOException e) {\n+                logger.severe(\"Error while executing the GET request. \" + e);\n+                logger.warning(\"GET URL: \"+target);\n+                logger.warning(\"Skipping this request.\");\n+                return null;\n+            }\n+        }        \n+    }\n+    \n+    /**\n+     * Issue a POST request at the given url\n+     * @param sUrl\n+     * @param body\n+     * @return\n+     */\n+    public FhirServerResponse post(String url, String body) {\n+        String target = buildTargetPath(url);\n+        if(logger.isLoggable(Level.FINE)) {\n+            logger.fine(\"REQUEST POST \"+ target);\n+        }\n+        \n+        try {\n+            HttpPost postRequest = new HttpPost(target);\n+            postRequest.setEntity(new StringEntity(body));\n+            addHeadersTo(postRequest);\n+            \n+            if(logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"REQUEST POST BODY - \" + body);\n+            }\n+            \n+            long startTime = System.currentTimeMillis();\n+            HttpResponse response = client.execute(postRequest);\n+            \n+            // Log details of the response if required\n+            if(logger.isLoggable(Level.FINE)) {\n+                Header responseHeaders[] = response.getAllHeaders();\n+                \n+                StringBuilder msg = new StringBuilder();\n+                msg.append(\"Response HTTP Headers: \");\n+                for (Header responseHeader : responseHeaders) {\n+                    msg.append(System.lineSeparator());\n+                    msg.append(\"\\t\" + responseHeader.getName() + \": \" + responseHeader.getValue());\n+                }\n+                logger.fine(msg.toString());\n+            }\n+\n+            // If we are posting a bundle, then we need to parse the response entity\n+            boolean isBundle = url.isEmpty();\n+            return buildResponse(response, startTime, isBundle);\n+            \n+        } catch (UnsupportedEncodingException e) {\n+            logger.severe(\"Can't encode json string into entity. \"+e);\n+            logger.warning(\"POST URL: \"+target+\"\\nRequest Body: \"+body);\n+            throw new IllegalStateException(\"FHIR client configuration error\");\n+        } catch (ClientProtocolException e) {\n+            logger.severe(\"Error while executing the POST request. \"+e);\n+            logger.warning(\"POST URL: \"+target+\"\\nRequest Body: \"+body);\n+            throw new DataAccessException(\"FHIR server connection failed\");\n+        } catch (IOException e) {\n+            logger.severe(\"Error while executing the POST request. \"+e);\n+            logger.warning(\"POST URL: \"+target+\"\\nRequest Body: \"+body);\n+            throw new DataAccessException(\"FHIR server connection failed\");\n+        }\n+    }\n+    \n+    public FhirServerResponse put(String url, Map<String, String> headers, String body) {\n+        String target = buildTargetPath(url);\n+\n+        if (logger.isLoggable(Level.FINE)) {\n+            logger.fine(\"REQUEST PUT \"+target);\n+        }\n+        \n+        try {\n+            HttpPut putRequest = new HttpPut(target);\n+            putRequest.setEntity(new StringEntity(body));\n+            addHeadersTo(putRequest);\n+            \n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"REQUEST PUT BODY - \" + body);\n+            }\n+            \n+            long startTime = System.currentTimeMillis();\n+            HttpResponse response = client.execute(putRequest);\n+            if (logger.isLoggable(Level.FINE)) {\n+                Header responseHeaders[] = response.getAllHeaders();\n+                logger.fine(\"Response HTTP Headers: \");\n+                for (Header responseHeader : responseHeaders) {\n+                    logger.fine(\"\\t\" + responseHeader.getName() + \": \" + responseHeader.getValue());\n+                }\n+            }\n+            return buildResponse(response, startTime, false);\n+            \n+        } catch (UnsupportedEncodingException e) {\n+            logger.severe(\"Can't encode json string into entity. \"+e);\n+            logger.warning(\"PUT URL: \"+target+\"\\nRequest Body: \"+body);\n+        } catch (ClientProtocolException e) {\n+            logger.severe(\"Error while executing the PUT request. \"+e);\n+            logger.warning(\"PUT URL: \"+target+\"\\nRequest Body: \"+body);\n+        } catch (IOException e) {\n+            logger.severe(\"Error while executing the PUT request. \"+e);\n+            logger.warning(\"PUT URL: \"+target+\"\\nRequest Body: \"+body);\n+        }\n+        \n+        return null;\n+    }\n+    \n+    public void shutdown() {\n+        if (client != null) {\n+            try {\n+                connManager.shutdown();\n+                client.close();\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\"Unable to shutdown HTTP clients and Connection Manager successfully. \", e);\n+            }\n+        }\n+        \n+    }\n+\n+    /**\n+     * Get statistics from the internal HTTP connection manager\n+     * @return\n+     */\n+    public PoolStats getPoolInformation() {\n+        if (connManager != null) {\n+            return connManager.getTotalStats();\n+        } \n+        \n+        return null;\n+    }\n+\n+    /**\n+     * Construct a FhirServerResponse from the FHIR server {@link HttpResponse}\n+     * @param response\n+     * @param startTime\n+     * @return\n+     */\n+    private FhirServerResponse buildResponse(HttpResponse response, long startTime, boolean processResponseEntity) {\n+        FhirServerResponse sr = new FhirServerResponse();\n+        \n+        int status = response.getStatusLine().getStatusCode();\n+        sr.setStatusCode(status);\n+        sr.setStatusMessage(response.getStatusLine().getReasonPhrase());\n+\n+        HttpEntity entity = response.getEntity();\n+        try {\n+            if (status == HttpStatus.SC_OK || status == HttpStatus.SC_CREATED) {\n+                if (processResponseEntity) {\n+                    processEntity(sr, entity);\n+                } else if (response.getFirstHeader(\"Location\") != null) {\n+                    // Single resource case, no response body, just the URL returned in the Location header\n+                    sr.setLocationHeader(response.getFirstHeader(\"Location\").getValue());\n+                } else {\n+                    logger.warning(\"No body or Location header in response\");\n+                }\n+            } else if (status == HttpStatus.SC_BAD_REQUEST) {\n+                processOperationalOutcome(sr, entity);\n+            } else {\n+                logger.warning(\"Unexpected server response: \" + status + \" \" + response.getStatusLine().getReasonPhrase());\n+            }\n+        } finally {\n+            consume(entity);\n+            long endTime = System.nanoTime();\n+            sr.setResponseTime((int)(endTime-startTime));\n+        }\n+        \n+            // Last-Modified: 2018-11-26T05:07:00.954Z\n+            // TODO\n+//            Header lastModifiedHeader = response.getFirstHeader(\"Last-Modified\");\n+//            if (lastModifiedHeader != null) {\n+//                sr.setLastModified(TimeUtil.getFhirTime(lastModifiedHeader.getValue()));", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MTg0NQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483751845", "bodyText": "I'm not using this at the moment, but noted for when I add this. Hopefully we have some utility code which already handles this, if not I create something.", "author": "punktilious", "createdAt": "2020-09-04T17:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNDkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwODg3MQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483708871", "bodyText": "I think I missed the intent of this class.  To be implemented?", "author": "prb112", "createdAt": "2020-09-04T15:51:56Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/DirectoryScanner.java", "diffHunk": "@@ -0,0 +1,10 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.scanner;\n+\n+public class DirectoryScanner {", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1Mjg2OQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483752869", "bodyText": "An artifact of my brain as I was thinking how best to scan through the COS tree (wondering if we might need to parallelize scanning of different branches of the tree). Not needed, so I'll remove.", "author": "punktilious", "createdAt": "2020-09-04T17:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwODg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwOTUyNA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483709524", "bodyText": "useful or extraneous now?", "author": "prb112", "createdAt": "2020-09-04T15:53:01Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/ResourceHandler.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.scanner;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.apache.http.HttpStatus;\n+\n+import com.ibm.fhir.bucket.api.ResourceBundleError;\n+import com.ibm.fhir.bucket.api.ResourceEntry;\n+import com.ibm.fhir.bucket.api.ResourceIdValue;\n+import com.ibm.fhir.bucket.client.FhirClient;\n+import com.ibm.fhir.bucket.client.FhirServerResponse;\n+import com.ibm.fhir.bucket.client.PostResource;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.generator.exception.FHIRGeneratorException;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Bundle.Entry.Response;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Calls the FHIR REST API to create resources, supported by a thread pool\n+ */\n+public class ResourceHandler {\n+    private static final Logger logger = Logger.getLogger(ResourceHandler.class.getName());\n+    private static final int BATCH_SIZE = 200;\n+    \n+    // Nanos in a millisecond\n+    private static final long NANOS_MS = 1000000;\n+\n+    // The number of concurrent FHIR requests we allow\n+    private final int maxConcurrentFhirRequests;\n+    \n+    // The thread pool\n+    private final ExecutorService pool;\n+\n+    // Client for making FHIR server requests\n+    private final FhirClient fhirClient;\n+    \n+    // flow control so we don't overload the thread pool queue\n+    private final Lock lock = new ReentrantLock();\n+    private final Condition capacityCondition = lock.newCondition();\n+    \n+    // how many resources are currently queued or being processed\n+    private int inflight;\n+    \n+    // flag used to handle shutdown\n+    private volatile boolean running = true;\n+\n+    // Access to the FHIR bucket persistence layer to record logical ids\n+    private final DataAccess dataAccess;\n+    \n+    /**\n+     * Public constructor\n+     * @param poolSize\n+     */\n+    public ResourceHandler(ExecutorService commonPool, int maxConcurrentFhirRequests, FhirClient fc, DataAccess dataAccess) {\n+        this.maxConcurrentFhirRequests = maxConcurrentFhirRequests;\n+        this.fhirClient = fc;\n+        this.pool = commonPool;\n+        this.dataAccess = dataAccess;\n+    }\n+\n+    /**\n+     * Tell the ResourceHandler to shut down processing\n+     */\n+    public void signalStop() {\n+        if (running) {\n+            logger.info(\"Shutting down resource handler\");\n+            this.running = false;\n+        }\n+        \n+        // Wake up anything which may be blocked\n+        lock.lock();\n+        try {\n+            capacityCondition.signalAll();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    /**\n+     * Shut down all resource processing\n+     */\n+    public void waitForStop() {\n+        signalStop();\n+        \n+        // We don't own the pool, so we don't wait for it to shut down\n+    }\n+\n+    /**\n+     * Add the resource entry to the thread-pool for processing, subject to the\n+     * rate limiting we have to make sure memory consumption is kept in check\n+     * @param entry\n+     * @return\n+     */\n+    public boolean process(ResourceEntry entry) {\n+        boolean result = false;\n+\n+        lock.lock();\n+        try {\n+            while (running && inflight >= maxConcurrentFhirRequests) {\n+                capacityCondition.await();\n+            }\n+            \n+            if (running) {\n+                inflight += entry.getCost(); // Grab the capacity while we're locked\n+                entry.getJob().addEntry(); // Add to row count so we can track when the job completes\n+                result = true;\n+            }\n+        } catch (InterruptedException x) {\n+            logger.info(\"Interrupted while waiting for capacity\");\n+        }\n+        finally {\n+            lock.unlock();\n+        }\n+\n+        // only submit to the pool if we have permission\n+        if (running && result) {\n+            pool.submit(() -> {\n+                try {\n+                    processThr(entry);\n+                } catch (Exception x) {\n+                    // don't let exceptions propagate to the thread-pool\n+                    logger.log(Level.SEVERE, entry.toString(), x);\n+                } finally {\n+                    lock.lock();\n+                    try {\n+                        // Free up the capacity consumed by this entry\n+                        inflight -= entry.getCost();\n+                        capacityCondition.signalAll();\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                }\n+            });\n+        }\n+        \n+        return result;\n+    }\n+    \n+    /**\n+     * Process the resource in the thread pool\n+     * @param resource\n+     */\n+    public void processThr(ResourceEntry re) {\n+        \n+        boolean success = false;\n+        try {\n+            Resource resource = re.getResource();\n+            final String resourceType = resource.getClass().getSimpleName();\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Processing resource: \" + resourceType);\n+            }\n+            \n+            // Build a post request for the resource and send to FHIR\n+            long start = System.nanoTime();\n+            PostResource post = new PostResource(resource);\n+            FhirServerResponse response = post.run(fhirClient);\n+            long end = System.nanoTime();\n+            switch (response.getStatusCode()) {\n+            case HttpStatus.SC_OK:\n+            case HttpStatus.SC_CREATED:\n+                String locn = response.getLocationHeader();\n+                if (response.getResource() != null) {\n+                    // Process the response bundle\n+                    success = processResponseResource(re, response.getResource());\n+                } else if (locn != null) {\n+                    if (locn.startsWith(\"https://\")) {\n+                        // the response was empty, so in this case we need to extract the id from\n+                        // the location header\n+                        int responseTimeMs = (int)((end - start) / NANOS_MS);\n+                        success = processLocation(re, locn, responseTimeMs);\n+                    } else {\n+                        logger.warning(\"FHIR bad location format [\" + re.toString() + \"]: \" + \n+                                locn);\n+                    }\n+                    \n+                } else {\n+                    logger.warning(\"FHIR request id not found [\" + re.toString() + \"]: \" + \n+                            response.getStatusCode() + \" \" + response.getStatusMessage());\n+                }\n+                break;\n+            default:\n+                logger.warning(\"FHIR request failed [\" + re.toString() + \"]: \" + \n+                        response.getStatusCode() + \" \" + response.getStatusMessage());\n+                processBadRequest(re, response);\n+                break;\n+            }\n+        } catch (Throwable x) {\n+            // don't let any exceptions propagate into the thread pool\n+            logger.log(Level.SEVERE, re.toString(), x);\n+        } finally {\n+            // Signal the processing is complete for this entry\n+            re.getJob().operationComplete(success);\n+        }\n+    }\n+\n+    /**\n+     * Process the bundle we received in the FHIR POST response to extract all the ids\n+     * Synthetic example:\n+        {           \n+            \"entry\": [\n+                {\n+                    \"response\": {\n+                        \"etag\": \"W/\\\"1\\\"\",\n+                        \"id\": \"1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309\",\n+                        \"lastModified\": \"2020-08-20T17:22:12.554128Z\",\n+                        \"location\": \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\",\n+                        \"status\": \"201\"\n+                    }\n+                },\n+                {\n+                    \"response\": {\n+                        \"etag\": \"W/\\\"1\\\"\",\n+                        \"id\": \"1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3\",\n+                        \"lastModified\": \"2020-08-20T17:22:12.980788Z\",\n+                        \"location\": \"Organization/1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3/_history/1\",\n+                        \"status\": \"201\"\n+                    }\n+                },\n+                ...\n+            ],  \n+            \"resourceType\": \"Bundle\",\n+            \"type\": \"transaction-response\"\n+        }\n+     * \n+     * @param bundle\n+     * @return\n+     */\n+    private boolean processResponseResource(ResourceEntry re, Resource resource) {\n+        boolean result;\n+        \n+        if (Bundle.class.isAssignableFrom(resource.getClass())) {\n+            Bundle bundle = resource.as(Bundle.class);\n+            result = processResponseBundle(re, bundle);\n+        } else {\n+            logger.severe(\"Resource is not a bundle. Skipping: \" + resource.getClass().getSimpleName());\n+            result = false;\n+        }\n+        \n+        \n+        return result;\n+    }\n+    \n+    private boolean processResponseBundle(ResourceEntry re, Bundle bundle) {\n+        \n+        // Extract the location from every entry in the bundle. Collect them\n+        // together so that we can make a single batch insert into the database\n+        // which is going to be a lot more efficient than individual inserts\n+        List<ResourceIdValue> idValues = new ArrayList<>();\n+        for (Bundle.Entry entry: bundle.getEntry()) {\n+            Response response = entry.getResponse();\n+            if (response != null) {\n+                if (response.getLocation() != null && response.getLocation().getValue() != null) {\n+                    String locn = response.getLocation().getValue();\n+                    logger.info(\"New resource: \" + locn);\n+                    ResourceIdValue rid = getResourceIdValue(locn);\n+                    if (rid != null) {\n+                        idValues.add(rid);\n+                    }\n+                }\n+            }\n+        }\n+\n+        processResourceIdValues(re, idValues);\n+        return idValues.size() > 0;\n+    }\n+\n+    /**\n+     * Process the list of resource ids as a batch\n+     * @param re\n+     * @param idValues\n+     * @return\n+     */\n+    private void processResourceIdValues(ResourceEntry re, List<ResourceIdValue> idValues) {\n+        dataAccess.recordLogicalIds(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), idValues, BATCH_SIZE);\n+    }\n+    /**\n+     * Parse the location to create a {@link ResourceIdValue} DTO object.\n+     * The location can take one of two forms:\n+     *   \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\"\n+     *   \"https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\"\n+     * @param location\n+     * @return\n+     */\n+    private ResourceIdValue getResourceIdValue(String location) {\n+        ResourceIdValue result;\n+    \n+        String[] parts = location.split(\"/\");\n+        if (parts.length == 10) {\n+            String resourceType = parts[6];\n+            String id = parts[7];\n+            result = new ResourceIdValue(resourceType, id);\n+        } else if (parts.length == 4) {\n+            String resourceType = parts[0];\n+            String id = parts[1];\n+            result = new ResourceIdValue(resourceType, id);\n+        } else {\n+            result = null;\n+        }\n+        \n+        return result;\n+    }\n+    \n+    private boolean processLocation(ResourceEntry re, String location, int responseTimeMs) {\n+        boolean result = false;\n+        // the response was empty, so in this case we need to extract the id from\n+        // the location header, which means cracking the string into parts:\n+        // https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\n+        String[] parts = location.split(\"/\");\n+        if (parts.length == 10) {\n+            String resourceType = parts[6];\n+            String id = parts[7];\n+            logger.info(\"[\" +re.toString() + \"] new \" + resourceType + \"/\" + id + \" [took \" + responseTimeMs + \" ms]\");\n+            dataAccess.recordLogicalId(resourceType, id, re.getJob().getResourceBundleLoadId(), re.getLineNumber(), responseTimeMs);\n+            result = true;\n+        }\n+        \n+        return result;\n+    }\n+\n+    /**\n+     * Record the error in the database\n+     * @param re\n+     * @param response\n+     */\n+    protected void processBadRequest(ResourceEntry re, FhirServerResponse response) {\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // dump the resource and full operational outcome to the log\n+            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n+                + resourceToString(re.getResource()));\n+            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n+                + response.getOperationalOutcomeText());\n+        }\n+        \n+        List<ResourceBundleError> errors = new ArrayList<>();\n+        errors.add(new ResourceBundleError(re.getLineNumber(), response.getOperationalOutcomeText(), \n+            response.getResponseTime(), response.getStatusCode(), response.getStatusMessage()));\n+        \n+        dataAccess.recordErrors(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), errors);\n+    }\n+\n+    /**\n+     * Render the resource as a string (for logging)\n+     * @param resource\n+     * @return\n+     */\n+    private String resourceToString(Resource resource) {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(4096);\n+        try {\n+            FHIRGenerator.generator(Format.JSON, false).generate(resource, os);\n+            return new String(os.toByteArray(), StandardCharsets.UTF_8);\n+        } catch (FHIRGeneratorException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void init() {\n+    }", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDc4MQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483754781", "bodyText": "My style. I tend to have init() methods on major classes to support initialization after dependencies have been injected. But in this case, everything gets set up in the constructor, so we're not really injecting anything. I'll leave for now, but may remove if it's really not useful next time I'm refactoring.", "author": "punktilious", "createdAt": "2020-09-04T17:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwOTUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzEyOQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713129", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.watson.health.fhir.persistence.FHIRPersistenceFactory#getInstance()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-09-04T15:59:45Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutFactory.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceNotSupportedException;\n+\n+/**\n+ * Factory for creating FHIRPersistence instances using Cloudant as the underlying\n+ * datastore.\n+ * @author rarnold\n+ *\n+ */\n+public class FHIRPersistenceScoutFactory implements FHIRPersistenceFactory {\n+    private static final Logger logger = Logger.getLogger(FHIRPersistenceScoutFactory.class.getName());\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.watson.health.fhir.persistence.FHIRPersistenceFactory#getInstance()\n+     */", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTEyOQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483749129", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzE5NA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713194", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author rarnold", "author": "prb112", "createdAt": "2020-09-04T15:59:53Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutFactory.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceNotSupportedException;\n+\n+/**\n+ * Factory for creating FHIRPersistence instances using Cloudant as the underlying\n+ * datastore.\n+ * @author rarnold", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0ODM2NQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483748365", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzM2MA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author Robin Arnold", "author": "prb112", "createdAt": "2020-09-04T16:00:11Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutImpl.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * (C) Copyright IBM Corp. 2017,2018,2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import static com.ibm.fhir.config.FHIRConfiguration.PROPERTY_UPDATE_CREATE_ENABLED;\n+import static com.ibm.fhir.model.type.String.string;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.text.MessageFormat;\n+import java.time.ZoneOffset;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.Map.Entry;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.datastax.oss.driver.api.core.CqlSessionBuilder;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.core.FHIRUtilities;\n+import com.ibm.fhir.database.utils.common.GetSequenceNextValueDAO;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.resource.SearchParameter;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.SearchParameter.Component;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Element;\n+import com.ibm.fhir.model.type.Id;\n+import com.ibm.fhir.model.type.Instant;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.SearchParamType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.visitor.Visitable;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.FHIRPathSystemValue;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.MultiResourceResult;\n+import com.ibm.fhir.persistence.SingleResourceResult;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.scout.SearchParameters;\n+import com.ibm.fhir.persistence.scout.SearchParameters.ParameterBlock;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValueList;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValueList;\n+import com.ibm.fhir.persistence.scout.cql.DatasourceSessions;\n+import com.ibm.fhir.search.SearchConstants.Type;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.date.DateTimeHandler;\n+import com.ibm.fhir.search.util.SearchUtil;\n+\n+/**\n+ * Scalable persistence layer, storing resources in Cassandra and the corresponding\n+ * indexes in Redis.\n+ * @author Robin Arnold", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NTc3MA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483755770", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzQ2NA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713464", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.FHIRPersistence#isDeleteSupported()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-09-04T16:00:23Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutImpl.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * (C) Copyright IBM Corp. 2017,2018,2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import static com.ibm.fhir.config.FHIRConfiguration.PROPERTY_UPDATE_CREATE_ENABLED;\n+import static com.ibm.fhir.model.type.String.string;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.text.MessageFormat;\n+import java.time.ZoneOffset;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.Map.Entry;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.datastax.oss.driver.api.core.CqlSessionBuilder;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.core.FHIRUtilities;\n+import com.ibm.fhir.database.utils.common.GetSequenceNextValueDAO;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.resource.SearchParameter;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.SearchParameter.Component;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Element;\n+import com.ibm.fhir.model.type.Id;\n+import com.ibm.fhir.model.type.Instant;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.SearchParamType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.visitor.Visitable;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.FHIRPathSystemValue;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.MultiResourceResult;\n+import com.ibm.fhir.persistence.SingleResourceResult;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.scout.SearchParameters;\n+import com.ibm.fhir.persistence.scout.SearchParameters.ParameterBlock;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValueList;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValueList;\n+import com.ibm.fhir.persistence.scout.cql.DatasourceSessions;\n+import com.ibm.fhir.search.SearchConstants.Type;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.date.DateTimeHandler;\n+import com.ibm.fhir.search.util.SearchUtil;\n+\n+/**\n+ * Scalable persistence layer, storing resources in Cassandra and the corresponding\n+ * indexes in Redis.\n+ * @author Robin Arnold\n+ */\n+public class FHIRPersistenceScoutImpl implements FHIRPersistence {\n+    private static final Logger logger = Logger.getLogger(FHIRPersistenceScoutImpl.class.getName());\n+    private static final String CLASSNAME = FHIRPersistenceScoutImpl.class.getName();\n+    private static final Logger log = Logger.getLogger(CLASSNAME);\n+        \n+    public static final String TRX_SYNCH_REG_JNDI_NAME = \"java:comp/TransactionSynchronizationRegistry\";\n+    \n+    // TODO. Shouldn't be necessary\n+    private static final int MAX_NUM_OF_COMPOSITE_COMPONENTS = 3;\n+    \n+    private TransactionSynchronizationRegistry trxSynchRegistry;\n+    \n+    private boolean updateCreateEnabled;\n+    \n+    private List<OperationOutcome.Issue> supplementalIssues = new ArrayList<>();\n+    \n+\n+    /**\n+     * Constructor for use when running as web application in WLP. \n+     * @throws Exception \n+     */\n+    public FHIRPersistenceScoutImpl() throws Exception {\n+        super();\n+        final String METHODNAME = \"FHIRPersistenceCloudantImpl()\";\n+        log.entering(CLASSNAME, METHODNAME);\n+        \n+        PropertyGroup fhirConfig = FHIRConfiguration.getInstance().loadConfiguration();\n+        this.updateCreateEnabled = fhirConfig.getBooleanProperty(PROPERTY_UPDATE_CREATE_ENABLED, Boolean.TRUE);\n+        log.exiting(CLASSNAME, METHODNAME);\n+    }\n+    \n+    /**\n+     * Constructor for use when running standalone, outside of any web container.\n+     * @throws Exception \n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    public FHIRPersistenceScoutImpl(Properties configProps) throws Exception {\n+        final String METHODNAME = \"FHIRPersistenceCloudantImpl(Properties)\";\n+        log.entering(CLASSNAME, METHODNAME);\n+        \n+        this.updateCreateEnabled = Boolean.parseBoolean(configProps.getProperty(\"updateCreateEnabled\"));\n+        \n+        log.exiting(CLASSNAME, METHODNAME);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.FHIRPersistence#isDeleteSupported()\n+     */", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NTg0OA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483755848", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNzAxNQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483717015", "bodyText": "Update in the code for the future? marking just to confirm", "author": "prb112", "createdAt": "2020-09-04T16:07:23Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/cql/InsertParameterBlock.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout.cql;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.ibm.fhir.persistence.scout.SearchParameters.ParameterBlock;\n+\n+/**\n+ * CQL command to insert the parameter block using the resource logical id as the key\n+ */\n+public class InsertParameterBlock {\n+    \n+    private final ParameterBlock parameterBlock;\n+    private final byte[] payload;\n+    \n+    public InsertParameterBlock(ParameterBlock pb, byte[] payload) {\n+        this.parameterBlock = pb;\n+        this.payload = payload;\n+    }\n+\n+    /**\n+     * Run the command against the given session\n+     * @param s\n+     */\n+    public void run(CqlSession s) {\n+        ", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NjE2NA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483756164", "bodyText": "Yes, this is a work in progress, but sharing to give others visibility.", "author": "punktilious", "createdAt": "2020-09-04T17:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxODEyMQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483718121", "bodyText": "no op?", "author": "prb112", "createdAt": "2020-09-04T16:09:43Z", "path": "fhir-persistence-scout/src/test/java/com/ibm/fhir/persistence/scale/test/ConfigTest.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scale.test;\n+\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ */\n+public class ConfigTest {\n+\n+    @Test\n+    public void test1() {\n+        ", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NjQ2Mw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483756463", "bodyText": "work in progress", "author": "punktilious", "createdAt": "2020-09-04T17:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxODEyMQ=="}], "type": "inlineReview"}, {"oid": "af882132deb9317ed3a35af66bf927a48d862add", "url": "https://github.com/IBM/FHIR/commit/af882132deb9317ed3a35af66bf927a48d862add", "message": "issue #1402 address pull request code review comments\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T17:23:04Z", "type": "commit"}, {"oid": "dd0629db54468331e19416da2dd1cbae75607829", "url": "https://github.com/IBM/FHIR/commit/dd0629db54468331e19416da2dd1cbae75607829", "message": "issue #1402 force fhir-bucket tests to be single-threaded\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T18:32:46Z", "type": "commit"}, {"oid": "542f22b887941c2ffcab4df73aa7dbc790686f2d", "url": "https://github.com/IBM/FHIR/commit/542f22b887941c2ffcab4df73aa7dbc790686f2d", "message": "issue #1402 use negative timeout for test to avoid potential clock jitter issue\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T19:09:27Z", "type": "commit"}]}