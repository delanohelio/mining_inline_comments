{"pr_number": 1604, "pr_title": "issue #1366 schema for efficient storage of reference search parameters and tokens", "pr_createdAt": "2020-10-20T03:40:58Z", "pr_url": "https://github.com/IBM/FHIR/pull/1604", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0OTgyMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513449822", "bodyText": "Copyright Year", "author": "prb112", "createdAt": "2020-10-28T13:39:37Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCParameterBuildingVisitor.java", "diffHunk": "@@ -52,6 +52,7 @@\n import com.ibm.fhir.persistence.jdbc.dto.LocationParmVal;\n import com.ibm.fhir.persistence.jdbc.dto.NumberParmVal;\n import com.ibm.fhir.persistence.jdbc.dto.QuantityParmVal;\n+import com.ibm.fhir.persistence.jdbc.dto.ReferenceParmVal;", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1MDY0NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513450644", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T13:40:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0OTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1MTUzMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513451530", "bodyText": "Is this now off the view?", "author": "prb112", "createdAt": "2020-10-28T13:41:44Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -729,13 +789,12 @@ private void appendInnerSelect(StringBuilder whereClauseSegment, QueryParameter\n         String chainedParmTableAlias = chainedParmVar + \".\";\n \n         // Build this piece: SELECT 'resource-type-name' || '/' || CLRx.LOGICAL_ID\n-        whereClauseSegment.append(\"SELECT \").append(\"'\" + resourceTypeName\n-                + \"'\").append(\" || \").append(\"'/'\").append(\" || \").append(chainedLogicalResourceTableAlias)\n-                .append(\"LOGICAL_ID\");\n+        // Note since #1366, we no longer need to prepend the resourceTypeName\n+        whereClauseSegment.append(\"SELECT \").append(chainedLogicalResourceTableAlias).append(\"LOGICAL_ID\");\n \n         QueryParameter nextParameter = currentParm.getNextParameter();\n \n-        // Build this piece: FROM Device_RESOURCES CR1, Device_LOGICAL_RESOURCES CLR1, Device_STR_VALUES CP1 WHERE\n+        // Build this piece: FROM Device_RESOURCES CR1, Device_LOGICAL_RESOURCES CLR1, Device_TOKEN_VALUES CP1 WHERE", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NDc1NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513454754", "bodyText": "fixed the comment", "author": "punktilious", "createdAt": "2020-10-28T13:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1MTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1MjgyMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513452822", "bodyText": "Could be combined to one else if", "author": "prb112", "createdAt": "2020-10-28T13:43:23Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -534,8 +564,10 @@ private SqlQueryData processReferenceParm(Class<?> resourceType, QueryParameter\n                                     + SqlParameterEncoder.encode(value.getValueString());\n                 } else {\n                     // This is a Reference type.\n-                    // As of versions greater than 4.4.0, we defer to the Search Layer to append the value.\n-                    searchValue = SqlParameterEncoder.encode(value.getValueString());\n+                    if (parts.length != 2) {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NjMwOA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513456308", "bodyText": "Could be, but I prefer not to because the predicate is based on a different variables than the enclosing if. It also helps to keep the Not a Reference/Reference comments neater.", "author": "punktilious", "createdAt": "2020-10-28T13:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1MjgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1MzU2NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513453564", "bodyText": "Would this ever be a URL reference?  e.g. http://localhost/fhir/api/v4/Patient/1", "author": "prb112", "createdAt": "2020-10-28T13:44:18Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -520,10 +544,16 @@ private SqlQueryData processReferenceParm(Class<?> resourceType, QueryParameter\n \n         boolean parmValueProcessed = false;\n         for (QueryParameterValue value : queryParm.getValues()) {\n-            // Handle query parm representing this name/value pair construct:\n-            // <code> {name} = {resource-type/resource-id}</code>\n+            String targetResourceType = null;\n             searchValue = SqlParameterEncoder.encode(value.getValueString());\n-\n+            \n+            // Make sure we split out the resource type if it is included in the search value\n+            String[] parts = value.getValueString().split(\"/\");\n+            if (parts.length == 2) {\n+                targetResourceType = parts[0];\n+                searchValue = parts[1];\n+            }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1ODUwNA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513458504", "bodyText": "It passes the reference search unit tests e.g.\n        assertSearchReturnsSavedResource(\"Reference-relative\", \"https://example.com/Patient/123\");", "author": "punktilious", "createdAt": "2020-10-28T13:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1MzU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NDYzNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513454636", "bodyText": "Should this use EQ?", "author": "prb112", "createdAt": "2020-10-28T13:45:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -609,14 +648,28 @@ protected SqlQueryData processChainedReferenceParm(QueryParameter queryParm) thr\n             if (nextParameter != null) {\n                 if (refParmIndex == 0) {\n                     // Must build this first piece using px placeholder table alias, which will be replaced with a\n-                    // generated value in the buildQuery() method.\n-                    // Build this piece:P1.PARAMETER_NAME_ID = x AND (p1.STR_VALUE IN\n+                    // generated value in the buildQuery() method. The CODE_SYSTEM_ID filter is added for issue #1366\n+                    // due to the normalization of token values\n+                    // Build this piece:P1.PARAMETER_NAME_ID = x AND AND P1.CODE_SYSTEM_ID = x AND (p1.TOKEN_VALUE IN\n                     this.populateNameIdSubSegment(whereClauseSegment, currentParm.getCode(), PARAMETER_TABLE_ALIAS);\n+\n+                    // The resource type of the reference is encoded as the code system associated with the token value\n+                    // so we need to add a filter to ensure we don't match logical-ids for other resource types\n+                    // Note if the match is for any resource, we simply don't filter on the resource type\n+                    final String codeSystemName = currentParm.getModifierResourceTypeName();\n+                    if (codeSystemName != null && !codeSystemName.equals(\"*\")) {\n+                        Integer codeSystemId = identityCache.getCodeSystemId(codeSystemName);\n+                        if (codeSystemId != null) {\n+                            whereClauseSegment.append(AND).append(PARAMETER_TABLE_ALIAS + DOT).append(CODE_SYSTEM_ID).append(\" = \")", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2MTA3Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513561077", "bodyText": "changed", "author": "punktilious", "createdAt": "2020-10-28T15:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NDYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NDczMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513454733", "bodyText": "Should this use EQ?", "author": "prb112", "createdAt": "2020-10-28T13:45:52Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -545,9 +577,16 @@ private SqlQueryData processReferenceParm(Class<?> resourceType, QueryParameter\n             } else {\n                 parmValueProcessed = true;\n             }\n-            // Build this piece: pX.str_value {operator} search-attribute-value\n-            whereClauseSegment.append(tableAlias).append(DOT).append(STR_VALUE).append(operator).append(BIND_VAR);\n+            // Build this piece: pX.token_value {operator} search-attribute-value [ AND pX.code_system_id = <n> ]\n+            whereClauseSegment.append(tableAlias).append(DOT).append(TOKEN_VALUE).append(operator).append(BIND_VAR);\n             bindVariables.add(searchValue);\n+            \n+            // add the [optional] condition for the resource type if we have one\n+            if (targetResourceType != null) {\n+                // Use a literal for the resource type code-system-id, not a parameter marker. Helps the cost-based optimizer\n+                int codeSystemIdForResourceType = getCodeSystemId(targetResourceType);\n+                whereClauseSegment.append(AND).append(tableAlias).append(DOT).append(CODE_SYSTEM_ID).append(\" = \").append(codeSystemIdForResourceType);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NTExNQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513455115", "bodyText": "Should this use EQ?", "author": "prb112", "createdAt": "2020-10-28T13:46:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -710,16 +765,21 @@ private SqlQueryData buildChainedIdClause(QueryParameter currentParm, String cha\n \n     private void appendMidChainParm(StringBuilder whereClauseSegment, QueryParameter currentParm, String chainedParmVar)\n             throws FHIRPersistenceDBConnectException, FHIRPersistenceDataAccessException, FHIRPersistenceException {\n-        Integer parameterNameId = ParameterNamesCache.getParameterNameId(currentParm.getCode());\n-        if (parameterNameId == null) {\n-            parameterNameId = this.parameterDao.readParameterNameId(currentParm.getCode());\n-            if (parameterNameId != null) {\n-                this.parameterDao.addParameterNamesCacheCandidate(currentParm.getCode(), parameterNameId);\n+        Integer parameterNameId = identityCache.getParameterNameId(currentParm.getCode());\n+        whereClauseSegment.append(chainedParmVar).append(DOT).append(\"PARAMETER_NAME_ID\").append(EQ)\n+                .append(parameterNameId);\n+\n+        // TODO handle code system lookup failures here. Perhaps = NULL to make the query return no rows?\n+        final String codeSystemName = currentParm.getModifierResourceTypeName();\n+        if (codeSystemName != null && !codeSystemName.equals(\"*\")) {\n+            Integer codeSystemId = identityCache.getCodeSystemId(codeSystemName);\n+            if (codeSystemId != null) {\n+                whereClauseSegment.append(AND).append(PARAMETER_TABLE_ALIAS + DOT).append(CODE_SYSTEM_ID).append(\" = \")", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1OTcwOA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513459708", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T13:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NTM5NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513455394", "bodyText": "Repetition... maybe a helper method to manage?", "author": "prb112", "createdAt": "2020-10-28T13:46:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -710,16 +765,21 @@ private SqlQueryData buildChainedIdClause(QueryParameter currentParm, String cha\n \n     private void appendMidChainParm(StringBuilder whereClauseSegment, QueryParameter currentParm, String chainedParmVar)\n             throws FHIRPersistenceDBConnectException, FHIRPersistenceDataAccessException, FHIRPersistenceException {\n-        Integer parameterNameId = ParameterNamesCache.getParameterNameId(currentParm.getCode());\n-        if (parameterNameId == null) {\n-            parameterNameId = this.parameterDao.readParameterNameId(currentParm.getCode());\n-            if (parameterNameId != null) {\n-                this.parameterDao.addParameterNamesCacheCandidate(currentParm.getCode(), parameterNameId);\n+        Integer parameterNameId = identityCache.getParameterNameId(currentParm.getCode());\n+        whereClauseSegment.append(chainedParmVar).append(DOT).append(\"PARAMETER_NAME_ID\").append(EQ)\n+                .append(parameterNameId);\n+\n+        // TODO handle code system lookup failures here. Perhaps = NULL to make the query return no rows?\n+        final String codeSystemName = currentParm.getModifierResourceTypeName();\n+        if (codeSystemName != null && !codeSystemName.equals(\"*\")) {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MTI5OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513461298", "bodyText": "Too risky to change anything here at this point, but I agree a helper would be useful. Raising an issue for the backlog.", "author": "punktilious", "createdAt": "2020-10-28T13:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NjQ2Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513456466", "bodyText": "Do we actually care if this is length 2? when would it not be 2? should it be <= to consider _history?", "author": "prb112", "createdAt": "2020-10-28T13:48:09Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -936,9 +995,23 @@ protected SqlQueryData processInclusionCriteria(QueryParameter queryParm) throws\n                 // (pX.PARAMETER_NAME_ID = x AND\n                 this.populateNameIdSubSegment(whereClauseSegment, currentParm.getCode(), PARAMETER_TABLE_ALIAS);\n                 whereClauseSegment.append(AND);\n-                // Build this piece: pX.str_value = search-attribute-value\n-                whereClauseSegment.append(PARAMETER_TABLE_ALIAS + DOT).append(STR_VALUE).append(operator)\n+                \n+                // split the resource type name out (since issue #1366)\n+                String resourceTypeName = null;\n+                String[] parts = currentParmValue.split(\"/\");\n+                if (parts.length == 2) {\n+                    resourceTypeName = parts[0];\n+                    currentParmValue = parts[1];\n+                }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NTE0OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513465149", "bodyText": "There aren't any unit tests for _history so I guess it's not currently supported or even handled.  Lee has an issue #1273 open to support it properly (which is now possible). I think this will need to be addressed as part of that", "author": "punktilious", "createdAt": "2020-10-28T13:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NjQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzAzMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513457030", "bodyText": "shouldn't this be split into two appends? .append(PARAMETER_TABLE_ALIAS).append(DOT)", "author": "prb112", "createdAt": "2020-10-28T13:48:51Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -936,9 +995,23 @@ protected SqlQueryData processInclusionCriteria(QueryParameter queryParm) throws\n                 // (pX.PARAMETER_NAME_ID = x AND\n                 this.populateNameIdSubSegment(whereClauseSegment, currentParm.getCode(), PARAMETER_TABLE_ALIAS);\n                 whereClauseSegment.append(AND);\n-                // Build this piece: pX.str_value = search-attribute-value\n-                whereClauseSegment.append(PARAMETER_TABLE_ALIAS + DOT).append(STR_VALUE).append(operator)\n+                \n+                // split the resource type name out (since issue #1366)\n+                String resourceTypeName = null;\n+                String[] parts = currentParmValue.split(\"/\");\n+                if (parts.length == 2) {\n+                    resourceTypeName = parts[0];\n+                    currentParmValue = parts[1];\n+                }\n+                \n+                // Build this piece: pX.token_value = search-attribute-value [ AND pX.code_system_id = <n> ]\n+                whereClauseSegment.append(PARAMETER_TABLE_ALIAS + DOT).append(TOKEN_VALUE).append(operator)", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NTgzMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513465830", "bodyText": "yes", "author": "punktilious", "createdAt": "2020-10-28T13:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzE1MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513457151", "bodyText": "shouldn't this be split into two appends? .append(PARAMETER_TABLE_ALIAS).append(DOT)", "author": "prb112", "createdAt": "2020-10-28T13:49:02Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -609,14 +648,28 @@ protected SqlQueryData processChainedReferenceParm(QueryParameter queryParm) thr\n             if (nextParameter != null) {\n                 if (refParmIndex == 0) {\n                     // Must build this first piece using px placeholder table alias, which will be replaced with a\n-                    // generated value in the buildQuery() method.\n-                    // Build this piece:P1.PARAMETER_NAME_ID = x AND (p1.STR_VALUE IN\n+                    // generated value in the buildQuery() method. The CODE_SYSTEM_ID filter is added for issue #1366\n+                    // due to the normalization of token values\n+                    // Build this piece:P1.PARAMETER_NAME_ID = x AND AND P1.CODE_SYSTEM_ID = x AND (p1.TOKEN_VALUE IN\n                     this.populateNameIdSubSegment(whereClauseSegment, currentParm.getCode(), PARAMETER_TABLE_ALIAS);\n+\n+                    // The resource type of the reference is encoded as the code system associated with the token value\n+                    // so we need to add a filter to ensure we don't match logical-ids for other resource types\n+                    // Note if the match is for any resource, we simply don't filter on the resource type\n+                    final String codeSystemName = currentParm.getModifierResourceTypeName();\n+                    if (codeSystemName != null && !codeSystemName.equals(\"*\")) {\n+                        Integer codeSystemId = identityCache.getCodeSystemId(codeSystemName);\n+                        if (codeSystemId != null) {\n+                            whereClauseSegment.append(AND).append(PARAMETER_TABLE_ALIAS + DOT).append(CODE_SYSTEM_ID).append(\" = \")\n+                                    .append(codeSystemId);\n+                        }\n+                    }\n+                    \n                     whereClauseSegment.append(AND);\n                     whereClauseSegment.append(LEFT_PAREN);\n-                    whereClauseSegment.append(PARAMETER_TABLE_ALIAS + DOT).append(STR_VALUE).append(IN);\n+                    whereClauseSegment.append(PARAMETER_TABLE_ALIAS + DOT).append(TOKEN_VALUE).append(IN);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NzA2NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513467064", "bodyText": "yes, although this was how it was originally written...not sure why", "author": "punktilious", "createdAt": "2020-10-28T14:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzUwMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513457501", "bodyText": "shouldn't this be split into two appends? .append(PARAMETER_TABLE_ALIAS).append(DOT)", "author": "prb112", "createdAt": "2020-10-28T13:49:27Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -936,9 +995,23 @@ protected SqlQueryData processInclusionCriteria(QueryParameter queryParm) throws\n                 // (pX.PARAMETER_NAME_ID = x AND\n                 this.populateNameIdSubSegment(whereClauseSegment, currentParm.getCode(), PARAMETER_TABLE_ALIAS);\n                 whereClauseSegment.append(AND);\n-                // Build this piece: pX.str_value = search-attribute-value\n-                whereClauseSegment.append(PARAMETER_TABLE_ALIAS + DOT).append(STR_VALUE).append(operator)\n+                \n+                // split the resource type name out (since issue #1366)\n+                String resourceTypeName = null;\n+                String[] parts = currentParmValue.split(\"/\");\n+                if (parts.length == 2) {\n+                    resourceTypeName = parts[0];\n+                    currentParmValue = parts[1];\n+                }\n+                \n+                // Build this piece: pX.token_value = search-attribute-value [ AND pX.code_system_id = <n> ]\n+                whereClauseSegment.append(PARAMETER_TABLE_ALIAS + DOT).append(TOKEN_VALUE).append(operator)\n                         .append(BIND_VAR);\n+                if (resourceTypeName != null) {\n+                    int codeSystemIdForResourceType = getCodeSystemId(resourceTypeName);\n+                    whereClauseSegment.append(AND).append(PARAMETER_TABLE_ALIAS + DOT)", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODM3NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513468375", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T14:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzU2Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513457566", "bodyText": "shouldn't this be split into two appends? .append(PARAMETER_TABLE_ALIAS).append(DOT)", "author": "prb112", "createdAt": "2020-10-28T13:49:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1023,13 +1096,9 @@ private SqlQueryData processTokenParm(QueryParameter queryParm, String tableAlia\n                     }\n                     whereClauseSegment.append(tableAlias + DOT).append(CODE_SYSTEM_ID).append(operator)", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODkxMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513468911", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T14:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1NzU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1ODIxNQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513458215", "bodyText": "Sounds ideal for a backlog issue", "author": "prb112", "createdAt": "2020-10-28T13:50:18Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/InclusionQuerySegmentAggregator.java", "diffHunk": "@@ -208,23 +212,31 @@ protected SqlQueryData buildQuery() throws Exception {\n     }\n \n     /**\n+     * TODO This should not be executed, but instead performed in the database as a join", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2OTU4Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513469587", "bodyText": "noted", "author": "punktilious", "createdAt": "2020-10-28T14:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1ODIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1OTMyMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513459321", "bodyText": "Where do these stray tabs come from", "author": "prb112", "createdAt": "2020-10-28T13:51:32Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/DerbyBootstrapper.java", "diffHunk": "@@ -137,7 +174,7 @@ public static void bootstrap(Connection connection, String adminSchemaName, Stri\n             populateResourceTypeAndParameterNameTableEntries(connection, adminSchemaName, dataSchemaName);\n         }\n     }\n-\n+    ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MDMxMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513470313", "bodyText": "Eclipse adds them if you look at it in the wrong way", "author": "punktilious", "createdAt": "2020-10-28T14:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1OTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MTA0MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513471040", "bodyText": "removed", "author": "punktilious", "createdAt": "2020-10-28T14:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1OTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1OTQ3MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513459470", "bodyText": "spaces", "author": "prb112", "createdAt": "2020-10-28T13:51:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/DerbyBootstrapper.java", "diffHunk": "@@ -77,7 +80,7 @@ public static void bootstrapDb(DataSource fhirDb) throws SQLException {\n             if (dbDriverName != null && dbDriverName.contains(\"Derby\")) {\n                 final String adminSchemaName = \"admin_\" + tenantId + \"_\" + dsId;\n                 final String dataSchemaName = connection.getSchema();\n-\n+                ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MDU4NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513460585", "bodyText": "Wrong Package location", "author": "prb112", "createdAt": "2020-10-28T13:53:15Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/Db2ResourceReferenceDAO.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ICommonTokenValuesCache;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceTokenValueRec;\n+import com.ibm.fhir.persistence.jdbc.dto.CommonTokenValue;\n+\n+\n+/**\n+ * Postgres-specific extension of the {@link ResourceReferenceDAO} to work around\n+ * some SQL syntax and Postgres concurrency issues\n+ */\n+public class Db2ResourceReferenceDAO extends ResourceReferenceDAO {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MTYyMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513471621", "bodyText": "save as..moving.", "author": "punktilious", "createdAt": "2020-10-28T14:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MTIyMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513461220", "bodyText": "Wrong package", "author": "prb112", "createdAt": "2020-10-28T13:54:08Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/DerbyResourceReferenceDAO.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ICommonTokenValuesCache;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceTokenValueRec;\n+import com.ibm.fhir.persistence.jdbc.dto.CommonTokenValue;\n+\n+\n+/**\n+ * Postgres-specific extension of the {@link ResourceReferenceDAO} to work around\n+ * some SQL syntax and Postgres concurrency issues\n+ */\n+public class DerbyResourceReferenceDAO extends ResourceReferenceDAO {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Mzg0OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513473848", "bodyText": "moved", "author": "punktilious", "createdAt": "2020-10-28T14:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MjUzMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513462531", "bodyText": "Note, we are inconsistent on the prefix for these classes.  I much prefer Postgres vs PostgreSQL\nAlso, this is a migration class?", "author": "prb112", "createdAt": "2020-10-28T13:55:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgresResourceReferenceDAO.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ICommonTokenValuesCache;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dto.CommonTokenValue;\n+\n+\n+/**\n+ * Postgres-specific extension of the {@link ResourceReferenceDAO} to work around\n+ * some SQL syntax and Postgres concurrency issues\n+ */\n+public class PostgresResourceReferenceDAO extends ResourceReferenceDAO {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3NTUzNA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513475534", "bodyText": "Yeah Postgres is much easier to read. The postgresql package name is legacy. What do you mean migration class? It's core to 1366 persistence.", "author": "punktilious", "createdAt": "2020-10-28T14:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MjUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzI4MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513627280", "bodyText": "Raised issue #1636.", "author": "punktilious", "createdAt": "2020-10-28T17:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MjUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMjY0OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513702648", "bodyText": "sounds good - I think the way I tried to read this it came out of order.", "author": "prb112", "createdAt": "2020-10-28T19:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MjUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MzgxMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513463812", "bodyText": "Inconsistent naming", "author": "prb112", "createdAt": "2020-10-28T13:57:18Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceNoProcDAO.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.CallableStatement;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCCache;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.IResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.JDBCIdentityCache;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.JDBCIdentityCacheImpl;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.impl.ParameterTransactionDataImpl;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to a PostgreSQL database.\n+ * Like the Derby implementation, this version uses individual SQL statements\n+ * instead of a stored procedure and is useful for debugging performance and/or\n+ * concurrency issues. It should not be used in production scenarios because\n+ * the numerous app-database round-trips slow things down considerably.\n+ * \n+ * @implNote This class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceNoProcDAO extends ResourceDAOImpl {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NTgwNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513465806", "bodyText": "Why are we splitting the implementations? is one better than the other?\nShould we add experimental or test to the package?", "author": "prb112", "createdAt": "2020-10-28T13:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MzgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Njk3MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513476971", "bodyText": "Just following previously established convention (Albert's initial implementation)", "author": "punktilious", "createdAt": "2020-10-28T14:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MzgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NDA5OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513464099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n          \n          \n            \n                public Resource insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n          \n      \n    \n    \n  \n\nextra space", "author": "prb112", "createdAt": "2020-10-28T13:57:39Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceNoProcDAO.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.CallableStatement;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCCache;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.IResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.JDBCIdentityCache;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.JDBCIdentityCacheImpl;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.impl.ParameterTransactionDataImpl;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to a PostgreSQL database.\n+ * Like the Derby implementation, this version uses individual SQL statements\n+ * instead of a stored procedure and is useful for debugging performance and/or\n+ * concurrency issues. It should not be used in production scenarios because\n+ * the numerous app-database round-trips slow things down considerably.\n+ * \n+ * @implNote This class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceNoProcDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final String SQL_READ_RESOURCE_TYPE = \"{CALL %s.add_resource_type(?, ?)}\";\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlResourceNoProcDAO(Connection connection, String schemaName, FHIRDbFlavor flavor, FHIRPersistenceJDBCCache cache, IResourceReferenceDAO rrd) {\n+        super(connection, schemaName, flavor, cache, rrd);\n+    }\n+\n+    public PostgreSqlResourceNoProcDAO(Connection connection, String schemaName, FHIRDbFlavor flavor, TransactionSynchronizationRegistry trxSynchRegistry, FHIRPersistenceJDBCCache cache, IResourceReferenceDAO rrd,\n+        ParameterTransactionDataImpl ptdi) {\n+        super(connection, schemaName, flavor, trxSynchRegistry, cache, rrd, ptdi);\n+    }\n+    \n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODQ5OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513478498", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T14:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NDA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NzYwMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513467602", "bodyText": "this one seems useful as a backlog issue / technical debt", "author": "prb112", "createdAt": "2020-10-28T14:02:06Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -256,6 +282,8 @@ public FHIRPersistenceJDBCImpl(Properties configProps, IConnectionProvider cp, F\n         // For unit tests (outside of JEE), we also need our own mechanism for handling transactions\n         this.transactionAdapter = new FHIRTestTransactionAdapter(cp);\n \n+        // TODO connect the transactionAdapter to our cache so that we can handle tx events in a non-JEE world\n+        this.transactionDataImpl = null;", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3OTc1Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513479756", "bodyText": "Creating an issue", "author": "punktilious", "createdAt": "2020-10-28T14:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NzYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODAxNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513468017", "bodyText": "Confirming... ONLY Derby?", "author": "prb112", "createdAt": "2020-10-28T14:02:38Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -267,7 +295,18 @@ public FHIRPersistenceJDBCImpl(Properties configProps, IConnectionProvider cp, F\n      */\n     protected Action buildActionChain() {\n         // Note: do not call setSchema on a connection. It exposes a bug in Liberty.\n-        return new SetTenantAction(this.configProvider);\n+        \n+        // Configure an action to set the tenant global variable the\n+        // first time we start using a connection in a transaction\n+        Action result = new SetTenantAction(this.configProvider);\n+        \n+        // For Derby, we also need to make sure that the declared global temporary tables\n+        // are created for the current session (connection). TODO. discuss if we only\n+        // want to invoke this for ingestion calls. These tables are not required for\n+        // reads/searches.\n+        result = new CreateTempTablesAction(result);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDEzMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513480131", "bodyText": "Only Derby", "author": "punktilious", "createdAt": "2020-10-28T14:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODc4Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513468787", "bodyText": "What's unchecked here?", "author": "prb112", "createdAt": "2020-10-28T14:03:45Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -1640,9 +1690,188 @@ public String getSchemaForRequestContext(Connection connection) throws FHIRPersi\n             throw new FHIRPersistenceDBConnectException(\"Datastore configuration issue. Details in server logs\");\n         }\n     }\n+\n+    /**\n+     * Prefill the caches\n+     */\n+    public void doCachePrefill(Connection connection) throws FHIRPersistenceException {\n+        // Perform the cache prefill just once (for a given tenant). This isn't synchronous, so\n+        // there's a chance for other threads to slip in before the prefill completes. Those threads\n+        // just end up having cache-misses for the names they need.\n+        // Note - this is done as the first thing in a transaction so there's no concern about reading\n+        // uncommitted values.\n+        if (cache.needToPrefill()) {\n+            ResourceDAO resourceDao = makeResourceDAO(connection);\n+            ParameterDAO parameterDao = makeParameterDAO(connection);\n+            FHIRPersistenceJDBCCacheUtil.prefill(resourceDao, parameterDao, cache);\n+        }\n+    }\n+    \n+    @Override\n+    public boolean isReindexSupported() {\n+        return true;\n+    }\n+\n+    @Override\n+    public int reindex(FHIRPersistenceContext context, OperationOutcome.Builder operationOutcomeResult, java.time.Instant tstamp)\n+        throws FHIRPersistenceException {\n+        final String METHODNAME = \"reindex\";\n+        log.entering(CLASSNAME, METHODNAME);\n+        \n+        int result = 0;\n+        \n+        if (log.isLoggable(Level.FINE)) {\n+            log.fine(\"reindex _tstamp=\" + tstamp.toString());\n+        }\n+        \n+        if (tstamp.isAfter(java.time.Instant.now())) {\n+            // protect against setting a future timestamp, which could otherwise \n+            // disable the ability to reindex anything\n+            throw new FHIRPersistenceException(\"Reindex _tstamp cannot be in the future\");\n+        }\n+\n+        try (Connection connection = openConnection()) {\n+            ResourceDAO resourceDao = makeResourceDAO(connection);\n+            ParameterDAO parameterDao = makeParameterDAO(connection);\n+            ReindexResourceDAO reindexDAO = FHIRResourceDAOFactory.getReindexResourceDAO(connection, FhirSchemaConstants.FHIR_ADMIN, schemaNameSupplier.getSchemaForRequestContext(connection), connectionStrategy.getFlavor(), this.trxSynchRegistry, this.cache, parameterDao);\n+            // Obtain a resource we will reindex in this request/transaction. The record is locked as part\n+            // of its selection, so we avoid a lot of (but not all) deadlock issues\n+            long start = System.nanoTime();\n+            ResourceIndexRecord rir = reindexDAO.getResourceToReindex(tstamp);\n+            long end = System.nanoTime();\n+            \n+            if (log.isLoggable(Level.FINER)) {\n+                double elapsed = (end-start)/1e6;\n+                log.finer(String.format(\"Selected %d resource for reindexing in %.3f ms \", rir != null ? 1 : 0, elapsed));\n+            }\n+\n+            if (rir != null) {\n+                // result is only 0 if getResourceToReindex doesn't give us anything because this indicates\n+                // there's nothing left to do\n+                result = 1;\n+                \n+                // This is important so we log it as info\n+                log.info(\"Reindexing FHIR Resource '\" + rir.getResourceType() + \"/\" + rir.getLogicalId() + \"'\");\n+                    \n+                // Read the current resource\n+                com.ibm.fhir.persistence.jdbc.dto.Resource existingResourceDTO = resourceDao.read(rir.getLogicalId(), rir.getResourceType());\n+                if (existingResourceDTO != null) {\n+                    List<String> elements = Collections.emptyList();\n+                    Resource existingResource = this.convertResourceDTO(existingResourceDTO, Resource.class, elements);\n+                    \n+                    reindexDAO.setPersistenceContext(context);\n+                    reindexDAO.updateParameters(rir.getResourceType(), this.extractSearchParameters(existingResource, existingResourceDTO), rir.getLogicalId(), rir.getLogicalResourceId());\n+    \n+                    // Use an OperationOutcome Issue to let the caller know that some work was performed\n+                    final String diag = \"Processed \" + rir.getResourceType() + \"/\" + rir.getLogicalId();\n+                    operationOutcomeResult.issue(Issue.builder().code(IssueType.INFORMATIONAL).severity(IssueSeverity.INFORMATION).diagnostics(com.ibm.fhir.model.type.String.of(diag)).build());\n+                } else {\n+                    // Reasonable to assume that this resource was deleted because we can't read it\n+                    final String diag = \"Failed to read resource: \" + rir.getResourceType() + \"/\" + rir.getLogicalId();\n+                    operationOutcomeResult.issue(Issue.builder().code(IssueType.NOT_FOUND).severity(IssueSeverity.WARNING).diagnostics(com.ibm.fhir.model.type.String.of(diag)).build());\n+                }                \n+            }\n+            \n+        } catch(FHIRPersistenceFKVException e) {\n+            getTransaction().setRollbackOnly();\n+            throw e;\n+        } catch(FHIRPersistenceException e) {\n+            getTransaction().setRollbackOnly();\n+            throw e;\n+        } catch (DataAccessException dax) {\n+            getTransaction().setRollbackOnly();\n+            \n+            // It's possible this is a deadlock exception, in which case it could be considered retryable\n+            if (dax.isTransactionRetryable()) {\n+                log.log(Level.SEVERE, \"retryable error\", dax);\n+                FHIRPersistenceDataAccessException fpx = new FHIRPersistenceDataAccessException(\"Data access error while performing a reindex operation.\");\n+                fpx.setTransactionRetryable(true);\n+                throw fpx;\n+            } else {\n+                log.log(Level.SEVERE, \"non-retryable error\", dax);\n+                throw new FHIRPersistenceDataAccessException(\"Data access error while performing a reindex operation.\");\n+            }\n+        } catch(Throwable e) {\n+            getTransaction().setRollbackOnly();\n+            // don't chain the exception to avoid leaking secrets\n+            FHIRPersistenceException fx = new FHIRPersistenceException(\"Unexpected error while performing a reindex operation.\");\n+            log.log(Level.SEVERE, fx.getMessage(), e);\n+            throw fx;\n+        }\n+        finally {\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        \n+        return result;\n+    }\n     \n     @Override\n     public String generateResourceId() {\n         return logicalIdentityProvider.createNewIdentityValue();\n     }\n+\n+    /**\n+     * Each datasource involved in a transaction gets its own TransactionData impl object\n+     * which is used to hold parameter data to be inserted into the datbase just prior to\n+     * commit.\n+     * @param datasourceId\n+     * @return the ParameterTransactionDataImpl used to hold onto data to persist at the end of the current transaction\n+     */\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTkyMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513481921", "bodyText": "this.transactionDataImpl = (TransactionDataImpl<ParameterTransactionDataImpl>)tdi;", "author": "punktilious", "createdAt": "2020-10-28T14:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MTM3OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513471379", "bodyText": "Confirming here... it does not exist when the Temp Table already exists", "author": "prb112", "createdAt": "2020-10-28T14:06:58Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/CreateCommonTokenValuesTmp.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.derby;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.schema.control.FhirSchemaConstants;\n+\n+\n+/**\n+ * Create the COMMON_TOKEN_VALUES_TMP table\n+ */\n+public class CreateCommonTokenValuesTmp implements IDatabaseStatement {\n+    private static final Logger logger = Logger.getLogger(CreateCommonTokenValuesTmp.class.getName());\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        \n+        if (!isExists(c)) {\n+            final String ddl = \"\"\n+                    + \"DECLARE GLOBAL TEMPORARY TABLE common_token_values_tmp (\"\n+                    + \"  token_value VARCHAR(\" + FhirSchemaConstants.MAX_TOKEN_VALUE_BYTES + \"), \"\n+                    + \"  code_system_id INT\"\n+                    + \") NOT LOGGED\";\n+            \n+            try (Statement s = c.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                logger.log(Level.SEVERE, ddl, x);\n+                throw translator.translate(x);\n+            }\n+        }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mzc5NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513483794", "bodyText": "The temp table is session based...it only exists when created on the current connection (and each connection sees its own version of the table). So we just need to create it once per connection, hence the check to see if it currently exists or not.", "author": "punktilious", "createdAt": "2020-10-28T14:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MTcyMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513471721", "bodyText": "This is fixed to something like 512?", "author": "prb112", "createdAt": "2020-10-28T14:07:24Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/CreateCommonTokenValuesTmp.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.derby;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.schema.control.FhirSchemaConstants;\n+\n+\n+/**\n+ * Create the COMMON_TOKEN_VALUES_TMP table\n+ */\n+public class CreateCommonTokenValuesTmp implements IDatabaseStatement {\n+    private static final Logger logger = Logger.getLogger(CreateCommonTokenValuesTmp.class.getName());\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        \n+        if (!isExists(c)) {\n+            final String ddl = \"\"\n+                    + \"DECLARE GLOBAL TEMPORARY TABLE common_token_values_tmp (\"\n+                    + \"  token_value VARCHAR(\" + FhirSchemaConstants.MAX_TOKEN_VALUE_BYTES + \"), \"", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4NTQ5OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513485499", "bodyText": "Yeah, it matches the definition in the real table for this column.\npublic static final int MAX_TOKEN_VALUE_BYTES = 1024;\nwhich is the same length as the string column these fields used to be stored in.", "author": "punktilious", "createdAt": "2020-10-28T14:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MjI1OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513472258", "bodyText": "Is WHERE needed?", "author": "prb112", "createdAt": "2020-10-28T14:08:08Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/CreateCodeSystemsTmp.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.derby;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.schema.control.FhirSchemaConstants;\n+\n+/**\n+ * Create the CODE_SYSTEMS_TMP table\n+ */\n+public class CreateCodeSystemsTmp implements IDatabaseStatement {\n+    private static final Logger logger = Logger.getLogger(CreateCommonTokenValuesTmp.class.getName());\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        \n+        if (!isExists(c)) {\n+            final String ddl = \"\"\n+                    + \"DECLARE GLOBAL TEMPORARY TABLE SESSION.code_systems_tmp (\"\n+                    + \"  code_system_name VARCHAR(\" + FhirSchemaConstants.MAX_TOKEN_VALUE_BYTES + \") \"\n+                    + \") NOT LOGGED\";\n+            \n+            try (Statement s = c.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                logger.log(Level.SEVERE, ddl, x);\n+                throw translator.translate(x);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Does the table currently exist\n+     * @param c\n+     * @return\n+     */\n+    private boolean isExists(Connection c) {\n+        boolean result = false;\n+        \n+        final String sql = \"SELECT 1 FROM SESSION.code_systems_tmp WHERE 1=0\";", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4NjE4NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513486185", "bodyText": "It's a standard pattern for avoiding doing more work than necessary (if the table were to contain rows at this point).", "author": "punktilious", "createdAt": "2020-10-28T14:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MjI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMzU0OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513703549", "bodyText": "got that 1=0 is what through me", "author": "prb112", "createdAt": "2020-10-28T19:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MjUyOA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513472528", "bodyText": "Where is needed?", "author": "prb112", "createdAt": "2020-10-28T14:08:29Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/CreateCommonTokenValuesTmp.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.derby;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.schema.control.FhirSchemaConstants;\n+\n+\n+/**\n+ * Create the COMMON_TOKEN_VALUES_TMP table\n+ */\n+public class CreateCommonTokenValuesTmp implements IDatabaseStatement {\n+    private static final Logger logger = Logger.getLogger(CreateCommonTokenValuesTmp.class.getName());\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        \n+        if (!isExists(c)) {\n+            final String ddl = \"\"\n+                    + \"DECLARE GLOBAL TEMPORARY TABLE common_token_values_tmp (\"\n+                    + \"  token_value VARCHAR(\" + FhirSchemaConstants.MAX_TOKEN_VALUE_BYTES + \"), \"\n+                    + \"  code_system_id INT\"\n+                    + \") NOT LOGGED\";\n+            \n+            try (Statement s = c.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                logger.log(Level.SEVERE, ddl, x);\n+                throw translator.translate(x);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Does the table currently exist\n+     * @param c\n+     * @return\n+     */\n+    private boolean isExists(Connection c) {\n+        boolean result = false;\n+        \n+        final String sql = \"SELECT 1 FROM SESSION.common_token_values_tmp WHERE 1=0\";", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4NjUzMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513486533", "bodyText": "Standard pattern for avoiding unnecessary work", "author": "punktilious", "createdAt": "2020-10-28T14:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MjUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3NzA3OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513477079", "bodyText": "Does this truncate without warning?", "author": "prb112", "createdAt": "2020-10-28T14:14:08Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceReferenceDAO.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.dao.impl;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ICommonTokenValuesCache;\n+import com.ibm.fhir.persistence.jdbc.dao.api.IResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dto.CommonTokenValue;\n+import com.ibm.fhir.schema.control.FhirSchemaConstants;\n+\n+/**\n+ * DAO to handle maintenance of the local and external reference tables\n+ * which contain the relationships described by \"reference\" elements in\n+ * each resource (e.g. Observation.subject).\n+ * \n+ * The DAO uses a cache for looking up the ids for various entities. The\n+ * DAO can create new entries, but these can only be used locally until\n+ * the transaction commits, at which point they can be consolidated into\n+ * the shared cache. This has the benefit that we reduce the number of times\n+ * we need to lock the global cache, because we only update it once per\n+ * transaction.\n+ * \n+ * For improved performance, we also make use of batch statements which\n+ * are managed as member variables. This is why it's important to close\n+ * this DAO before the transaction commits, ensuring that any outstanding\n+ * DML batched but not yet executed is processed. Calling close does not\n+ * close the provided Connection. That is up to the caller to manage.\n+ * Close does close any statements which are opened inside the class.\n+ */\n+public abstract class ResourceReferenceDAO implements IResourceReferenceDAO, AutoCloseable {\n+    private static final Logger logger = Logger.getLogger(ResourceReferenceDAO.class.getName());\n+    \n+    private final String schemaName;\n+\n+    // hold on to the connection because we use batches to improve efficiency\n+    private final Connection connection;\n+    \n+    // The cache used to track the ids of the normalized entities we're managing\n+    private final ICommonTokenValuesCache cache;\n+    \n+    // The translator for the type of database we are connected to\n+    private final IDatabaseTranslator translator;\n+\n+    // The number of operations we allow before submitting a batch\n+    protected static final int BATCH_SIZE = 100;\n+    \n+    /**\n+     * Public constructor\n+     * @param c\n+     */\n+    public ResourceReferenceDAO(IDatabaseTranslator t, Connection c, String schemaName, ICommonTokenValuesCache cache) {\n+        this.translator = t;\n+        this.connection = c;\n+        this.cache = cache;\n+        this.schemaName = schemaName;\n+    }\n+\n+    /**\n+     * Getter for the {@link IDatabaseTranslator} held by this DAO\n+     * @return\n+     */\n+    protected IDatabaseTranslator getTranslator() {\n+        return this.translator;\n+    }\n+\n+    /**\n+     * Getter for the {@link ICommonTokenValuesCache} held by this DAO\n+     * @return\n+     */\n+    protected ICommonTokenValuesCache getCache() {\n+        return this.cache;\n+    }\n+\n+    /**\n+     * Getter for the {@link Connection} held by this DAO\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+        return this.connection;\n+    }\n+\n+    /**\n+     * Getter for subclass access to the schemaName\n+     * @return\n+     */\n+    protected String getSchemaName() {\n+        return this.schemaName;\n+    }\n+\n+    @Override\n+    public void flush() throws FHIRPersistenceException {\n+    }\n+\n+    @Override\n+    public void close() throws FHIRPersistenceException {\n+        flush();\n+    }\n+\n+    @Override\n+    public ICommonTokenValuesCache getResourceReferenceCache() {\n+        return this.cache;\n+    }\n+\n+    /**\n+     * Look up the database id for the given externalSystemName\n+     * @param externalSystemName\n+     * @return the database id, or null if no record exists\n+     */\n+    public Integer queryExternalSystemId(String externalSystemName) {\n+        Integer result;\n+        \n+        final String SQL = \"SELECT external_system_id FROM external_systems where external_system_name = ?\";\n+\n+        try (PreparedStatement ps = connection.prepareStatement(SQL)) {\n+            ps.setString(1, externalSystemName);\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            } else {\n+                result = null;\n+            }\n+        } catch (SQLException x) {\n+            // make the exception a little bit more meaningful knowing the database type\n+            throw translator.translate(x);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    /**\n+     * Find the database id for the given externalReferenceValue\n+     * @param externalReferenceValue\n+     * @return\n+     */\n+    public Integer queryExternalReferenceValueId(String externalReferenceValue) {\n+        Integer result;\n+        \n+        final String SQL = \"SELECT external_reference_value_id FROM external_reference_values WHERE external_reference_value = ?\";\n+        try (PreparedStatement ps = connection.prepareStatement(SQL)) {\n+            ps.setString(1, externalReferenceValue);\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            } else {\n+                result = null;\n+            }\n+        } catch (SQLException x) {\n+            // make the exception a little bit more meaningful knowing the database type\n+            logger.log(Level.SEVERE, SQL, x);\n+            throw translator.translate(x);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    /**\n+     * Get a list of matching records from external_reference_values. Cheaper to do as one\n+     * query instead of individuals\n+     * @param externalReferenceValue\n+     * @return\n+     */\n+    public List<ExternalReferenceValue> queryExternalReferenceValues(String... externalReferenceValues) {\n+        List<ExternalReferenceValue> result = new ArrayList<>();\n+        if (externalReferenceValues.length == 0) {\n+            throw new IllegalArgumentException(\"externalReferenceValues array cannot be empty\");\n+        }\n+\n+        final StringBuilder sql = new StringBuilder();\n+        sql.append(\"SELECT external_reference_value_id, external_reference_value FROM external_reference_values WHERE external_reference_value IN (\");\n+        \n+        for (int i=0; i<externalReferenceValues.length; i++) {\n+            if (i == 0) {\n+                sql.append(\"?\");\n+            } else {\n+                sql.append(\",?\");\n+            }\n+        }\n+        sql.append(\")\");\n+        \n+        try (PreparedStatement ps = connection.prepareStatement(sql.toString())) {\n+            int a = 1;\n+            for (String xrv: externalReferenceValues) {\n+                ps.setString(a++, xrv);\n+            }\n+            \n+            ResultSet rs = ps.executeQuery();\n+            while (rs.next()) {\n+                result.add(new ExternalReferenceValue(rs.getLong(1), rs.getString(2)));\n+            }\n+        } catch (SQLException x) {\n+            // make the exception a little bit more meaningful knowing the database type\n+            logger.log(Level.SEVERE, sql.toString(), x);\n+            throw translator.translate(x);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public List<ExternalSystem> queryExternalSystems(String... externalSystemNames) {\n+        List<ExternalSystem> result = new ArrayList<>();\n+        if (externalSystemNames.length == 0) {\n+            throw new IllegalArgumentException(\"externalReferenceValues array cannot be empty\");\n+        }\n+\n+        final StringBuilder sql = new StringBuilder();\n+        sql.append(\"SELECT external_system_id, external_system_name FROM external_systems WHERE external_system_name IN (\");\n+        \n+        for (int i=0; i<externalSystemNames.length; i++) {\n+            if (i == 0) {\n+                sql.append(\"?\");\n+            } else {\n+                sql.append(\",?\");\n+            }\n+        }\n+        sql.append(\")\");\n+        \n+        try (PreparedStatement ps = connection.prepareStatement(sql.toString())) {\n+            int a = 1;\n+            for (String xrv: externalSystemNames) {\n+                ps.setString(a++, xrv);\n+            }\n+            \n+            ResultSet rs = ps.executeQuery();\n+            while (rs.next()) {\n+                result.add(new ExternalSystem(rs.getLong(1), rs.getString(2)));\n+            }\n+        } catch (SQLException x) {\n+            // make the exception a little bit more meaningful knowing the database type\n+            logger.log(Level.SEVERE, sql.toString(), x);\n+            throw translator.translate(x);\n+        }\n+        \n+        return result;\n+    }\n+\n+    @Override\n+    public void deleteExternalReferences(int resourceTypeId, String logicalId) {\n+        final String DML = \"DELETE FROM external_references \"\n+                + \"WHERE logical_resource_id IN ( \"\n+                + \" SELECT logical_resource_id FROM logical_resources \"\n+                + \"  WHERE resource_type_id = ? \"\n+                + \"    AND logical_id = ?)\";\n+        \n+        try (PreparedStatement ps = connection.prepareStatement(DML)) {\n+            ps.setInt(1, resourceTypeId);\n+            ps.setString(2, logicalId);\n+            ps.executeUpdate();\n+        } catch (SQLException x) {\n+            // make the exception a little bit more meaningful knowing the database type\n+            logger.log(Level.SEVERE, DML, x);\n+            throw translator.translate(x);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void deleteLocalReferences(long logicalResourceId) {\n+        final String DML = \"DELETE FROM local_references WHERE logical_resource_id = ?\";\n+        \n+        try (PreparedStatement ps = connection.prepareStatement(DML)) {\n+            ps.setLong(1, logicalResourceId);\n+            ps.executeUpdate();\n+        } catch (SQLException x) {\n+            // make the exception a little bit more meaningful knowing the database type\n+            logger.log(Level.SEVERE, DML, x);\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void deleteLogicalResourceCompartments(long logicalResourceId) {\n+        final String DML = \"DELETE FROM logical_resource_compartments WHERE logical_resource_id = ?\";\n+        \n+        try (PreparedStatement ps = connection.prepareStatement(DML)) {\n+            ps.setLong(1, logicalResourceId);\n+            ps.executeUpdate();\n+        } catch (SQLException x) {\n+            // make the exception a little bit more meaningful knowing the database type\n+            logger.log(Level.SEVERE, DML, x);\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void addCommonTokenValues(String resourceType, Collection<ResourceTokenValueRec> xrefs) {\n+        // Grab the ids for all the code-systems, and upsert any misses\n+        List<ResourceTokenValueRec> systemMisses = new ArrayList<>();\n+        cache.resolveCodeSystems(xrefs, systemMisses);\n+        upsertCodeSystems(systemMisses);\n+\n+        // Now that all the code-systems ids are known, we can search the cache\n+        // for all the token values, upserting anything new\n+        List<ResourceTokenValueRec> valueMisses = new ArrayList<>();\n+        cache.resolveTokenValues(xrefs, valueMisses);\n+        upsertCommonTokenValues(valueMisses);\n+\n+        insertResourceTokenRefs(resourceType, xrefs);\n+    }\n+\n+    /**\n+     * Insert the values in the resource-type-specific _resource_token_refs table. This\n+     * is a simple batch insert because all the FKs have already been resolved and updated\n+     * in the ResourceTokenValueRec records\n+     * @param resourceType\n+     * @param xrefs\n+     */\n+    protected void insertResourceTokenRefs(String resourceType, Collection<ResourceTokenValueRec> xrefs) {\n+        // Now all the values should have ids assigned so we can go ahead and insert them\n+        // as a batch\n+        final String tableName = resourceType + \"_RESOURCE_TOKEN_REFS\";\n+        DataDefinitionUtil.assertValidName(tableName);\n+        final String insert = \"INSERT INTO \" + tableName + \"(\"\n+                + \"parameter_name_id, logical_resource_id, common_token_value_id, ref_version_id) \"\n+                + \"VALUES (?, ?, ?, ?)\";\n+        try (PreparedStatement ps = connection.prepareStatement(insert)) {\n+            int count = 0;\n+            for (ResourceTokenValueRec xr: xrefs) {\n+                ps.setInt(1, xr.getParameterNameId());\n+                ps.setLong(2, xr.getLogicalResourceId());\n+\n+                // common token value can be null\n+                if (xr.getCommonTokenValueId() != null) {\n+                    ps.setLong(3, xr.getCommonTokenValueId());\n+                } else {\n+                    ps.setNull(3, Types.BIGINT);                    \n+                }\n+\n+                // version can be null\n+                if (xr.getRefVersionId() != null) {\n+                    ps.setInt(4, xr.getRefVersionId());\n+                } else {\n+                    ps.setNull(4, Types.INTEGER);\n+                }\n+                ps.addBatch();\n+                if (++count == BATCH_SIZE) {\n+                    ps.executeBatch();\n+                    count = 0;\n+                }\n+            }\n+            \n+            if (count > 0) {\n+                ps.executeBatch();\n+            }\n+        } catch (SQLException x) {\n+            logger.log(Level.SEVERE, insert, x);\n+            throw translator.translate(x);\n+        }\n+    }\n+    \n+    /**\n+     * Add all the systems we currently don't have in the database. If all target\n+     * databases handled MERGE properly this would be easy, but they don't so\n+     * we go old-school with a negative outer join instead (which is pretty much\n+     * what MERGE does behind the scenes anyway).\n+     * @param systems\n+     */\n+    public void upsertCodeSystems(List<ResourceTokenValueRec> systems) {\n+        if (systems.isEmpty()) {\n+            return;\n+        }\n+        \n+        // Unique list so we don't try and create the same name more than once\n+        Set<String> systemNames = systems.stream().map(xr -> xr.getCodeSystemValue()).collect(Collectors.toSet());\n+        StringBuilder paramList = new StringBuilder();\n+        StringBuilder inList = new StringBuilder();\n+        for (int i=0; i<systemNames.size(); i++) {\n+            if (paramList.length() > 0) {\n+                paramList.append(\", \");\n+                inList.append(\",\");\n+            }\n+            paramList.append(\"(CAST(? AS VARCHAR(\" + FhirSchemaConstants.MAX_SEARCH_STRING_BYTES + \")))\");\n+            inList.append(\"?\");\n+        }\n+        \n+        final String paramListStr = paramList.toString();\n+        doCodeSystemsUpsert(paramListStr, systemNames);\n+        \n+        \n+        // Now grab the ids for the rows we just created. If we had a RETURNING implementation\n+        // which worked reliably across all our database platforms, we wouldn't need this\n+        // second query.\n+        StringBuilder select = new StringBuilder();\n+        select.append(\"SELECT code_system_name, code_system_id FROM code_systems WHERE code_system_name IN (\");\n+        select.append(inList);\n+        select.append(\")\");\n+        \n+        Map<String, Integer> idMap = new HashMap<>();\n+        try (PreparedStatement ps = connection.prepareStatement(select.toString())) {\n+            // load a map with all the ids we need which we can then use to update the\n+            // ExternalResourceReferenceRec objects\n+            int a = 1;\n+            for (String name: systemNames) {\n+                ps.setString(a++, name);\n+            }\n+\n+            ResultSet rs = ps.executeQuery();\n+            while (rs.next()) {\n+                idMap.put(rs.getString(1), rs.getInt(2));\n+            }\n+        } catch (SQLException x) {\n+            logger.log(Level.SEVERE, select.toString(), x);\n+            throw translator.translate(x);\n+        }\n+        \n+        // Now update the ids for all the matching systems in our list\n+        for (ResourceTokenValueRec xr: systems) {\n+            Integer id = idMap.get(xr.getCodeSystemValue());\n+            if (id != null) {\n+                xr.setCodeSystemValueId(id);\n+\n+                // Add this value to the (thread-local) cache\n+                cache.addCodeSystem(xr.getCodeSystemValue(), id);\n+            } else {\n+                // Unlikely...but need to handle just in case\n+                logger.severe(\"Record for code_system_name '\" + xr.getCodeSystemValue() + \"' inserted but not found\");\n+                throw new IllegalStateException(\"id deleted from database!\");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Insert any missing values into the code_systems table\n+     * @param paramList\n+     * @param systems\n+     */\n+    public abstract void doCodeSystemsUpsert(String paramList, Collection<String> systemNames);\n+    \n+    /**\n+     * Add reference value records for each unique reference name in the given list\n+     * @param values\n+     */\n+    public void upsertCommonTokenValues(List<ResourceTokenValueRec> values) {\n+        \n+        // Unique list so we don't try and create the same name more than once.\n+        // Ignore any null token-values, because we don't want to (can't) store\n+        // them in our common token values table.\n+        Set<CommonTokenValue> tokenValues = values.stream().filter(x -> x.getTokenValue() != null).map(xr -> new CommonTokenValue(xr.getCodeSystemValueId(), xr.getTokenValue())).collect(Collectors.toSet());\n+        \n+        if (tokenValues.isEmpty()) {\n+            // nothing to do\n+            return;\n+        }\n+\n+        // Build a string of parameter values we use in the query to drive the insert statement.\n+        // The database needs to know the type when it parses the query, hence the slightly verbose CAST functions:\n+        // VALUES ((CAST(? AS VARCHAR(1234)), CAST(? AS INT)), (...)) AS V(common_token_value, parameter_name_id, code_system_id)\n+        StringBuilder inList = new StringBuilder(); // for the select query later\n+        StringBuilder paramList = new StringBuilder();\n+        for (int i=0; i<tokenValues.size(); i++) {\n+            if (paramList.length() > 0) {\n+                paramList.append(\", \");\n+            }\n+            paramList.append(\"(CAST(? AS VARCHAR(\" + FhirSchemaConstants.MAX_TOKEN_VALUE_BYTES + \"))\");", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Njk3Mw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513486973", "bodyText": "How do you mean without warning?", "author": "punktilious", "createdAt": "2020-10-28T14:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3NzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODUxNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513638516", "bodyText": "If the value is too long, it will generate a SQLException (which may not happen until the value gets inserted into the actual table, but it will happen).", "author": "punktilious", "createdAt": "2020-10-28T17:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3NzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Nzg2Mw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513477863", "bodyText": "Local not External?", "author": "prb112", "createdAt": "2020-10-28T14:15:06Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/LocalResourceReferenceRec.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.dao.impl;\n+\n+\n+/**\n+ * A DTO representing an external resource reference. This object is initialized\n+ * with names which are resolved to ids when passed through the cache. The idea\n+ * is to reduce the number of times we have to iterate over the list of records", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4ODg0OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513488848", "bodyText": "This probably is no longer required, but too risky to remove at this point so creating an issue to cover clean-up.", "author": "punktilious", "createdAt": "2020-10-28T14:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Nzg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNDgzMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513704830", "bodyText": "My comment is to the DTO comment is on external, the class cites Local\nIs this comment accurate?", "author": "prb112", "createdAt": "2020-10-28T19:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Nzg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyMzgyNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513723827", "bodyText": "Doesn't matter. The design changed so this class is no longer required. Issue #1639 for cleanup.", "author": "punktilious", "createdAt": "2020-10-28T19:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Nzg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Nzk4MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513477981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The loca ref resource type\n          \n          \n            \n                // The local ref resource type", "author": "prb112", "createdAt": "2020-10-28T14:15:14Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/LocalResourceReferenceRec.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.dao.impl;\n+\n+\n+/**\n+ * A DTO representing an external resource reference. This object is initialized\n+ * with names which are resolved to ids when passed through the cache. The idea\n+ * is to reduce the number of times we have to iterate over the list of records\n+ */\n+public class LocalResourceReferenceRec extends ResourceRefRec {\n+\n+    // The loca ref resource type", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4OTM4OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513489389", "bodyText": "Will probably be removed in subsequent cleanup", "author": "punktilious", "createdAt": "2020-10-28T14:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3Nzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODQ3NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513478474", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Look up the code system. If it doesn't exist, add it to the database\n          \n          \n            \n                 * Look up the code system. If it doesn't exist, adds it to the database", "author": "prb112", "createdAt": "2020-10-28T14:15:52Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterVisitorBatchDAO.java", "diffHunk": "@@ -194,17 +219,16 @@ public ParameterVisitorBatchDAO(Connection c, String adminSchemaName, String tab\n      * @return\n      */\n     protected int getParameterNameId(String parameterName) throws FHIRPersistenceException {\n-        return parameterNameCache.readOrAddParameterNameId(parameterName);\n-\n+        return identityCache.getParameterNameId(parameterName);\n     }\n \n     /**\n-     * Look up the code system\n+     * Look up the code system. If it doesn't exist, add it to the database", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNTI5Mw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513515293", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-10-28T14:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODk4NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513478985", "bodyText": "maybe I'm missing this one? What does this todo mean?", "author": "prb112", "createdAt": "2020-10-28T14:16:29Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterVisitorBatchDAO.java", "diffHunk": "@@ -370,9 +394,11 @@ public void visit(TokenParmVal param) throws FHIRPersistenceException {\n         String tokenValue = param.getValueCode();\n         try {\n             int parameterNameId = getParameterNameId(parameterName);\n-            int codeSystemId = getCodeSystemId(codeSystem);\n \n+            // TODO handle base (non-resource-specific) token values for issue #1366", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxMzkxNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513513917", "bodyText": "TODO was left over. Removed.", "author": "punktilious", "createdAt": "2020-10-28T14:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDE3Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513480172", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final String endpoint = \"fhir-server/api/v4/\";\n          \n          \n            \n                        final String endpoint = \"fhir-server/api/v4/\";\n          \n      \n    \n    \n  \n\nThis is not always true.\nConsider our interop enviroment which has dev-1234", "author": "prb112", "createdAt": "2020-10-28T14:18:01Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterVisitorBatchDAO.java", "diffHunk": "@@ -708,4 +745,136 @@ private void closeStatement(PreparedStatement ps) {\n     private boolean isBase(ExtractedParameterValue param) {\n         return \"Resource\".equals(param.getBase());\n     }\n-}\n+    \n+    /**\n+     * Get the leading part of the url e.g. https://example.com\n+     * @return\n+     */\n+    private String getServerUrl() throws FHIRPersistenceException {\n+        \n+        if (this.serverBase != null) {\n+            return this.serverBase;\n+        }\n+        \n+        String uri = FHIRRequestContext.get().getOriginalRequestUri();\n+\n+        // request URI is not set for all unit-tests, so we need to take that into account\n+        if (uri == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            StringBuilder result = new StringBuilder();\n+            URL url = new URL(uri);\n+            \n+            result.append(url.getProtocol());\n+            result.append(\"://\");\n+            result.append(url.getHost());\n+            \n+            if (url.getPort() != -1) {\n+                result.append(\":\");\n+                result.append(url.getPort());\n+            }\n+            \n+            // https://example.com:9443/\n+            result.append(\"/\");\n+            \n+            final String endpoint = \"fhir-server/api/v4/\";", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDgwMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513480801", "bodyText": "Reading below, I'm not even sure this is needed", "author": "prb112", "createdAt": "2020-10-28T14:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5NDE3OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513494178", "bodyText": "Where can we get this value from?", "author": "punktilious", "createdAt": "2020-10-28T14:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNDM1OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513624358", "bodyText": "Raised issue #1635 to address this after.", "author": "punktilious", "createdAt": "2020-10-28T17:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTMwMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513481301", "bodyText": "unused, but would be useful", "author": "prb112", "createdAt": "2020-10-28T14:19:29Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/api/IResourceReferenceDAO.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.dao.api;\n+\n+import java.util.Collection;\n+\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceTokenValueRec;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.LocalResourceReferenceRec;\n+\n+/**\n+ *\n+ */", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MjQ1OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513492458", "bodyText": "Added comment. It's implemented by ResourceReferenceDAO.", "author": "punktilious", "createdAt": "2020-10-28T14:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTMwMQ=="}], "type": "inlineReview"}, {"oid": "8579329a579d6a6dddf28fc930011cf2c77959ab", "url": "https://github.com/IBM/FHIR/commit/8579329a579d6a6dddf28fc930011cf2c77959ab", "message": "issue #1366 addressed code review comments\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-28T17:24:08Z", "type": "commit"}, {"oid": "5f1faa51e26cbdee54cc65db3f15d3d64dd326e1", "url": "https://github.com/IBM/FHIR/commit/5f1faa51e26cbdee54cc65db3f15d3d64dd326e1", "message": "issue #1402 added a simple read request load generator to measure impact of reads on ingestion\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-08T04:11:17Z", "type": "commit"}, {"oid": "88b2814df25a89d9fe845b90d3eef9362947f857", "url": "https://github.com/IBM/FHIR/commit/88b2814df25a89d9fe845b90d3eef9362947f857", "message": "issue 1425 - do not allow database exceptions to fail main loops\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-10T21:06:53Z", "type": "commit"}, {"oid": "5be136da9c5c00202c544ec5474b8a76dd05d378", "url": "https://github.com/IBM/FHIR/commit/5be136da9c5c00202c544ec5474b8a76dd05d378", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-09-10T21:08:38Z", "type": "commit"}, {"oid": "4ccbb430e69a165d882088ec4d29889edfd3fca0", "url": "https://github.com/IBM/FHIR/commit/4ccbb430e69a165d882088ec4d29889edfd3fca0", "message": "issue #1425 measure performance as database grows\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-15T23:02:49Z", "type": "commit"}, {"oid": "e2ad79dedd84e31fb30935d8e37e740213e08acf", "url": "https://github.com/IBM/FHIR/commit/e2ad79dedd84e31fb30935d8e37e740213e08acf", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-09-16T13:42:53Z", "type": "commit"}, {"oid": "45fffde8b2fd26a192bb9a16a32e3c5f1d2f3a20", "url": "https://github.com/IBM/FHIR/commit/45fffde8b2fd26a192bb9a16a32e3c5f1d2f3a20", "message": "WIP #1366 new reference schema design\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-21T03:21:33Z", "type": "commit"}, {"oid": "091c8a833eb5d63fd744644f1592a1f2df03e2e5", "url": "https://github.com/IBM/FHIR/commit/091c8a833eb5d63fd744644f1592a1f2df03e2e5", "message": "issue #1366 working external_references test case\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-22T20:29:53Z", "type": "commit"}, {"oid": "2fd18587a3d69b8ffbd6e407e00dd2780dc5b3ef", "url": "https://github.com/IBM/FHIR/commit/2fd18587a3d69b8ffbd6e407e00dd2780dc5b3ef", "message": "issue #1366 working unit tests for external and local references\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-23T03:32:25Z", "type": "commit"}, {"oid": "f29f3032f2317cfd22f65e705c3592013acb52d6", "url": "https://github.com/IBM/FHIR/commit/f29f3032f2317cfd22f65e705c3592013acb52d6", "message": "issue 1366 integrated cache and reference DAO with JDBC persistence layer\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-25T22:03:45Z", "type": "commit"}, {"oid": "a863e6f37bd14950ecd6e710753a1ea8a2f89f70", "url": "https://github.com/IBM/FHIR/commit/a863e6f37bd14950ecd6e710753a1ea8a2f89f70", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-09-25T22:04:35Z", "type": "commit"}, {"oid": "fc042c43e525bd5722211e121d12f823ae0d8cac", "url": "https://github.com/IBM/FHIR/commit/fc042c43e525bd5722211e121d12f823ae0d8cac", "message": "issue #1366 temp fix for broken AbstractSearchDateTest approx date range calculation\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-26T19:47:49Z", "type": "commit"}, {"oid": "78f6539e228f0d1f89ffad5948e0ed93806c5613", "url": "https://github.com/IBM/FHIR/commit/78f6539e228f0d1f89ffad5948e0ed93806c5613", "message": "issue #1366 refactor for more efficient storage of token_values\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-29T03:27:09Z", "type": "commit"}, {"oid": "36f31f42837adbba786f158a4792f96162f777b7", "url": "https://github.com/IBM/FHIR/commit/36f31f42837adbba786f158a4792f96162f777b7", "message": "issue #1366 refactored parameter and resource type caches to reduce code entropy\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-30T14:13:38Z", "type": "commit"}, {"oid": "02515fb0811779b41d02e9254f8df0ebe7cd7eec", "url": "https://github.com/IBM/FHIR/commit/02515fb0811779b41d02e9254f8df0ebe7cd7eec", "message": "issue #1366 updated search queries for tokens and references\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-04T23:28:46Z", "type": "commit"}, {"oid": "53b2c4638f42494808b6a0a914253cd3ff259332", "url": "https://github.com/IBM/FHIR/commit/53b2c4638f42494808b6a0a914253cd3ff259332", "message": "issue #1366 added reindex custom operation to migrate data to new schema\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-06T03:45:46Z", "type": "commit"}, {"oid": "66d3e0d5bf8e92878857329fa9007ab88c93c44f", "url": "https://github.com/IBM/FHIR/commit/66d3e0d5bf8e92878857329fa9007ab88c93c44f", "message": "issue #1366 added reindex custom operation to support migration to new token tables\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-08T03:38:03Z", "type": "commit"}, {"oid": "0fd9f9e738b66790d1df1a79b836cccb645be98f", "url": "https://github.com/IBM/FHIR/commit/0fd9f9e738b66790d1df1a79b836cccb645be98f", "message": "issue #1366 added deadlock transaction retry for reindex operation\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-10T04:22:36Z", "type": "commit"}, {"oid": "67218b4162d5c76669bbaf9fa078616d40f00d36", "url": "https://github.com/IBM/FHIR/commit/67218b4162d5c76669bbaf9fa078616d40f00d36", "message": "issue #1366 improved concurrency for reindex including optimization for postgres\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-12T19:48:55Z", "type": "commit"}, {"oid": "5b611c79856fd1fbd27cff7d703b95a2c747b925", "url": "https://github.com/IBM/FHIR/commit/5b611c79856fd1fbd27cff7d703b95a2c747b925", "message": "issue #1366 reworked schema migration logic to avoid Liberty/Derby transaction defect\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-18T15:00:17Z", "type": "commit"}, {"oid": "01a95d24049168144cbb0445deaa0277617b2e70", "url": "https://github.com/IBM/FHIR/commit/01a95d24049168144cbb0445deaa0277617b2e70", "message": "issue #1366 merge conflict resolution with latest master\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-19T19:26:17Z", "type": "commit"}, {"oid": "366049a6a89bcfbdb42aa0be2325067ae7460048", "url": "https://github.com/IBM/FHIR/commit/366049a6a89bcfbdb42aa0be2325067ae7460048", "message": "issue #1366 fixed reference search SIT regression following merge\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-20T03:37:36Z", "type": "commit"}, {"oid": "9120003a95c31b6e58102cf7b1dd7537e1235297", "url": "https://github.com/IBM/FHIR/commit/9120003a95c31b6e58102cf7b1dd7537e1235297", "message": "issue #1619 fix contention issue on inserts into common_token_values\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-23T13:08:34Z", "type": "commit"}, {"oid": "6b36983c0016392d24b40bbda98e390407319a32", "url": "https://github.com/IBM/FHIR/commit/6b36983c0016392d24b40bbda98e390407319a32", "message": "issue #1366 fixes to support Db2 and merge latest from master\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-24T17:55:39Z", "type": "commit"}, {"oid": "525a134c335fc964e52e61c90b1ef7d0a180183f", "url": "https://github.com/IBM/FHIR/commit/525a134c335fc964e52e61c90b1ef7d0a180183f", "message": "issue #1366 cleaned info message when tokenValue is null\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-24T20:00:41Z", "type": "commit"}, {"oid": "7d5c381975f6252fbecd76cf32835676241fdde2", "url": "https://github.com/IBM/FHIR/commit/7d5c381975f6252fbecd76cf32835676241fdde2", "message": "issue #1366 use temp table for Derby to avoid huge DML statements causing failures during pipeline builds\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-25T02:36:18Z", "type": "commit"}, {"oid": "add7063934b9c5ff292068925ff2064483ade2b2", "url": "https://github.com/IBM/FHIR/commit/add7063934b9c5ff292068925ff2064483ade2b2", "message": "issue #1366 remove another stack overflow in Derby from pipeline build\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-25T04:15:15Z", "type": "commit"}, {"oid": "7bada2f8bf768ac5b9965ee406a3f451fa4fccb5", "url": "https://github.com/IBM/FHIR/commit/7bada2f8bf768ac5b9965ee406a3f451fa4fccb5", "message": "issue #1366 serialize the db2 migration step to avoid deadlocks when adding FKs to a common table\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-25T13:46:40Z", "type": "commit"}, {"oid": "2a7726893f06d291092861af3b1ef97e73f9a66a", "url": "https://github.com/IBM/FHIR/commit/2a7726893f06d291092861af3b1ef97e73f9a66a", "message": "issue #1366 db2 migration test update grants and partitions for new tables\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-10-25T15:18:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNDQ2OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512014469", "bodyText": "from where? what is the difference between the processor and the resource handler? fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/IResourceHandler.java", "author": "prb112", "createdAt": "2020-10-26T14:43:29Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/IResourceEntryProcessor.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.api;\n+\n+\n+/**\n+ * Process a ResourceEntry", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzMzM0OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513533348", "bodyText": "Converged over iterations. Probably could be combined, but I don't think a necessary change at this stage.", "author": "punktilious", "createdAt": "2020-10-28T15:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNDQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNDgyNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512014826", "bodyText": "While I think I get the intent, what is the difference with fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/IResourceEntryProcessor.java", "author": "prb112", "createdAt": "2020-10-26T14:43:56Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/IResourceHandler.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.api;\n+\n+\n+/**\n+ * Interface for handling the processing of resources read from COS\n+ */\n+public interface IResourceHandler {\n+\n+    /**\n+     * Add the resource entry to the thread-pool for processing, subject to the\n+     * rate limiting we have to make sure memory consumption is kept in check\n+     * @param entry\n+     * @return\n+     */\n+    public boolean process(ResourceEntry entry);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MTE1NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513151155", "bodyText": "They are used in different contexts and I initially had different signatures in one of my iterations. They are used in different contexts, so I'm not planning on refactoring at this point. One returns a boolean whereas the other doesn't.", "author": "punktilious", "createdAt": "2020-10-28T03:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNTQ5Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512015496", "bodyText": "I suggest just calling this Interop", "author": "prb112", "createdAt": "2020-10-26T14:44:45Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/app/Main.java", "diffHunk": "@@ -152,7 +162,34 @@\n     private int recycleSeconds = -1;\n     \n     // Assign a higher cost to processing bundles to reduce concurrency and avoid overload/timeouts\n-    private int bundleCostFactor = 1;\n+    private double bundleCostFactor = 1.0;\n+    \n+    // How many payer scenario requests do we want to make at a time.\n+    private int concurrentPayerRequests = 0;\n+    \n+    // Simple scenario to add some read load to a FHIR server\n+    private CmsPayerInterop cmsPayerWorkload;", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MTIzMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513151230", "bodyText": "done", "author": "punktilious", "createdAt": "2020-10-28T03:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNjMxMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512016312", "bodyText": "Where is the readme for this? There is a lot of surface area, and I'm afraid you are the only one who knows what they all do.", "author": "prb112", "createdAt": "2020-10-26T14:45:47Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/app/Main.java", "diffHunk": "@@ -284,18 +328,83 @@ public void parseArgs(String[] args) {\n                     throw new IllegalArgumentException(\"missing value for --path-prefix\");\n                 }\n                 break;\n+            case \"--target-bucket\":\n+                if (i < args.length + 1) {\n+                    this.targetBucket = args[++i];\n+                } else {\n+                    throw new IllegalArgumentException(\"missing value for --target-bucket\");\n+                }\n+                break;", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MTcxNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513151717", "bodyText": "Should be in the base directory, but probably warrants being a guide. Will  need to add additional content to cover the ever-expanding list of capabilities", "author": "punktilious", "createdAt": "2020-10-28T03:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNjMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwMDI0Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513400247", "bodyText": "Should there be a backlog issue for this?", "author": "prb112", "createdAt": "2020-10-28T12:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNjMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwMDQxMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513400410", "bodyText": "marking unresolved so we don't lose the need for an issue.", "author": "prb112", "createdAt": "2020-10-28T12:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNjMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzMzc3OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513533779", "bodyText": "Issue is #1633", "author": "punktilious", "createdAt": "2020-10-28T15:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNjMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNjg0Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512016847", "bodyText": "I suggest not using cmspayer.  let's just call it workload", "author": "prb112", "createdAt": "2020-10-26T14:46:24Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/app/Main.java", "diffHunk": "@@ -579,7 +699,18 @@ protected void shutdown() {\n         this.resourceHandler.signalStop();\n         \n         \n-        this.scanner.waitForStop();\n+        if (this.scanner != null) {\n+            this.scanner.waitForStop();\n+        }\n+        \n+        if (driveReindexOperation != null) {\n+            driveReindexOperation.waitForStop();\n+        }\n+        \n+        if (cmsPayerWorkload != null) {\n+            cmsPayerWorkload.waitForStop();", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MTgwNQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513151805", "bodyText": "done", "author": "punktilious", "createdAt": "2020-10-28T03:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNjg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNzgzMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512017832", "bodyText": "Per convention please upper case this as FHIRClient\nI'd also suggest giving this a slightly different name FHIRBucketClient", "author": "prb112", "createdAt": "2020-10-26T14:47:40Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/client/FhirClient.java", "diffHunk": "@@ -291,9 +290,11 @@ public FhirServerResponse post(String url, String body) {\n                 logger.fine(msg.toString());\n             }\n \n-            // If we are posting a bundle, then we need to parse the response entity\n-            boolean isBundle = url.isEmpty();\n-            return buildResponse(response, startTime, isBundle);\n+            // If we are posting a bundle or calling a custom operation, ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzMTc3Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512631772", "bodyText": "I guess this comment belongs at the class level...i was confused at first so thought I'd make that clear.", "author": "lmsurpre", "createdAt": "2020-10-27T11:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNzgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MjM2MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513152361", "bodyText": "done", "author": "punktilious", "createdAt": "2020-10-28T03:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNzgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxODk0MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512018941", "bodyText": "Per convention let's capitilize\nAlso FHIRBulkClientUtil (scoping it in typeaheads)", "author": "prb112", "createdAt": "2020-10-26T14:49:03Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/client/FhirClientUtil.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.client;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.generator.exception.FHIRGeneratorException;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Utilities for working with the FHIR client\n+ */\n+public class FhirClientUtil {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MjQ5Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513152492", "bodyText": "done", "author": "punktilious", "createdAt": "2020-10-28T03:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxODk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxOTk2NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512019965", "bodyText": "I'm almost certain there is an existing method for this in a lower level fhir-model - we should push this down there in that package.", "author": "prb112", "createdAt": "2020-10-26T14:50:13Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/client/FhirClientUtil.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.client;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.generator.exception.FHIRGeneratorException;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Utilities for working with the FHIR client\n+ */\n+public class FhirClientUtil {\n+    \n+    \n+    /**\n+     * Render the resource as a string\n+     * @param resource\n+     * @return\n+     */\n+    public static String resourceToString(Resource resource) {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(4096);\n+        try {\n+            FHIRGenerator.generator(Format.JSON, false).generate(resource, os);\n+            return new String(os.toByteArray(), StandardCharsets.UTF_8);\n+        } catch (FHIRGeneratorException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MzE3NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513153175", "bodyText": "there probably should be, but this pattern is used all over", "author": "punktilious", "createdAt": "2020-10-28T03:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxOTk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5OTY2OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513399668", "bodyText": "This is not a comment on your code, more on the utility of this method.", "author": "prb112", "createdAt": "2020-10-28T12:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxOTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMDc5Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512020792", "bodyText": "Do we care about binding this to the IBM Cloud?", "author": "prb112", "createdAt": "2020-10-26T14:51:12Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/cos/CosClient.java", "diffHunk": "@@ -50,6 +58,7 @@\n     // Set to false to tell a scan to return early\n     private volatile boolean running = true;\n     \n+    \n     static {\n         SDKGlobalConfiguration.IAM_ENDPOINT = \"https://iam.cloud.ibm.com/oidc/token\";\n     }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzMzA4OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512633088", "bodyText": "HMAC is a more s3-compatible way to configure access to COS buckets so I'd suggest that we eventually move to that.  One downside is that its not the \"default\" in IBM Cloud...users must take explicit action to get HMAC creds.", "author": "lmsurpre", "createdAt": "2020-10-27T11:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMDc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NDAzMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513154032", "bodyText": "I'm not happy with this either, but it comes from the bulk importer.", "author": "punktilious", "createdAt": "2020-10-28T03:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMDc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMDk3OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512020979", "bodyText": "COS should also be capitalized per convention.", "author": "prb112", "createdAt": "2020-10-26T14:51:27Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/cos/CosClient.java", "diffHunk": "@@ -41,6 +46,9 @@\n  */\n public class CosClient {\n     private static final Logger logger = Logger.getLogger(CosClient.class.getName());\n+", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MzYyMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513153622", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-10-28T03:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMDk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMjExNQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512022115", "bodyText": "I assume the logformatter is injecting the thread ID so you can identifying which statement belongs to which thread?", "author": "prb112", "createdAt": "2020-10-26T14:52:56Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/cos/CosClient.java", "diffHunk": "@@ -175,4 +184,40 @@ public void scan(String bucketName, String pathPrefix, Function<String, FileType\n             }\n         } while (running && result != null && result.isTruncated());\n     }\n+\n+    /**\n+     * Write the payload to the given bundleName as key\n+     * @param bundleName\n+     * @param payload\n+     */\n+    public void write(String bucketName, String objectName, String payload) {\n+        byte[] raw = payload.getBytes(StandardCharsets.UTF_8);\n+        \n+        ObjectMetadata omd = new ObjectMetadata();\n+        omd.setContentLength(raw.length);\n+        omd.setContentEncoding(\"application/json\");\n+        \n+        logger.info(\"Writing to COS '\" + bucketName + \":\" + objectName + \"', bytes: \" + raw.length);\n+\n+        if (DEBUG) {\n+            try (FileOutputStream fos = new FileOutputStream(objectName)) {\n+                fos.write(raw);\n+                fos.flush();\n+            } catch (IOException x) {\n+                logger.log(Level.SEVERE, \"Writing \" + objectName, x);\n+            }\n+        } else {\n+            // Write the object to the target key (objectName) in the given bucket\n+            InputStream inputStream = new ByteArrayInputStream(raw);\n+            PutObjectResult result = client.putObject(new PutObjectRequest(bucketName, objectName, inputStream, omd));\n+            if (result != null) {\n+                if (logger.isLoggable(Level.FINE)) {\n+                    logger.fine(\"Wrote [\" + bucketName + \"]/\" + objectName + \", ETag: \" + result.getETag());\n+                }\n+            } else {\n+                logger.warning(\"Writing failed for [\" + bucketName + \"]/\" + objectName + \", bytes: \" + raw.length);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NDQ3NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513154474", "bodyText": "Just makes things more readable.", "author": "punktilious", "createdAt": "2020-10-28T03:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMjExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5OTAzMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513399033", "bodyText": "That's fine - I was confirming the logformat enabled disambiguation.", "author": "prb112", "createdAt": "2020-10-28T12:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMjExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMjUxMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512022513", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Very simple emulation of a possible CMS Payer Interop workload. Adds some random\n          \n          \n            \n             * Very simple emulation of a possible Interop workload. Adds some random", "author": "prb112", "createdAt": "2020-10-26T14:53:27Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/interop/CmsPayerInterop.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.interop;\n+\n+import java.security.SecureRandom;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.bucket.scanner.DataAccess;\n+\n+/**\n+ * Very simple emulation of a possible CMS Payer Interop workload. Adds some random", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NDk0Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513154946", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-10-28T03:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMjUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMzQ5OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512023498", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class CmsPayerScenario implements IPatientScenario {\n          \n          \n            \n            public class InteropPatientScenario implements IPatientScenario {\n          \n      \n    \n    \n  \n\nI don't think we should reference CmsPayer", "author": "prb112", "createdAt": "2020-10-26T14:54:38Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/interop/CmsPayerScenario.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.interop;\n+\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.bucket.client.FhirClient;\n+import com.ibm.fhir.model.resource.Bundle;\n+\n+/**\n+ *\n+ */\n+public class CmsPayerScenario implements IPatientScenario {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NTEwNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513155106", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-10-28T03:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMzQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDMwNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512024307", "bodyText": "If you want to 'visit', the best is FHIRPath", "author": "prb112", "createdAt": "2020-10-26T14:55:39Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/interop/GetExplanationOfBenefitDetail.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.interop;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.apache.http.HttpStatus;\n+\n+import com.ibm.fhir.bucket.client.FhirClient;\n+import com.ibm.fhir.bucket.client.FhirClientUtil;\n+import com.ibm.fhir.bucket.client.FhirServerResponse;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Bundle.Entry;\n+import com.ibm.fhir.model.resource.Bundle.Entry.Request;\n+import com.ibm.fhir.model.resource.ExplanationOfBenefit;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+\n+/**\n+ * Use the response bundle from the GetPatientBundle request and use it to retrieve\n+ * other resources referenced by the ExplanationOfBenefit entries\n+ */\n+public class GetExplanationOfBenefitDetail {\n+    private static final Logger logger = Logger.getLogger(GetPatientBundle.class.getName());\n+    \n+    // The logical id of the Patient for which we are retrieving information\n+    private final Bundle inputBundle;\n+        \n+    public GetExplanationOfBenefitDetail(Bundle inputBundle) {\n+        this.inputBundle = inputBundle;\n+    }\n+\n+    /**\n+     * Get the bundle containing the Patient resource plus a list of ExplanationOfBenefit\n+     * resources associated with the patient\n+     * @param client\n+     * @return\n+     */\n+    public Bundle run(FhirClient client) {\n+        Bundle.Builder bundleBuilder = Bundle.builder();\n+        \n+        // Build a bundle with gets for each ExplanationOfBenefit we can find in the\n+        // inputBundle\n+        for (Entry entry: inputBundle.getEntry()) {\n+            Resource r = entry.getResource();\n+            if (r.is(Bundle.class)) {\n+                // this should be the result of the ExplanationOfBenefit search, so iterate\n+                // over each entry. TODO should visit instead", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NTYyOQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513155629", "bodyText": "I know our convention is not to leave TODO...but I sometimes like to leave notes of better ways to do things as inspiration in case we come back and refactor stuff in the future.", "author": "punktilious", "createdAt": "2020-10-28T03:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5ODQ1Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513398452", "bodyText": "oh my comment was on the ability to use a visitor, I didn't have a problem with the todo.", "author": "prb112", "createdAt": "2020-10-28T12:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjU0NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512206545", "bodyText": "since the design of $reindex involves getting invoked a lot in parallel, its probably worth guarding this with a logger.isLoggable", "author": "lmsurpre", "createdAt": "2020-10-26T19:14:01Z", "path": "operation/fhir-operation-reindex/src/main/java/com/ibm/fhir/operation/reindex/ReindexOperation.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.operation.reindex;\n+\n+import java.io.InputStream;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.parser.FHIRParser;\n+import com.ibm.fhir.model.resource.OperationDefinition;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.server.operation.spi.AbstractOperation;\n+import com.ibm.fhir.server.operation.spi.FHIROperationContext;\n+import com.ibm.fhir.server.operation.spi.FHIRResourceHelpers;\n+import com.ibm.fhir.server.util.FHIROperationUtil;\n+\n+/**\n+ * Custom operation to invoke the persistence layer reindexing of resources\n+ */\n+public class ReindexOperation extends AbstractOperation {\n+    private static final Logger logger = Logger.getLogger(ReindexOperation.class.getName());\n+    \n+    private static final String PARAM_TSTAMP = \"_tstamp\";\n+    private static final String PARAM_RESOURCE_COUNT = \"_resourceCount\";\n+    \n+    static final DateTimeFormatter DAY_FORMAT = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd\")\n+            .parseDefaulting(ChronoField.NANO_OF_DAY, 0)\n+            .toFormatter()\n+            .withZone(ZoneId.of(\"UTC\"));\n+    \n+    public ReindexOperation() {\n+        super();\n+    }\n+\n+    @Override\n+    protected OperationDefinition buildOperationDefinition() {\n+        try (InputStream in = getClass().getClassLoader().getResourceAsStream(\"reindex.json\")) {\n+            return FHIRParser.parser(Format.JSON).parse(in);\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    @Override\n+    protected Parameters doInvoke(FHIROperationContext operationContext, Class<? extends Resource> resourceType,\n+            String logicalId, String versionId, Parameters parameters, FHIRResourceHelpers resourceHelper)\n+            throws FHIROperationException {\n+        \n+        // Allow only POST because we're changing the state of the database\n+        String method = (String) operationContext.getProperty(FHIROperationContext.PROPNAME_METHOD_TYPE);\n+        if (!\"POST\".equalsIgnoreCase(method)) {\n+            throw new FHIROperationException(\"HTTP method not supported: \" + method);\n+        }\n+        \n+        try {\n+            Instant tstamp = Instant.now();\n+            int resourceCount = 10;\n+            \n+            if (parameters != null) {\n+                for (Parameters.Parameter parameter : parameters.getParameter()) {\n+                    if (parameter.getValue() != null) {\n+                        logger.fine(\"reindex param: \" + parameter.getName().getValue() + \" = \" + parameter.getValue().toString());", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0NzAxMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513547012", "bodyText": "agreed", "author": "punktilious", "createdAt": "2020-10-28T15:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5OTM2Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513699366", "bodyText": "Is this updated?", "author": "prb112", "createdAt": "2020-10-28T19:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMjY1OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512212658", "bodyText": "is this a \"3rd way\" to do schema migrations?  i was already concerned about supporting two different ways...", "author": "lmsurpre", "createdAt": "2020-10-26T19:25:02Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/patch/Main.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.patch;\n+\n+import static com.ibm.fhir.schema.app.util.CommonUtil.configureLogger;\n+import static com.ibm.fhir.schema.app.util.CommonUtil.getDbAdapter;\n+import static com.ibm.fhir.schema.app.util.CommonUtil.getPropertyAdapter;\n+import static com.ibm.fhir.schema.app.util.CommonUtil.loadDriver;\n+import static com.ibm.fhir.schema.app.util.CommonUtil.logClasspath;\n+import static com.ibm.fhir.schema.app.util.CommonUtil.printUsage;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.ibm.fhir.database.utils.api.DatabaseNotReadyException;\n+import com.ibm.fhir.database.utils.api.IDatabaseAdapter;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.common.DropForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.JdbcPropertyAdapter;\n+import com.ibm.fhir.database.utils.common.JdbcTarget;\n+import com.ibm.fhir.database.utils.db2.Db2Translator;\n+import com.ibm.fhir.database.utils.derby.DerbyTranslator;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.model.type.code.FHIRResourceType;\n+\n+/**\n+ * Utility to patch an old schema for use-cases which fall outside the standard\n+ * automatic schema migration process\n+ */\n+public class Main {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMzk1NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513433955", "bodyText": "Same concerns here.", "author": "prb112", "createdAt": "2020-10-28T13:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMjY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NjM5NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513556395", "bodyText": "No choice. One of the dev databases had cruft left over from a previous design that our current migration code doesn't know how to handle. It's a one-off, and not part of the standard mechanism.", "author": "punktilious", "createdAt": "2020-10-28T15:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMjY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMzk5MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512213990", "bodyText": "I've got my eclipse set up to expand this on every save.  Any tips/tricks for selectively avoiding that?", "author": "lmsurpre", "createdAt": "2020-10-26T19:27:20Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -6,43 +6,7 @@\n \n package com.ibm.fhir.schema.control;\n \n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.CODE_SYSTEMS;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.CODE_SYSTEM_ID;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.CODE_SYSTEM_NAME;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.DATE_END;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.DATE_START;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.DATE_VALUES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.DATE_VALUE_DROPPED_COLUMN;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.FHIR_REF_SEQUENCE;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.FHIR_SEQUENCE;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.FK;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.IDX;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.LOGICAL_ID;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.LOGICAL_ID_BYTES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.LOGICAL_RESOURCES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.LOGICAL_RESOURCE_ID;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.MAX_SEARCH_STRING_BYTES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.MAX_TOKEN_VALUE_BYTES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.MT_ID;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.PARAMETER_NAME;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.PARAMETER_NAMES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.PARAMETER_NAME_ID;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.RESOURCE_TYPE;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.RESOURCE_TYPES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.RESOURCE_TYPE_ID;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.STR_VALUE;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.STR_VALUES;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.STR_VALUE_LCASE;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANTS;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANT_HASH;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANT_KEYS;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANT_KEY_ID;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANT_NAME;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANT_SALT;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANT_SEQUENCE;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TENANT_STATUS;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TOKEN_VALUE;\n-import static com.ibm.fhir.schema.control.FhirSchemaConstants.TOKEN_VALUES;\n+import static com.ibm.fhir.schema.control.FhirSchemaConstants.*;", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMDY0OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513430649", "bodyText": "try //@formatter:off and then //@formatter:on", "author": "prb112", "createdAt": "2020-10-28T13:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzOTQ5Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513639492", "bodyText": "In this case I like the .* because it ensures I always have all the constants available when I'm typing new code.", "author": "punktilious", "createdAt": "2020-10-28T17:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMzk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIyMDY4NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512220684", "bodyText": "super minor\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /// Build the multitenant variant of the schema\n          \n          \n            \n                // Build the multitenant variant of the schema", "author": "lmsurpre", "createdAt": "2020-10-26T19:39:23Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirResourceTableGroup.java", "diffHunk": "@@ -90,6 +98,9 @@\n \n     // The session variable we depend on for access control\n     private final SessionVariableDef sessionVariable;\n+    \n+    /// Build the multitenant variant of the schema", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzIyMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513557222", "bodyText": "done", "author": "punktilious", "createdAt": "2020-10-28T15:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIyMDY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIyMzc0NQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512223745", "bodyText": "is there a way to scope the warning to just derby dbs?\nand maybe reference the issue from a comment?  I think I saw you open one with openliberty but now I can't seem to locate it.", "author": "lmsurpre", "createdAt": "2020-10-26T19:44:27Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyConnection.java", "diffHunk": "@@ -348,6 +348,7 @@ public boolean isWrapperFor(Class<?> iface) throws SQLException {\n \n     @Override\n     public void setSchema(String schema) throws SQLException {\n+        logger.warning(\"Calling setSchema, which exposes a transaction bug in Liberty+Derby: \" + schema);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNTkwMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513425900", "bodyText": "I thought it was naturally only used in Derby", "author": "prb112", "createdAt": "2020-10-28T13:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIyMzc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1OTYyOA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513559628", "bodyText": "This will only be hit from Derby when executing unit-tests. It should never be hit when running in Liberty. However, I found a similar (but not the same) defect when executing alter table statements in Derby and I was worried we might somehow be making a call here, hence the log message. If we see this message in our FHIR server logs, it's a bug.", "author": "punktilious", "createdAt": "2020-10-28T15:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIyMzc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzMTM3OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512231378", "bodyText": "should we introduce a similar property for enabling/disabling the new ResourceReference caching?\nor maybe we should remove all of these...i'm not sure why someone would turn them off (unless they found a bug in our stuff).", "author": "lmsurpre", "createdAt": "2020-10-26T19:58:30Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -195,12 +219,13 @@ public FHIRPersistenceJDBCImpl() throws Exception {\n         ResourceTypesCache.setEnabled(fhirConfig.getBooleanProperty(PROPERTY_JDBC_ENABLE_RESOURCE_TYPES_CACHE,\n                                       Boolean.TRUE));\n ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2NzA4OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513467089", "bodyText": "+1 on the comment/question", "author": "prb112", "createdAt": "2020-10-28T14:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzMTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0MjYzNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513642637", "bodyText": "Created issue #1637. We cannot disable the cache in the new code - it is central to how some of the processing is performed. However, we should definitely replace the old cache stuff with the new cache.", "author": "punktilious", "createdAt": "2020-10-28T17:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzMTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MDYxOQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512270619", "bodyText": "ooo, do we use this yet?   I know the IBM Cloud Databases for PostgreSQL recommends that applications add retry logic but I had assumed that we'd just pass that burden onto our clients for now...", "author": "lmsurpre", "createdAt": "2020-10-26T21:10:50Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/DataAccessException.java", "diffHunk": "@@ -14,6 +14,8 @@\n \n     // All exceptions are serializable\n     private static final long serialVersionUID = -3385697603070014498L;\n+    \n+    private boolean transactionRetryable;", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NDE4Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512944186", "bodyText": "+1 on Lee's comments", "author": "prb112", "createdAt": "2020-10-27T18:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MDYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2Mzc0Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513163747", "bodyText": "I had to implement it for the reindex operation because I was getting occasional deadlocks when processing the inserts into common_token_values. However, after I fixed the contention issue on this table by delaying the inserts until just before the commit, we ended up not getting any more deadlocks - even though there is protection provided in the reindex operation REST layer. It would be fairly easy to extend this now to the other operations, but I recommend coming up with a nice pattern for invoking a retryable operation.", "author": "punktilious", "createdAt": "2020-10-28T03:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MDYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3Mzc0MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512273740", "bodyText": "should we remove these lines?", "author": "lmsurpre", "createdAt": "2020-10-26T21:16:49Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/DataAccess.java", "diffHunk": "@@ -240,8 +244,22 @@ public void markJobDone(BucketLoaderJob job) {\n     public void recordLogicalIds(long resourceBundleLoadId, int lineNumber, List<ResourceIdValue> idValues, int batchSize) {\n         try (ITransaction tx = transactionProvider.getTransaction()) {\n             try {\n-                RecordLogicalIdList cmd = new RecordLogicalIdList(resourceBundleLoadId, lineNumber, idValues, resourceTypeMap, batchSize);\n-                dbAdapter.runStatement(cmd);\n+//                RecordLogicalIdList cmd = new RecordLogicalIdList(resourceBundleLoadId, lineNumber, idValues, resourceTypeMap, batchSize);\n+//                dbAdapter.runStatement(cmd);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1Nzg4Mw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513157883", "bodyText": "done", "author": "punktilious", "createdAt": "2020-10-28T03:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3Mzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NDE3Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512274177", "bodyText": "cool!", "author": "lmsurpre", "createdAt": "2020-10-26T21:17:40Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/BundleBreakerResourceProcessor.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.scanner;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.bucket.api.IResourceEntryProcessor;\n+import com.ibm.fhir.bucket.api.ResourceEntry;\n+import com.ibm.fhir.bucket.cos.CosClient;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.generator.exception.FHIRGeneratorException;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Bundle.Entry;\n+import com.ibm.fhir.model.resource.Bundle.Entry.Request;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+\n+/**\n+ * Breaks a large Bundle into smaller Bundles, translating local references to external references to\n+ * maintain the relationships between the resources when they are loaded into the FHIR server. This\n+ * is experimental, and primarily used for analyzing the performance of different bundle sizes.", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzOTc4NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512639784", "bodyText": "should this get reconciled with com.ibm.fhir.core.util.LRUCache?  Its basically the same approach, although this new one has a tad more.", "author": "lmsurpre", "createdAt": "2020-10-27T12:09:20Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/cache/LRUCache.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.cache;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * An LRU implementation which limits the maximum number\n+ * of entries and ejects older entries. Null values are\n+ * not permitted in this implementation.\n+ */\n+public class LRUCache<K,V> extends LinkedHashMap<K,V> {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxMjMxMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513412313", "bodyText": "I think this should become a backlog issue.", "author": "prb112", "createdAt": "2020-10-28T12:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzOTc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNzAxMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513427012", "bodyText": "creating an issue", "author": "punktilious", "createdAt": "2020-10-28T13:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzOTc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc2MzY5Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513763692", "bodyText": "#1643", "author": "lmsurpre", "createdAt": "2020-10-28T21:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzOTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxNDM1Nw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512814357", "bodyText": "This is a bit strange.", "author": "prb112", "createdAt": "2020-10-27T15:53:53Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/persistence/AllocateJobs.java", "diffHunk": "@@ -73,6 +79,21 @@ public void run(IDatabaseTranslator translator, Connection c) {\n             logger.log(Level.SEVERE, NEXTVAL, x);\n             throw new DataAccessException(\"Get next allocationId failed\");\n         }\n+\n+        // Build the bucket-path predicate if the user has specified any\n+        StringBuilder bpBuilder = new StringBuilder();\n+        for (@SuppressWarnings(\"unused\") BucketPath bp: bucketPaths) {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NjkyMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513156922", "bodyText": "I don't need to use the value here, I just need to create a predicate for each entry. I could get the size and do a for count loop...but then the loop variable wouldn't really be used either (other than to terminate the loop), but this is just as easy.", "author": "punktilious", "createdAt": "2020-10-28T03:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxNDM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5NzgxOA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513397818", "bodyText": "I understand, it's just funky - in a Blue Cheese kind of way.", "author": "prb112", "createdAt": "2020-10-28T12:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxNDM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkzOTE5MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512939191", "bodyText": "This is all over the place (e.g. repeated code)", "author": "prb112", "createdAt": "2020-10-27T18:39:11Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/CosReader.java", "diffHunk": "@@ -203,20 +215,21 @@ public void mainAllocationLoop() {\n                 // We have more capacity than work is currently available in the database,\n                 // so take a nap before checking again\n                 logger.fine(\"No work. Napping\");\n-                safeSleep(5000);\n+                safeSleep(10000L);\n             }\n         }\n     }\n     \n     /**\n-     * Sleep this thread for the given milliseconds\n+     * Sleep current thread for given number of milliseconds or until\n+     * the thread is interrupted.\n      * @param millis\n      */\n     protected void safeSleep(long millis) {\n         try {\n             Thread.sleep(millis);\n         } catch (InterruptedException x) {\n-            // NOP\n+            // woken up early from sleep, probably shutting down, so this is a NOP\n         }\n     }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NzQ5NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513157494", "bodyText": "guilty. Will create a utility, not now.", "author": "punktilious", "createdAt": "2020-10-28T03:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkzOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5NzQxMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513397413", "bodyText": "Something for the future.  agreed, marking resolved.", "author": "prb112", "createdAt": "2020-10-28T12:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkzOTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0MDM0OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512940348", "bodyText": "Dead code", "author": "prb112", "createdAt": "2020-10-27T18:41:05Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/FhirClientResourceProcessor.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.scanner;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.apache.http.HttpStatus;\n+\n+import com.ibm.fhir.bucket.api.IResourceEntryProcessor;\n+import com.ibm.fhir.bucket.api.ResourceBundleError;\n+import com.ibm.fhir.bucket.api.ResourceEntry;\n+import com.ibm.fhir.bucket.api.ResourceIdValue;\n+import com.ibm.fhir.bucket.client.FhirClient;\n+import com.ibm.fhir.bucket.client.FhirServerResponse;\n+import com.ibm.fhir.bucket.client.PostResource;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.generator.exception.FHIRGeneratorException;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Bundle.Entry.Response;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Calls the FHIR REST API to create resources\n+ */\n+public class FhirClientResourceProcessor implements IResourceEntryProcessor {\n+    private static final Logger logger = Logger.getLogger(FhirClientResourceProcessor.class.getName());\n+    private static final int BATCH_SIZE = 200;\n+    \n+    // Nanos in a millisecond\n+    private static final long NANOS_MS = 1000000;\n+\n+    // Client for making FHIR server requests\n+    private final FhirClient fhirClient;\n+\n+    // Access to the FHIR bucket persistence layer to record logical ids\n+    private final DataAccess dataAccess;\n+    \n+    /**\n+     * Public constructor\n+     * @param poolSize\n+     */\n+    public FhirClientResourceProcessor(FhirClient fc, DataAccess dataAccess) {\n+        this.fhirClient = fc;\n+        this.dataAccess = dataAccess;\n+    }\n+\n+    @Override\n+    public void process(ResourceEntry re) {\n+        \n+        boolean success = false;\n+        try {\n+            Resource resource = re.getResource();\n+            final String resourceType = resource.getClass().getSimpleName();\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Processing resource: \" + resourceType);\n+            }\n+            \n+            // Build a post request for the resource and send to FHIR\n+            long start = System.nanoTime();\n+            PostResource post = new PostResource(resource);\n+            FhirServerResponse response = post.run(fhirClient);\n+            long end = System.nanoTime();\n+            switch (response.getStatusCode()) {\n+            case HttpStatus.SC_OK:\n+            case HttpStatus.SC_CREATED:\n+                String locn = response.getLocationHeader();\n+                if (response.getResource() != null) {\n+                    // Process the response bundle\n+                    success = processResponseResource(re, response.getResource());\n+                    \n+                    // Update the job with the response time for this entry (for local logging)\n+                    int responseTimeMs = (int)((end - start) / NANOS_MS);\n+                    re.getJob().setLastCallResponseTime(responseTimeMs);\n+                } else if (locn != null) {\n+                    if (locn.startsWith(\"https://\")) {\n+                        // the response was empty, so in this case we need to extract the id from\n+                        // the location header\n+                        int responseTimeMs = (int)((end - start) / NANOS_MS);\n+                        success = processLocation(re, locn, responseTimeMs);\n+                    } else {\n+                        logger.warning(\"FHIR bad location format [\" + re.toString() + \"]: \" + \n+                                locn);\n+                    }\n+                    \n+                } else {\n+                    logger.warning(\"FHIR request id not found [\" + re.toString() + \"]: \" + \n+                            response.getStatusCode() + \" \" + response.getStatusMessage());\n+                }\n+                break;\n+            default:\n+                logger.warning(\"FHIR request failed [\" + re.toString() + \"]: \" + \n+                        response.getStatusCode() + \" \" + response.getStatusMessage());\n+                processBadRequest(re, response);\n+                \n+                // Still set the response time so we can see if it failed because the transaction took too long\n+                int responseTimeMs = (int)((end - start) / NANOS_MS);\n+                re.getJob().setLastCallResponseTime(responseTimeMs);\n+                break;\n+            }\n+        } catch (Throwable x) {\n+            // don't let any exceptions propagate into the thread pool\n+            logger.log(Level.SEVERE, re.toString(), x);\n+        } finally {\n+            // Signal the processing is complete for this entry\n+            re.getJob().operationComplete(success);\n+        }\n+    }\n+\n+    /**\n+     * Process the bundle we received in the FHIR POST response to extract all the ids\n+     * Synthetic example:\n+        {           \n+            \"entry\": [\n+                {\n+                    \"response\": {\n+                        \"etag\": \"W/\\\"1\\\"\",\n+                        \"id\": \"1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309\",\n+                        \"lastModified\": \"2020-08-20T17:22:12.554128Z\",\n+                        \"location\": \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\",\n+                        \"status\": \"201\"\n+                    }\n+                },\n+                {\n+                    \"response\": {\n+                        \"etag\": \"W/\\\"1\\\"\",\n+                        \"id\": \"1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3\",\n+                        \"lastModified\": \"2020-08-20T17:22:12.980788Z\",\n+                        \"location\": \"Organization/1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3/_history/1\",\n+                        \"status\": \"201\"\n+                    }\n+                },\n+                ...\n+            ],  \n+            \"resourceType\": \"Bundle\",\n+            \"type\": \"transaction-response\"\n+        }\n+     * \n+     * @param bundle\n+     * @return\n+     */\n+    private boolean processResponseResource(ResourceEntry re, Resource resource) {\n+        boolean result;\n+        \n+        if (Bundle.class.isAssignableFrom(resource.getClass())) {\n+            Bundle bundle = resource.as(Bundle.class);\n+            result = processResponseBundle(re, bundle);\n+        } else {\n+            logger.severe(\"Resource is not a bundle. Skipping: \" + resource.getClass().getSimpleName());\n+            result = false;\n+        }\n+        \n+        \n+        return result;\n+    }\n+    \n+    private boolean processResponseBundle(ResourceEntry re, Bundle bundle) {\n+        \n+        // Extract the location from every entry in the bundle. Collect them\n+        // together so that we can make a single batch insert into the database\n+        // which is going to be a lot more efficient than individual inserts\n+        List<ResourceIdValue> idValues = new ArrayList<>();\n+        re.getJob().addTotalResourceCount(bundle.getEntry().size());\n+        for (Bundle.Entry entry: bundle.getEntry()) {\n+            Response response = entry.getResponse();\n+            if (response != null) {\n+                if (response.getLocation() != null && response.getLocation().getValue() != null) {\n+                    String locn = response.getLocation().getValue();\n+                    if (logger.isLoggable(Level.FINE)) {\n+                        logger.fine(\"New resource: \" + locn);\n+                    }\n+                    ResourceIdValue rid = getResourceIdValue(locn);\n+                    if (rid != null) {\n+                        idValues.add(rid);\n+                    }\n+                }\n+            }\n+        }\n+\n+        processResourceIdValues(re, idValues);\n+        return idValues.size() > 0;\n+    }\n+\n+    /**\n+     * Process the list of resource ids as a batch\n+     * @param re\n+     * @param idValues\n+     * @return\n+     */\n+    private void processResourceIdValues(ResourceEntry re, List<ResourceIdValue> idValues) {\n+        dataAccess.recordLogicalIds(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), idValues, BATCH_SIZE);\n+    }\n+    /**\n+     * Parse the location to create a {@link ResourceIdValue} DTO object.\n+     * The location can take one of two forms:\n+     *   \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\"\n+     *   \"https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\"\n+     * @param location\n+     * @return\n+     */\n+    private ResourceIdValue getResourceIdValue(String location) {\n+        ResourceIdValue result;\n+    \n+        String[] parts = location.split(\"/\");\n+        if (parts.length == 10) {\n+            String resourceType = parts[6];\n+            String id = parts[7];\n+            result = new ResourceIdValue(resourceType, id);\n+        } else if (parts.length == 4) {\n+            String resourceType = parts[0];\n+            String id = parts[1];\n+            result = new ResourceIdValue(resourceType, id);\n+        } else {\n+            result = null;\n+        }\n+        \n+        return result;\n+    }\n+    \n+    private boolean processLocation(ResourceEntry re, String location, int responseTimeMs) {\n+        boolean result = false;\n+        // the response was empty, so in this case we need to extract the id from\n+        // the location header, which means cracking the string into parts:\n+        // https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\n+        re.getJob().addTotalResourceCount(1);\n+        String[] parts = location.split(\"/\");\n+        if (parts.length == 10) {\n+            String resourceType = parts[6];\n+            String id = parts[7];\n+            logger.info(\"[\" +re.toString() + \"] new \" + resourceType + \"/\" + id + \" [took \" + responseTimeMs + \" ms]\");\n+            dataAccess.recordLogicalId(resourceType, id, re.getJob().getResourceBundleLoadId(), re.getLineNumber(), responseTimeMs);\n+            result = true;\n+        }\n+        \n+        return result;\n+    }\n+\n+    /**\n+     * Record the error in the database\n+     * @param re\n+     * @param response\n+     */\n+    protected void processBadRequest(ResourceEntry re, FhirServerResponse response) {\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // dump the resource and full operational outcome to the log\n+            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n+                + resourceToString(re.getResource()));\n+            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n+                + response.getOperationalOutcomeText());\n+        }\n+        \n+        List<ResourceBundleError> errors = new ArrayList<>();\n+        errors.add(new ResourceBundleError(re.getLineNumber(), response.getOperationalOutcomeText(), \n+            response.getResponseTime(), response.getStatusCode(), response.getStatusMessage()));\n+        \n+        dataAccess.recordErrors(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), errors);\n+    }\n+\n+    /**\n+     * Render the resource as a string (for logging)\n+     * @param resource\n+     * @return\n+     */\n+    private String resourceToString(Resource resource) {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(4096);\n+        try {\n+            FHIRGenerator.generator(Format.JSON, false).generate(resource, os);\n+            return new String(os.toByteArray(), StandardCharsets.UTF_8);\n+        } catch (FHIRGeneratorException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void init() {\n+    }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1ODIzOA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513158238", "bodyText": "removed", "author": "punktilious", "createdAt": "2020-10-28T03:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0MDM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0MDg1OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512940858", "bodyText": "Where is this called, and is this more than dead code?", "author": "prb112", "createdAt": "2020-10-27T18:41:53Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/ResourceHandler.java", "diffHunk": "@@ -152,227 +124,9 @@ public boolean process(ResourceEntry entry) {\n         \n         return result;\n     }\n-    \n-    /**\n-     * Process the resource in the thread pool\n-     * @param resource\n-     */\n-    public void processThr(ResourceEntry re) {\n-        \n-        boolean success = false;\n-        try {\n-            Resource resource = re.getResource();\n-            final String resourceType = resource.getClass().getSimpleName();\n-            if (logger.isLoggable(Level.FINE)) {\n-                logger.fine(\"Processing resource: \" + resourceType);\n-            }\n-            \n-            // Build a post request for the resource and send to FHIR\n-            long start = System.nanoTime();\n-            PostResource post = new PostResource(resource);\n-            FhirServerResponse response = post.run(fhirClient);\n-            long end = System.nanoTime();\n-            switch (response.getStatusCode()) {\n-            case HttpStatus.SC_OK:\n-            case HttpStatus.SC_CREATED:\n-                String locn = response.getLocationHeader();\n-                if (response.getResource() != null) {\n-                    // Process the response bundle\n-                    success = processResponseResource(re, response.getResource());\n-                } else if (locn != null) {\n-                    if (locn.startsWith(\"https://\")) {\n-                        // the response was empty, so in this case we need to extract the id from\n-                        // the location header\n-                        int responseTimeMs = (int)((end - start) / NANOS_MS);\n-                        success = processLocation(re, locn, responseTimeMs);\n-                    } else {\n-                        logger.warning(\"FHIR bad location format [\" + re.toString() + \"]: \" + \n-                                locn);\n-                    }\n-                    \n-                } else {\n-                    logger.warning(\"FHIR request id not found [\" + re.toString() + \"]: \" + \n-                            response.getStatusCode() + \" \" + response.getStatusMessage());\n-                }\n-                break;\n-            default:\n-                logger.warning(\"FHIR request failed [\" + re.toString() + \"]: \" + \n-                        response.getStatusCode() + \" \" + response.getStatusMessage());\n-                processBadRequest(re, response);\n-                break;\n-            }\n-        } catch (Throwable x) {\n-            // don't let any exceptions propagate into the thread pool\n-            logger.log(Level.SEVERE, re.toString(), x);\n-        } finally {\n-            // Signal the processing is complete for this entry\n-            re.getJob().operationComplete(success);\n-        }\n-    }\n-\n-    /**\n-     * Process the bundle we received in the FHIR POST response to extract all the ids\n-     * Synthetic example:\n-        {           \n-            \"entry\": [\n-                {\n-                    \"response\": {\n-                        \"etag\": \"W/\\\"1\\\"\",\n-                        \"id\": \"1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309\",\n-                        \"lastModified\": \"2020-08-20T17:22:12.554128Z\",\n-                        \"location\": \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\",\n-                        \"status\": \"201\"\n-                    }\n-                },\n-                {\n-                    \"response\": {\n-                        \"etag\": \"W/\\\"1\\\"\",\n-                        \"id\": \"1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3\",\n-                        \"lastModified\": \"2020-08-20T17:22:12.980788Z\",\n-                        \"location\": \"Organization/1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3/_history/1\",\n-                        \"status\": \"201\"\n-                    }\n-                },\n-                ...\n-            ],  \n-            \"resourceType\": \"Bundle\",\n-            \"type\": \"transaction-response\"\n-        }\n-     * \n-     * @param bundle\n-     * @return\n-     */\n-    private boolean processResponseResource(ResourceEntry re, Resource resource) {\n-        boolean result;\n-        \n-        if (Bundle.class.isAssignableFrom(resource.getClass())) {\n-            Bundle bundle = resource.as(Bundle.class);\n-            result = processResponseBundle(re, bundle);\n-        } else {\n-            logger.severe(\"Resource is not a bundle. Skipping: \" + resource.getClass().getSimpleName());\n-            result = false;\n-        }\n-        \n-        \n-        return result;\n-    }\n-    \n-    private boolean processResponseBundle(ResourceEntry re, Bundle bundle) {\n-        \n-        // Extract the location from every entry in the bundle. Collect them\n-        // together so that we can make a single batch insert into the database\n-        // which is going to be a lot more efficient than individual inserts\n-        List<ResourceIdValue> idValues = new ArrayList<>();\n-        for (Bundle.Entry entry: bundle.getEntry()) {\n-            Response response = entry.getResponse();\n-            if (response != null) {\n-                if (response.getLocation() != null && response.getLocation().getValue() != null) {\n-                    String locn = response.getLocation().getValue();\n-                    logger.info(\"New resource: \" + locn);\n-                    ResourceIdValue rid = getResourceIdValue(locn);\n-                    if (rid != null) {\n-                        idValues.add(rid);\n-                    }\n-                }\n-            }\n-        }\n-\n-        processResourceIdValues(re, idValues);\n-        return idValues.size() > 0;\n-    }\n-\n-    /**\n-     * Process the list of resource ids as a batch\n-     * @param re\n-     * @param idValues\n-     * @return\n-     */\n-    private void processResourceIdValues(ResourceEntry re, List<ResourceIdValue> idValues) {\n-        dataAccess.recordLogicalIds(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), idValues, BATCH_SIZE);\n-    }\n-    /**\n-     * Parse the location to create a {@link ResourceIdValue} DTO object.\n-     * The location can take one of two forms:\n-     *   \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\"\n-     *   \"https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\"\n-     * @param location\n-     * @return\n-     */\n-    private ResourceIdValue getResourceIdValue(String location) {\n-        ResourceIdValue result;\n-    \n-        String[] parts = location.split(\"/\");\n-        if (parts.length == 10) {\n-            String resourceType = parts[6];\n-            String id = parts[7];\n-            result = new ResourceIdValue(resourceType, id);\n-        } else if (parts.length == 4) {\n-            String resourceType = parts[0];\n-            String id = parts[1];\n-            result = new ResourceIdValue(resourceType, id);\n-        } else {\n-            result = null;\n-        }\n-        \n-        return result;\n-    }\n-    \n-    private boolean processLocation(ResourceEntry re, String location, int responseTimeMs) {\n-        boolean result = false;\n-        // the response was empty, so in this case we need to extract the id from\n-        // the location header, which means cracking the string into parts:\n-        // https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\n-        String[] parts = location.split(\"/\");\n-        if (parts.length == 10) {\n-            String resourceType = parts[6];\n-            String id = parts[7];\n-            logger.info(\"[\" +re.toString() + \"] new \" + resourceType + \"/\" + id + \" [took \" + responseTimeMs + \" ms]\");\n-            dataAccess.recordLogicalId(resourceType, id, re.getJob().getResourceBundleLoadId(), re.getLineNumber(), responseTimeMs);\n-            result = true;\n-        }\n-        \n-        return result;\n-    }\n-\n-    /**\n-     * Record the error in the database\n-     * @param re\n-     * @param response\n-     */\n-    protected void processBadRequest(ResourceEntry re, FhirServerResponse response) {\n-        \n-        if (logger.isLoggable(Level.FINE)) {\n-            // dump the resource and full operational outcome to the log\n-            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n-                + resourceToString(re.getResource()));\n-            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n-                + response.getOperationalOutcomeText());\n-        }\n-        \n-        List<ResourceBundleError> errors = new ArrayList<>();\n-        errors.add(new ResourceBundleError(re.getLineNumber(), response.getOperationalOutcomeText(), \n-            response.getResponseTime(), response.getStatusCode(), response.getStatusMessage()));\n-        \n-        dataAccess.recordErrors(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), errors);\n-    }\n-\n-    /**\n-     * Render the resource as a string (for logging)\n-     * @param resource\n-     * @return\n-     */\n-    private String resourceToString(Resource resource) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream(4096);\n-        try {\n-            FHIRGenerator.generator(Format.JSON, false).generate(resource, os);\n-            return new String(os.toByteArray(), StandardCharsets.UTF_8);\n-        } catch (FHIRGeneratorException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n \n     /**\n-     * \n+     * Perform any initialization after things have been wired up\n      */\n     public void init() {\n     }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1ODgyMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513158821", "bodyText": "It was called from Main, but I removed it.", "author": "punktilious", "createdAt": "2020-10-28T03:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0MDg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NjMzMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512946331", "bodyText": "How is this different than what we had before? The ordered columns?", "author": "prb112", "createdAt": "2020-10-27T18:50:32Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/CreateIndexStatement.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.model.OrderedColumnDef;\n+\n+/**\n+ * Create an index\n+ */\n+public class CreateIndexStatement implements IDatabaseStatement {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDc1Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513164752", "bodyText": "It's used in a different context...as part of the migration step Lee implemented. There's some redundancy here, but at the time I was fighting the Derby/Liberty alter table bug.", "author": "punktilious", "createdAt": "2020-10-28T03:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NjMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NzAwMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512947002", "bodyText": "Is this always going to be an ArrayList or ordered list underneath?", "author": "prb112", "createdAt": "2020-10-27T18:51:43Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -109,6 +110,16 @@ public static String join(Collection<String> things) {\n         return things.stream().collect(Collectors.joining(\",\"));\n     }\n \n+    /**\n+     * Join the ordered column definitions\n+     * @param things\n+     * @return\n+     */\n+    public static String joinOrderedColumnDefs(Collection<OrderedColumnDef> things) {\n+        return things.stream().map(c -> c.toString()).collect(Collectors.joining(\",\"));", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NTAxNQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513165015", "bodyText": "Probably. Why?", "author": "punktilious", "createdAt": "2020-10-28T03:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NzAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5NjAwMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513396002", "bodyText": "I read the OrderedColumDef afterwards (I see how it orders now)", "author": "prb112", "createdAt": "2020-10-28T12:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NzAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NzgxMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512947810", "bodyText": "Why finest?  typically we target FINE? this is a curiosity question.", "author": "prb112", "createdAt": "2020-10-27T18:53:07Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/JdbcTarget.java", "diffHunk": "@@ -33,6 +36,10 @@ public JdbcTarget(Connection c) {\n \n     @Override\n     public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        if (logger.isLoggable(Level.FINEST)) {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NTMxNA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513165314", "bodyText": "It generates a lot of output and we already log a ton under FINE so I was trying to avoid making it any worse.", "author": "punktilious", "createdAt": "2020-10-28T03:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0NzgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0ODIyNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512948227", "bodyText": "please set your save actions to remove trailing spaces (per team convention)", "author": "prb112", "createdAt": "2020-10-27T18:53:53Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -207,9 +245,9 @@ public void run() {\n             // Not cool. This means that only some of the tables will have the partition assigned\n             throw new DataAccessException(\"Tenant partition creation did not complete\");\n         }\n-\n+        ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NTY2MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513165660", "bodyText": "that's OK as long as all the files are clean, but it can cause big issues when dealing with merge conflicts as I recently experienced.", "author": "punktilious", "createdAt": "2020-10-28T03:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0ODIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5NTcwOA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513395708", "bodyText": "yeah - we should cut it down when we all have it set.", "author": "prb112", "createdAt": "2020-10-28T12:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0ODIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMTYwMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513431601", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-10-28T13:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0ODIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0ODgzMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512948832", "bodyText": "interesting code from the prior commit.\nLet's remove this commented line", "author": "prb112", "createdAt": "2020-10-27T18:54:52Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyTranslator.java", "diffHunk": "@@ -179,11 +179,24 @@ public String dualTableName() {\n     @Override\n     public String selectSequenceNextValue(String schemaName, String sequenceName) {\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n-        return \"SELECT NEXT VALUE FOR \" + qname + \" FROM SYSIBM.SYSDUMMY1\";\n+        // return \"SELECT NEXT VALUE FOR \" + qname + \" FROM SYSIBM.SYSDUMMY1\";", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NjA5MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513166091", "bodyText": "yeah, probably cruft left over from my search for the Derby/Liberty alter table bug.", "author": "punktilious", "createdAt": "2020-10-28T03:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk0ODgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MDAyMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512950020", "bodyText": "Random tabs... save action in Eclipse", "author": "prb112", "createdAt": "2020-10-27T18:56:55Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/Table.java", "diffHunk": "@@ -281,14 +281,24 @@ public Builder addSmallIntColumn(String columnName, Integer defaultValue, boolea\n             columns.add(cd);\n             return this;\n         }\n-\n+        ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NjgxMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513166812", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T04:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MDMyNw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512950327", "bodyText": "same save action comment", "author": "prb112", "createdAt": "2020-10-27T18:57:23Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/TimestampColumn.java", "diffHunk": "@@ -16,14 +16,14 @@\n      * The number of fractional second decimals to store or null to use the database's default\n      */\n     private final Integer precision;\n-\n+    ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NzA4OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513167088", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T04:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MDMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MDYzMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512950633", "bodyText": "unused comment.", "author": "prb112", "createdAt": "2020-10-27T18:57:55Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/View.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseAdapter;\n+\n+\n+/**\n+ * ", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NzM0Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513167346", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T04:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MjIyMg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r512952222", "bodyText": "seems strange to flip to another paradigm to build the ddl - I think it's OK though.", "author": "prb112", "createdAt": "2020-10-27T19:00:44Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/tenant/DropViewDAO.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.tenant;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * Executes a DROP VIEW statement\n+ */\n+public class DropViewDAO implements IDatabaseStatement {\n+    private static final Logger logger = Logger.getLogger(DropViewDAO.class.getName());\n+    \n+    private final String schemaName;\n+    \n+    private final String viewName;\n+    \n+    private final boolean propagateError;\n+    \n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param viewName\n+     * @param propagateError if false, errors will be suppressed, if true, they will be propagated\n+     */\n+    public DropViewDAO(String schemaName, String viewName, boolean propagateError) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        DataDefinitionUtil.assertValidName(viewName);\n+        this.schemaName = schemaName;\n+        this.viewName = viewName;\n+        this.propagateError = propagateError;\n+    }\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        final String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, viewName);\n+        final StringBuilder ddl = new StringBuilder();\n+        ddl.append(\"DROP VIEW \");\n+        ddl.append(qualifiedName);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxMDk2MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513410960", "bodyText": "The comment doesn't appear to agree with the classes purpose.\nAlso where is this used?", "author": "prb112", "createdAt": "2020-10-28T12:43:10Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/CreateTempTablesAction.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.config.FHIRConfigProvider;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.api.BadTenantFrozenException;\n+import com.ibm.fhir.database.utils.api.BadTenantKeyException;\n+import com.ibm.fhir.database.utils.api.BadTenantNameException;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.JdbcTarget;\n+import com.ibm.fhir.database.utils.db2.Db2Adapter;\n+import com.ibm.fhir.database.utils.db2.Db2SetTenantVariable;\n+import com.ibm.fhir.database.utils.derby.DerbyAdapter;\n+import com.ibm.fhir.database.utils.derby.DerbyTranslator;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.derby.CreateCodeSystemsTmp;\n+import com.ibm.fhir.persistence.jdbc.derby.CreateCommonTokenValuesTmp;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+/**\n+ * Set the tenant variable in the session (part of Db2 multi-tenancy\n+ * support). This needs to be executed at the beginning of an\n+ * interaction with a database connection, before any other\n+ * DML/SQL.\n+ */", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNTE1OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513435159", "bodyText": "fixed comment. See FHIRPersistenceJDBCImpl#buildActionChain.", "author": "punktilious", "createdAt": "2020-10-28T13:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxMDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxMTM0OQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513411349", "bodyText": "Is this actually used?  It appears that this might be a longer term thing?", "author": "prb112", "createdAt": "2020-10-28T12:43:47Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/CreateTempTablesAction.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.config.FHIRConfigProvider;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.api.BadTenantFrozenException;\n+import com.ibm.fhir.database.utils.api.BadTenantKeyException;\n+import com.ibm.fhir.database.utils.api.BadTenantNameException;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.JdbcTarget;\n+import com.ibm.fhir.database.utils.db2.Db2Adapter;\n+import com.ibm.fhir.database.utils.db2.Db2SetTenantVariable;\n+import com.ibm.fhir.database.utils.derby.DerbyAdapter;\n+import com.ibm.fhir.database.utils.derby.DerbyTranslator;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.derby.CreateCodeSystemsTmp;\n+import com.ibm.fhir.persistence.jdbc.derby.CreateCommonTokenValuesTmp;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+/**\n+ * Set the tenant variable in the session (part of Db2 multi-tenancy\n+ * support). This needs to be executed at the beginning of an\n+ * interaction with a database connection, before any other\n+ * DML/SQL.\n+ */\n+public class CreateTempTablesAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetTenantAction.class.getName());\n+        \n+    /**\n+     * Public constructor. No next action, so this will be the last action applied\n+     */\n+    public CreateTempTablesAction() {\n+        super();\n+    }\n+    \n+    /**\n+     * Public constructor\n+     * @param next the next action in the chain\n+     */\n+    public CreateTempTablesAction(Action next) {\n+        super(next);\n+    }\n+\n+    @Override\n+    public void performOn(FHIRDbFlavor flavor, Connection connection) throws FHIRPersistenceDBConnectException {\n+\n+        if (flavor.getType() == DbType.DERBY) {\n+            // This is only used for Derby databases\n+            JdbcTarget target = new JdbcTarget(connection);\n+            DerbyAdapter adapter = new DerbyAdapter(target);\n+    \n+            createCodeSystemsTmp(adapter);\n+            createCommonTokenValuesTmp(adapter);\n+        }\n+        \n+        // perform next action in the chain\n+        super.performOn(flavor, connection);\n+    }\n+\n+    /**\n+     * Create the declared global temporary table COMMON_TOKEN_VALUES_TMP\n+     * @param connection\n+     * @throws FHIRPersistenceDBConnectException\n+     */\n+    public void createCommonTokenValuesTmp(DerbyAdapter adapter) throws FHIRPersistenceDBConnectException {\n+        IDatabaseStatement cmd = new CreateCommonTokenValuesTmp();\n+        adapter.runStatement(cmd);\n+    }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNTU5OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513435598", "bodyText": "yes, it's used. It fixes the stack overflow error I was getting during the pipeline builds.", "author": "punktilious", "createdAt": "2020-10-28T13:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxMTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxNjcxMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513416711", "bodyText": "Where are the unit tests? is this suppose to be abstract?", "author": "prb112", "createdAt": "2020-10-28T12:52:31Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/impl/test/ResourceReferenceDAOTest.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.impl.test;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+\n+import com.ibm.fhir.database.utils.derby.DerbyMaster;\n+import com.ibm.fhir.database.utils.derby.DerbyTranslator;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCCache;\n+import com.ibm.fhir.persistence.jdbc.cache.CommonTokenValuesCacheImpl;\n+import com.ibm.fhir.persistence.jdbc.cache.FHIRPersistenceJDBCCacheImpl;\n+import com.ibm.fhir.persistence.jdbc.cache.NameIdCache;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavorImpl;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.DerbyResourceReferenceDAO;\n+import com.ibm.fhir.schema.derby.DerbyFhirDatabase;\n+\n+/**\n+ * Unit tests for {@link ResourceReferenceDAO}\n+ */\n+public class ResourceReferenceDAOTest {", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1Mjk3MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513452971", "bodyText": "They were no longer relevant after one of my refactors. There's plenty of coverage from existing tests so I'm going to remove.", "author": "punktilious", "createdAt": "2020-10-28T13:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQxNjcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMTA3OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513421078", "bodyText": "Should this be a warning? I realize it's informational, and hasn't yet failed.", "author": "prb112", "createdAt": "2020-10-28T12:59:06Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/FHIRRestHelper.java", "diffHunk": "@@ -2669,4 +2671,31 @@ private void setOperationContextProperties(FHIROperationContext operationContext\n         operationContext.setProperty(FHIROperationContext.PROPNAME_PERSISTENCE_IMPL, persistence);\n         operationContext.setProperty(FHIROperationContext.PROPNAME_REQUEST_PROPERTIES, requestProperties);\n     }\n+\n+    @Override\n+    public int doReindex(FHIROperationContext operationContext, OperationOutcome.Builder operationOutcomeResult, Instant tstamp) throws Exception {\n+        int result = 0;\n+        // handle some retries in case of deadlock exceptions\n+        final int TX_ATTEMPTS = 5;\n+        int attempt = 1;\n+        do {\n+            FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+            txn.begin();\n+            try {\n+                FHIRPersistenceContext persistenceContext = null;\n+                result = persistence.reindex(persistenceContext, operationOutcomeResult, tstamp);\n+                attempt = TX_ATTEMPTS; // end the retry loop\n+            } catch (FHIRPersistenceDataAccessException x) {\n+                if (x.isTransactionRetryable() && attempt < TX_ATTEMPTS) {\n+                    log.info(\"attempt #\" + attempt + \" failed, retrying transaction\");", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNzUzNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513437536", "bodyText": "Warnings might be used to generate alerts, but it hasn't yet failed so I think info is fine. Also, with the new parameter persistence code, we're no longer seeing any deadlocks during reindex.", "author": "punktilious", "createdAt": "2020-10-28T13:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMTA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMTU5NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513421594", "bodyText": "Copyright Year", "author": "prb112", "createdAt": "2020-10-28T12:59:51Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/MockPersistenceImpl.java", "diffHunk": "@@ -6,6 +6,8 @@\n \n package com.ibm.fhir.persistence.test;\n \n+import java.time.Instant;", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNzk5Mg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513437992", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T13:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMjU0MA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513422540", "bodyText": "Best practice with test-ng is to use @BeforeTest and @aftertest.  it may be worth parking that in your arsernal", "author": "prb112", "createdAt": "2020-10-28T13:01:18Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/search/test/AbstractSearchDateTest.java", "diffHunk": "@@ -631,11 +635,17 @@ public void testSearchDate_date_missing() throws Exception {\n     }\n     @Test\n     public void testSearchDate_date_chained() throws Exception {\n-        // Date is specific - 2018-10-29\n-        assertSearchReturnsComposition(\"subject:Basic.date\", \"2018-10-29\");\n-        assertSearchDoesntReturnComposition(\"subject:Basic.date\", \"2018-10-29T17:12:00-04:00\");\n-        assertSearchDoesntReturnComposition(\"subject:Basic.date\", \"2018-10-29T17:12:00\");\n-        assertSearchDoesntReturnComposition(\"subject:Basic.date\", \"2025-10-29\");\n+        final String METHOD = \"testSearchDate_date_chained\";\n+        logger.entering(CLASSNAME, METHOD);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0MDA3NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513440074", "bodyText": "How does this relate to the highlighted lines?", "author": "punktilious", "createdAt": "2020-10-28T13:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMjU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNTA0Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513425046", "bodyText": "Unused todos", "author": "prb112", "createdAt": "2020-10-28T13:05:13Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockTransactionSynchronizationRegistry.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.Synchronization;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRUserTransactionAdapter;\n+\n+\n+/**\n+ * Mock implementation of {@link TransactionSynchronizationRegistry} for testing the {@link FHIRUserTransactionAdapter}\n+ */\n+public class MockTransactionSynchronizationRegistry implements TransactionSynchronizationRegistry {\n+\n+    @Override\n+    public Object getTransactionKey() {\n+        // TODO Auto-generated method stub", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0MDgyMw==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513440823", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T13:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMTAxMQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513431011", "bodyText": "is this useful?", "author": "prb112", "createdAt": "2020-10-28T13:14:04Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -436,25 +419,82 @@ public void buildDatabaseSpecificArtifactsPostgres(PhysicalDataModel model) {\n      */\n     public void addLogicalResources(PhysicalDataModel pdm) {\n         final String tableName = LOGICAL_RESOURCES;\n+        \n+        final String IDX_LOGICAL_RESOURCES_RITS = \"IDX_\" + LOGICAL_RESOURCES + \"_RITS\";\n \n         Table tbl = Table.builder(schemaName, tableName)\n                 .setTenantColumnName(MT_ID)\n                 .addBigIntColumn(LOGICAL_RESOURCE_ID, false)\n                 .addIntColumn(RESOURCE_TYPE_ID, false)\n                 .addVarcharColumn(LOGICAL_ID, LOGICAL_ID_BYTES, false)\n+                .addTimestampColumn(REINDEX_TSTAMP, false, \"CURRENT_TIMESTAMP\") // new column for V0006\n+                .addBigIntColumn(REINDEX_TXID, false, \"0\")                      // new column for V0006\n                 .addPrimaryKey(tableName + \"_PK\", LOGICAL_RESOURCE_ID)\n                 .addUniqueIndex(\"UNQ_\" + LOGICAL_RESOURCES, RESOURCE_TYPE_ID, LOGICAL_ID)\n+                .addIndex(IDX_LOGICAL_RESOURCES_RITS, new OrderedColumnDef(REINDEX_TSTAMP, OrderedColumnDef.Direction.DESC, null))\n                 .setTablespace(fhirTablespace)\n                 .addPrivileges(resourceTablePrivileges)\n                 .addForeignKeyConstraint(FK + tableName + \"_RTID\", schemaName, RESOURCE_TYPES, RESOURCE_TYPE_ID)\n                 .enableAccessControl(this.sessionVariable)\n+                .setVersion(FhirSchemaVersion.V0006.vid())\n+                .addMigration(priorVersion -> {\n+                    List<IDatabaseStatement> statements = new ArrayList<>();\n+                    if (priorVersion == FhirSchemaVersion.V0001.vid()) {\n+                        // Add statements to migrate from version V0001 to V0006 of this object\n+                        List<ColumnBase> cols = ColumnDefBuilder.builder()\n+                                .addTimestampColumn(REINDEX_TSTAMP, false, \"CURRENT_TIMESTAMP\")\n+                                .addBigIntColumn(REINDEX_TXID, false, \"0\")\n+                                .buildColumns();\n+\n+                        statements.add(new AddColumn(schemaName, tableName, cols.get(0)));\n+                        statements.add(new AddColumn(schemaName, tableName, cols.get(1)));\n+                        \n+                        // Add the new index on REINDEX_TSTAMP. This index is special because it's the\n+                        // first index in our schema to use DESC.\n+                        final String mtId = this.multitenant ? MT_ID : null;\n+                        List<OrderedColumnDef> indexCols = Arrays.asList(new OrderedColumnDef(REINDEX_TSTAMP, OrderedColumnDef.Direction.DESC, null));\n+                        statements.add(new CreateIndexStatement(schemaName, IDX_LOGICAL_RESOURCES_RITS, tableName, mtId, indexCols));\n+                    }\n+                    return statements;\n+                })\n                 .build(pdm);\n \n         // TODO should not need to add as a table and an object. Get the table to add itself?\n         tbl.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n         this.procedureDependencies.add(tbl);\n         pdm.addTable(tbl);\n         pdm.addObject(tbl);\n+        \n+        // For V0006 we also add a couple of new columns and an index to support\n+        // reindexing of resources. Note CURRENT_TIMESTAMP works for Derby, Postgres and Db2.\n+//        List<ColumnBase> cols = new ColumnDefBuilder()\n+//                .addTimestampColumn(REINDEX_TSTAMP, false, \"CURRENT_TIMESTAMP\")\n+//                .addBigIntColumn(REINDEX_TXID, false, \"0\")\n+//                .buildColumns();\n+//        AlterTableAddColumn addCols = new AlterTableAddColumn(schemaName, tableName, FhirSchemaVersion.V0006.vid(), cols);\n+//        addCols.addDependency(tbl); // table must be created before we try to alter it\n+//        pdm.addObject(addCols);\n+\n+        // Make sure we have an index on the REINDEX_TSTAMP column so that we can quickly\n+        // identify which resources need to be reindexed. For the reindex resource selection\n+        // query, it's essential that we collate the reindex_tstamp with NULLS FIRST\n+//        CreateIndex tsidx = CreateIndex.builder()\n+//                .setSchemaName(schemaName)\n+//                .setTableName(tableName)\n+//                .setTenantColumnName(MT_ID)\n+//                .setIndexName(\"IDX_\" + LOGICAL_RESOURCES + \"_RITS\")\n+//                .setVersion(FhirSchemaVersion.V0006.vid())\n+//                .addColumn(REINDEX_TSTAMP, OrderedColumnDef.Direction.DESC, null)\n+//                .build();\n+//        tsidx.addDependency(addCols);\n+//        pdm.addObject(tsidx);\n+\n+\n+        // Create a new sequence to use as a transaction id for our reindexing process\n+//        Sequence seq = new Sequence(schemaName, FhirSchemaConstants.REINDEX_SEQ, FhirSchemaVersion.V0001.vid(), 1, 100, 1);\n+//        seq.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+//        sequencePrivileges.forEach(p -> p.addToObject(seq));\n+//        pdm.addObject(seq);", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0MzQ5MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513443491", "bodyText": "Cruft left over from the alter table bug in Derby. Cleaned up.", "author": "punktilious", "createdAt": "2020-10-28T13:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMTUxOQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513431519", "bodyText": "the question made me smile... but makes sense", "author": "prb112", "createdAt": "2020-10-28T13:14:39Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -704,6 +787,94 @@ protected void addCodeSystems(PhysicalDataModel model) {\n \n     }\n \n+    /**\n+     * Table used to store normalized values for tokens, shared by all the\n+     * <RESOURCE_TYPE>_TOKEN_VALUES tables. Although this requires an additional\n+     * join, it cuts down on space by avoiding repeating long strings (e.g. urls).\n+     * This also helps to reduce the total sizes of the indexes, helping to improve\n+     * cache hit rates for a given buffer cache size.\n+     * Token values may or may not have an associated code system, in which case,\n+     * it assigned a default system. This is why CODE_SYSTEM_ID is not nullable and \n+     * has a FK constraint. \n+     * \n+     * We never need to find all token values for a given code-system, so there's no need\n+     * for a second index (CODE_SYSTEM_ID, TOKEN_VALUE). Do not add it.\n+     * \n+     * Because different parameter names may reference the same token value (e.g. \n+     * 'Observation.subject' and 'Claim.patient' are both patient references), the\n+     * common token value is not distinguished by a parameter_name_id.\n+     * \n+     * Where common token values are used to represent local relationships between two resources,\n+     * the code_system encodes the resource type of the referenced resource and\n+     * the token_value represents its logical_id. This approach simplifies query writing when\n+     * following references.\n+     * \n+     * @param pdm\n+     * @return the table definition\n+     */\n+    public void addCommonTokenValues(PhysicalDataModel pdm) {\n+        final String tableName = COMMON_TOKEN_VALUES;\n+        commonTokenValuesTable = Table.builder(schemaName, tableName)\n+                .setVersion(FhirSchemaVersion.V0006.vid())\n+                .setTenantColumnName(MT_ID)\n+                .addBigIntColumn(     COMMON_TOKEN_VALUE_ID,                          false)\n+                .setIdentityColumn(   COMMON_TOKEN_VALUE_ID, Generated.ALWAYS)\n+                .addIntColumn(               CODE_SYSTEM_ID,                          false)\n+                .addVarcharColumn(              TOKEN_VALUE, MAX_TOKEN_VALUE_BYTES,   false)\n+                .addUniqueIndex(IDX + tableName + \"_TVCP\", TOKEN_VALUE, CODE_SYSTEM_ID)\n+                .addPrimaryKey(tableName + \"_PK\", COMMON_TOKEN_VALUE_ID)\n+                .addForeignKeyConstraint(FK + tableName + \"_CSID\", schemaName, CODE_SYSTEMS, CODE_SYSTEM_ID)\n+                .setTablespace(fhirTablespace)\n+                .addPrivileges(resourceTablePrivileges)\n+                .enableAccessControl(this.sessionVariable)\n+                .build(pdm);\n+\n+        // TODO should not need to add as a table and an object. Get the table to add itself?\n+        commonTokenValuesTable.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+        pdm.addTable(commonTokenValuesTable);\n+        pdm.addObject(commonTokenValuesTable);\n+    }\n+\n+    /**\n+     * Add the system-wide RESOURCE_TOKEN_REFS table which is used for\n+     * _tag and _security search properties in R4 (new table\n+     * for issue #1366 V0006 schema change). Replaces the\n+     * previous TOKEN_VALUES table. All token values are now\n+     * normalized in the COMMON_TOKEN_VALUES table\n+     * @param pdm\n+     * @return Table the table that was added to the PhysicalDataModel\n+     */\n+    public Table addResourceTokenRefs(PhysicalDataModel pdm) {\n+\n+        final String tableName = RESOURCE_TOKEN_REFS;\n+\n+        // logical_resources (0|1) ---- (*) resource_token_refs\n+        Table tbl = Table.builder(schemaName, tableName)\n+                .setVersion(FhirSchemaVersion.V0006.vid())\n+                .setTenantColumnName(MT_ID)\n+                .addIntColumn(       PARAMETER_NAME_ID,    false)\n+                .addBigIntColumn(COMMON_TOKEN_VALUE_ID,     true) // support for null token value entries\n+                .addBigIntColumn(  LOGICAL_RESOURCE_ID,    false)\n+                .addIntColumn(          REF_VERSION_ID,     true) // for when the referenced value is a logical resource with a version\n+                .addIndex(IDX + tableName + \"_TVLR\", COMMON_TOKEN_VALUE_ID, LOGICAL_RESOURCE_ID)\n+                .addIndex(IDX + tableName + \"_LRTV\", LOGICAL_RESOURCE_ID, COMMON_TOKEN_VALUE_ID)\n+                .addForeignKeyConstraint(FK + tableName + \"_CTV\", schemaName, COMMON_TOKEN_VALUES, COMMON_TOKEN_VALUE_ID)\n+                .addForeignKeyConstraint(FK + tableName + \"_LR\", schemaName, LOGICAL_RESOURCES, LOGICAL_RESOURCE_ID)\n+                .addForeignKeyConstraint(FK + tableName + \"_PNID\", schemaName, PARAMETER_NAMES, PARAMETER_NAME_ID)\n+                .setTablespace(fhirTablespace)\n+                .addPrivileges(resourceTablePrivileges)\n+                .enableAccessControl(this.sessionVariable)\n+                .build(pdm);\n+\n+        // TODO should not need to add as a table and an object. Get the table to add itself?", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0OTk3NA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513449974", "bodyText": "Yeah, one of the things I'd like to clean up when we have some time", "author": "punktilious", "createdAt": "2020-10-28T13:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMjQ0Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513432446", "bodyText": "Is this too optimistic? What happens if the table isn't deployed?", "author": "prb112", "createdAt": "2020-10-28T13:15:57Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/derby/DerbyFhirDatabase.java", "diffHunk": "@@ -108,21 +126,18 @@ public void populateResourceTypeAndParameterNameTableEntries() throws SQLExcepti\n         try (Connection connection = getConnection()) {\n \n             // Ensures we don't double up the generated derby db prepopulation.\n-            // Docs for the table are at https://db.apache.org/derby/docs/10.5/ref/rrefsistabs24269.html\n-            boolean process = true;\n-            final String sql = \"SELECT COUNT(TABLENAME) AS CNT FROM SYS.SYSTABLES WHERE TABLENAME = 'PARAMETER_NAMES'\";\n-            try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n-                stmt.execute();\n-                ResultSet set = stmt.getResultSet();\n-                if (set.next()) {\n-                    int val = set.getInt(\"CNT\");\n-                    if (val > 0) {\n-                        process = false;\n-                    }\n+            boolean populated;\n+            final String sql = \"SELECT 1 FROM PARAMETER_NAMES FETCH FIRST 1 ROWS ONLY\";", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0NTgxMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513445810", "bodyText": "Why would the table not be deployed? This is called after the schema has been generated, so if the table doesn't exist, we have bigger issues.", "author": "punktilious", "createdAt": "2020-10-28T13:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMjQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMDAzMA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513700030", "bodyText": "I am pretty sure that's why I wrote the sys.systables query as we were hitting that occasionally when the Schema failed.", "author": "prb112", "createdAt": "2020-10-28T19:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzMjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNTg3OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513435878", "bodyText": "Copyright", "author": "prb112", "createdAt": "2020-10-28T13:20:59Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dto/TokenParmVal.java", "diffHunk": "@@ -27,6 +27,12 @@\n     public TokenParmVal() {\n         super();\n     }\n+    \n+    @Override", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0NDAxOQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513444019", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T13:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNTg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNjA0OA==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513436048", "bodyText": "Copyright", "author": "prb112", "createdAt": "2020-10-28T13:21:14Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dto/ReferenceParmVal.java", "diffHunk": "@@ -9,15 +9,26 @@\n import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n import com.ibm.fhir.search.SearchConstants.Type;\n \n+/**", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0NDU5MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513444591", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-10-28T13:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNjA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0NDczNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513444736", "bodyText": "When is this important?", "author": "prb112", "createdAt": "2020-10-28T13:32:57Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/ReindexResourceDAO.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.derby;\n+\n+\n+import java.security.SecureRandom;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCCache;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n+import com.ibm.fhir.persistence.jdbc.dao.api.IResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.JDBCIdentityCache;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceIndexRecord;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.JDBCIdentityCacheImpl;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.impl.ParameterTransactionDataImpl;\n+\n+/**\n+ * DAO used to contain the logic required to reindex a given resource\n+ */\n+public class ReindexResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(ReindexResourceDAO.class.getName());\n+    private static final String CLASSNAME = ReindexResourceDAO.class.getSimpleName();\n+    private static final SecureRandom random = new SecureRandom();\n+\n+    // The translator specific to the database type we're working with\n+    private final IDatabaseTranslator translator;\n+    \n+    private final ParameterDAO parameterDao;\n+\n+    /**\n+     * Public constructor\n+     * @param connection\n+     * @param translator\n+     * @param parameterDao\n+     * @param schemaName\n+     * @param flavor\n+     * @param cache\n+     * @param rrd\n+     */\n+    public ReindexResourceDAO(Connection connection, IDatabaseTranslator translator, ParameterDAO parameterDao, String schemaName, FHIRDbFlavor flavor, FHIRPersistenceJDBCCache cache, IResourceReferenceDAO rrd) {\n+        super(connection, schemaName, flavor, cache, rrd);\n+        this.translator = translator;\n+        this.parameterDao = parameterDao;\n+    }\n+\n+    /**\n+     * Public constructor\n+     * @param connection\n+     * @param translator\n+     * @param parameterDao\n+     * @param schemaName\n+     * @param flavor\n+     * @param trxSynchRegistry\n+     * @param cache\n+     * @param rrd\n+     */\n+    public ReindexResourceDAO(Connection connection, IDatabaseTranslator translator, ParameterDAO parameterDao, String schemaName, FHIRDbFlavor flavor, TransactionSynchronizationRegistry trxSynchRegistry, FHIRPersistenceJDBCCache cache, IResourceReferenceDAO rrd, ParameterTransactionDataImpl ptdi) {\n+        super(connection, schemaName, flavor, trxSynchRegistry, cache, rrd, ptdi);\n+        this.translator = translator;\n+        this.parameterDao = parameterDao;\n+\n+    }\n+\n+    /**\n+     * Getter for the translator currently held by this DAO\n+     * @return\n+     */\n+    protected IDatabaseTranslator getTranslator() {\n+        return this.translator;\n+    }", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0Njk5Ng==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513446996", "bodyText": "For subclasses like the Postgres and Derby specializations.", "author": "punktilious", "createdAt": "2020-10-28T13:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0NDczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0NTAwNg==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513445006", "bodyText": "why not just this.translator?", "author": "prb112", "createdAt": "2020-10-28T13:33:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/ReindexResourceDAO.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.derby;\n+\n+\n+import java.security.SecureRandom;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCCache;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n+import com.ibm.fhir.persistence.jdbc.dao.api.IResourceReferenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.JDBCIdentityCache;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceIndexRecord;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.JDBCIdentityCacheImpl;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.impl.ParameterTransactionDataImpl;\n+\n+/**\n+ * DAO used to contain the logic required to reindex a given resource\n+ */\n+public class ReindexResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(ReindexResourceDAO.class.getName());\n+    private static final String CLASSNAME = ReindexResourceDAO.class.getSimpleName();\n+    private static final SecureRandom random = new SecureRandom();\n+\n+    // The translator specific to the database type we're working with\n+    private final IDatabaseTranslator translator;\n+    \n+    private final ParameterDAO parameterDao;\n+\n+    /**\n+     * Public constructor\n+     * @param connection\n+     * @param translator\n+     * @param parameterDao\n+     * @param schemaName\n+     * @param flavor\n+     * @param cache\n+     * @param rrd\n+     */\n+    public ReindexResourceDAO(Connection connection, IDatabaseTranslator translator, ParameterDAO parameterDao, String schemaName, FHIRDbFlavor flavor, FHIRPersistenceJDBCCache cache, IResourceReferenceDAO rrd) {\n+        super(connection, schemaName, flavor, cache, rrd);\n+        this.translator = translator;\n+        this.parameterDao = parameterDao;\n+    }\n+\n+    /**\n+     * Public constructor\n+     * @param connection\n+     * @param translator\n+     * @param parameterDao\n+     * @param schemaName\n+     * @param flavor\n+     * @param trxSynchRegistry\n+     * @param cache\n+     * @param rrd\n+     */\n+    public ReindexResourceDAO(Connection connection, IDatabaseTranslator translator, ParameterDAO parameterDao, String schemaName, FHIRDbFlavor flavor, TransactionSynchronizationRegistry trxSynchRegistry, FHIRPersistenceJDBCCache cache, IResourceReferenceDAO rrd, ParameterTransactionDataImpl ptdi) {\n+        super(connection, schemaName, flavor, trxSynchRegistry, cache, rrd, ptdi);\n+        this.translator = translator;\n+        this.parameterDao = parameterDao;\n+\n+    }\n+\n+    /**\n+     * Getter for the translator currently held by this DAO\n+     * @return\n+     */\n+    protected IDatabaseTranslator getTranslator() {\n+        return this.translator;\n+    }\n+    \n+    /**\n+     * Pick the next resource to process resource and lock it. Specializations for different\n+     * databases may use different techniques to optimize locking/concurrency control\n+     * @param reindexTstamp\n+     * @return\n+     * @throws Exception\n+     */\n+    protected ResourceIndexRecord getNextResource(SecureRandom random, Instant reindexTstamp) throws Exception {\n+        ResourceIndexRecord result = null;\n+        \n+        // no need to close\n+        Connection connection = getConnection();\n+        IDatabaseTranslator translator = getTranslator();", "originalCommit": "2a7726893f06d291092861af3b1ef97e73f9a66a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0OTE0MQ==", "url": "https://github.com/IBM/FHIR/pull/1604#discussion_r513449141", "bodyText": "With some refactoring things got moved around. It doesn't hurt to hide how the translator is provided, and this aligns with how the subclasses obtain the translator.", "author": "punktilious", "createdAt": "2020-10-28T13:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0NTAwNg=="}], "type": "inlineReview"}]}