{"pr_number": 973, "pr_title": "Add NATS support for FHIR notifications", "pr_createdAt": "2020-04-22T21:05:00Z", "pr_url": "https://github.com/IBM/FHIR/pull/973", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MDMwNA==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r414850304", "bodyText": "Its funny because we literally just changed all our other keystores from JKS to PKCS12.\nCan NATS work with PKCS12 or it really needs JKS?", "author": "lmsurpre", "createdAt": "2020-04-24T20:41:07Z", "path": "fhir-notification-nats/src/main/java/com/ibm/fhir/notifications/nats/impl/FHIRNotificationNATSPublisher.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.notifications.nats.impl;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FileInputStream;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.nats.client.Connection;\n+import io.nats.client.Nats;\n+import io.nats.streaming.AckHandler;\n+import io.nats.streaming.NatsStreaming;\n+import io.nats.streaming.Options;\n+import io.nats.streaming.StreamingConnection;\n+import io.nats.streaming.StreamingConnectionFactory;\n+\n+import com.ibm.fhir.notification.FHIRNotificationEvent;\n+import com.ibm.fhir.notification.FHIRNotificationService;\n+import com.ibm.fhir.notification.FHIRNotificationSubscriber;\n+import com.ibm.fhir.notification.exception.FHIRNotificationException;\n+import com.ibm.fhir.notification.util.FHIRNotificationUtil;\n+\n+/**\n+ * This class implements the FHIR server notification service via a NATS channel.\n+ */\n+public class FHIRNotificationNATSPublisher implements FHIRNotificationSubscriber {\n+    private static final Logger log = Logger.getLogger(FHIRNotificationNATSPublisher.class.getName());\n+    private static FHIRNotificationService service = FHIRNotificationService.getInstance();\n+\n+    private StreamingConnection sc = null;\n+    private AckHandler acb = null;\n+    private String channelName = null;\n+\n+    // \"Hide\" the default constructor.\n+    protected FHIRNotificationNATSPublisher() {\n+    }\n+\n+    public FHIRNotificationNATSPublisher(String clusterId, String channelName, String clientId, String servers, Properties tlsProps) {\n+        log.entering(this.getClass().getName(), \"constructor\");\n+        try {\n+            init(clusterId, channelName, clientId, servers, tlsProps);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"constructor\");\n+        }\n+    }\n+\n+    /**\n+     * Performs any required initialization to allow us to publish events to the channel.\n+     */\n+    private void init(String clusterId, String channelName, String clientId, String servers, Properties tlsProps) {\n+        log.entering(this.getClass().getName(), \"init\");\n+\n+        SSLContext ctx = null;\n+\n+        try {\n+            this.channelName = channelName;\n+            if (log.isLoggable(Level.FINER)) {\n+                log.finer(\"ClusterId: \" + clusterId);\n+                log.finer(\"Channel name: \" + channelName);\n+                log.finer(\"ClientId: \" + clientId);\n+                log.finer(\"Servers: \" + servers);\n+            }\n+\n+            // Make sure that the properties file contains the expected properties.\n+            if (clusterId == null || channelName == null || clientId == null || servers == null || servers.length() == 0) {\n+                throw new IllegalStateException(\"Config property missing from the NATS connection properties.\");\n+            }\n+\n+            if (Boolean.parseBoolean(tlsProps.getProperty(\"useTLS\"))) {\n+                // Make sure that the tls properties are set.\n+                if (tlsProps.getProperty(\"truststore\") == null || tlsProps.getProperty(\"truststore-pw\") == null || \n+                    tlsProps.getProperty(\"keystore\") == null || tlsProps.getProperty(\"keystore-pw\") == null) {\n+                    throw new IllegalStateException(\"TLS config property missing from the NATS connection properties.\");\n+                }\n+\n+                ctx = SSLUtils.createSSLContext(tlsProps);\n+            }\n+\n+            // Create the NATS client connection options\n+            io.nats.client.Options.Builder builder = new io.nats.client.Options.Builder();\n+            builder.maxReconnects(-1);\n+            builder.connectionName(channelName);\n+            builder.servers(servers.split(\",\"));\n+            if (ctx != null) {\n+                builder.sslContext(ctx);\n+            }\n+            io.nats.client.Options natsOptions = builder.build();\n+\n+            // Create the NATS connection and the streaming connection\n+            Connection nc = Nats.connect(natsOptions);\n+            Options streamingOptions = new Options.Builder().natsConn(nc).build();\n+            sc = NatsStreaming.connect(clusterId, clientId, streamingOptions);\n+\n+            // Create the publish callback\n+            acb = new AckHandler() {\n+                @Override\n+                public void onAck(String nuid, Exception ex) {\n+                    log.finer(\"Received ACK for guid: \" + nuid);\n+                    if (ex != null && log.isLoggable(Level.SEVERE)) {\n+                        log.log(Level.SEVERE, \"Error in server ack for guid \" + nuid + \": \" + ex.getMessage(), ex);\n+                    }\n+                }\n+            };\n+\n+            // Register this NATS implementation as a \"subscriber\" with our Notification Service.\n+            // This means that our \"notify\" method will be called when the server publishes an event.\n+            service.subscribe(this);\n+            log.info(\"Initialized NATS publisher for channel '\" + channelName + \"' using servers: '\" + servers + \"'.\");\n+        } catch (Throwable t) {\n+            String msg = \"Caught exception while initializing NATS publisher.\";\n+            log.log(Level.SEVERE, msg, t);\n+            throw new IllegalStateException(msg, t);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"init\");\n+        }\n+    }\n+\n+    /**\n+     * Performs any necessary \"shutdown\" logic to disconnect from the channel.\n+     */\n+    public void shutdown() {\n+        log.entering(this.getClass().getName(), \"shutdown\");\n+\n+        try {\n+            if (log.isLoggable(Level.FINE)) {   \n+                log.fine(\"Shutting down NATS publisher for channel: '\" + channelName + \"'.\");\n+            }\n+            if (sc != null) {\n+               sc.close();\n+            }\n+        } catch (Throwable t) {\n+            String msg = \"Caught exception shutting down NATS publisher for channel: '\" + channelName + \"'.\";\n+            log.log(Level.SEVERE, msg, t);\n+            throw new IllegalStateException(msg, t);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"shutdown\");\n+        }\n+    }\n+\n+    /**\n+     * Publishes an event to NATS.\n+     */\n+    @Override\n+    public void notify(FHIRNotificationEvent event) throws FHIRNotificationException {\n+        log.entering(this.getClass().getName(), \"notify\");\n+        String jsonString = null;\n+        try {\n+            jsonString = FHIRNotificationUtil.toJsonString(event, true);\n+\n+            if (log.isLoggable(Level.FINE)) { \n+                log.fine(\"Publishing NATS notification event to channel '\" + channelName + \"',\\nmessage: '\" + jsonString + \"'.\");\n+            }\n+            \n+            sc.publish(\"FHIRNotificationEvent\", jsonString.getBytes(), acb);\n+    \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Published NATS notification event to channel '\" + channelName + \"'\");\n+            }\n+        } catch (Throwable e) {\n+            String msg = buildNotificationErrorMessage(channelName, (jsonString == null ? \"<null>\" : jsonString));\n+            log.log(Level.SEVERE, msg , e);\n+            throw new FHIRNotificationException(msg, e);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"notify\");\n+        }\n+    }\n+    \n+    /**\n+     * Builds a formatted error message to indicate a notification publication failure.\n+     */\n+    private String buildNotificationErrorMessage(String channelName, String notificationEvent) {\n+        return String.format(\"NATS publication failure; channel '%s'\\nNotification event: '%s'\\n.\", channelName, notificationEvent);\n+    }\n+}\n+\n+/* \n+* Modified from original NATS documentation @ https://docs.nats.io/developing-with-nats/security/tls\n+*\n+* This example requires certificates to be in the java keystore format (.jks).", "originalCommit": "3ac11d1c8ab4f7995acfa130570bfab6ca97212e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwNzc3NA==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r415907774", "bodyText": "The .jks keystore and truststore files we create are of type pkcs12, so I believe we could just change the name to .p12.  That should be easy enough to test.\nUpdate: tested successfully with names changed to .p12 to match the fact that they were already .p12.", "author": "ccorley", "createdAt": "2020-04-27T15:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MDMwNA=="}], "type": "inlineReview"}, {"oid": "0908735c3bb710956c9f5f2158bf8e00805fce59", "url": "https://github.com/IBM/FHIR/commit/0908735c3bb710956c9f5f2158bf8e00805fce59", "message": "parent fd44bdd39e004256cf043b71f219fb613b981491\nauthor ccorley <ccorley@us.ibm.com> 1585150915 -0500\ncommitter ccorley <ccorley@us.ibm.com> 1587571679 -0500\n\nInitial check-in\n\nfhir config update\nUpdated nats node addresses and added http for testing\n\nconfig updates\nconfig updates and minor code changes based on reviews.\n\nfurther updates based on reviews\nadd configurable clientId, update year, remove javadoc\n\nSupport TLS connections to NATS\n\nremove .empty files\n\nAdded README and nats test cluster config\n\nUpdate FHIRNotificationNATSPublisher.java\nclean-up\n\nUpdated README and NATS test config\n\nUpdate README.MD\nIncorporated review comments\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nremove .empty files\n\nUpdate FHIRNotificationNATSPublisher.java\n\nclean-up\n\nUpdated README and NATS test config\n\nUpdate README.MD\n\nIncorporated review comments\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-24T22:27:04Z", "type": "commit"}, {"oid": "1f2158c4b96680d53d9ead60dfd846affdf27642", "url": "https://github.com/IBM/FHIR/commit/1f2158c4b96680d53d9ead60dfd846affdf27642", "message": "Minor packaging tweaks to avoid an extra docker image for config\n\n1. added sample config with nats enabled and mounted it from the fhir\n\n2. modified the port-mappings and the ports being use in the default\nconfig\n\n3. added node-related stuff to .gitignore\n\nI think we could move most of this into our CI build and have a real\nautomated test...would be great!\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-04-24T22:27:05Z", "type": "forcePushed"}, {"oid": "3ba5b261d48c8cc1b899bc52374a8ab8bf41b5ad", "url": "https://github.com/IBM/FHIR/commit/3ba5b261d48c8cc1b899bc52374a8ab8bf41b5ad", "message": "Readme cleanup for github rendering\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nUpdate README.MD\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nUpdate README.MD\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nUpdate README.MD and post-test changes\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nUpdate README.MD\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nUpdate README.MD\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nRemaining changes from IBM FHIR comments\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\nPost-test updates\nSuccessful test\nSigned-off-by: ccorley <ccorley@us.ibm.com>\n\n Changes to be committed:\n\tmodified:   fhir-notification-nats/pom.xml\n\tmodified:   fhir-notification-nats/src/main/java/com/ibm/fhir/notifications/nats/impl/FHIRNotificationNATSPublisher.java\n\tmodified:   fhir-server-test/src/test/resources/nats/docker-compose.yml\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-27T16:09:27Z", "type": "commit"}, {"oid": "0997fdf62cc7233a5abf0d765d27f7d5bb40ef9c", "url": "https://github.com/IBM/FHIR/commit/0997fdf62cc7233a5abf0d765d27f7d5bb40ef9c", "message": "Removed http port from server.xml\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-27T16:09:52Z", "type": "commit"}, {"oid": "b33b1f53c554ac6a72a4b5e4032c022bcbf603a6", "url": "https://github.com/IBM/FHIR/commit/b33b1f53c554ac6a72a4b5e4032c022bcbf603a6", "message": "Support for IBM FHIR 4.1.1\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-27T16:09:52Z", "type": "commit"}, {"oid": "feeaf13312b4fa53707a8547943d8cad1ff08c0a", "url": "https://github.com/IBM/FHIR/commit/feeaf13312b4fa53707a8547943d8cad1ff08c0a", "message": "Minor packaging tweaks to avoid an extra docker image for config\n\n1. added sample config with nats enabled and mounted it from the fhir\n\n2. modified the port-mappings and the ports being use in the default\nconfig\n\n3. added node-related stuff to .gitignore\n\nI think we could move most of this into our CI build and have a real\nautomated test...would be great!\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-04-27T16:09:52Z", "type": "commit"}, {"oid": "007e5e730f9c00dee431ba1185e6a07b886870c4", "url": "https://github.com/IBM/FHIR/commit/007e5e730f9c00dee431ba1185e6a07b886870c4", "message": "Move the nats test env into the fhir-server e2e test infra\n\nWith these changes, `build/pre-integration-test-docker.sh` will launch\nthe nats cluster in addition to db2 and fhir and all create/update\ninteractions will get published to nats.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-04-27T16:09:52Z", "type": "commit"}, {"oid": "007e5e730f9c00dee431ba1185e6a07b886870c4", "url": "https://github.com/IBM/FHIR/commit/007e5e730f9c00dee431ba1185e6a07b886870c4", "message": "Move the nats test env into the fhir-server e2e test infra\n\nWith these changes, `build/pre-integration-test-docker.sh` will launch\nthe nats cluster in addition to db2 and fhir and all create/update\ninteractions will get published to nats.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-04-27T16:09:52Z", "type": "forcePushed"}, {"oid": "f9354170d201426360027bbc15e1272d12083198", "url": "https://github.com/IBM/FHIR/commit/f9354170d201426360027bbc15e1272d12083198", "message": "Updated docs and readmes\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-28T16:05:18Z", "type": "commit"}, {"oid": "0dab06d2680876bcbaf6cd6255d687d7d1775965", "url": "https://github.com/IBM/FHIR/commit/0dab06d2680876bcbaf6cd6255d687d7d1775965", "message": "Added FHIR trademark statement to nats readme\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-28T16:05:18Z", "type": "commit"}, {"oid": "a499351b581facfea98a72060ee25d3f4eb7c7a6", "url": "https://github.com/IBM/FHIR/commit/a499351b581facfea98a72060ee25d3f4eb7c7a6", "message": "Changed method comment\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-28T16:05:18Z", "type": "commit"}, {"oid": "a499351b581facfea98a72060ee25d3f4eb7c7a6", "url": "https://github.com/IBM/FHIR/commit/a499351b581facfea98a72060ee25d3f4eb7c7a6", "message": "Changed method comment\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-28T16:05:18Z", "type": "forcePushed"}, {"oid": "4d1f4c39f94ab7611db08b6066ac6e3478467163", "url": "https://github.com/IBM/FHIR/commit/4d1f4c39f94ab7611db08b6066ac6e3478467163", "message": "Updated readme\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-29T15:30:45Z", "type": "commit"}, {"oid": "992e435f41ba7420b8690a5923f4134f97fff9cc", "url": "https://github.com/IBM/FHIR/commit/992e435f41ba7420b8690a5923f4134f97fff9cc", "message": "Updated readme\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-29T15:36:55Z", "type": "commit"}, {"oid": "e77e2e0a94104bd8981e310389c4a0b0bc78e1ed", "url": "https://github.com/IBM/FHIR/commit/e77e2e0a94104bd8981e310389c4a0b0bc78e1ed", "message": "Updated nats ports\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-29T16:22:25Z", "type": "commit"}, {"oid": "c92e53445c2617136719db59ce7ef9b69f2307bb", "url": "https://github.com/IBM/FHIR/commit/c92e53445c2617136719db59ce7ef9b69f2307bb", "message": "Merge branch 'nats-tls2' of https://github.com/ccorley/FHIR into nats-tls2\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-29T16:23:31Z", "type": "commit"}, {"oid": "5e68d4ba6aa17f74dc2c5172686aeff8597e2fc1", "url": "https://github.com/IBM/FHIR/commit/5e68d4ba6aa17f74dc2c5172686aeff8597e2fc1", "message": "Updated nats ports\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-29T16:25:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1Mjg0NQ==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r417452845", "bodyText": "this is system specific and not tenant specific.  Best to change the docs to reflect that.\nI also suggest using a seamless naming convention, truststore-pw and truststore_pwd are different names.", "author": "prb112", "createdAt": "2020-04-29T16:34:50Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/listener/FHIRServletContextListener.java", "diffHunk": "@@ -127,6 +142,32 @@ public void contextInitialized(ServletContextEvent event) {\n                 log.info(\"Bypassing Kafka notification init.\");\n             }\n \n+            // If NATS notifications are enabled, start up our NATS notification publisher.\n+            Boolean natsEnabled = fhirConfig.getBooleanProperty(PROPERTY_NATS_ENABLED, Boolean.FALSE);\n+            if (natsEnabled) {\n+                // Retrieve the cluster ID.\n+                String clusterId = fhirConfig.getStringProperty(PROPERTY_NATS_CLUSTER, DEFAULT_NATS_CLUSTER);\n+                // Retrieve the channel name.\n+                String channelName = fhirConfig.getStringProperty(PROPERTY_NATS_CHANNEL, DEFAULT_NATS_CHANNEL);\n+                // Retrieve the NATS client ID.\n+                String clientId = fhirConfig.getStringProperty(PROPERTY_NATS_CLIENT, DEFAULT_NATS_CLIENT);\n+                // Retrieve the server URL.\n+                String servers = fhirConfig.getStringProperty(PROPERTY_NATS_SERVERS);\n+\n+                // Gather up the NATS TLS properties.\n+                Properties tlsProps = new Properties();\n+                tlsProps.setProperty(\"useTLS\", fhirConfig.getBooleanProperty(PROPERTY_NATS_TLS_ENABLED).toString());\n+                tlsProps.setProperty(\"truststore\", fhirConfig.getStringProperty(PROPERTY_NATS_TRUSTSTORE));\n+                tlsProps.setProperty(\"truststore-pw\", fhirConfig.getStringProperty(PROPERTY_NATS_TRUSTSTORE_PW));\n+                tlsProps.setProperty(\"keystore\", fhirConfig.getStringProperty(PROPERTY_NATS_KEYSTORE));\n+                tlsProps.setProperty(\"keystore-pw\", fhirConfig.getStringProperty(PROPERTY_NATS_KEYSTORE_PW));", "originalCommit": "4d1f4c39f94ab7611db08b6066ac6e3478467163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4ODcxNg==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r417988716", "bodyText": "docs are updated.  naming can be addressed at some future date if needed.", "author": "lmsurpre", "createdAt": "2020-04-30T12:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1Mjg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzQwMQ==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r417453401", "bodyText": "break this out, or put in a nested class.\nThis breaks some static source code analysis tools.\nThe Extension doesn't make sense to me here.\nThe best step is just to make this private methods in the class.", "author": "prb112", "createdAt": "2020-04-29T16:35:45Z", "path": "fhir-notification-nats/src/main/java/com/ibm/fhir/notifications/nats/impl/FHIRNotificationNATSPublisher.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.notifications.nats.impl;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FileInputStream;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.nats.client.Connection;\n+import io.nats.client.Nats;\n+import io.nats.streaming.AckHandler;\n+import io.nats.streaming.NatsStreaming;\n+import io.nats.streaming.Options;\n+import io.nats.streaming.StreamingConnection;\n+import io.nats.streaming.StreamingConnectionFactory;\n+\n+import com.ibm.fhir.notification.FHIRNotificationEvent;\n+import com.ibm.fhir.notification.FHIRNotificationService;\n+import com.ibm.fhir.notification.FHIRNotificationSubscriber;\n+import com.ibm.fhir.notification.exception.FHIRNotificationException;\n+import com.ibm.fhir.notification.util.FHIRNotificationUtil;\n+\n+/**\n+ * This class implements the FHIR server notification service via a NATS channel.\n+ */\n+public class FHIRNotificationNATSPublisher implements FHIRNotificationSubscriber {\n+    private static final Logger log = Logger.getLogger(FHIRNotificationNATSPublisher.class.getName());\n+    private static FHIRNotificationService service = FHIRNotificationService.getInstance();\n+\n+    private StreamingConnection sc = null;\n+    private AckHandler acb = null;\n+    private String channelName = null;\n+\n+    // \"Hide\" the default constructor.\n+    protected FHIRNotificationNATSPublisher() {\n+    }\n+\n+    public FHIRNotificationNATSPublisher(String clusterId, String channelName, String clientId, String servers, Properties tlsProps) {\n+        log.entering(this.getClass().getName(), \"constructor\");\n+        try {\n+            init(clusterId, channelName, clientId, servers, tlsProps);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"constructor\");\n+        }\n+    }\n+\n+    /**\n+     * Performs any required initialization to allow us to publish events to the channel.\n+     */\n+    private void init(String clusterId, String channelName, String clientId, String servers, Properties tlsProps) {\n+        log.entering(this.getClass().getName(), \"init\");\n+\n+        SSLContext ctx = null;\n+\n+        try {\n+            this.channelName = channelName;\n+            if (log.isLoggable(Level.FINER)) {\n+                log.finer(\"ClusterId: \" + clusterId);\n+                log.finer(\"Channel name: \" + channelName);\n+                log.finer(\"ClientId: \" + clientId);\n+                log.finer(\"Servers: \" + servers);\n+            }\n+\n+            // Make sure that the properties file contains the expected properties.\n+            if (clusterId == null || channelName == null || clientId == null || servers == null || servers.length() == 0) {\n+                throw new IllegalStateException(\"Config property missing from the NATS connection properties.\");\n+            }\n+\n+            if (Boolean.parseBoolean(tlsProps.getProperty(\"useTLS\"))) {\n+                // Make sure that the tls properties are set.\n+                if (tlsProps.getProperty(\"truststore\") == null || tlsProps.getProperty(\"truststore-pw\") == null || \n+                    tlsProps.getProperty(\"keystore\") == null || tlsProps.getProperty(\"keystore-pw\") == null) {\n+                    throw new IllegalStateException(\"TLS config property missing from the NATS connection properties.\");\n+                }\n+\n+                ctx = SSLUtils.createSSLContext(tlsProps);\n+            }\n+\n+            // Create the NATS client connection options\n+            io.nats.client.Options.Builder builder = new io.nats.client.Options.Builder();\n+            builder.maxReconnects(-1);\n+            builder.connectionName(channelName);\n+            builder.servers(servers.split(\",\"));\n+            if (ctx != null) {\n+                builder.sslContext(ctx);\n+            }\n+            io.nats.client.Options natsOptions = builder.build();\n+\n+            // Create the NATS connection and the streaming connection\n+            Connection nc = Nats.connect(natsOptions);\n+            Options streamingOptions = new Options.Builder().natsConn(nc).build();\n+            sc = NatsStreaming.connect(clusterId, clientId, streamingOptions);\n+\n+            // Create the publish callback\n+            acb = new AckHandler() {\n+                @Override\n+                public void onAck(String nuid, Exception ex) {\n+                    log.finer(\"Received ACK for guid: \" + nuid);\n+                    if (ex != null && log.isLoggable(Level.SEVERE)) {\n+                        log.log(Level.SEVERE, \"Error in server ack for guid \" + nuid + \": \" + ex.getMessage(), ex);\n+                    }\n+                }\n+            };\n+\n+            // Register this NATS implementation as a \"subscriber\" with our Notification Service.\n+            // This means that our \"notify\" method will be called when the server publishes an event.\n+            service.subscribe(this);\n+            log.info(\"Initialized NATS publisher for channel '\" + channelName + \"' using servers: '\" + servers + \"'.\");\n+        } catch (Throwable t) {\n+            String msg = \"Caught exception while initializing NATS publisher.\";\n+            log.log(Level.SEVERE, msg, t);\n+            throw new IllegalStateException(msg, t);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"init\");\n+        }\n+    }\n+\n+    /**\n+     * Performs any necessary \"shutdown\" logic to disconnect from the channel.\n+     */\n+    public void shutdown() {\n+        log.entering(this.getClass().getName(), \"shutdown\");\n+\n+        try {\n+            if (log.isLoggable(Level.FINE)) {   \n+                log.fine(\"Shutting down NATS publisher for channel: '\" + channelName + \"'.\");\n+            }\n+            if (sc != null) {\n+               sc.close();\n+            }\n+        } catch (Throwable t) {\n+            String msg = \"Caught exception shutting down NATS publisher for channel: '\" + channelName + \"'.\";\n+            log.log(Level.SEVERE, msg, t);\n+            throw new IllegalStateException(msg, t);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"shutdown\");\n+        }\n+    }\n+\n+    /**\n+     * Publishes an event to NATS.\n+     */\n+    @Override\n+    public void notify(FHIRNotificationEvent event) throws FHIRNotificationException {\n+        log.entering(this.getClass().getName(), \"notify\");\n+        String jsonString = null;\n+        try {\n+            jsonString = FHIRNotificationUtil.toJsonString(event, true);\n+\n+            if (log.isLoggable(Level.FINE)) { \n+                log.fine(\"Publishing NATS notification event to channel '\" + channelName + \"',\\nmessage: '\" + jsonString + \"'.\");\n+            }\n+            \n+            sc.publish(\"FHIRNotificationEvent\", jsonString.getBytes(), acb);\n+    \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Published NATS notification event to channel '\" + channelName + \"'\");\n+            }\n+        } catch (Throwable e) {\n+            String msg = buildNotificationErrorMessage(channelName, (jsonString == null ? \"<null>\" : jsonString));\n+            log.log(Level.SEVERE, msg , e);\n+            throw new FHIRNotificationException(msg, e);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"notify\");\n+        }\n+    }\n+    \n+    /**\n+     * Builds a formatted error message to indicate a notification publication failure.\n+     */\n+    private String buildNotificationErrorMessage(String channelName, String notificationEvent) {\n+        return String.format(\"NATS publication failure; channel '%s'\\nNotification event: '%s'\\n.\", channelName, notificationEvent);\n+    }\n+}\n+\n+/* \n+* Modified from original NATS documentation @ https://docs.nats.io/developing-with-nats/security/tls\n+*\n+* openssl is used to generate a pkcs12 file (.p12) from client-cert.pem and client-key.pem.\n+* The resulting file is then imported into a java keystore using keytool which is part of java jdk.\n+* keytool is also used to import the CA certificate rootCA.pem into the truststore.  \n+*/\n+class SSLUtils extends FHIRNotificationNATSPublisher {", "originalCommit": "4d1f4c39f94ab7611db08b6066ac6e3478467163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4OTMyNQ==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r417989325", "bodyText": "Paul mentioned this one was addressed.", "author": "lmsurpre", "createdAt": "2020-04-30T12:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzQwMQ=="}], "type": "inlineReview"}, {"oid": "5e90e9995f2bc3230fecbef9d91dc84d702750de", "url": "https://github.com/IBM/FHIR/commit/5e90e9995f2bc3230fecbef9d91dc84d702750de", "message": "Apply suggestions from code review\r\n\r\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <paul@bastide.org>", "committedDate": "2020-04-29T16:57:58Z", "type": "commit"}, {"oid": "0a3589942bda0c7d9dafa158ee01f7cb0970ccf4", "url": "https://github.com/IBM/FHIR/commit/0a3589942bda0c7d9dafa158ee01f7cb0970ccf4", "message": "More edits based on code review\n\nDocumentation edits and style changes to nats-subscriber.js\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-04-29T18:52:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3NjM3MA==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r417576370", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n                /*\n          \n          \n            \n                 * Modified from original NATS documentation @ https://docs.nats.io/developing-with-nats/security/tls\n          \n          \n            \n                 * openssl is used to generate a pkcs12 file (.p12) from client-cert.pem and client-key.pem.\n          \n          \n            \n                 * The resulting file is then imported into a java keystore using keytool which is part of java jdk.\n          \n          \n            \n                 * keytool is also used to import the CA certificate rootCA.pem into the truststore.\n          \n          \n            \n                 */\n          \n          \n            \n                private static KeyStore loadKeystore(String path, String password) throws Exception {\n          \n          \n            \n                    KeyStore store = KeyStore.getInstance(\"PKCS12\");\n          \n          \n            \n                    try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(path));) {\n          \n          \n            \n                        store.load(in, password.toCharArray());\n          \n          \n            \n                    }\n          \n          \n            \n                    return store;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static KeyManager[] createKeyManagers(Properties tlsProps) throws Exception {\n          \n          \n            \n                    KeyStore store = loadKeystore(tlsProps.getProperty(\"keystore\"), tlsProps.getProperty(\"keystore-pw\"));\n          \n          \n            \n                    KeyManagerFactory factory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n          \n          \n            \n                    factory.init(store, tlsProps.getProperty(\"keystore-pw\").toCharArray());\n          \n          \n            \n                    return factory.getKeyManagers();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static TrustManager[] createTrustManagers(Properties tlsProps) throws Exception {\n          \n          \n            \n                    KeyStore store = loadKeystore(tlsProps.getProperty(\"truststore\"), tlsProps.getProperty(\"truststore-pw\"));\n          \n          \n            \n                    TrustManagerFactory factory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n          \n          \n            \n                    factory.init(store);\n          \n          \n            \n                    return factory.getTrustManagers();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static SSLContext createSSLContext(Properties tlsProps) throws Exception {\n          \n          \n            \n                    SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n          \n          \n            \n                    ctx.init(createKeyManagers(tlsProps), createTrustManagers(tlsProps), new SecureRandom());\n          \n          \n            \n                    return ctx;\n          \n          \n            \n                }\n          \n          \n            \n            }", "author": "prb112", "createdAt": "2020-04-29T20:01:09Z", "path": "fhir-notification-nats/src/main/java/com/ibm/fhir/notifications/nats/impl/FHIRNotificationNATSPublisher.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.notifications.nats.impl;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FileInputStream;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.nats.client.Connection;\n+import io.nats.client.Nats;\n+import io.nats.streaming.AckHandler;\n+import io.nats.streaming.NatsStreaming;\n+import io.nats.streaming.Options;\n+import io.nats.streaming.StreamingConnection;\n+import io.nats.streaming.StreamingConnectionFactory;\n+\n+import com.ibm.fhir.notification.FHIRNotificationEvent;\n+import com.ibm.fhir.notification.FHIRNotificationService;\n+import com.ibm.fhir.notification.FHIRNotificationSubscriber;\n+import com.ibm.fhir.notification.exception.FHIRNotificationException;\n+import com.ibm.fhir.notification.util.FHIRNotificationUtil;\n+\n+/**\n+ * This class implements the FHIR server notification service via a NATS channel.\n+ */\n+public class FHIRNotificationNATSPublisher implements FHIRNotificationSubscriber {\n+    private static final Logger log = Logger.getLogger(FHIRNotificationNATSPublisher.class.getName());\n+    private static FHIRNotificationService service = FHIRNotificationService.getInstance();\n+\n+    private StreamingConnection sc = null;\n+    private AckHandler acb = null;\n+    private String channelName = null;\n+\n+    // \"Hide\" the default constructor.\n+    protected FHIRNotificationNATSPublisher() {\n+    }\n+\n+    public FHIRNotificationNATSPublisher(String clusterId, String channelName, String clientId, String servers, Properties tlsProps) {\n+        log.entering(this.getClass().getName(), \"constructor\");\n+        try {\n+            init(clusterId, channelName, clientId, servers, tlsProps);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"constructor\");\n+        }\n+    }\n+\n+    /**\n+     * Performs any required initialization to allow us to publish events to the channel.\n+     */\n+    private void init(String clusterId, String channelName, String clientId, String servers, Properties tlsProps) {\n+        log.entering(this.getClass().getName(), \"init\");\n+\n+        SSLContext ctx = null;\n+\n+        try {\n+            this.channelName = channelName;\n+            if (log.isLoggable(Level.FINER)) {\n+                log.finer(\"ClusterId: \" + clusterId);\n+                log.finer(\"Channel name: \" + channelName);\n+                log.finer(\"ClientId: \" + clientId);\n+                log.finer(\"Servers: \" + servers);\n+            }\n+\n+            // Make sure that the properties file contains the expected properties.\n+            if (clusterId == null || channelName == null || clientId == null || servers == null || servers.length() == 0) {\n+                throw new IllegalStateException(\"Config property missing from the NATS connection properties.\");\n+            }\n+\n+            if (Boolean.parseBoolean(tlsProps.getProperty(\"useTLS\"))) {\n+                // Make sure that the tls properties are set.\n+                if (tlsProps.getProperty(\"truststore\") == null || tlsProps.getProperty(\"truststore-pw\") == null || \n+                    tlsProps.getProperty(\"keystore\") == null || tlsProps.getProperty(\"keystore-pw\") == null) {\n+                    throw new IllegalStateException(\"TLS config property missing from the NATS connection properties.\");\n+                }\n+\n+                ctx = SSLUtils.createSSLContext(tlsProps);\n+            }\n+\n+            // Create the NATS client connection options\n+            io.nats.client.Options.Builder builder = new io.nats.client.Options.Builder();\n+            builder.maxReconnects(-1);\n+            builder.connectionName(channelName);\n+            builder.servers(servers.split(\",\"));\n+            if (ctx != null) {\n+                builder.sslContext(ctx);\n+            }\n+            io.nats.client.Options natsOptions = builder.build();\n+\n+            // Create the NATS connection and the streaming connection\n+            Connection nc = Nats.connect(natsOptions);\n+            Options streamingOptions = new Options.Builder().natsConn(nc).build();\n+            sc = NatsStreaming.connect(clusterId, clientId, streamingOptions);\n+\n+            // Create the publish callback\n+            acb = new AckHandler() {\n+                @Override\n+                public void onAck(String nuid, Exception ex) {\n+                    log.finer(\"Received ACK for guid: \" + nuid);\n+                    if (ex != null && log.isLoggable(Level.SEVERE)) {\n+                        log.log(Level.SEVERE, \"Error in server ack for guid \" + nuid + \": \" + ex.getMessage(), ex);\n+                    }\n+                }\n+            };\n+\n+            // Register this NATS implementation as a \"subscriber\" with our Notification Service.\n+            // This means that our \"notify\" method will be called when the server publishes an event.\n+            service.subscribe(this);\n+            log.info(\"Initialized NATS publisher for channel '\" + channelName + \"' using servers: '\" + servers + \"'.\");\n+        } catch (Throwable t) {\n+            String msg = \"Caught exception while initializing NATS publisher.\";\n+            log.log(Level.SEVERE, msg, t);\n+            throw new IllegalStateException(msg, t);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"init\");\n+        }\n+    }\n+\n+    /**\n+     * Performs any necessary \"shutdown\" logic to disconnect from the channel.\n+     */\n+    public void shutdown() {\n+        log.entering(this.getClass().getName(), \"shutdown\");\n+\n+        try {\n+            if (log.isLoggable(Level.FINE)) {   \n+                log.fine(\"Shutting down NATS publisher for channel: '\" + channelName + \"'.\");\n+            }\n+            if (sc != null) {\n+               sc.close();\n+            }\n+        } catch (Throwable t) {\n+            String msg = \"Caught exception shutting down NATS publisher for channel: '\" + channelName + \"'.\";\n+            log.log(Level.SEVERE, msg, t);\n+            throw new IllegalStateException(msg, t);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"shutdown\");\n+        }\n+    }\n+\n+    /**\n+     * Publishes an event to NATS.\n+     */\n+    @Override\n+    public void notify(FHIRNotificationEvent event) throws FHIRNotificationException {\n+        log.entering(this.getClass().getName(), \"notify\");\n+        String jsonString = null;\n+        try {\n+            jsonString = FHIRNotificationUtil.toJsonString(event, true);\n+\n+            if (log.isLoggable(Level.FINE)) { \n+                log.fine(\"Publishing NATS notification event to channel '\" + channelName + \"',\\nmessage: '\" + jsonString + \"'.\");\n+            }\n+            \n+            sc.publish(\"FHIRNotificationEvent\", jsonString.getBytes(), acb);\n+    \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Published NATS notification event to channel '\" + channelName + \"'\");\n+            }\n+        } catch (Throwable e) {\n+            String msg = buildNotificationErrorMessage(channelName, (jsonString == null ? \"<null>\" : jsonString));\n+            log.log(Level.SEVERE, msg , e);\n+            throw new FHIRNotificationException(msg, e);\n+        } finally {\n+            log.exiting(this.getClass().getName(), \"notify\");\n+        }\n+    }\n+    \n+    /**\n+     * Builds a formatted error message to indicate a notification publication failure.\n+     */\n+    private String buildNotificationErrorMessage(String channelName, String notificationEvent) {\n+        return String.format(\"NATS publication failure; channel '%s'\\nNotification event: '%s'\\n.\", channelName, notificationEvent);\n+    }\n+}", "originalCommit": "4d1f4c39f94ab7611db08b6066ac6e3478467163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3NjY5Nw==", "url": "https://github.com/IBM/FHIR/pull/973#discussion_r417576697", "bodyText": "I tried doing a wider edit, but ran into github comments issues.  apologies for deleting another one.\nThis should address my concerns.", "author": "prb112", "createdAt": "2020-04-29T20:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3NjM3MA=="}], "type": "inlineReview"}, {"oid": "6a479c35f79794819930af18d9bb5cba8c9ad18c", "url": "https://github.com/IBM/FHIR/commit/6a479c35f79794819930af18d9bb5cba8c9ad18c", "message": "Update fhir-notification-nats/src/main/java/com/ibm/fhir/notifications/nats/impl/FHIRNotificationNATSPublisher.java\n\nCo-Authored-By: Paul Bastide <paul@bastide.org>\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-30T12:16:02Z", "type": "commit"}, {"oid": "5f163919f688252b1cf29a0a72d7c22330fe8e41", "url": "https://github.com/IBM/FHIR/commit/5f163919f688252b1cf29a0a72d7c22330fe8e41", "message": "Update fhir-notification-nats/README.MD\n\nCo-Authored-By: Paul Bastide <paul@bastide.org>\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-30T12:16:02Z", "type": "commit"}, {"oid": "267e0ec98d8877fe33ac16106e45a5922d24e389", "url": "https://github.com/IBM/FHIR/commit/267e0ec98d8877fe33ac16106e45a5922d24e389", "message": "Updated var names\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-30T12:16:02Z", "type": "commit"}, {"oid": "267e0ec98d8877fe33ac16106e45a5922d24e389", "url": "https://github.com/IBM/FHIR/commit/267e0ec98d8877fe33ac16106e45a5922d24e389", "message": "Updated var names\n\nSigned-off-by: ccorley <ccorley@us.ibm.com>", "committedDate": "2020-04-30T12:16:02Z", "type": "forcePushed"}]}