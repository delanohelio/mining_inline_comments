{"pr_number": 1267, "pr_title": "Issue 1144", "pr_createdAt": "2020-06-22T22:31:31Z", "pr_url": "https://github.com/IBM/FHIR/pull/1267", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NzU3MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446977570", "bodyText": "Fix the copyright at the top of the file", "author": "prb112", "createdAt": "2020-06-29T13:38:00Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/pool/PoolConnectionProvider.java", "diffHunk": "@@ -275,4 +275,21 @@ public void describe(String prefix, StringBuilder cfg, String key) {\n     public int getPoolSize() {\n         return this.maxPoolSize;\n     }\n+\n+    /**\n+     * The caller is telling us they no longer need to use the pool so we can free\n+     * any internal resources. This also let's us check for anything currently\n+     * in-use that shouldn't be\n+     * @throws IllegalStateException if there are open connections or a transaction\n+     *         is active.\n+     */\n+    public void close() {\n+        if (activeConnection.get() != null) {\n+            throw new IllegalStateException(\"transaction still active\");\n+        }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0NzYyNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447747626", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T14:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NzU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3OTgyOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446979829", "bodyText": "what's the behavior for default?", "author": "prb112", "createdAt": "2020-06-29T13:41:06Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -7,77 +7,71 @@\n package com.ibm.fhir.persistence.jdbc;\n \n import java.sql.Connection;\n-import java.sql.SQLException;\n \n import javax.transaction.TransactionSynchronizationRegistry;\n \n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n \n+/**\n+ * Factory for constructing ResourceDAO implementations specific to a\n+ * particular {@link FHIRDbFlavor}.\n+ */\n public class FHIRResourceDAOFactory {\n \n-    // The various DAO Types that are used in the JDBC Persistence layer.\n-    public enum FHIRResourceDAOType {\n-        DB2(\"jdbc:db2:\"),\n-        DERBY(\"derby\"),\n-        POSTGRESQL(\"jdbc:postgresql:\");\n-\n-        private final String value;\n-\n-        FHIRResourceDAOType(String value) {\n-            this.value = value;\n-        }\n-\n-        public String value() {\n-            return value;\n-        }\n-\n-        public static FHIRResourceDAOType of(Connection conn) throws SQLException, IllegalArgumentException {\n-            String dbUrl = conn.getMetaData().getURL();\n-            dbUrl = dbUrl.toLowerCase();\n-            if (dbUrl.contains(DB2.value)) {\n-                return DB2;\n-            } else if (dbUrl.contains(DERBY.value)) {\n-                return DERBY;\n-            } else if (dbUrl.contains(POSTGRESQL.value)) {\n-                return POSTGRESQL;\n-            } else {\n-                throw new IllegalArgumentException(dbUrl);\n-            }\n-\n-        }\n-    }\n-\n-   public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+    /**\n+     * Construct a new ResourceDAO implementation matching the database type\n+     * @param connection valid connection to the database\n+     * @param schemaName the name of the schema containing the FHIR resource tables\n+     * @param flavor the type and capability of the database and schema\n+     * @param trxSynchRegistry\n+     * @return a concrete implementation of {@link ResourceDAO}\n+     * @throws IllegalArgumentException\n+     * @throws FHIRPersistenceException\n+     */\n+    public static ResourceDAO getResourceDAO(Connection connection, String schemaName, FHIRDbFlavor flavor, TransactionSynchronizationRegistry trxSynchRegistry)\n+        throws IllegalArgumentException, FHIRPersistenceException {\n         ResourceDAO resourceDAO = null;\n-        switch (FHIRResourceDAOType.of(conn)) {\n-            case DB2:\n-                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n-                break;\n-            case DERBY:\n-                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n-                break;\n-            case POSTGRESQL:\n-                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n-                break;\n+        \n+        switch (flavor.getType()) {\n+        case DB2:\n+            resourceDAO = new ResourceDAOImpl(connection, schemaName, flavor, trxSynchRegistry);\n+            break;\n+        case DERBY:\n+            resourceDAO = new DerbyResourceDAO(connection, schemaName, flavor, trxSynchRegistry);\n+            break;\n+        case POSTGRESQL:\n+            resourceDAO = new PostgreSqlResourceDAO(connection, schemaName, flavor, trxSynchRegistry);\n+            break;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0OTM2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447749363", "bodyText": "default not required because all the cases of the enum are covered.", "author": "punktilious", "createdAt": "2020-06-30T14:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3OTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MDYwMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446980600", "bodyText": "default behavior?\nps. seems very duplicate of prior method?", "author": "prb112", "createdAt": "2020-06-29T13:42:08Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -7,77 +7,71 @@\n package com.ibm.fhir.persistence.jdbc;\n \n import java.sql.Connection;\n-import java.sql.SQLException;\n \n import javax.transaction.TransactionSynchronizationRegistry;\n \n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n \n+/**\n+ * Factory for constructing ResourceDAO implementations specific to a\n+ * particular {@link FHIRDbFlavor}.\n+ */\n public class FHIRResourceDAOFactory {\n \n-    // The various DAO Types that are used in the JDBC Persistence layer.\n-    public enum FHIRResourceDAOType {\n-        DB2(\"jdbc:db2:\"),\n-        DERBY(\"derby\"),\n-        POSTGRESQL(\"jdbc:postgresql:\");\n-\n-        private final String value;\n-\n-        FHIRResourceDAOType(String value) {\n-            this.value = value;\n-        }\n-\n-        public String value() {\n-            return value;\n-        }\n-\n-        public static FHIRResourceDAOType of(Connection conn) throws SQLException, IllegalArgumentException {\n-            String dbUrl = conn.getMetaData().getURL();\n-            dbUrl = dbUrl.toLowerCase();\n-            if (dbUrl.contains(DB2.value)) {\n-                return DB2;\n-            } else if (dbUrl.contains(DERBY.value)) {\n-                return DERBY;\n-            } else if (dbUrl.contains(POSTGRESQL.value)) {\n-                return POSTGRESQL;\n-            } else {\n-                throw new IllegalArgumentException(dbUrl);\n-            }\n-\n-        }\n-    }\n-\n-   public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+    /**\n+     * Construct a new ResourceDAO implementation matching the database type\n+     * @param connection valid connection to the database\n+     * @param schemaName the name of the schema containing the FHIR resource tables\n+     * @param flavor the type and capability of the database and schema\n+     * @param trxSynchRegistry\n+     * @return a concrete implementation of {@link ResourceDAO}\n+     * @throws IllegalArgumentException\n+     * @throws FHIRPersistenceException\n+     */\n+    public static ResourceDAO getResourceDAO(Connection connection, String schemaName, FHIRDbFlavor flavor, TransactionSynchronizationRegistry trxSynchRegistry)\n+        throws IllegalArgumentException, FHIRPersistenceException {\n         ResourceDAO resourceDAO = null;\n-        switch (FHIRResourceDAOType.of(conn)) {\n-            case DB2:\n-                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n-                break;\n-            case DERBY:\n-                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n-                break;\n-            case POSTGRESQL:\n-                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n-                break;\n+        \n+        switch (flavor.getType()) {\n+        case DB2:\n+            resourceDAO = new ResourceDAOImpl(connection, schemaName, flavor, trxSynchRegistry);\n+            break;\n+        case DERBY:\n+            resourceDAO = new DerbyResourceDAO(connection, schemaName, flavor, trxSynchRegistry);\n+            break;\n+        case POSTGRESQL:\n+            resourceDAO = new PostgreSqlResourceDAO(connection, schemaName, flavor, trxSynchRegistry);\n+            break;\n         }\n         return resourceDAO;\n     }\n \n-    public static ResourceDAO getResourceDAO (Connection conn) throws IllegalArgumentException, SQLException {\n+    /**\n+     * Construct a new ResourceDAO implementation matching the database type\n+     * @param connection valid connection to the database\n+     * @param schemaName the name of the schema containing the FHIR resource tables\n+     * @param flavor the type and capability of the database and schema\n+     * @return a concrete implementation of {@link ResourceDAO}\n+     * @throws IllegalArgumentException\n+     * @throws FHIRPersistenceException\n+     */\n+    public static ResourceDAO getResourceDAO(Connection connection, String schemaName, FHIRDbFlavor flavor) throws IllegalArgumentException, FHIRPersistenceException {\n         ResourceDAO resourceDAO = null;\n-        switch (FHIRResourceDAOType.of(conn)) {\n-            case DB2:\n-                resourceDAO = new ResourceDAOImpl(conn);\n-                break;\n-            case DERBY:\n-                resourceDAO = new DerbyResourceDAO(conn);\n-                break;\n-            case POSTGRESQL:\n-                resourceDAO = new PostgreSqlResourceDAO(conn);\n-                break;\n+        switch (flavor.getType()) {\n+        case DB2:\n+            resourceDAO = new ResourceDAOImpl(connection, schemaName, flavor);\n+            break;\n+        case DERBY:\n+            resourceDAO = new DerbyResourceDAO(connection, schemaName, flavor);\n+            break;\n+        case POSTGRESQL:\n+            resourceDAO = new PostgreSqlResourceDAO(connection, schemaName, flavor);\n+            break;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1MDkzOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447750938", "bodyText": "No default required.\nOne method passed a trxSynchRegistry.", "author": "punktilious", "createdAt": "2020-06-30T14:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MTI3NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446981274", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:43:02Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/ChainedAction.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1MTYyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447751628", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T14:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MTQzMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446981432", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-29T13:43:17Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/ChainedAction.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Base for chaining actions together\n+ */\n+public class ChainedAction implements Action {\n+\n+    // the next action in the chain\n+    private final Action next;\n+\n+    /**\n+     * Public constructor\n+     * @param next the next action in the chain\n+     */\n+    public ChainedAction(Action next) {\n+        this.next = next;\n+    }\n+\n+    /**\n+     * Public constructor where this action is the end of the chain\n+     */\n+    public ChainedAction() {\n+        this.next = null;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1MjA4Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447752082", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T14:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MTQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NDAwNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446984005", "bodyText": "isn't this inclusive of type name and version already? version isn't necessary", "author": "prb112", "createdAt": "2020-06-29T13:46:43Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/BaseObject.java", "diffHunk": "@@ -256,7 +256,7 @@ public void applyTx(IDatabaseAdapter target, ITransactionProvider tp, IVersionHi\n     @Override\n     public void applyVersion(IDatabaseAdapter target, IVersionHistoryService vhs) {\n         if (vhs.applies(getSchemaName(), getObjectType().name(), getObjectName(), version)) {\n-            logger.fine(\"Applying change [v\" + version + \"]: \" + this.getTypeAndName());\n+            logger.fine(\"Applying change [v\" + version + \"]: \" + this.getTypeNameVersion());", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0NDI2MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447744260", "bodyText": "No, the logic requires we use version to distinguish the name - this is really important when creating the task list, which is used to apply the objects in parallel. Each version ends up being a task, but depends on the prior version so that they are applied in the correct order.", "author": "punktilious", "createdAt": "2020-06-30T14:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NDAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NTI5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446985296", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:48:26Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConstants.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+\n+/**\n+ * Constants used with FHIR DB datasources and connections\n+ * \n+ * @implNote extracted from FHIRDbDAO\n+ */\n+public class FHIRDbConstants {\n+    public static final String FHIRDB_JNDI_NAME_DEFAULT = \"jdbc/fhirProxyDataSource\";\n+    public static final String PROPERTY_DB_DRIVER = \"dbDriverName\";\n+    public static final String PROPERTY_DB_URL = \"dbUrl\";\n+    public static final String PROPERTY_DB2_USER = \"user\";\n+    public static final String PROPERTY_DB2_PSWD = \"password\";\n+    public static final String PROPERTY_SCHEMA_NAME = \"schemaName\";\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1Mjc0OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447752749", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T15:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NjM0OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446986349", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:49:55Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTestConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc2MjI3Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447762272", "bodyText": "next commit", "author": "punktilious", "createdAt": "2020-06-30T15:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NjM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NjY4MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446986681", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:50:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionAdapter.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.ITransaction;\n+import com.ibm.fhir.database.utils.transaction.SimpleTransactionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc2MzMxMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447763310", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T15:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NjY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4Njk4Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446986982", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:50:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionFactory.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3MTc2OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447771768", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T15:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4Njk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NzE2NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446987164", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:51:02Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionFactory.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+\n+\n+/**\n+ * Factory/strategy to instantiate FHIRTestTransactionHandler implementations\n+ * of the {@link FHIRPersistenceTransaction} interface. Typically used\n+ * to support unit-tests\n+ */\n+public class FHIRTestTransactionFactory implements FHIRTransactionFactory {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     */\n+    public FHIRTestTransactionFactory(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRTransactionFactory#create()\n+     */\n+    @Override\n+    public FHIRPersistenceTransaction create() {\n+        return new FHIRTestTransactionAdapter(connectionProvider);\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3MjQzMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447772432", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T15:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NzE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4OTE5NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446989194", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param Connection - A database connection that will be managed by the caller.\n          \n          \n            \n                 * @param Connection - A database connection that will be managed by the caller.\n          \n          \n            \n                 * @param schemaName\n          \n          \n            \n                 * @param flavor", "author": "prb112", "createdAt": "2020-06-29T13:53:53Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterDAOImpl.java", "diffHunk": "@@ -45,28 +44,32 @@\n     private Map<String, Integer> newParameterNameIds = new HashMap<>();\n     private Map<String, Integer> newCodeSystemIds = new HashMap<>();\n \n-    private boolean runningInTrx = false;\n+    private final TransactionSynchronizationRegistry trxSynchRegistry;\n+    private final boolean runningInTrx;\n     private CodeSystemsCacheUpdater csCacheUpdater = null;\n     private ParameterNamesCacheUpdater pnCacheUpdater = null;\n-    private TransactionSynchronizationRegistry trxSynchRegistry;\n \n \n     /**\n      * Constructs a DAO instance suitable for acquiring connections from a JDBC Datasource object.\n      */\n-    public ParameterDAOImpl(TransactionSynchronizationRegistry trxSynchRegistry) {\n-        super();\n-        this.runningInTrx = true;\n+    public ParameterDAOImpl(Connection connection, String schemaName, FHIRDbFlavor flavor, TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(connection, schemaName, flavor);\n         this.trxSynchRegistry = trxSynchRegistry;\n+        this.runningInTrx = true;\n     }\n \n     /**\n      * Constructs a DAO using the passed externally managed database connection.\n      * The connection used by this instance for all DB operations will be the passed connection.\n      * @param Connection - A database connection that will be managed by the caller.", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NzU3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447777576", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T15:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4OTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MDI2MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446990260", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param c\n          \n          \n            \n                 * @param fsd\n          \n          \n            \n                 * @param c\n          \n          \n            \n                 * @param schemaName", "author": "prb112", "createdAt": "2020-06-29T13:55:22Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/DerbyCodeSystemDAO.java", "diffHunk": "@@ -28,8 +28,8 @@\n      * @param c\n      * @param fsd", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3OTcwMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447779702", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T15:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MDI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MDk2MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446990961", "bodyText": "Technically we are not use Parameter Name, we're using code... just something to think about.", "author": "prb112", "createdAt": "2020-06-29T13:56:19Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/DerbyParameterNamesDAO.java", "diffHunk": "@@ -22,8 +22,8 @@\n public class DerbyParameterNamesDAO extends ParameterNameDAOImpl {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MTMwMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446991303", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param fsd\n          \n          \n            \n                 * @param schemaName", "author": "prb112", "createdAt": "2020-06-29T13:56:48Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -30,8 +30,8 @@\n      * @param c\n      * @param fsd", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NDkzNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447974935", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MzMzOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446993339", "bodyText": "Turns out this is not used in the code base.  Please remove or add a backlog issue to support its use", "author": "prb112", "createdAt": "2020-06-29T13:59:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbHelper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Helper functions used for managing FHIR database interactions\n+ */\n+public class FHIRDbHelper {\n+    private static final Logger log = Logger.getLogger(FHIRDbHelper.class.getName());\n+    \n+    /**\n+     * Convenience function to log the cause of an exception about to be thrown. This\n+     * is useful when avoiding chaining the cause with the persistence exception, which\n+     * could inadvertently leak sensitive information (details of the schema, for example)\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, Throwable cause) {\n+        logger.log(Level.SEVERE, fx.getMessage(), cause);\n+        return fx;\n+    }\n+    \n+    /**\n+     * Log the exception message here along with the cause stack. Return the\n+     * exception fx to the caller so that it can be thrown easily.\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param errorMessage\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, String errorMessage,\n+            Throwable cause) {\n+        if (cause != null) {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage), cause);\n+        } else {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage));\n+        }\n+        return fx;\n+    }\n+    \n+    public static FHIRPersistenceDataAccessException buildExceptionWithIssue(String msg, IssueType issueType)\n+            throws FHIRPersistenceDataAccessException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDataAccessException(msg).withIssue(ooi);\n+    }\n+\n+    public static FHIRPersistenceDBConnectException buildFHIRPersistenceDBConnectException(String msg, IssueType issueType)\n+            throws FHIRPersistenceDBConnectException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDBConnectException(msg).withIssue(ooi);\n+    }\n+\n+    /**\n+     * Close the connection if not null.\n+     * @implNote This connection object is just a wrapper. If we're in a \n+     *           transaction, then closing it doesn't do much, other than tell\n+     *           the transaction manager that the connection is no longer in\n+     *           use. The transaction manager still holds the underlying \n+     *           database connection open, and will use that connection the \n+     *           next time getConnection() is called for the same datasource \n+     *           within this thread. Only when the transaction commits \n+     *           will the connection be returned to the pool (or closed). \n+     *           If connections remain open when commit() is called, the \n+     *           transaction will fail.\n+     * @param c\n+     */\n+    public static void close(Connection connection) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1NTY3NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447755675", "bodyText": "I've removed. It's no longer needed because we now always use try-with-resource to manage connection scope.", "author": "punktilious", "createdAt": "2020-06-30T15:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5NTAwMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446995000", "bodyText": "interesting... so this was never used?", "author": "prb112", "createdAt": "2020-06-29T14:01:48Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -261,14 +252,11 @@ public Integer readResourceTypeId(String resourceType) throws FHIRPersistenceDBC\n                 logger.finer(\"DB read resource type id complete. executionTime=\" + dbCallDuration + \"ms\");\n             }\n             resourceTypeId = stmt.getInt(2);\n-        } catch(FHIRPersistenceDBConnectException e) {\n-            throw e;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NDc3NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447784775", "bodyText": "The DAO is passed a valid connection so it never attempts to connect itself, and therefore will never see FHIRPersistenceDBConnectException. This is a lot cleaner, because connection issues are handled higher up, leaving the DAO to focus on performing statements.", "author": "punktilious", "createdAt": "2020-06-30T15:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5NTAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5NTI2OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446995268", "bodyText": "Where does this happen now?", "author": "prb112", "createdAt": "2020-06-29T14:02:12Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -261,14 +252,11 @@ public Integer readResourceTypeId(String resourceType) throws FHIRPersistenceDBC\n                 logger.finer(\"DB read resource type id complete. executionTime=\" + dbCallDuration + \"ms\");\n             }\n             resourceTypeId = stmt.getInt(2);\n-        } catch(FHIRPersistenceDBConnectException e) {\n-            throw e;\n         } catch (Throwable e) {\n             final String errMsg = \"Failure storing Resource type name id: name=\" + resourceType;\n             FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(errMsg);\n             throw severe(logger, fx, e);\n         } finally {\n-            this.cleanup(stmt, connection);", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NzEzMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447797130", "bodyText": "Connections are opened and closed using try-with-resource in the corresponding FHIRPersistenceJDBCImpl method. We keep connection management in one place. Much less risk.", "author": "punktilious", "createdAt": "2020-06-30T15:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5NTI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5OTk3NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447799974", "bodyText": "I've added a cleanup(stmt). The statement would be closed as soon as the connection (wrapper) is closed, but it makes sense to close it where it was opened. We ought to use try-with-resource for all statements, but doing so requires a bit more finesse in the exception handling.", "author": "punktilious", "createdAt": "2020-06-30T16:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5NTI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5ODUzNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446998535", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:06:47Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchIdLastUpdatedTest.java", "diffHunk": "@@ -27,12 +31,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NjM2Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447786362", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5ODUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTEzMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446999130", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:07:32Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchNumberTest.java", "diffHunk": "@@ -16,22 +18,39 @@\n \n public class JDBCSearchNumberTest extends AbstractSearchNumberTest {\n     private Properties testProps;\n+    \n+    private PoolConnectionProvider connectionPool;\n \n     public JDBCSearchNumberTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4ODUwNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447788504", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTQwNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446999407", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:07:55Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchQuantityTest.java", "diffHunk": "@@ -17,22 +19,39 @@\n public class JDBCSearchQuantityTest extends AbstractSearchQuantityTest {\n \n     private Properties testProps;\n+    \n+    private PoolConnectionProvider connectionPool;\n \n     public JDBCSearchQuantityTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4OTYwNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447789607", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTY0NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446999645", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:08:16Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchReferenceTest.java", "diffHunk": "@@ -19,21 +21,38 @@\n     \n     private Properties testProps;\n     \n+    private PoolConnectionProvider connectionPool;\n+    \n     public JDBCSearchReferenceTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MDYwOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447790609", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTg2Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446999867", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:08:35Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchReferenceTest.java", "diffHunk": "@@ -19,21 +21,38 @@\n     \n     private Properties testProps;\n     \n+    private PoolConnectionProvider connectionPool;\n+    \n     public JDBCSearchReferenceTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTA3OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447791078", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5OTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDA2MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447000061", "bodyText": "copyright needs to be updated", "author": "prb112", "createdAt": "2020-06-29T14:08:55Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchReferenceTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MDA2OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447790069", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDI5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447000296", "bodyText": "update copyright", "author": "prb112", "createdAt": "2020-06-29T14:09:15Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchQuantityTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4OTA3Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447789077", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDQyNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447000427", "bodyText": "update copyright", "author": "prb112", "createdAt": "2020-06-29T14:09:29Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchNumberTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4ODAzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447788037", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMTIyMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447001221", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import org.apache.derby.impl.store.raw.xact.BeginXact;", "author": "prb112", "createdAt": "2020-06-29T14:10:32Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchNearTest.java", "diffHunk": "@@ -22,6 +22,7 @@\n import java.util.Properties;\n import java.util.logging.LogManager;\n \n+import org.apache.derby.impl.store.raw.xact.BeginXact;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NzQ5NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447787494", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMTY3NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447001675", "bodyText": "Update Copyright", "author": "prb112", "createdAt": "2020-06-29T14:11:10Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchNearTest.java", "diffHunk": "@@ -22,6 +22,7 @@\n import java.util.Properties;\n import java.util.logging.LogManager;\n \n+import org.apache.derby.impl.store.raw.xact.BeginXact;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NzY3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447787676", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMTY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMTk4OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447001988", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:11:38Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchCompositeTest.java", "diffHunk": "@@ -29,12 +33,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMDYxOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447800618", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMjE2NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447002165", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:11:51Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchCompositeTest.java", "diffHunk": "@@ -29,12 +33,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n+    }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n     }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NTgzNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447785834", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMjE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzY5OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447003698", "bodyText": "Please remove this.\nIt gets called every 60 seconds...", "author": "prb112", "createdAt": "2020-06-29T14:14:09Z", "path": "operation/fhir-operation-healthcheck/src/main/java/com/ibm/fhir/operation/healthcheck/HealthcheckOperation.java", "diffHunk": "@@ -45,9 +49,22 @@ protected Parameters doInvoke(FHIROperationContext operationContext, Class<? ext\n         try {\n             FHIRPersistence pl =\n                     (FHIRPersistence) operationContext.getProperty(FHIROperationContext.PROPNAME_PERSISTENCE_IMPL);\n-            OperationOutcome operationOutcome = pl.getHealth();\n-            checkOperationOutcome(operationOutcome);\n-            return FHIROperationUtil.getOutputParameters(operationOutcome);\n+\n+            FHIRPersistenceTransaction tx = resourceHelper.getTransaction();\n+            tx.begin();\n+            \n+            try {\n+                logger.info(\"checking health\");", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NTM3Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447975373", "bodyText": "this was removed a while back", "author": "punktilious", "createdAt": "2020-06-30T20:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzkzNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447003936", "bodyText": "Please remove this", "author": "prb112", "createdAt": "2020-06-29T14:14:27Z", "path": "operation/fhir-operation-healthcheck/src/main/java/com/ibm/fhir/operation/healthcheck/HealthcheckOperation.java", "diffHunk": "@@ -45,9 +49,22 @@ protected Parameters doInvoke(FHIROperationContext operationContext, Class<? ext\n         try {\n             FHIRPersistence pl =\n                     (FHIRPersistence) operationContext.getProperty(FHIROperationContext.PROPNAME_PERSISTENCE_IMPL);\n-            OperationOutcome operationOutcome = pl.getHealth();\n-            checkOperationOutcome(operationOutcome);\n-            return FHIROperationUtil.getOutputParameters(operationOutcome);\n+\n+            FHIRPersistenceTransaction tx = resourceHelper.getTransaction();\n+            tx.begin();\n+            \n+            try {\n+                logger.info(\"checking health\");\n+                OperationOutcome operationOutcome = pl.getHealth();\n+                checkOperationOutcome(operationOutcome);\n+                logger.info(\"checked health\");", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NTU5MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447975590", "bodyText": "already removed", "author": "punktilious", "createdAt": "2020-06-30T20:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNDIyMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447014221", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                        // just log the error...things are already bad if this method has been called\n          \n          \n            \n                        logger.severe(\"dumpLockInfo - connection failure: \" + x.getMessage());\n          \n          \n            \n                    }\n          \n          \n            \n                    } catch (SQLException x) {\n          \n          \n            \n                        // just log the error...things are already bad if this method has been called\n          \n          \n            \n                        logger.severe(\"dumpLockInfo - connection failure: \" + x.getMessage());\n          \n          \n            \n                    }", "author": "prb112", "createdAt": "2020-06-29T14:28:15Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCPagingTest.java", "diffHunk": "@@ -29,12 +37,37 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb(false);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n+    }\n+\n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+    \n+    @Override\n+    protected void debugLocks() {\n+        // Exception running a query. Let's dump the lock table\n+        try (Connection c = connectionPool.getConnection()) {\n+            DerbyMaster.dumpLockInfo(c);\n+        }\n+        catch (SQLException x) {\n+            // just log the error...things are already bad if this method has been called\n+            logger.severe(\"dumpLockInfo - connection failure: \" + x.getMessage());\n+        }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjA2Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447806066", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNDIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNDU3Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447014572", "bodyText": "Copyright", "author": "prb112", "createdAt": "2020-06-29T14:28:45Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCPagingTest.java", "diffHunk": "@@ -6,8 +6,14 @@\n \n package com.ibm.fhir.persistence.jdbc.test;\n \n+import java.sql.Connection;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNDU5MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447804591", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNDU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjE4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447032180", "bodyText": "Fix copyright", "author": "prb112", "createdAt": "2020-06-29T14:52:11Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCDeleteTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMzEyMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447803122", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjQyMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447032421", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T14:52:28Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCDeleteTest.java", "diffHunk": "@@ -33,12 +39,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb(false);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMzM4NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447803385", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzODQ2OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447038468", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-06-29T15:00:37Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchStringTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTY1MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447791650", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzODQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzODc0Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447038747", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:01:01Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchStringTest.java", "diffHunk": "@@ -18,22 +20,39 @@\n public class JDBCSearchStringTest extends AbstractSearchStringTest {\n \n     private Properties testProps;\n+    \n+    private PoolConnectionProvider connectionPool;\n \n     public JDBCSearchStringTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjEzOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447792138", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzODc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzODg3OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447038878", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:01:13Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchStringTest.java", "diffHunk": "@@ -18,22 +20,39 @@\n public class JDBCSearchStringTest extends AbstractSearchStringTest {\n \n     private Properties testProps;\n+    \n+    private PoolConnectionProvider connectionPool;\n \n     public JDBCSearchStringTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n+    }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n     }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjQ3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447792476", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzODg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzOTU1Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447039556", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-06-29T15:02:09Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchTokenTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5Mjg0Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447792843", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzOTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDI2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447040263", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:03:08Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchTokenTest.java", "diffHunk": "@@ -29,12 +33,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MzA5NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447793095", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0ODE5NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447048195", "bodyText": "Copyright", "author": "prb112", "createdAt": "2020-06-29T15:14:10Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCCompartmentTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjM1Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447802352", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0ODE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0ODM4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447048380", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:14:24Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCCompartmentTest.java", "diffHunk": "@@ -29,12 +33,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb(false);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+\n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjY1MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447802651", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0ODM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1MjMxNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447052315", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-06-29T15:19:50Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCMultiResourceTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMzkwOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447803909", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1MjMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1Mjc3Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447052773", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:20:25Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCMultiResourceTest.java", "diffHunk": "@@ -29,12 +34,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb(false);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNDE0Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447804142", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1Mjc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1MzQyNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447053424", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-06-29T15:21:22Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchURITest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMTIyMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447801223", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1MzQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1MzYwMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447053600", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:21:36Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchURITest.java", "diffHunk": "@@ -27,12 +31,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDE4MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447794181", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1MzYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1NDA2NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447054064", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-06-29T15:22:15Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCWholeSystemSearchTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.pool.PoolConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjAzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447976031", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T21:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1NDA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1NDI4Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447054287", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:22:32Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCWholeSystemSearchTest.java", "diffHunk": "@@ -28,12 +32,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb(false);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMTk1MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447801951", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T16:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1NDI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1Nzk5OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447057998", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (Throwable x) {\n          \n          \n            \n                    } catch (Throwable x) {", "author": "prb112", "createdAt": "2020-06-29T15:27:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionAdapter.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.ITransaction;\n+import com.ibm.fhir.database.utils.transaction.SimpleTransactionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Use by unit tests or other scenarios where connections are obtained using an\n+ * IConnectionProvider implementation, outside the scope of a JEE container.\n+ * Transactions are managed with the help of the SimpleTransactionProvider and\n+ * wrapped by this class, meaning we have a uniform interface for handling\n+ * transactions across JEE and unit-test scenarios.\n+ * \n+ */\n+public class FHIRTestTransactionAdapter implements FHIRPersistenceTransaction {\n+    private static final Logger log = Logger.getLogger(FHIRDbTestConnectionStrategy.class.getName());\n+    \n+    // Provides connections when outside of a container\n+    private final IConnectionProvider connectionProvider;\n+    \n+    // Support transactions for the persistence unit tests\n+    private final SimpleTransactionProvider transactionProvider;\n+    \n+    // Just in case we have nesting issues, use ThreadLocal to track the current tx\n+    private final ThreadLocal<ITransaction> currentTransaction = new ThreadLocal<>();\n+    \n+    // Was this instance responsible for starting the transaction\n+    private boolean startedByThis;\n+    \n+    // support nesting by tracking the number of begin/end requests\n+    private int startCount;\n+        \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRTestTransactionAdapter(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+\n+        // provide transaction support for our tests\n+        this.transactionProvider = new SimpleTransactionProvider(this.connectionProvider);\n+    }\n+\n+    @Override\n+    public void begin() throws FHIRPersistenceException {\n+        if (currentTransaction.get() == null) {\n+            // allocate a new transaction\n+            this.currentTransaction.set(this.transactionProvider.getTransaction());\n+            this.startedByThis = true;\n+        }\n+        \n+        // add to the start request counter every time. We only close when this\n+        // counter reaches 0.\n+        startCount++;\n+    }\n+\n+    @Override\n+    public void end() throws FHIRPersistenceException {\n+        if (currentTransaction.get() == null) {\n+            throw new FHIRPersistenceDataAccessException(\"Transaction not started\");\n+        }\n+        \n+        try {\n+            // only end it if we started it\n+            if (startedByThis && --startCount == 0) {\n+                this.currentTransaction.get().close();\n+            }\n+        }\n+        catch (Throwable x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3MDczNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447770736", "bodyText": "fixed next commit", "author": "punktilious", "createdAt": "2020-06-30T15:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1Nzk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1ODIyMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447058221", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    finally {\n          \n          \n            \n                    } finally {", "author": "prb112", "createdAt": "2020-06-29T15:27:59Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionAdapter.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.ITransaction;\n+import com.ibm.fhir.database.utils.transaction.SimpleTransactionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Use by unit tests or other scenarios where connections are obtained using an\n+ * IConnectionProvider implementation, outside the scope of a JEE container.\n+ * Transactions are managed with the help of the SimpleTransactionProvider and\n+ * wrapped by this class, meaning we have a uniform interface for handling\n+ * transactions across JEE and unit-test scenarios.\n+ * \n+ */\n+public class FHIRTestTransactionAdapter implements FHIRPersistenceTransaction {\n+    private static final Logger log = Logger.getLogger(FHIRDbTestConnectionStrategy.class.getName());\n+    \n+    // Provides connections when outside of a container\n+    private final IConnectionProvider connectionProvider;\n+    \n+    // Support transactions for the persistence unit tests\n+    private final SimpleTransactionProvider transactionProvider;\n+    \n+    // Just in case we have nesting issues, use ThreadLocal to track the current tx\n+    private final ThreadLocal<ITransaction> currentTransaction = new ThreadLocal<>();\n+    \n+    // Was this instance responsible for starting the transaction\n+    private boolean startedByThis;\n+    \n+    // support nesting by tracking the number of begin/end requests\n+    private int startCount;\n+        \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRTestTransactionAdapter(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+\n+        // provide transaction support for our tests\n+        this.transactionProvider = new SimpleTransactionProvider(this.connectionProvider);\n+    }\n+\n+    @Override\n+    public void begin() throws FHIRPersistenceException {\n+        if (currentTransaction.get() == null) {\n+            // allocate a new transaction\n+            this.currentTransaction.set(this.transactionProvider.getTransaction());\n+            this.startedByThis = true;\n+        }\n+        \n+        // add to the start request counter every time. We only close when this\n+        // counter reaches 0.\n+        startCount++;\n+    }\n+\n+    @Override\n+    public void end() throws FHIRPersistenceException {\n+        if (currentTransaction.get() == null) {\n+            throw new FHIRPersistenceDataAccessException(\"Transaction not started\");\n+        }\n+        \n+        try {\n+            // only end it if we started it\n+            if (startedByThis && --startCount == 0) {\n+                this.currentTransaction.get().close();\n+            }\n+        }\n+        catch (Throwable x) {\n+            // translate to a FHIRPersistenceException\n+            FHIRPersistenceException fx = new FHIRPersistenceException(\"Unexpected error while committing a transaction.\");\n+            log.log(Level.SEVERE, fx.getMessage(), x);\n+            throw fx;\n+        }\n+        finally {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3MDkyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447770928", "bodyText": "fixed next commit", "author": "punktilious", "createdAt": "2020-06-30T15:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1ODIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTQzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447059431", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-06-29T15:29:40Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCSortTest.java", "diffHunk": "@@ -8,6 +8,8 @@\n \n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.api.IConnectionProvider;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NjIyNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447896227", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T18:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMzUyMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447913523", "bodyText": "not fixed", "author": "prb112", "createdAt": "2020-06-30T19:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTU4OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447059588", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:29:52Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCSortTest.java", "diffHunk": "@@ -29,12 +33,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb(false);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NjQ0NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447896445", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T18:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MDE3OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447060179", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param connectionStrategy", "author": "prb112", "createdAt": "2020-06-29T15:30:37Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceDAOImpl.java", "diffHunk": "@@ -112,20 +113,30 @@\n     /**\n      * Constructs a DAO instance suitable for acquiring connections from a JDBC Datasource object.\n      */\n-    public ResourceDAOImpl(TransactionSynchronizationRegistry trxSynchRegistry) {\n-        super();\n+    public ResourceDAOImpl(Connection c, String schemaName, FHIRDbFlavor flavor, TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(c, schemaName, flavor);\n         this.runningInTrx = true;\n         this.trxSynchRegistry = trxSynchRegistry;\n     }\n \n+    /**\n+     * Constructs a DAO instance for use outside a managed transaction (JEE) environment\n+     * @param connectionStrategy", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3ODgyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447778828", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T15:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MDE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MjMwMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447062300", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-06-29T15:33:38Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/util/QuantityParmBehaviorUtilTest.java", "diffHunk": "@@ -177,12 +177,7 @@ public Connection getConnection() throws FHIRPersistenceDBConnectException {\n             }\n \n             @Override\n-            public Connection getExternalConnection() {\n-                return null;\n-            }\n-\n-            @Override\n-            public boolean isDb2Database() throws Exception {\n+            public boolean isDb2Database() {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NzcwOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447897708", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T18:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MjMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2Mjg4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447062880", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String CLASSNAME = FHIRDebugXADataSource.class.getName();", "author": "prb112", "createdAt": "2020-06-29T15:34:27Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRDebugXADataSource.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright IBM Corp. 2017, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.io.PrintWriter;\n+import java.sql.SQLException;\n+import java.sql.SQLFeatureNotSupportedException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.XAConnection;\n+import javax.sql.XADataSource;\n+\n+import org.apache.commons.beanutils.PropertyUtils;\n+\n+/**\n+ * Wraps a Derby embedded datasource so we can debug connection handling issues\n+ * by returning wrapped datasources (and wrapped connections)\n+ */\n+public class FHIRDebugXADataSource implements XADataSource {\n+    private static final Logger log = Logger.getLogger(FHIRDebugXADataSource.class.getName());\n+    private static final String CLASSNAME = FHIRDebugXADataSource.class.getName();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NzQ1OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447897458", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T18:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2Mjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2Mzc1MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447063751", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:35:39Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODExNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447898115", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T18:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2Mzc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2Mzk5MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447063991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.sql.PooledConnection#addStatementEventListener(javax.sql.StatementEventListener)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-29T15:36:01Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+\n+/**\n+ * Proxy/wrapper for XAConnection objects obtained via the FHIRProxyXADataSource.\n+ * Provides additional tracing for connection/transaction/pooling issues\n+ */\n+public class FHIRProxyXAConnection implements XAConnection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyXAConnection.class.getName());\n+    private final XAConnection delegate;\n+    \n+    public FHIRProxyXAConnection(XAConnection delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws SQLException {\n+        // dump the stack showing who's calling\n+        Exception x = new Exception(\"stack\");\n+        logger.log(Level.INFO, \"PROXY XA CONNECTION\", x);\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // Wrap the connection so that we can really see what's going on\n+            return new FHIRProxyConnection(delegate.getConnection());\n+        } else {\n+            return delegate.getConnection();\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#close()\n+     */\n+    @Override\n+    public void close() throws SQLException {\n+        this.delegate.close();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */\n+    @Override\n+    public void addConnectionEventListener(ConnectionEventListener listener) {\n+        this.delegate.addConnectionEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#removeConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */\n+    @Override\n+    public void removeConnectionEventListener(ConnectionEventListener listener) {\n+        this.delegate.removeConnectionEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addStatementEventListener(javax.sql.StatementEventListener)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODM2MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447898360", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T18:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2Mzk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2NDEwMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447064101", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.sql.PooledConnection#removeStatementEventListener(javax.sql.StatementEventListener)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-29T15:36:12Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+\n+/**\n+ * Proxy/wrapper for XAConnection objects obtained via the FHIRProxyXADataSource.\n+ * Provides additional tracing for connection/transaction/pooling issues\n+ */\n+public class FHIRProxyXAConnection implements XAConnection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyXAConnection.class.getName());\n+    private final XAConnection delegate;\n+    \n+    public FHIRProxyXAConnection(XAConnection delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws SQLException {\n+        // dump the stack showing who's calling\n+        Exception x = new Exception(\"stack\");\n+        logger.log(Level.INFO, \"PROXY XA CONNECTION\", x);\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // Wrap the connection so that we can really see what's going on\n+            return new FHIRProxyConnection(delegate.getConnection());\n+        } else {\n+            return delegate.getConnection();\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#close()\n+     */\n+    @Override\n+    public void close() throws SQLException {\n+        this.delegate.close();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */\n+    @Override\n+    public void addConnectionEventListener(ConnectionEventListener listener) {\n+        this.delegate.addConnectionEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#removeConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */\n+    @Override\n+    public void removeConnectionEventListener(ConnectionEventListener listener) {\n+        this.delegate.removeConnectionEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addStatementEventListener(javax.sql.StatementEventListener)\n+     */\n+    @Override\n+    public void addStatementEventListener(StatementEventListener listener) {\n+        this.delegate.addStatementEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#removeStatementEventListener(javax.sql.StatementEventListener)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2NDI3NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447064274", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.sql.XAConnection#getXAResource()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-29T15:36:25Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+\n+/**\n+ * Proxy/wrapper for XAConnection objects obtained via the FHIRProxyXADataSource.\n+ * Provides additional tracing for connection/transaction/pooling issues\n+ */\n+public class FHIRProxyXAConnection implements XAConnection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyXAConnection.class.getName());\n+    private final XAConnection delegate;\n+    \n+    public FHIRProxyXAConnection(XAConnection delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws SQLException {\n+        // dump the stack showing who's calling\n+        Exception x = new Exception(\"stack\");\n+        logger.log(Level.INFO, \"PROXY XA CONNECTION\", x);\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // Wrap the connection so that we can really see what's going on\n+            return new FHIRProxyConnection(delegate.getConnection());\n+        } else {\n+            return delegate.getConnection();\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#close()\n+     */\n+    @Override\n+    public void close() throws SQLException {\n+        this.delegate.close();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */\n+    @Override\n+    public void addConnectionEventListener(ConnectionEventListener listener) {\n+        this.delegate.addConnectionEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#removeConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */\n+    @Override\n+    public void removeConnectionEventListener(ConnectionEventListener listener) {\n+        this.delegate.removeConnectionEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addStatementEventListener(javax.sql.StatementEventListener)\n+     */\n+    @Override\n+    public void addStatementEventListener(StatementEventListener listener) {\n+        this.delegate.addStatementEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#removeStatementEventListener(javax.sql.StatementEventListener)\n+     */\n+    @Override\n+    public void removeStatementEventListener(StatementEventListener listener) {\n+        this.delegate.removeStatementEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.XAConnection#getXAResource()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2OTYwMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447069601", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:43:36Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/RedefineDerbyDB.java", "diffHunk": "@@ -38,5 +40,10 @@ public void bootstrapDatabase() throws Exception {\n             derbyInit.bootstrapDb(true);\n         }\n     }\n+        \n+    @AfterSuite\n+    public void shutdownDerbyFhir() throws Exception {\n+        DerbyMaster.shutdown(DerbyInitializer.DB_NAME);\n+    }\n     ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2OTk4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447069980", "bodyText": "We no longer have JDBCNormXXX", "author": "prb112", "createdAt": "2020-06-29T15:44:10Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/RedefineDerbyDB.java", "diffHunk": "@@ -8,14 +8,16 @@\n \n import java.util.Properties;\n \n+import org.testng.annotations.AfterSuite;\n import org.testng.annotations.Test;\n \n+import com.ibm.fhir.database.utils.derby.DerbyMaster;\n import com.ibm.fhir.model.test.TestUtil;\n import com.ibm.fhir.persistence.jdbc.test.util.DerbyInitializer;\n \n /**\n- * This sole purpose of this class is to delete and redefine the Derby database used by the JDBCNormXXX testng tests. This test class should run first in\n- * the suite of tests that gets run when the fhir-persistence-jdbc project is built.\n+ * This sole purpose of this class is to delete and redefine the Derby database used by the JDBCNormXXX testng tests. \n+ * This test class should run first in the suite of tests that gets run when the fhir-persistence-jdbc project is built.", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzQxMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447903410", "bodyText": "Agreed. Not used, so deleting class.", "author": "punktilious", "createdAt": "2020-06-30T18:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2OTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMzgyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447913828", "bodyText": "JDBCNormXXX is in the comment still", "author": "prb112", "createdAt": "2020-06-30T19:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2OTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjMwNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447976306", "bodyText": "This entire class has been deleted.", "author": "punktilious", "createdAt": "2020-06-30T21:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2OTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MTEwNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447071107", "bodyText": "Love having this unit test", "author": "prb112", "createdAt": "2020-06-29T15:45:52Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/FHIRUserTransactionAdapterTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import javax.transaction.Status;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRUserTransactionAdapter;\n+\n+/**\n+ * Unit test for the {@link FHIRUserTransactionAdapter}\n+ */\n+public class FHIRUserTransactionAdapterTest {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMTg2OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447901868", "bodyText": "Yeah, this really helps give confidence that the transaction adapter is doing the right thing with all the nesting that happens in our persistence layer.", "author": "punktilious", "createdAt": "2020-06-30T18:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MjcwNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447072705", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param reset reset the database if true\n          \n          \n            \n                 * @param reset resets the database if true", "author": "prb112", "createdAt": "2020-06-29T15:48:12Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/util/DerbyInitializer.java", "diffHunk": "@@ -129,4 +132,22 @@ public Connection getConnection() throws SQLException {\n         connection.setAutoCommit(false);\n         return connection;\n     }\n+\n+    /**\n+     * Bootstrap the database if necessary, and get a connection provider for it\n+     * @return an {@link IConnectionProvider} configured for the FHIR Derby database\n+     * @param reset reset the database if true", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNDAxNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447904016", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MzM1NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447073354", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T15:49:18Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNTQxMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447905410", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NDUzMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447074530", "bodyText": "Please update the copyright", "author": "prb112", "createdAt": "2020-06-29T15:50:56Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractSortTest.java", "diffHunk": "@@ -106,11 +106,14 @@ public void createResources() throws Exception {\n     public void removeSavedResourcesAndResetTenant() throws Exception {\n         Resource[] resources = {resource1a, resource1b, resource2a, resource2b, resource3a, resource3b};\n         if (persistence.isDeleteSupported()) {\n+            if (persistence.isTransactional()) {\n+                persistence.getTransaction().begin();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNTY5OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447905698", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NDUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTE3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447075176", "bodyText": "Please update the copyright", "author": "prb112", "createdAt": "2020-06-29T15:51:52Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractPagingTest.java", "diffHunk": "@@ -79,12 +79,12 @@ public void createResources() throws Exception {\n     public void removeSavedResourcesAndResetTenant() throws Exception {\n         Resource[] resources = {resource1, resource2, resource3};\n         if (persistence.isDeleteSupported()) {\n+            // as this is AfterClass, we need to manually start/end the transaction\n+            startTrx();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNjE0MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447906141", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NzM2NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447077364", "bodyText": "Please update JDBCSearchNearTest or create a back log issue to update and remove commit", "author": "prb112", "createdAt": "2020-06-29T15:55:08Z", "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/FHIRPersistenceTransaction.java", "diffHunk": "@@ -25,44 +41,37 @@\n     void begin() throws FHIRPersistenceException;\n \n     /**\n-     * Commit the current thread's transaction.\n+     * End the current thread's transaction. If setRollbackOnly has been called,\n+     * then roll back the transaction instead.\n+     * This call only affects the current transaction if this object actually\n+     * started the transaction (i.e. is the outermost instance of a transaction).\n      * @throws Exception\n      */\n-    void commit() throws FHIRPersistenceException;\n-\n-\n-    /**\n-     * Roll back the current thread's transaction.\n-     * @throws Exception\n-     */\n-    void rollback() throws FHIRPersistenceException;\n+    void end() throws FHIRPersistenceException;\n \n     /**\n      * Modify the transaction associated with the current thread such that the only possible outcome of the transaction\n      * is to roll back the transaction.\n      * @throws FHIRPersistenceException\n      */\n     void setRollbackOnly() throws FHIRPersistenceException;\n+    \n \n     /**\n-     * Enroll in an existing transaction.\n-     *\n-     * <p>Enrolling in an existing transaction is an alternative to beginning a new transaction. Calling this method\n-     * gives implementations a chance to create necessary resources associated with a given unit of work when that\n-     * unit of work is performed under an existing user-managed transaction.\n-     *\n+     * Commit the transaction (if we started it).\n+     * Use {@link #end()} instead.\n      * @throws FHIRPersistenceException\n      */\n-    void enroll() throws FHIRPersistenceException;\n+    @Deprecated\n+    default void commit() throws FHIRPersistenceException { end(); }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNjc0OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447906748", "bodyText": "Creating a backlog issue.", "author": "punktilious", "createdAt": "2020-06-30T18:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NzM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3ODE2OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447078168", "bodyText": "I think this should be removed or a backlog issue to track the removal after Deprecation complete", "author": "prb112", "createdAt": "2020-06-29T15:56:16Z", "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/FHIRPersistenceTransaction.java", "diffHunk": "@@ -25,44 +41,37 @@\n     void begin() throws FHIRPersistenceException;\n \n     /**\n-     * Commit the current thread's transaction.\n+     * End the current thread's transaction. If setRollbackOnly has been called,\n+     * then roll back the transaction instead.\n+     * This call only affects the current transaction if this object actually\n+     * started the transaction (i.e. is the outermost instance of a transaction).\n      * @throws Exception\n      */\n-    void commit() throws FHIRPersistenceException;\n-\n-\n-    /**\n-     * Roll back the current thread's transaction.\n-     * @throws Exception\n-     */\n-    void rollback() throws FHIRPersistenceException;\n+    void end() throws FHIRPersistenceException;\n \n     /**\n      * Modify the transaction associated with the current thread such that the only possible outcome of the transaction\n      * is to roll back the transaction.\n      * @throws FHIRPersistenceException\n      */\n     void setRollbackOnly() throws FHIRPersistenceException;\n+    \n \n     /**\n-     * Enroll in an existing transaction.\n-     *\n-     * <p>Enrolling in an existing transaction is an alternative to beginning a new transaction. Calling this method\n-     * gives implementations a chance to create necessary resources associated with a given unit of work when that\n-     * unit of work is performed under an existing user-managed transaction.\n-     *\n+     * Commit the transaction (if we started it).\n+     * Use {@link #end()} instead.\n      * @throws FHIRPersistenceException\n      */\n-    void enroll() throws FHIRPersistenceException;\n+    @Deprecated\n+    default void commit() throws FHIRPersistenceException { end(); }\n \n     /**\n-     * Unenroll from the existing transaction.\n-     *\n-     * <p>Unenrolling from an existing transaction is an alternative to committing or rolling back the transaction. Calling\n-     * this method gives implementations a chance to release resources associated with a given unit of work when that\n-     * unit of work is performed under an existing user-managed transaction.\n-     *\n+     * Request rollback. Will only perform the rollback if this\n+     * instance actually started the transaction\n+     * Use {@link #setRollbackOnly()} and {@link #end()} instead.\n      * @throws FHIRPersistenceException\n      */\n-    void unenroll() throws FHIRPersistenceException;\n+    @Deprecated\n+    default void rollback() throws FHIRPersistenceException { setRollbackOnly(); end(); }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNzE5OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447907198", "bodyText": "Same backlog issue as commit()", "author": "punktilious", "createdAt": "2020-06-30T18:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3ODE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4MDY5MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447080690", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (Throwable t) {\n          \n          \n            \n                    } catch (Throwable t) {", "author": "prb112", "createdAt": "2020-06-29T15:59:54Z", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractPersistenceTest.java", "diffHunk": "@@ -155,9 +170,16 @@ public void tearDown() throws Exception {\n             searchContext.setPageSize(maxPageSize);\n         }\n         FHIRPersistenceContext persistenceContext = getPersistenceContextForSearch(searchContext);\n-        MultiResourceResult<Resource> result = persistence.search(persistenceContext, resourceType);\n-        assertNotNull(result.getResource());\n-        return result;\n+        \n+        try {\n+            MultiResourceResult<Resource> result = persistence.search(persistenceContext, resourceType);\n+            assertNotNull(result.getResource());\n+            return result;\n+        }\n+        catch (Throwable t) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNzU3Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447907573", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4MDY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyOTA4OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447129089", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T17:17:56Z", "path": "fhir-server/src/main/java/com/ibm/fhir/server/listener/FHIRServletContextListener.java", "diffHunk": "@@ -69,6 +70,8 @@\n     public static final String FHIR_SERVER_INIT_COMPLETE = \"com.ibm.fhir.webappInitComplete\";\n     private static FHIRNotificationKafkaPublisher kafkaPublisher = null;\n     private static FHIRNotificationNATSPublisher natsPublisher = null;\n+    private static final String TXN_JNDI_NAME = \"java:comp/UserTransaction\";\n+\n ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwODI4NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447908285", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyOTA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMTk0Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447131943", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // the translator we use to handle Derby syntax\n          \n          \n            \n                // private static final IDatabaseTranslator DERBY_TRANSLATOR = new DerbyTranslator();", "author": "prb112", "createdAt": "2020-06-29T17:23:04Z", "path": "fhir-persistence-schema/src/test/java/com/ibm/fhir/schema/derby/DerbyMigrationTest.java", "diffHunk": "@@ -42,6 +48,10 @@\n     private static final String SCHEMA_NAME = \"FHIRDATA\";\n     private static final String ADMIN_SCHEMA_NAME = \"FHIR_ADMIN\";\n     private static final String OAUTH_SCHEMANAME = \"FHIR_OAUTH\";\n+    \n+    // the translator we use to handle Derby syntax\n+    // private static final IDatabaseTranslator DERBY_TRANSLATOR = new DerbyTranslator();\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwOTI1NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447909254", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMzU1OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447133558", "bodyText": "@lmsurpre can you review this part? I think you intended and I'd like to defer to you here.", "author": "prb112", "createdAt": "2020-06-29T17:25:46Z", "path": "fhir-persistence-schema/src/test/java/com/ibm/fhir/schema/derby/DerbyMigrationTest.java", "diffHunk": "@@ -52,86 +62,121 @@ protected void setUp() throws SecurityException, IOException\n \n     @Test\n     public void testMigrateFhirSchema() throws Exception {\n+        // The schema for each resource is the same, so we only need to", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "05399fd30223f7a8566e76b5b28b9a5a76e3425f", "url": "https://github.com/IBM/FHIR/commit/05399fd30223f7a8566e76b5b28b9a5a76e3425f", "message": "issue-1144 removed extraneous logging added for debug\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-30T13:46:17Z", "type": "commit"}, {"oid": "c9de852d91af7b463526380d55e51124664926fe", "url": "https://github.com/IBM/FHIR/commit/c9de852d91af7b463526380d55e51124664926fe", "message": "Apply suggestions from code review\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>\n\nCo-authored-by: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-30T13:46:17Z", "type": "commit"}, {"oid": "b074da862e12fa450eeb439af7ecacc2a7ea014e", "url": "https://github.com/IBM/FHIR/commit/b074da862e12fa450eeb439af7ecacc2a7ea014e", "message": "issue-1144 addressed review comments including formatting\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-30T13:46:17Z", "type": "commit"}, {"oid": "b074da862e12fa450eeb439af7ecacc2a7ea014e", "url": "https://github.com/IBM/FHIR/commit/b074da862e12fa450eeb439af7ecacc2a7ea014e", "message": "issue-1144 addressed review comments including formatting\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-30T13:46:17Z", "type": "forcePushed"}, {"oid": "460c0af7eb65fc3825987479c0dc5ce164462d58", "url": "https://github.com/IBM/FHIR/commit/460c0af7eb65fc3825987479c0dc5ce164462d58", "message": "issue-1144 cleanup review suggestions\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-30T16:22:40Z", "type": "commit"}, {"oid": "79399381a28991fd477c8d9064b82da9c3282b4f", "url": "https://github.com/IBM/FHIR/commit/79399381a28991fd477c8d9064b82da9c3282b4f", "message": "Merge remote-tracking branch 'origin/HEAD' into issue-1144", "committedDate": "2020-06-30T16:23:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzY3Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447903677", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param c the new connection\n          \n          \n            \n                 * @param connection the new connection", "author": "prb112", "createdAt": "2020-06-30T18:45:26Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategyBase.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Common base for multi-tenant connection strategy implementations\n+ */\n+public abstract class FHIRDbConnectionStrategyBase implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbConnectionStrategyBase.class.getName());\n+    // We use the sync registry to remember connections we've configured in the current transaction.\n+    private final TransactionSynchronizationRegistry trxSyncRegistry;\n+\n+    // the action chain to be applied to new connections\n+    private final Action newConnectionAction;\n+    \n+    // Type and capability \n+    private final FHIRDbFlavor flavor;\n+    \n+    /**\n+     * Protected constructor\n+     * @param userTx the transaction handler\n+     * @param trxSyncRegistry\n+     * @param newConnectionAction\n+     */\n+    protected FHIRDbConnectionStrategyBase(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRPersistenceDataAccessException {\n+        this.trxSyncRegistry = trxSyncRegistry;\n+        this.newConnectionAction = newConnectionAction;\n+        \n+        // initialize the flavor from the configuration\n+        this.flavor = createFlavor();\n+    }\n+\n+    /**\n+     * Check with the transaction sync registry to see if this is the first time\n+     * we've worked with this connection in the current transaction.\n+     * @param c the new connection", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDY5Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447910693", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T18:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzc3NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447903774", "bodyText": "javadoc does not agree", "author": "prb112", "createdAt": "2020-06-30T18:45:36Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategyBase.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Common base for multi-tenant connection strategy implementations\n+ */\n+public abstract class FHIRDbConnectionStrategyBase implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbConnectionStrategyBase.class.getName());\n+    // We use the sync registry to remember connections we've configured in the current transaction.\n+    private final TransactionSynchronizationRegistry trxSyncRegistry;\n+\n+    // the action chain to be applied to new connections\n+    private final Action newConnectionAction;\n+    \n+    // Type and capability \n+    private final FHIRDbFlavor flavor;\n+    \n+    /**\n+     * Protected constructor\n+     * @param userTx the transaction handler\n+     * @param trxSyncRegistry\n+     * @param newConnectionAction", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMDMwOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447920308", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T19:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNTM3MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447905370", "bodyText": "This is in Javadoc, I suggest a // after this comment or inside the method", "author": "prb112", "createdAt": "2020-06-30T18:48:24Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTenantDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Uses datasource and tenant ids configured in the fhir-server-config to\n+ * map directly to a managed datasource. All managed datasources must be\n+ * available when the server starts. This differs from the proxy\n+ * datasource strategy {@link FHIRDbPropsConnectionStrategy} which supports\n+ * dynamic (programmatic) definition of managed datasources.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ *           Currently not used - just needs some additional integration\n+ *           with the fhir-server-configuration to be supported.\n+ */\n+public class FHIRDbTenantDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbDAOImpl.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final long NANOMS = 1000000;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceBaseName = \"jdbc/fhir_\";\n+\n+    // Cache of datasources we've found\n+    private final Map<String, DataSource> datasourceMap = new ConcurrentHashMap<>();\n+    \n+    // the flavor of the database we are configured to represent\n+    private final FHIRDbFlavor flavor;\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbTenantDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+\n+        // Find the base JNDI name of the datasource we want to use\n+        try {\n+//            this.datasourceBaseName =\n+//                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+//                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);\n+            \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Using datasource JNDI name: \" + datasourceBaseName);\n+            }\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure to find proxy datasource in FHIR server configuration\"), e);\n+            throw fx;\n+        }\n+        \n+        this.flavor = createFlavor();\n+    }\n+\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        Connection connection = null;\n+        final String METHODNAME = \"getConnection\";\n+\n+        if (log.isLoggable(Level.FINEST)) {\n+            log.entering(CLASSNAME, METHODNAME);\n+        }\n+        \n+        // the dsId/tenantId specific datasource we need to locate\n+        DataSource datasource;\n+        \n+        // Resources can be routed to different databases using the dsId currently\n+        // set on the context.\n+        String tenantId = FHIRRequestContext.get().getTenantId();\n+        String dsId = FHIRRequestContext.get().getDataStoreId();\n+        \n+        // this is the important bit...how we name our actual datasources\n+        final String datasourceName = datasourceBaseName + tenantId + \"_\" + dsId;\n+        \n+        // Note: we don't need any synchronization around ConcurrentHashMap, but that\n+        // doesn't change the fact that we may look up the datasource and put it into\n+        // the map more than once. That's fine. There aren't any integrity issues, just\n+        // the chance of doing more work than necessary a single time, but we avoid the\n+        // need for any synchronization. We cache locally, because we've found that JNDI\n+        // lookups can become a bottleneck with high concurrency\n+        datasource = datasourceMap.get(datasourceName);\n+        if (datasource == null) {\n+            // cache miss\n+            try {\n+                InitialContext ctxt = new InitialContext();\n+                \n+                datasource = (DataSource) ctxt.lookup(datasourceName);\n+                datasourceMap.put(datasourceName, datasource);\n+            } catch (Throwable e) {\n+                // don't emit secrets in exceptions\n+                FHIRPersistenceDBConnectException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+                throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceName, e);\n+            } finally {\n+                if (log.isLoggable(Level.FINEST)) {\n+                    log.exiting(CLASSNAME, METHODNAME);\n+                }\n+            }\n+        }\n+        \n+        long start = System.nanoTime();\n+        if (log.isLoggable(Level.FINE)) {\n+            log.fine(\"Getting connection for tenantId/dsId: [\" + tenantId + \"/\" + dsId + \"]...\");\n+        }\n+\n+        // Now use the dsId/tenantId specific JEE datasource to get a connection\n+        try {\n+            connection = getConnection(datasource, tenantId, dsId);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                long deltams = (System.nanoTime() - start) / NANOMS;\n+                log.fine(\"Got the connection for [\" + tenantId + \"/\" + dsId + \"]. Took \" + deltams + \" ms\");\n+            }\n+        } catch (Throwable e) {\n+            // Don't emit secrets in case they are returned to a client\n+            FHIRPersistenceDBConnectException fx =\n+                    new FHIRPersistenceDBConnectException(\"Failure acquiring connection for datasource\");\n+            throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceName, e);\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+        \n+        return connection;\n+    }\n+    \n+    @Override\n+    public FHIRDbFlavor getFlavor() throws FHIRPersistenceDataAccessException {\n+        return this.flavor;\n+    }\n+\n+    /**\n+     * Identify the flavor of the database using information from the\n+     * datasource configuration.\n+     * TODO duplicate code in FHIRDbConnectionStrategyBase. Refactor", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxODk2NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447918964", "bodyText": "Moved comment and included reference to issue-916.", "author": "punktilious", "createdAt": "2020-06-30T19:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNjk5OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447906999", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-30T18:51:02Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetTenantAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.api.BadTenantFrozenException;\n+import com.ibm.fhir.database.utils.api.BadTenantKeyException;\n+import com.ibm.fhir.database.utils.api.BadTenantNameException;\n+import com.ibm.fhir.database.utils.common.JdbcTarget;\n+import com.ibm.fhir.database.utils.db2.Db2Adapter;\n+import com.ibm.fhir.database.utils.db2.Db2SetTenantVariable;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+/**\n+ * Set the tenant variable in the session (part of Db2 multi-tenancy\n+ * support). This needs to be executed at the beginning of an\n+ * interaction with a database connection, before any other\n+ * DML/SQL.\n+ */\n+public class SetTenantAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetTenantAction.class.getName());\n+    \n+    // Used to indicate the default behavior of a datastore as multitenant.\n+    public static final List<String> DATASTORE_REQUIRES_ROW_PERMISSIONS = Arrays.asList(\"db2\");\n+\n+    /**\n+     * Default public constructor. No next action, so this will be the last action applied\n+     */\n+    public SetTenantAction() {\n+        super();\n+    }\n+    \n+    /**\n+     * Public constructor\n+     * @param next the next action in the chain\n+     */\n+    public SetTenantAction(Action next) {\n+        super(next);\n+    }\n+\n+", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMDU1MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447920550", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T19:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNjk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDYzMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447910632", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2018, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2018,2020", "author": "prb112", "createdAt": "2020-06-30T18:56:25Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchReferenceTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2018,2019\n+ * (C) Copyright IBM Corp. 2018, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MjY0Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447942643", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDc1Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447910757", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2018, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2018,2020", "author": "prb112", "createdAt": "2020-06-30T18:56:38Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchStringTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2018,2019\n+ * (C) Copyright IBM Corp. 2018, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MjcxNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447942715", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDg1OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447910858", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2018, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2018,2020", "author": "prb112", "createdAt": "2020-06-30T18:56:49Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchTokenTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2018,2019\n+ * (C) Copyright IBM Corp. 2018, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0Mjg2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447942863", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTA0Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447911046", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2018, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2018,2020", "author": "prb112", "createdAt": "2020-06-30T18:57:03Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchURITest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2018,2019\n+ * (C) Copyright IBM Corp. 2018, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MzAyNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447943026", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTE4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447911180", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2017, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2017,2020", "author": "prb112", "createdAt": "2020-06-30T18:57:16Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCWholeSystemSearchTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2017,2019\n+ * (C) Copyright IBM Corp. 2017, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MzEwNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447943104", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTQyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447911428", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2017, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2017,2020", "author": "prb112", "createdAt": "2020-06-30T18:57:39Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCCompartmentTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2017,2019\n+ * (C) Copyright IBM Corp. 2017, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MzE3OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447943178", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTU3Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447911572", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-30T18:57:55Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCCompartmentTest.java", "diffHunk": "@@ -29,12 +33,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb(false);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n     \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n     }\n+\n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n+    }\n+", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyNTY5MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447925690", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T19:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTY4NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447911685", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2017, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2017,2020", "author": "prb112", "createdAt": "2020-06-30T18:58:11Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCDeleteTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2017,2019\n+ * (C) Copyright IBM Corp. 2017, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MzIzOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447943238", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTg4NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447911885", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2018, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2018,2020", "author": "prb112", "createdAt": "2020-06-30T18:58:35Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCMultiResourceTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * (C) Copyright IBM Corp. 2018,2019\n+ * (C) Copyright IBM Corp. 2018, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MzM0Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447943347", "bodyText": "agreed to ignore", "author": "prb112", "createdAt": "2020-06-30T19:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMTg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMjAxMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447912012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2017, 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2017,2020", "author": "prb112", "createdAt": "2020-06-30T18:58:50Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/JDBCPagingTest.java", "diffHunk": "@@ -1,13 +1,19 @@\n /*\n- * (C) Copyright IBM Corp. 2017,2019\n+ * (C) Copyright IBM Corp. 2017, 2019, 2020", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMjc4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447912780", "bodyText": "This is no longer used", "author": "prb112", "createdAt": "2020-06-30T19:00:09Z", "path": "operation/fhir-operation-healthcheck/src/main/java/com/ibm/fhir/operation/healthcheck/HealthcheckOperation.java", "diffHunk": "@@ -19,12 +20,15 @@\n import com.ibm.fhir.model.resource.Resource;\n import com.ibm.fhir.model.type.code.IssueSeverity;\n import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n import com.ibm.fhir.server.operation.spi.AbstractOperation;\n import com.ibm.fhir.server.operation.spi.FHIROperationContext;\n import com.ibm.fhir.server.operation.spi.FHIRResourceHelpers;\n import com.ibm.fhir.server.util.FHIROperationUtil;\n \n public class HealthcheckOperation extends AbstractOperation {\n+    private static final Logger logger = Logger.getLogger(HealthcheckOperation.class.getName());\n+    ", "originalCommit": "79399381a28991fd477c8d9064b82da9c3282b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyNDYxOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447924619", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T19:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMjc4MA=="}], "type": "inlineReview"}, {"oid": "4460020daaf15e89809e3b2642d461c23498dfc3", "url": "https://github.com/IBM/FHIR/commit/4460020daaf15e89809e3b2642d461c23498dfc3", "message": "issue-1144 additional review cleanup\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-30T19:27:16Z", "type": "commit"}, {"oid": "11b5d0ae08727be12304796316b50bfbdf0aee22", "url": "https://github.com/IBM/FHIR/commit/11b5d0ae08727be12304796316b50bfbdf0aee22", "message": "issue-1144 another review comment cleanup\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-30T21:17:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI4NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:33:03Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTenantDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Uses datasource and tenant ids configured in the fhir-server-config to\n+ * map directly to a managed datasource. All managed datasources must be\n+ * available when the server starts. This differs from the proxy\n+ * datasource strategy {@link FHIRDbPropsConnectionStrategy} which supports\n+ * dynamic (programmatic) definition of managed datasources.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbTenantDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbDAOImpl.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final long NANOMS = 1000000;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceBaseName = \"jdbc/fhir_\";\n+\n+    // Cache of datasources we've found\n+    private final Map<String, DataSource> datasourceMap = new ConcurrentHashMap<>();\n+    \n+    // the flavor of the database we are configured to represent\n+    private final FHIRDbFlavor flavor;\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbTenantDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+\n+        // Find the base JNDI name of the datasource we want to use\n+        try {\n+//            this.datasourceBaseName =\n+//                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+//                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);\n+            \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Using datasource JNDI name: \" + datasourceBaseName);\n+            }\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure to find proxy datasource in FHIR server configuration\"), e);\n+            throw fx;\n+        }\n+        \n+        this.flavor = createFlavor();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583296", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#getFlavor()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:33:20Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTenantDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Uses datasource and tenant ids configured in the fhir-server-config to\n+ * map directly to a managed datasource. All managed datasources must be\n+ * available when the server starts. This differs from the proxy\n+ * datasource strategy {@link FHIRDbPropsConnectionStrategy} which supports\n+ * dynamic (programmatic) definition of managed datasources.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbTenantDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbDAOImpl.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final long NANOMS = 1000000;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceBaseName = \"jdbc/fhir_\";\n+\n+    // Cache of datasources we've found\n+    private final Map<String, DataSource> datasourceMap = new ConcurrentHashMap<>();\n+    \n+    // the flavor of the database we are configured to represent\n+    private final FHIRDbFlavor flavor;\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbTenantDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+\n+        // Find the base JNDI name of the datasource we want to use\n+        try {\n+//            this.datasourceBaseName =\n+//                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+//                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);\n+            \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Using datasource JNDI name: \" + datasourceBaseName);\n+            }\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure to find proxy datasource in FHIR server configuration\"), e);\n+            throw fx;\n+        }\n+        \n+        this.flavor = createFlavor();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        Connection connection = null;\n+        final String METHODNAME = \"getConnection\";\n+\n+        if (log.isLoggable(Level.FINEST)) {\n+            log.entering(CLASSNAME, METHODNAME);\n+        }\n+        \n+        // the dsId/tenantId specific datasource we need to locate\n+        DataSource datasource;\n+        \n+        // Resources can be routed to different databases using the dsId currently\n+        // set on the context.\n+        String tenantId = FHIRRequestContext.get().getTenantId();\n+        String dsId = FHIRRequestContext.get().getDataStoreId();\n+        \n+        // this is the important bit...how we name our actual datasources\n+        final String datasourceName = datasourceBaseName + tenantId + \"_\" + dsId;\n+        \n+        // Note: we don't need any synchronization around ConcurrentHashMap, but that\n+        // doesn't change the fact that we may look up the datasource and put it into\n+        // the map more than once. That's fine. There aren't any integrity issues, just\n+        // the chance of doing more work than necessary a single time, but we avoid the\n+        // need for any synchronization. We cache locally, because we've found that JNDI\n+        // lookups can become a bottleneck with high concurrency\n+        datasource = datasourceMap.get(datasourceName);\n+        if (datasource == null) {\n+            // cache miss\n+            try {\n+                InitialContext ctxt = new InitialContext();\n+                \n+                datasource = (DataSource) ctxt.lookup(datasourceName);\n+                datasourceMap.put(datasourceName, datasource);\n+            } catch (Throwable e) {\n+                // don't emit secrets in exceptions\n+                FHIRPersistenceDBConnectException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+                throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceName, e);\n+            } finally {\n+                if (log.isLoggable(Level.FINEST)) {\n+                    log.exiting(CLASSNAME, METHODNAME);\n+                }\n+            }\n+        }\n+        \n+        long start = System.nanoTime();\n+        if (log.isLoggable(Level.FINE)) {\n+            log.fine(\"Getting connection for tenantId/dsId: [\" + tenantId + \"/\" + dsId + \"]...\");\n+        }\n+\n+        // Now use the dsId/tenantId specific JEE datasource to get a connection\n+        try {\n+            connection = getConnection(datasource, tenantId, dsId);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                long deltams = (System.nanoTime() - start) / NANOMS;\n+                log.fine(\"Got the connection for [\" + tenantId + \"/\" + dsId + \"]. Took \" + deltams + \" ms\");\n+            }\n+        } catch (Throwable e) {\n+            // Don't emit secrets in case they are returned to a client\n+            FHIRPersistenceDBConnectException fx =\n+                    new FHIRPersistenceDBConnectException(\"Failure acquiring connection for datasource\");\n+            throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceName, e);\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+        \n+        return connection;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#getFlavor()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzMwMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583303", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:33:35Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTenantDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Uses datasource and tenant ids configured in the fhir-server-config to\n+ * map directly to a managed datasource. All managed datasources must be\n+ * available when the server starts. This differs from the proxy\n+ * datasource strategy {@link FHIRDbPropsConnectionStrategy} which supports\n+ * dynamic (programmatic) definition of managed datasources.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbTenantDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbDAOImpl.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final long NANOMS = 1000000;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceBaseName = \"jdbc/fhir_\";\n+\n+    // Cache of datasources we've found\n+    private final Map<String, DataSource> datasourceMap = new ConcurrentHashMap<>();\n+    \n+    // the flavor of the database we are configured to represent\n+    private final FHIRDbFlavor flavor;\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbTenantDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+\n+        // Find the base JNDI name of the datasource we want to use\n+        try {\n+//            this.datasourceBaseName =\n+//                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+//                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);\n+            \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Using datasource JNDI name: \" + datasourceBaseName);\n+            }\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure to find proxy datasource in FHIR server configuration\"), e);\n+            throw fx;\n+        }\n+        \n+        this.flavor = createFlavor();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        Connection connection = null;\n+        final String METHODNAME = \"getConnection\";\n+\n+        if (log.isLoggable(Level.FINEST)) {\n+            log.entering(CLASSNAME, METHODNAME);\n+        }\n+        \n+        // the dsId/tenantId specific datasource we need to locate\n+        DataSource datasource;\n+        \n+        // Resources can be routed to different databases using the dsId currently\n+        // set on the context.\n+        String tenantId = FHIRRequestContext.get().getTenantId();\n+        String dsId = FHIRRequestContext.get().getDataStoreId();\n+        \n+        // this is the important bit...how we name our actual datasources\n+        final String datasourceName = datasourceBaseName + tenantId + \"_\" + dsId;\n+        \n+        // Note: we don't need any synchronization around ConcurrentHashMap, but that\n+        // doesn't change the fact that we may look up the datasource and put it into\n+        // the map more than once. That's fine. There aren't any integrity issues, just\n+        // the chance of doing more work than necessary a single time, but we avoid the\n+        // need for any synchronization. We cache locally, because we've found that JNDI\n+        // lookups can become a bottleneck with high concurrency\n+        datasource = datasourceMap.get(datasourceName);\n+        if (datasource == null) {\n+            // cache miss\n+            try {\n+                InitialContext ctxt = new InitialContext();\n+                \n+                datasource = (DataSource) ctxt.lookup(datasourceName);\n+                datasourceMap.put(datasourceName, datasource);\n+            } catch (Throwable e) {\n+                // don't emit secrets in exceptions\n+                FHIRPersistenceDBConnectException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+                throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceName, e);\n+            } finally {\n+                if (log.isLoggable(Level.FINEST)) {\n+                    log.exiting(CLASSNAME, METHODNAME);\n+                }\n+            }\n+        }\n+        \n+        long start = System.nanoTime();\n+        if (log.isLoggable(Level.FINE)) {\n+            log.fine(\"Getting connection for tenantId/dsId: [\" + tenantId + \"/\" + dsId + \"]...\");\n+        }\n+\n+        // Now use the dsId/tenantId specific JEE datasource to get a connection\n+        try {\n+            connection = getConnection(datasource, tenantId, dsId);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                long deltams = (System.nanoTime() - start) / NANOMS;\n+                log.fine(\"Got the connection for [\" + tenantId + \"/\" + dsId + \"]. Took \" + deltams + \" ms\");\n+            }\n+        } catch (Throwable e) {\n+            // Don't emit secrets in case they are returned to a client\n+            FHIRPersistenceDBConnectException fx =\n+                    new FHIRPersistenceDBConnectException(\"Failure acquiring connection for datasource\");\n+            throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceName, e);\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+        \n+        return connection;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#getFlavor()\n+     */\n+    @Override\n+    public FHIRDbFlavor getFlavor() throws FHIRPersistenceDataAccessException {\n+        return this.flavor;\n+    }\n+\n+    /**\n+     * Identify the flavor of the database using information from the\n+     * datasource configuration.\n+     * TODO duplicate code in FHIRDbConnectionStrategyBase. Refactor\n+     * @return\n+     * @throws FHIRPersistenceException\n+     */\n+    private FHIRDbFlavor createFlavor() throws FHIRPersistenceDataAccessException {\n+        FHIRDbFlavor result;\n+        \n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        // Find and set the tenantKey for the request, otherwise subsequent pulls from the pool\n+        // miss the tenantKey.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            \n+            try {\n+                boolean multitenant = false;\n+                String typeValue = dsPG.getStringProperty(\"type\");\n+                \n+                DbType type = DbType.from(typeValue);\n+                if (type == DbType.DB2) {\n+                    // We make this absolute for now. May change in the future if we\n+                    // support a single-tenant schema in DB2.\n+                    multitenant = true;\n+                }\n+                \n+                result = new FHIRDbFlavorImpl(type, multitenant);\n+            }\n+            catch (Exception x) {\n+                log.log(Level.SEVERE, \"No type property found for datastore '\" + datastoreId + \"'\", x);\n+                throw new FHIRPersistenceDataAccessException(\"Datastore configuration issue. Details in server logs\");\n+            }\n+        } else {\n+            log.log(Level.SEVERE, \"Missing datastore configuration for '\" + datastoreId + \"'\");\n+            throw new FHIRPersistenceDataAccessException(\"Datastore configuration issue. Details in server logs\");\n+        }\n+        \n+        return result;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzM2NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583364", "bodyText": "missing a parameter\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 */\n          \n          \n            \n                 * @param action\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:34:12Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTestConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy object is local to a thread, and because we use the same\n+ * underlying connection to our test database within a transaction, we\n+ * only need to configure the connection once. We can track this initialization\n+ * with nothing more complicated than a Boolean flag.\n+ * \n+ * Use by unit tests or other scenarios where connections are obtained using an\n+ * IConnectionProvider implementation, outside the scope of a JEE container. For\n+ * example, this is used when connecting to in-memory instances of Derby when\n+ * running persistence layer unit-tests.\n+ * \n+ */\n+public class FHIRDbTestConnectionStrategy implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbTestConnectionStrategy.class.getName());\n+    \n+    // Provides connections when outside of a container\n+    private final IConnectionProvider connectionProvider;\n+    \n+    private boolean initialized = false;\n+\n+    // Action to take to initialize a new connection\n+    private final Action action;\n+    \n+    // The type and capability of the database we connect to\n+    private final FHIRDbFlavor flavor;\n+            \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzM4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583380", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            catch (Throwable t) {\n          \n          \n            \n                            } catch (Throwable t) {", "author": "prb112", "createdAt": "2020-06-28T00:34:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTestConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy object is local to a thread, and because we use the same\n+ * underlying connection to our test database within a transaction, we\n+ * only need to configure the connection once. We can track this initialization\n+ * with nothing more complicated than a Boolean flag.\n+ * \n+ * Use by unit tests or other scenarios where connections are obtained using an\n+ * IConnectionProvider implementation, outside the scope of a JEE container. For\n+ * example, this is used when connecting to in-memory instances of Derby when\n+ * running persistence layer unit-tests.\n+ * \n+ */\n+public class FHIRDbTestConnectionStrategy implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbTestConnectionStrategy.class.getName());\n+    \n+    // Provides connections when outside of a container\n+    private final IConnectionProvider connectionProvider;\n+    \n+    private boolean initialized = false;\n+\n+    // Action to take to initialize a new connection\n+    private final Action action;\n+    \n+    // The type and capability of the database we connect to\n+    private final FHIRDbFlavor flavor;\n+            \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRDbTestConnectionStrategy(IConnectionProvider cp, Action action) {\n+        this.connectionProvider = cp;\n+        this.action = action;\n+\n+        // we don't support multi-tenancy in our unit-test database\n+        flavor = new FHIRDbFlavorImpl(cp.getTranslator().getType(), false);\n+    }\n+\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        try {\n+            // The connection we get from this connection provider will be wrapped, so it\n+            // can be closed by the caller.\n+            Connection result = connectionProvider.getConnection();\n+\n+            if (!this.initialized) {\n+                log.fine(\"Initializing new connection\");\n+                try {\n+                    // actions are optional so may be null\n+                    if (action != null) {\n+                        action.performOn(result);\n+                    }\n+                    this.initialized = true;\n+                    \n+                    log.fine(\"Connection initialized\");\n+                }\n+                catch (Throwable t) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzQwMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583401", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-28T00:34:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTestConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy object is local to a thread, and because we use the same\n+ * underlying connection to our test database within a transaction, we\n+ * only need to configure the connection once. We can track this initialization\n+ * with nothing more complicated than a Boolean flag.\n+ * \n+ * Use by unit tests or other scenarios where connections are obtained using an\n+ * IConnectionProvider implementation, outside the scope of a JEE container. For\n+ * example, this is used when connecting to in-memory instances of Derby when\n+ * running persistence layer unit-tests.\n+ * \n+ */\n+public class FHIRDbTestConnectionStrategy implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbTestConnectionStrategy.class.getName());\n+    \n+    // Provides connections when outside of a container\n+    private final IConnectionProvider connectionProvider;\n+    \n+    private boolean initialized = false;\n+\n+    // Action to take to initialize a new connection\n+    private final Action action;\n+    \n+    // The type and capability of the database we connect to\n+    private final FHIRDbFlavor flavor;\n+            \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRDbTestConnectionStrategy(IConnectionProvider cp, Action action) {\n+        this.connectionProvider = cp;\n+        this.action = action;\n+\n+        // we don't support multi-tenancy in our unit-test database\n+        flavor = new FHIRDbFlavorImpl(cp.getTranslator().getType(), false);\n+    }\n+\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        try {\n+            // The connection we get from this connection provider will be wrapped, so it\n+            // can be closed by the caller.\n+            Connection result = connectionProvider.getConnection();\n+\n+            if (!this.initialized) {\n+                log.fine(\"Initializing new connection\");\n+                try {\n+                    // actions are optional so may be null\n+                    if (action != null) {\n+                        action.performOn(result);\n+                    }\n+                    this.initialized = true;\n+                    \n+                    log.fine(\"Connection initialized\");\n+                }\n+                catch (Throwable t) {\n+                    // inialization failed, but the connection is open so we need to close it\n+                    log.severe(\"Connection initialization failed\");\n+                    result.close();\n+                    throw t;\n+                }\n+            }\n+            \n+            return result;\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzQ4Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583487", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:35:41Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionAdapter.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.ITransaction;\n+import com.ibm.fhir.database.utils.transaction.SimpleTransactionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Use by unit tests or other scenarios where connections are obtained using an\n+ * IConnectionProvider implementation, outside the scope of a JEE container.\n+ * Transactions are managed with the help of the SimpleTransactionProvider and\n+ * wrapped by this class, meaning we have a uniform interface for handling\n+ * transactions across JEE and unit-test scenarios.\n+ * \n+ */\n+public class FHIRTestTransactionAdapter implements FHIRPersistenceTransaction {\n+    private static final Logger log = Logger.getLogger(FHIRDbTestConnectionStrategy.class.getName());\n+    \n+    // Provides connections when outside of a container\n+    private final IConnectionProvider connectionProvider;\n+    \n+    // Support transactions for the persistence unit tests\n+    private final SimpleTransactionProvider transactionProvider;\n+    \n+    // Just in case we have nesting issues, use ThreadLocal to track the current tx\n+    private final ThreadLocal<ITransaction> currentTransaction = new ThreadLocal<>();\n+    \n+    // Was this instance responsible for starting the transaction\n+    private boolean startedByThis;\n+    \n+    // support nesting by tracking the number of begin/end requests\n+    private int startCount;\n+        \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRTestTransactionAdapter(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+\n+        // provide transaction support for our tests\n+        this.transactionProvider = new SimpleTransactionProvider(this.connectionProvider);\n+    }\n+\n+    @Override\n+    public void begin() throws FHIRPersistenceException {\n+        if (currentTransaction.get() == null) {\n+            // allocate a new transaction\n+            this.currentTransaction.set(this.transactionProvider.getTransaction());\n+            this.startedByThis = true;\n+        }\n+        \n+        // add to the start request counter every time. We only close when this\n+        // counter reaches 0.\n+        startCount++;\n+    }\n+\n+    @Override\n+    public void end() throws FHIRPersistenceException {\n+        if (currentTransaction.get() == null) {\n+            throw new FHIRPersistenceDataAccessException(\"Transaction not started\");\n+        }\n+        \n+        try {\n+            // only end it if we started it\n+            if (startedByThis && --startCount == 0) {\n+                this.currentTransaction.get().close();\n+            }\n+        }\n+        catch (Throwable x) {\n+            // translate to a FHIRPersistenceException\n+            FHIRPersistenceException fx = new FHIRPersistenceException(\"Unexpected error while committing a transaction.\");\n+            log.log(Level.SEVERE, fx.getMessage(), x);\n+            throw fx;\n+        }\n+        finally {\n+            this.currentTransaction.set(null);\n+            this.startedByThis = false;\n+        }\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() throws FHIRPersistenceException {\n+        if (currentTransaction.get() == null) {\n+            throw new FHIRPersistenceDataAccessException(\"Transaction not started\");\n+        }\n+\n+        // always mark the transaction for rollback, even if not started by this\n+        this.currentTransaction.get().setRollbackOnly();\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzQ5NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583495", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.FHIRTransactionFactory#create()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:36:01Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionFactory.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+\n+\n+/**\n+ * Factory/strategy to instantiate FHIRTestTransactionHandler implementations\n+ * of the {@link FHIRPersistenceTransaction} interface. Typically used\n+ * to support unit-tests\n+ */\n+public class FHIRTestTransactionFactory implements FHIRTransactionFactory {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     */\n+    public FHIRTestTransactionFactory(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRTransactionFactory#create()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzUyMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583523", "bodyText": "missing the parameter javadoc", "author": "prb112", "createdAt": "2020-06-28T00:36:17Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRTestTransactionFactory.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+\n+\n+/**\n+ * Factory/strategy to instantiate FHIRTestTransactionHandler implementations\n+ * of the {@link FHIRPersistenceTransaction} interface. Typically used\n+ * to support unit-tests\n+ */\n+public class FHIRTestTransactionFactory implements FHIRTransactionFactory {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NTYzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447795637", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T15:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzU2NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583564", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Public constructor\n          \n          \n            \n                 * @param strat\n          \n          \n            \n                 * Public constructor\n          \n          \n            \n                 * @param tx", "author": "prb112", "createdAt": "2020-06-28T00:36:48Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRUserTransactionAdapter.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.Status;\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Adapter to simplify transaction handling. This object is returned by\n+ * FHIRPersistenceJDBCImpl and can be used instead of the old FHIRTransactionHelper\n+ */\n+public class FHIRUserTransactionAdapter implements FHIRPersistenceTransaction {\n+    private static final Logger log = Logger.getLogger(FHIRUserTransactionAdapter.class.getName());\n+    \n+    // The connection strategy handling the underlying transaction object\n+    private final UserTransaction userTransaction;\n+    \n+    // Did this instance start the transaction?\n+    private boolean startedByThis;\n+    \n+    // support nesting by tracking the number of begin/end requests\n+    private int startCount;\n+    \n+    /**\n+     * Public constructor\n+     * @param strat", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzU5Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583597", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:37:29Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRUserTransactionFactory.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+\n+/**\n+ * Factory implementation for creating new instances of FHIRTransactionImpl\n+ * referencing a given {@link UserTransaction} object\n+ */\n+public class FHIRUserTransactionFactory implements FHIRTransactionFactory {\n+    // The UserTransaction object used to create the objects we manufacture\n+    private final UserTransaction userTransaction;\n+\n+    /**\n+     * Public constructor\n+     * @param tx\n+     */\n+    public FHIRUserTransactionFactory(UserTransaction tx) {\n+        this.userTransaction = tx;\n+    }\n+    \n+    @Override\n+    public FHIRPersistenceTransaction create() {\n+        return new FHIRUserTransactionAdapter(userTransaction);\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzYzNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583634", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:37:56Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SchemaNameFromProps.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Properties;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Returns a constant schemaName. Useful for unit test configurations\n+ */\n+public class SchemaNameFromProps implements SchemaNameSupplier { \n+\n+    // The constant schema name we supply\n+    private final String schemaName;\n+ \n+    /**\n+     * Public constructor\n+     * @param configProps should contain the \"schemaName\" property\n+     */\n+    public SchemaNameFromProps(Properties configProps) {\n+        // get the schema name from the configuration properties\n+        this.schemaName = configProps.getProperty(\"schemaName\", null);\n+    }\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName constant\n+     */\n+    public SchemaNameFromProps(String schemaName) {\n+        this.schemaName = schemaName;\n+    }\n+\n+    @Override\n+    public String getSchemaForRequestContext(Connection connection) throws FHIRPersistenceDBConnectException {\n+        return this.schemaName;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzY0MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583640", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (SQLException x) {\n          \n          \n            \n                        } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-28T00:38:14Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SchemaNameImpl.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Supplier which tries to obtain the schema name from the given delegate,\n+ * falling back to calling getSchema() from the connection if the supplier\n+ * returns a null\n+ */\n+public class SchemaNameImpl implements SchemaNameSupplier { \n+    private static final Logger logger = Logger.getLogger(SchemaNameImpl.class.getName());\n+    \n+    // the delegate we use ask for the schema name\n+    private final SchemaNameSupplier delegate;\n+\n+    /**\n+     * Public constructor\n+     * @param delegate\n+     * @param connection\n+     */\n+    public SchemaNameImpl(SchemaNameSupplier delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public String getSchemaForRequestContext(Connection connection) throws FHIRPersistenceDBConnectException {\n+        String result = delegate.getSchemaForRequestContext(connection);\n+        if (result == null) {\n+            try {\n+                // fall back to getting the name of the schema from the connection\n+                // which is slower. We need this because \"currentSchema\" isn't\n+                // a supported property in the Derby datasource properties.\n+                if (result == null) {\n+                    // log a warning...the schema name will have to be obtained from the\n+                    // connection later...which is slower because it requires a DB round-trip\n+                    logger.warning(\"Calling Connection#getSchema() to obtain schema name. Put schema name in configuration for better performance\");\n+                }\n+                \n+                result = connection.getSchema();\n+                \n+                if (logger.isLoggable(Level.FINE)) {\n+                    logger.fine(\"schema name from connection: \" + result);\n+                }\n+            }\n+            catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzY1MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583651", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:38:23Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SchemaNameImpl.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Supplier which tries to obtain the schema name from the given delegate,\n+ * falling back to calling getSchema() from the connection if the supplier\n+ * returns a null\n+ */\n+public class SchemaNameImpl implements SchemaNameSupplier { \n+    private static final Logger logger = Logger.getLogger(SchemaNameImpl.class.getName());\n+    \n+    // the delegate we use ask for the schema name\n+    private final SchemaNameSupplier delegate;\n+\n+    /**\n+     * Public constructor\n+     * @param delegate\n+     * @param connection\n+     */\n+    public SchemaNameImpl(SchemaNameSupplier delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public String getSchemaForRequestContext(Connection connection) throws FHIRPersistenceDBConnectException {\n+        String result = delegate.getSchemaForRequestContext(connection);\n+        if (result == null) {\n+            try {\n+                // fall back to getting the name of the schema from the connection\n+                // which is slower. We need this because \"currentSchema\" isn't\n+                // a supported property in the Derby datasource properties.\n+                if (result == null) {\n+                    // log a warning...the schema name will have to be obtained from the\n+                    // connection later...which is slower because it requires a DB round-trip\n+                    logger.warning(\"Calling Connection#getSchema() to obtain schema name. Put schema name in configuration for better performance\");\n+                }\n+                \n+                result = connection.getSchema();\n+                \n+                if (logger.isLoggable(Level.FINE)) {\n+                    logger.fine(\"schema name from connection: \" + result);\n+                }\n+            }\n+            catch (SQLException x) {\n+                throw new FHIRPersistenceDBConnectException(\"Unable to obtain schema name from connection\", x);\n+            }\n+        }\n+        return result;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzY4NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583684", "bodyText": "You are missing the right names", "author": "prb112", "createdAt": "2020-06-28T00:39:04Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetSchemaAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to set the named schema on a connection\n+ */\n+public class SetSchemaAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetSchemaAction.class.getName());\n+\n+    // supplier to obtain the schema name when we need it\n+    private final SchemaNameSupplier schemaNameSupplier;\n+    \n+    /**\n+     * Use a provided schema name (handy for testing)\n+     * @param schemaName", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNDI0MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447024240", "bodyText": "?", "author": "punktilious", "createdAt": "2020-06-29T14:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1OTAwNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447959006", "bodyText": "Does this comment refer to javadoc? It should be correct.", "author": "punktilious", "createdAt": "2020-06-30T20:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzcwOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583708", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:39:20Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetSchemaAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to set the named schema on a connection\n+ */\n+public class SetSchemaAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetSchemaAction.class.getName());\n+\n+    // supplier to obtain the schema name when we need it\n+    private final SchemaNameSupplier schemaNameSupplier;\n+    \n+    /**\n+     * Use a provided schema name (handy for testing)\n+     * @param schemaName\n+     */\n+    public SetSchemaAction(SchemaNameSupplier schemaNameSupplier, Action next) {\n+        super(next);\n+        this.schemaNameSupplier = schemaNameSupplier;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzcxOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583719", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:39:34Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetSchemaAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to set the named schema on a connection\n+ */\n+public class SetSchemaAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetSchemaAction.class.getName());\n+\n+    // supplier to obtain the schema name when we need it\n+    private final SchemaNameSupplier schemaNameSupplier;\n+    \n+    /**\n+     * Use a provided schema name (handy for testing)\n+     * @param schemaName\n+     */\n+    public SetSchemaAction(SchemaNameSupplier schemaNameSupplier, Action next) {\n+        super(next);\n+        this.schemaNameSupplier = schemaNameSupplier;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n+     */\n+    @Override\n+    public void performOn(Connection c) throws FHIRPersistenceDBConnectException {\n+        // this is being called the first time we've seen a connection for this\n+        // particular datastore. Find out which schema is configured, and make\n+        // sure it is set as the current schema.\n+        String schemaName = schemaNameSupplier.getSchemaForRequestContext(c);\n+        if (schemaName != null) {\n+            try {\n+                log.severe(\"Calling setSchema(...) may break connection pool/transaction manager\");\n+                c.setSchema(schemaName);\n+            } catch (SQLException x) {\n+                log.log(Level.SEVERE, \"failed to set current schema '\" + schemaName + \"'\");\n+                \n+                // schemaName is a secret, so don't emit in the exception to avoid propagating to client\n+                throw new FHIRPersistenceDBConnectException(\"Failed setting schema on connection\");\n+            }\n+        } else {\n+            // rare\n+            log.fine(\"schemaName is null, so skipping setSchema() on connection\");\n+        }\n+        \n+        // call the next action in the chain\n+        super.performOn(c);\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mzc2MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583761", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (Exception x) {\n          \n          \n            \n                        } catch (Exception x) {", "author": "prb112", "createdAt": "2020-06-28T00:40:07Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetTenantAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.api.BadTenantFrozenException;\n+import com.ibm.fhir.database.utils.api.BadTenantKeyException;\n+import com.ibm.fhir.database.utils.api.BadTenantNameException;\n+import com.ibm.fhir.database.utils.common.JdbcTarget;\n+import com.ibm.fhir.database.utils.db2.Db2Adapter;\n+import com.ibm.fhir.database.utils.db2.Db2SetTenantVariable;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+/**\n+ * Set the tenant variable in the session (part of Db2 multi-tenancy\n+ * support). This needs to be executed at the beginning of an\n+ * interaction with a database connection, before any other\n+ * DML/SQL.\n+ */\n+public class SetTenantAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetTenantAction.class.getName());\n+    \n+    // Used to indicate the default behavior of a datastore as multitenant.\n+    public static final List<String> DATASTORE_REQUIRES_ROW_PERMISSIONS = Arrays.asList(\"db2\");\n+\n+    /**\n+     * Default public constructor. No next action, so this will be the last action applied\n+     */\n+    public SetTenantAction() {\n+        super();\n+    }\n+    \n+    /**\n+     * Public constructor\n+     * @param next the next action in the chain\n+     */\n+    public SetTenantAction(Action next) {\n+        super(next);\n+    }\n+\n+\n+    @Override\n+    public void performOn(Connection c) throws FHIRPersistenceDBConnectException {\n+        \n+        configureTenantAccess(c);\n+        \n+        // perform next action in the chain\n+        super.performOn(c);\n+    }\n+\n+    /**\n+     * Find the tenantKey for the datasource/tenant from the FHIR server configuration\n+     * and use it to set up the connection for access by this tenant by setting \n+     * the SV_TENANT_ID session variable (via the FHIR_ADMIN.SET_TENANT stored procedure).\n+     * Note that the database user we connect as does not have direct access to WRITE\n+     * to the SV_TENANT_ID...it can only be set through the SET_TENANT call, for which\n+     * we have been explicitly granted execute privilege.\n+     *\n+     * @param connection the connection to configure\n+     * @throws FHIRPersistenceException if the configuration fails\n+     */\n+    public void configureTenantAccess(Connection connection) throws FHIRPersistenceDBConnectException {\n+        boolean multiTenantFeature = false;\n+        String tenantKey = null;\n+        \n+        // Get the datastore and tenant from the request context\n+        String tenantName = FHIRRequestContext.get().getTenantId();\n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        // Find and set the tenantKey for the request, otherwise subsequent pulls from the pool\n+        // miss the tenantKey.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            \n+            try {\n+                tenantKey = dsPG.getStringProperty(\"tenantKey\", null);\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.finer(\"tenantKey is null? = [\" + Objects.isNull(tenantKey) + \"]\");\n+                }\n+    \n+                // Specific to Db2 right now, we want to switch behavior if multitenant row level permission is required.\n+                String type = dsPG.getStringProperty(\"type\", null);\n+                if (type != null) {\n+                    // Based on the default for the database type, the code.\n+                    multiTenantFeature =\n+                            dsPG.getBooleanProperty(\"multitenant\", DATASTORE_REQUIRES_ROW_PERMISSIONS.contains(type));\n+                }\n+            }\n+            catch (Exception x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzgzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583837", "bodyText": "Please update the copyright year to 2017, 2020", "author": "prb112", "createdAt": "2020-06-28T00:40:54Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/api/ParameterDAO.java", "diffHunk": "@@ -6,7 +6,6 @@\n \n package com.ibm.fhir.persistence.jdbc.dao.api;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mzg1NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583855", "bodyText": "Why have the constants if these still exist?", "author": "prb112", "createdAt": "2020-06-28T00:41:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/api/FHIRDbDAO.java", "diffHunk": "@@ -21,32 +21,18 @@\n     public static final String PROPERTY_DB2_PSWD = \"password\";", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNzYwMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447027603", "bodyText": "should be refactored...although this is now probably dead code, so some cleanup is required. Will create a separate issue.", "author": "punktilious", "createdAt": "2020-06-29T14:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MDY2OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447960669", "bodyText": "issue #1305 to track.", "author": "punktilious", "createdAt": "2020-06-30T20:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mzg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzkwNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583907", "bodyText": "I don't think we. should reference a date (reference a tag) 4.3.0", "author": "prb112", "createdAt": "2020-06-28T00:42:14Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/FHIRDbDAOImpl.java", "diffHunk": "@@ -7,96 +7,86 @@\n package com.ibm.fhir.persistence.jdbc.dao.impl;\n \n import java.sql.Connection;\n-import java.sql.DriverManager;\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n-import java.sql.SQLException;\n import java.sql.Timestamp;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Properties;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n \n-import javax.naming.InitialContext;\n-import javax.sql.DataSource;\n-\n-import com.ibm.fhir.config.FHIRConfigHelper;\n-import com.ibm.fhir.config.FHIRConfiguration;\n-import com.ibm.fhir.config.FHIRRequestContext;\n-import com.ibm.fhir.config.PropertyGroup;\n-import com.ibm.fhir.database.utils.api.BadTenantFrozenException;\n-import com.ibm.fhir.database.utils.api.BadTenantKeyException;\n-import com.ibm.fhir.database.utils.api.BadTenantNameException;\n-import com.ibm.fhir.database.utils.api.IConnectionProvider;\n-import com.ibm.fhir.database.utils.common.JdbcTarget;\n-import com.ibm.fhir.database.utils.db2.Db2Adapter;\n-import com.ibm.fhir.database.utils.db2.Db2SetTenantVariable;\n-import com.ibm.fhir.exception.FHIRException;\n+\n+import com.ibm.fhir.database.utils.model.DbType;\n import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n import com.ibm.fhir.model.type.code.IssueType;\n import com.ibm.fhir.model.util.FHIRUtil;\n import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n import com.ibm.fhir.persistence.jdbc.JDBCConstants;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor;\n import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n import com.ibm.fhir.persistence.jdbc.dto.Resource;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n \n /**\n- * This class is a root Data Access Object for managing JDBC access to the FHIR database. It contains common functions\n- * for managing connections, closing used\n- * JDBC resources, and running database queries.\n+ * This class is a root Data Access Object for managing JDBC access to the FHIR database.\n+ * As of 2020-06-16, connection handling is factored out of the DAO and is instead the", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MTIzNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447961236", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mzk2MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583961", "bodyText": "Is this method necessary?", "author": "prb112", "createdAt": "2020-06-28T00:43:11Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/FHIRDbDAOImpl.java", "diffHunk": "@@ -574,29 +338,9 @@ protected Resource createDTO(ResultSet resultSet) throws FHIRPersistenceDataAcce\n         return null;\n     }\n \n-    private Properties getDbProps() {\n-        return dbProps;\n-    }\n-\n-    private void setDbProps(Properties dbProps) {\n-        this.dbProps = dbProps;\n-    }\n-\n-    @Override\n-    public Connection getExternalConnection() {\n-        return externalConnection;\n-    }\n-\n-    @Override\n-    public void setExternalConnection(Connection externalConnection) {\n-        this.externalConnection = externalConnection;\n-    }\n-\n     @Override\n-    public boolean isDb2Database() throws FHIRPersistenceDBConnectException, SQLException {\n-        String dbUrl = this.getConnection().getMetaData().getURL();\n-        dbUrl = dbUrl.toLowerCase();\n-        return dbUrl.contains(\"db2\");\n+    public boolean isDb2Database() {\n+        return this.flavor.getType() == DbType.DB2;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDA0OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584049", "bodyText": "What does this mean? Where is the error thrown now>?", "author": "prb112", "createdAt": "2020-06-28T00:44:52Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceDAOImpl.java", "diffHunk": "@@ -223,18 +234,19 @@ protected Resource createDTO(ResultSet resultSet) throws FHIRPersistenceDataAcce\n                 }\n             } else {\n                 stmtString = String.format(SQL_HISTORY, resourceType, resourceType);\n-                if (this.isDb2Database()) {\n+                if (isDb2Database()) {\n                     stmtString = stmtString + DB2_PAGINATION_PARMS;\n                     resources = this.runQuery(stmtString, logicalId, maxResults, offset);\n                 } else {\n                     stmtString = stmtString + DERBY_PAGINATION_PARMS;\n                     resources = this.runQuery(stmtString, logicalId, offset, maxResults);\n                 }\n             }\n-        } catch (SQLException e) {\n-            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure running history query\");\n-            String errMsg = \"Failure running history query: \" + stmtString;\n-            throw severe(log, fx, errMsg, e);\n+//        } \n+//        catch (SQLException e) {\n+//            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure running history query\");\n+//            String errMsg = \"Failure running history query: \" + stmtString;\n+//            throw severe(log, fx, errMsg, e);", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzNTM5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447035396", "bodyText": "This should be removed. The block no longer throws SQLException, so this particular catch is no longer required.", "author": "punktilious", "createdAt": "2020-06-29T14:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDE1MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584151", "bodyText": "Do we need this ?", "author": "prb112", "createdAt": "2020-06-28T00:46:11Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -154,61 +169,98 @@ public FHIRPersistenceJDBCImpl() throws Exception {\n         }\n         this.updateCreateEnabled = fhirConfig.getBooleanProperty(PROPERTY_UPDATE_CREATE_ENABLED, Boolean.TRUE);\n         this.userTransaction = retrieveUserTransaction(TXN_JNDI_NAME);\n+        \n+        if (userTransaction != null) {\n+            this.trxSynchRegistry = getTrxSynchRegistry();\n+        } else {\n+            this.trxSynchRegistry = null;\n+        }\n \n         ParameterNamesCache.setEnabled(fhirConfig.getBooleanProperty(PROPERTY_JDBC_ENABLE_PARAMETER_NAMES_CACHE,\n                                        Boolean.TRUE));\n         CodeSystemsCache.setEnabled(fhirConfig.getBooleanProperty(PROPERTY_JDBC_ENABLE_CODE_SYSTEMS_CACHE,\n                                     Boolean.TRUE));\n         ResourceTypesCache.setEnabled(fhirConfig.getBooleanProperty(PROPERTY_JDBC_ENABLE_RESOURCE_TYPES_CACHE,\n                                       Boolean.TRUE));\n-\n-        sharedConnection = this.createConnection();\n-        this.resourceDao = FHIRResourceDAOFactory.getResourceDAO(sharedConnection, this.getTrxSynchRegistry());\n-        this.parameterDao = new ParameterDAOImpl(this.getTrxSynchRegistry());\n+        \n+        //this.connectionStrategy = new FHIRDbTenantDatasourceConnectionStrategy(getTrxSynchRegistry(), buildActionChain());", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MjE3NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447962174", "bodyText": "I've removed for now, because we'll need something a little more sophisticated when we implement the simple datasource feature.", "author": "punktilious", "createdAt": "2020-06-30T20:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDE5MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584191", "bodyText": "Do we need this?", "author": "prb112", "createdAt": "2020-06-28T00:46:38Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -154,61 +169,98 @@ public FHIRPersistenceJDBCImpl() throws Exception {\n         }\n         this.updateCreateEnabled = fhirConfig.getBooleanProperty(PROPERTY_UPDATE_CREATE_ENABLED, Boolean.TRUE);\n         this.userTransaction = retrieveUserTransaction(TXN_JNDI_NAME);\n+        \n+        if (userTransaction != null) {\n+            this.trxSynchRegistry = getTrxSynchRegistry();\n+        } else {\n+            this.trxSynchRegistry = null;\n+        }\n \n         ParameterNamesCache.setEnabled(fhirConfig.getBooleanProperty(PROPERTY_JDBC_ENABLE_PARAMETER_NAMES_CACHE,\n                                        Boolean.TRUE));\n         CodeSystemsCache.setEnabled(fhirConfig.getBooleanProperty(PROPERTY_JDBC_ENABLE_CODE_SYSTEMS_CACHE,\n                                     Boolean.TRUE));\n         ResourceTypesCache.setEnabled(fhirConfig.getBooleanProperty(PROPERTY_JDBC_ENABLE_RESOURCE_TYPES_CACHE,\n                                       Boolean.TRUE));\n-\n-        sharedConnection = this.createConnection();\n-        this.resourceDao = FHIRResourceDAOFactory.getResourceDAO(sharedConnection, this.getTrxSynchRegistry());\n-        this.parameterDao = new ParameterDAOImpl(this.getTrxSynchRegistry());\n+        \n+        //this.connectionStrategy = new FHIRDbTenantDatasourceConnectionStrategy(getTrxSynchRegistry(), buildActionChain());\n+        \n+        // Set up the connection strategy for use within a JEE container. The actions\n+        // are processed the first time a connection is established to a particular tenant/datasource.\n+        this.schemaNameSupplier = new SchemaNameImpl(this);\n+        this.connectionStrategy = new FHIRDbProxyDatasourceConnectionStrategy(getTrxSynchRegistry(), buildActionChain());\n+        this.transactionAdapter = new FHIRUserTransactionAdapter(userTransaction);\n \n         log.exiting(CLASSNAME, METHODNAME);\n     }\n-\n+    \n     /**\n-     * Constructor for use when running standalone, outside of any web container.\n+     * Constructor for use when running standalone, outside of any web container. The\n+     * IConnectionProvider should be a pooling implementation which supports an\n+     * ITransactionProvider.\n+     * \n+     * @implNote This constructor is defined to simplify unit-tests\n      * @throws Exception\n      */\n-    public FHIRPersistenceJDBCImpl(Properties configProps) throws Exception {\n-        final String METHODNAME = \"FHIRPersistenceJDBCImpl(Properties)\";\n+    public FHIRPersistenceJDBCImpl(Properties configProps, IConnectionProvider cp) throws Exception {\n+        final String METHODNAME = \"FHIRPersistenceJDBCImpl(Properties, IConnectionProvider)\";\n         log.entering(CLASSNAME, METHODNAME);\n \n         this.updateCreateEnabled = Boolean.parseBoolean(configProps.getProperty(\"updateCreateEnabled\"));\n \n-        FHIRDbDAO dao = new FHIRDbDAOImpl(configProps);\n+        // not running inside a JEE container\n+        this.trxSynchRegistry = null;\n \n-        this.setBaseDao(dao);\n-        this.setManagedConnection(this.getBaseDao().getConnection());\n-        this.resourceDao = FHIRResourceDAOFactory.getResourceDAO(this.getManagedConnection());\n-        this.parameterDao = new ParameterDAOImpl(this.getManagedConnection());\n+        // use the schema name from the configProps, or the connection.getSchema if we have to\n+        this.schemaNameSupplier = new SchemaNameImpl(new SchemaNameFromProps(configProps));\n+        \n+        // Obtain connections from the IConnectionProvider (typically used in Derby-based test-cases)\n+        this.connectionStrategy = new FHIRDbTestConnectionStrategy(cp, buildActionChain());\n+        \n+        // For unit tests (outside of JEE), we also need our own mechanism for handling transactions\n+        this.transactionAdapter = new FHIRTestTransactionAdapter(cp);\n \n         log.exiting(CLASSNAME, METHODNAME);\n     }\n+    \n \n     /**\n      * Constructor for use when running standalone, outside of any web container.\n      * @throws Exception\n      */\n-    public FHIRPersistenceJDBCImpl(Properties configProps, IConnectionProvider cp) throws Exception {\n-        final String METHODNAME = \"FHIRPersistenceJDBCImpl(Properties, IConnectionProvider)\";\n-        log.entering(CLASSNAME, METHODNAME);\n-\n-        this.updateCreateEnabled = Boolean.parseBoolean(configProps.getProperty(\"updateCreateEnabled\"));\n-\n-        FHIRDbDAO dao = new FHIRDbDAOImpl(cp.getConnection());\n-\n-        this.setBaseDao(dao);\n-        this.setManagedConnection(this.getBaseDao().getConnection());\n-        this.resourceDao = FHIRResourceDAOFactory.getResourceDAO(this.getManagedConnection());\n-        this.parameterDao = new ParameterDAOImpl(this.getManagedConnection());\n-\n-        log.exiting(CLASSNAME, METHODNAME);\n+//    @Deprecated\n+//    public FHIRPersistenceJDBCImpl(Properties configProps) throws Exception {\n+//        final String METHODNAME = \"FHIRPersistenceJDBCImpl(Properties)\";\n+//        log.entering(CLASSNAME, METHODNAME);\n+//\n+//        this.updateCreateEnabled = Boolean.parseBoolean(configProps.getProperty(\"updateCreateEnabled\"));\n+//\n+//        // not running inside a JEE container\n+//        this.trxSynchRegistry = null;\n+//\n+//        // Obtain connections from DriverManager\n+//        this.schemaName = getSchema();\n+//\n+////        Action setSchema = new SetSchemaAction(schemaName);\n+////        Action setTenant = new SetTenantAction(setSchema);\n+//        this.connectionStrategy = new FHIRDbPropsConnectionStrategy(configProps);\n+//        \n+//\n+//        log.exiting(CLASSNAME, METHODNAME);\n+//    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MzEyNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447963127", "bodyText": "gone", "author": "punktilious", "createdAt": "2020-06-30T20:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDIyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584228", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    }\n          \n          \n            \n                                    else {\n          \n          \n            \n                                    } else {", "author": "prb112", "createdAt": "2020-06-28T00:47:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -499,15 +593,15 @@ public FHIRPersistenceJDBCImpl(Properties configProps, IConnectionProvider cp) t\n                         // Sorting results of a system-level search is limited, and has a different logic path\n                         // than other sorted searches.\n                         if (resourceType.equals(Resource.class)) {\n-                           resources = this.convertResourceDTOList(this.resourceDao.search(query), resourceType, elements);\n+                           resources = this.convertResourceDTOList(resourceDao.search(query), resourceType, elements);\n                         }\n                         else {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3ODc5OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447978799", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T21:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDI1Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                }\n          \n          \n            \n                                else {\n          \n          \n            \n                                } else {", "author": "prb112", "createdAt": "2020-06-28T00:47:36Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -499,15 +593,15 @@ public FHIRPersistenceJDBCImpl(Properties configProps, IConnectionProvider cp) t\n                         // Sorting results of a system-level search is limited, and has a different logic path\n                         // than other sorted searches.\n                         if (resourceType.equals(Resource.class)) {\n-                           resources = this.convertResourceDTOList(this.resourceDao.search(query), resourceType, elements);\n+                           resources = this.convertResourceDTOList(resourceDao.search(query), resourceType, elements);\n                         }\n                         else {\n-                            sortedIdList = this.resourceDao.searchForIds(query);\n-                            resources = this.buildSortedFhirResources(context, resourceType, sortedIdList, elements);\n+                            sortedIdList = resourceDao.searchForIds(query);\n+                            resources = this.buildSortedFhirResources(resourceDao, context, resourceType, sortedIdList, elements);\n                         }\n                     }\n                     else {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NzQ5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447977496", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T21:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDMxMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584310", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch(Throwable e) {\n          \n          \n            \n                        FHIRPersistenceException fx = new FHIRPersistenceException(\"Failed to acquire TrxSynchRegistry service\");\n          \n          \n            \n                    } catch(Throwable e) {\n          \n          \n            \n                        FHIRPersistenceException fx = new FHIRPersistenceException(\"Failed to acquire TrxSynchRegistry service\");", "author": "prb112", "createdAt": "2020-06-28T00:48:24Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -1011,22 +1115,17 @@ private String performCacheDiagnostics() {\n      * @throws FHIRPersistenceException\n      */\n     private TransactionSynchronizationRegistry getTrxSynchRegistry() throws FHIRPersistenceException {\n-\n         InitialContext ctxt;\n \n-        if (this.trxSynchRegistry == null) {\n-            try {\n-                ctxt = new InitialContext();\n-                this.trxSynchRegistry = (TransactionSynchronizationRegistry) ctxt.lookup(TRX_SYNCH_REG_JNDI_NAME);\n-            }\n-            catch(Throwable e) {\n-                FHIRPersistenceException fx = new FHIRPersistenceException(\"Failed to acquire TrxSynchRegistry service\");\n-                log.log(Level.SEVERE, fx.getMessage(), e);\n-                throw fx;\n-            }\n+        try {\n+            ctxt = new InitialContext();\n+            return (TransactionSynchronizationRegistry) ctxt.lookup(TRX_SYNCH_REG_JNDI_NAME);\n+        }\n+        catch(Throwable e) {\n+            FHIRPersistenceException fx = new FHIRPersistenceException(\"Failed to acquire TrxSynchRegistry service\");", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NDA2Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447964066", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDM0NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584345", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (Exception x) {\n          \n          \n            \n                        } catch (Exception x) {", "author": "prb112", "createdAt": "2020-06-28T00:49:12Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/impl/FHIRPersistenceJDBCImpl.java", "diffHunk": "@@ -1673,4 +1563,38 @@ private void addWarning(IssueType issueType, String message, String... expressio\n                 .expression(Arrays.stream(expression).map(com.ibm.fhir.model.type.String::string).collect(Collectors.toList()))\n                 .build());\n     }\n+    \n+    \n+    @Override\n+    public String getSchemaForRequestContext(Connection connection) throws FHIRPersistenceDBConnectException {\n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId + \"/connectionProperties\";\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            try {\n+                // If the currentSchema parameter isn't given, we have to\n+                // get it from the database when we have a connection.\n+                String currentSchema = dsPG.getStringProperty(\"currentSchema\", null);\n+                \n+                if (currentSchema == null) {\n+                    // Backup plan. Try getting it from the parent (datasource) property group\n+                    dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+                    dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+                    currentSchema = dsPG.getStringProperty(\"currentSchema\", null);\n+                }\n+\n+                // can be null\n+                return currentSchema;\n+            }\n+            catch (Exception x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NDQxNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447964414", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDM3NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584375", "bodyText": "parameters dont match javadoc", "author": "prb112", "createdAt": "2020-06-28T00:49:38Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -30,8 +30,8 @@\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c) {\n-        super(c);\n+    public PostgreSqlCodeSystemDAO(Connection c, String schemaName) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MTQzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447781431", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T15:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDUzNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584536", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:51:35Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchDateTest.java", "diffHunk": "@@ -27,12 +31,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDU2Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584567", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:51:48Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchDateTest.java", "diffHunk": "@@ -27,12 +31,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n+    }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n     }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDU3OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584579", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:52:12Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchIdLastUpdatedTest.java", "diffHunk": "@@ -27,12 +31,26 @@ public void bootstrapDatabase() throws Exception {\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n             derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n+    }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n     }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDY0Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584647", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:52:38Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchNumberTest.java", "diffHunk": "@@ -16,22 +18,39 @@\n \n public class JDBCSearchNumberTest extends AbstractSearchNumberTest {\n     private Properties testProps;\n+    \n+    private PoolConnectionProvider connectionPool;\n \n     public JDBCSearchNumberTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n+    }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n     }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDY2OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584669", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:52:56Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/search/test/JDBCSearchQuantityTest.java", "diffHunk": "@@ -17,22 +19,39 @@\n public class JDBCSearchQuantityTest extends AbstractSearchQuantityTest {\n \n     private Properties testProps;\n+    \n+    private PoolConnectionProvider connectionPool;\n \n     public JDBCSearchQuantityTest() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n     @Override\n     public void bootstrapDatabase() throws Exception {\n+        DerbyInitializer derbyInit;\n         String dbDriverName = this.testProps.getProperty(\"dbDriverName\");\n         if (dbDriverName != null && dbDriverName.contains(\"derby\")) {\n-            DerbyInitializer derbyInit = new DerbyInitializer(this.testProps);\n-            derbyInit.bootstrapDb();\n+            derbyInit = new DerbyInitializer(this.testProps);\n+            IConnectionProvider cp = derbyInit.getConnectionProvider(false);\n+            this.connectionPool = new PoolConnectionProvider(cp, 1);\n         }\n     }\n-\n+    \n     @Override\n     public FHIRPersistence getPersistenceImpl() throws Exception {\n-        return new FHIRPersistenceJDBCImpl(this.testProps);\n+        if (this.connectionPool == null) {\n+            throw new IllegalStateException(\"Database not bootstrapped\");\n+        }\n+        return new FHIRPersistenceJDBCImpl(this.testProps, this.connectionPool);\n+    }\n+    \n+    @Override\n+    protected void shutdownPools() throws Exception {\n+        // Mark the pool as no longer in use. This allows the pool to check for\n+        // lingering open connections/transactions.\n+        if (this.connectionPool != null) {\n+            this.connectionPool.close();\n+        }\n     }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDc2MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584760", "bodyText": "use the FHIRDbConstants to be consistent", "author": "prb112", "createdAt": "2020-06-28T00:54:40Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/FHIRDbDAOTest.java", "diffHunk": "@@ -52,9 +69,14 @@ public void testGetDB2Connection() throws Exception {\n         props.setProperty(FHIRDbDAO.PROPERTY_DB_URL, \"jdbc:db2://localhost:50000/fhirdb\");\n         props.setProperty(FHIRDbDAO.PROPERTY_DB2_USER, \"user\");\n         props.setProperty(FHIRDbDAO.PROPERTY_DB2_PSWD, \"password\");", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzOTEyNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447039127", "bodyText": "Yes, should be part of the FHIRDbDAO properties cleanup.", "author": "punktilious", "createdAt": "2020-06-29T15:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NDk1OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447964959", "bodyText": "removed because class no longer exists.", "author": "punktilious", "createdAt": "2020-06-30T20:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDg3Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584877", "bodyText": "What is this for?", "author": "prb112", "createdAt": "2020-06-28T00:56:13Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/RedefineDerbyDB.java", "diffHunk": "@@ -26,7 +28,7 @@ public RedefineDerbyDB() throws Exception {\n         this.testProps = TestUtil.readTestProperties(\"test.jdbc.properties\");\n     }\n \n-    @Test\n+//    @Test", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NTQ3OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447965479", "bodyText": "This is legacy code. Removed now.", "author": "punktilious", "createdAt": "2020-06-30T20:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDkyNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584925", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:56:51Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/FHIRUserTransactionAdapterTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import javax.transaction.Status;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRUserTransactionAdapter;\n+\n+/**\n+ * Unit test for the {@link FHIRUserTransactionAdapter}\n+ */\n+public class FHIRUserTransactionAdapterTest {\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testStandardFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testRepeatFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+\n+        // start a new transaction\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+        ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDk1MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584950", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                \n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-28T00:57:20Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/FHIRUserTransactionAdapterTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import javax.transaction.Status;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRUserTransactionAdapter;\n+\n+/**\n+ * Unit test for the {@link FHIRUserTransactionAdapter}\n+ */\n+public class FHIRUserTransactionAdapterTest {\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testStandardFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testRepeatFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+\n+        // start a new transaction\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+        \n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+    \n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedBeginAfterRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we should see the rollback\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        \n+        // inner transaction, so setRollbackOnly is suppressed\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be marked active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDk3Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446584972", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n                }\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-28T00:57:48Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/FHIRUserTransactionAdapterTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import javax.transaction.Status;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRUserTransactionAdapter;\n+\n+/**\n+ * Unit test for the {@link FHIRUserTransactionAdapter}\n+ */\n+public class FHIRUserTransactionAdapterTest {\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testStandardFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testRepeatFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+\n+        // start a new transaction\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+        \n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+    \n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedBeginAfterRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we should see the rollback\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        \n+        // inner transaction, so setRollbackOnly is suppressed\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be marked active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+    \n+    @Test(groups = {\"jdbc\"})\n+    public void sharedNestedRollback() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        FHIRUserTransactionAdapter nested = new FHIRUserTransactionAdapter(tx);\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        nested.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // when we end the nested, because we didn't start the tx, it should still\n+        // be marked for active\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // the outer transaction can mark for rollback\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we can end the transaction (rollback to no transaction)\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTAwNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585007", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n                }\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-28T00:58:05Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/FHIRUserTransactionAdapterTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import javax.transaction.Status;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRUserTransactionAdapter;\n+\n+/**\n+ * Unit test for the {@link FHIRUserTransactionAdapter}\n+ */\n+public class FHIRUserTransactionAdapterTest {\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testStandardFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testRepeatFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+\n+        // start a new transaction\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+        \n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+    \n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedBeginAfterRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we should see the rollback\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        \n+        // inner transaction, so setRollbackOnly is suppressed\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be marked active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+    \n+    @Test(groups = {\"jdbc\"})\n+    public void sharedNestedRollback() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        FHIRUserTransactionAdapter nested = new FHIRUserTransactionAdapter(tx);\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        nested.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // when we end the nested, because we didn't start the tx, it should still\n+        // be marked for active\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // the outer transaction can mark for rollback\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we can end the transaction (rollback to no transaction)\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void sharedNestedCommit() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        FHIRUserTransactionAdapter nested = new FHIRUserTransactionAdapter(tx);\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // when we end the nested, because we didn't start the tx, it should be active\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // now we can end (commit) the transaction\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTAyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585028", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n                }\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-28T00:58:23Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/FHIRUserTransactionAdapterTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import javax.transaction.Status;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRUserTransactionAdapter;\n+\n+/**\n+ * Unit test for the {@link FHIRUserTransactionAdapter}\n+ */\n+public class FHIRUserTransactionAdapterTest {\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testStandardFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testRepeatFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+\n+        // start a new transaction\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+        \n+    }\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedFlow() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+    \n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedBeginAfterRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // should still be active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we should see the rollback\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void testNestedRollbackOnly() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        \n+        // inner transaction, so setRollbackOnly is suppressed\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // should still be marked active\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        \n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+    \n+    @Test(groups = {\"jdbc\"})\n+    public void sharedNestedRollback() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        FHIRUserTransactionAdapter nested = new FHIRUserTransactionAdapter(tx);\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        \n+        nested.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // when we end the nested, because we didn't start the tx, it should still\n+        // be marked for active\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // the outer transaction can mark for rollback\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we can end the transaction (rollback to no transaction)\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void sharedNestedCommit() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        adapter.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        FHIRUserTransactionAdapter nested = new FHIRUserTransactionAdapter(tx);\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // when we end the nested, because we didn't start the tx, it should be active\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+\n+        // now we can end (commit) the transaction\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void sharedNestedAfterRollback() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+\n+        FHIRUserTransactionAdapter adapter = new FHIRUserTransactionAdapter(tx);\n+        adapter.begin();\n+        adapter.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now try and start a nested transaction\n+        FHIRUserTransactionAdapter nested = new FHIRUserTransactionAdapter(tx);\n+        nested.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // should be a NOP\n+        nested.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // when we end the nested, because we didn't start the tx, it should still\n+        // be marked for rollback\n+        nested.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+\n+        // now we can end the transaction (rollback to no transaction)\n+        adapter.end();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTAzNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.transaction.UserTransaction#begin()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:58:42Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+\n+/**\n+ * Pretend to be a {@link UserTransaction} with modifiable behavior to\n+ * support different test scenarios\n+ */\n+public class MockUserTransaction implements UserTransaction {\n+    private int status = Status.STATUS_NO_TRANSACTION;\n+    private int transactionTimeout = 0;\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#begin()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NTczNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447965734", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T20:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTA1Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585052", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.transaction.UserTransaction#commit()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:58:54Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+\n+/**\n+ * Pretend to be a {@link UserTransaction} with modifiable behavior to\n+ * support different test scenarios\n+ */\n+public class MockUserTransaction implements UserTransaction {\n+    private int status = Status.STATUS_NO_TRANSACTION;\n+    private int transactionTimeout = 0;\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#begin()\n+     */\n+    @Override\n+    public void begin() throws NotSupportedException, SystemException {\n+        if (this.status != Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction already active\");\n+        }\n+        this.status = Status.STATUS_ACTIVE;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#commit()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NTgyNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447965826", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T20:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTA1NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585054", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.transaction.UserTransaction#rollback()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:59:12Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+\n+/**\n+ * Pretend to be a {@link UserTransaction} with modifiable behavior to\n+ * support different test scenarios\n+ */\n+public class MockUserTransaction implements UserTransaction {\n+    private int status = Status.STATUS_NO_TRANSACTION;\n+    private int transactionTimeout = 0;\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#begin()\n+     */\n+    @Override\n+    public void begin() throws NotSupportedException, SystemException {\n+        if (this.status != Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction already active\");\n+        }\n+        this.status = Status.STATUS_ACTIVE;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#commit()\n+     */\n+    @Override\n+    public void commit()\n+        throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException {\n+\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            throw new RollbackException(\"transaction rolled back\");\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#rollback()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NjA0MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447966041", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T20:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTA5Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585092", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.transaction.UserTransaction#setRollbackOnly()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:59:36Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+\n+/**\n+ * Pretend to be a {@link UserTransaction} with modifiable behavior to\n+ * support different test scenarios\n+ */\n+public class MockUserTransaction implements UserTransaction {\n+    private int status = Status.STATUS_NO_TRANSACTION;\n+    private int transactionTimeout = 0;\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#begin()\n+     */\n+    @Override\n+    public void begin() throws NotSupportedException, SystemException {\n+        if (this.status != Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction already active\");\n+        }\n+        this.status = Status.STATUS_ACTIVE;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#commit()\n+     */\n+    @Override\n+    public void commit()\n+        throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException {\n+\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            throw new RollbackException(\"transaction rolled back\");\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#rollback()\n+     */\n+    @Override\n+    public void rollback() throws IllegalStateException, SecurityException, SystemException {\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#setRollbackOnly()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NjEyNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447966126", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T20:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTExMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585110", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:59:53Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+\n+/**\n+ * Pretend to be a {@link UserTransaction} with modifiable behavior to\n+ * support different test scenarios\n+ */\n+public class MockUserTransaction implements UserTransaction {\n+    private int status = Status.STATUS_NO_TRANSACTION;\n+    private int transactionTimeout = 0;\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#begin()\n+     */\n+    @Override\n+    public void begin() throws NotSupportedException, SystemException {\n+        if (this.status != Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction already active\");\n+        }\n+        this.status = Status.STATUS_ACTIVE;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#commit()\n+     */\n+    @Override\n+    public void commit()\n+        throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException {\n+\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            throw new RollbackException(\"transaction rolled back\");\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#rollback()\n+     */\n+    @Override\n+    public void rollback() throws IllegalStateException, SecurityException, SystemException {\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#setRollbackOnly()\n+     */\n+    @Override\n+    public void setRollbackOnly() throws IllegalStateException, SystemException {\n+        if (this.status == Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+        this.status = Status.STATUS_MARKED_ROLLBACK;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#getStatus()\n+     */\n+    @Override\n+    public int getStatus() throws SystemException {\n+        return this.status;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#setTransactionTimeout(int)\n+     */\n+    @Override\n+    public void setTransactionTimeout(int seconds) throws SystemException {\n+        this.transactionTimeout = seconds;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NjM3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447966376", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTE0Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585146", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.transaction.UserTransaction#setTransactionTimeout(int)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T01:00:08Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+\n+/**\n+ * Pretend to be a {@link UserTransaction} with modifiable behavior to\n+ * support different test scenarios\n+ */\n+public class MockUserTransaction implements UserTransaction {\n+    private int status = Status.STATUS_NO_TRANSACTION;\n+    private int transactionTimeout = 0;\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#begin()\n+     */\n+    @Override\n+    public void begin() throws NotSupportedException, SystemException {\n+        if (this.status != Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction already active\");\n+        }\n+        this.status = Status.STATUS_ACTIVE;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#commit()\n+     */\n+    @Override\n+    public void commit()\n+        throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException {\n+\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            throw new RollbackException(\"transaction rolled back\");\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#rollback()\n+     */\n+    @Override\n+    public void rollback() throws IllegalStateException, SecurityException, SystemException {\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#setRollbackOnly()\n+     */\n+    @Override\n+    public void setRollbackOnly() throws IllegalStateException, SystemException {\n+        if (this.status == Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+        this.status = Status.STATUS_MARKED_ROLLBACK;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#getStatus()\n+     */\n+    @Override\n+    public int getStatus() throws SystemException {\n+        return this.status;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#setTransactionTimeout(int)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NzAyMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447967023", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTE2OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585168", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.transaction.UserTransaction#getStatus()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T01:00:18Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransaction.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+\n+\n+/**\n+ * Pretend to be a {@link UserTransaction} with modifiable behavior to\n+ * support different test scenarios\n+ */\n+public class MockUserTransaction implements UserTransaction {\n+    private int status = Status.STATUS_NO_TRANSACTION;\n+    private int transactionTimeout = 0;\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#begin()\n+     */\n+    @Override\n+    public void begin() throws NotSupportedException, SystemException {\n+        if (this.status != Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction already active\");\n+        }\n+        this.status = Status.STATUS_ACTIVE;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#commit()\n+     */\n+    @Override\n+    public void commit()\n+        throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException {\n+\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            throw new RollbackException(\"transaction rolled back\");\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#rollback()\n+     */\n+    @Override\n+    public void rollback() throws IllegalStateException, SecurityException, SystemException {\n+        switch (this.status) {\n+        case Status.STATUS_ACTIVE:\n+        case Status.STATUS_MARKED_ROLLBACK:\n+            this.status = Status.STATUS_NO_TRANSACTION;\n+            break;\n+        default:\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#setRollbackOnly()\n+     */\n+    @Override\n+    public void setRollbackOnly() throws IllegalStateException, SystemException {\n+        if (this.status == Status.STATUS_NO_TRANSACTION) {\n+            throw new IllegalStateException(\"transaction not active\");\n+        }\n+        this.status = Status.STATUS_MARKED_ROLLBACK;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.transaction.UserTransaction#getStatus()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NzA5OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447967098", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTIwMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585202", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T01:00:42Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/connection/MockUserTransactionTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.test.connection;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import javax.transaction.RollbackException;\n+import javax.transaction.Status;\n+import javax.transaction.UserTransaction;\n+\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test our mock for {@link UserTransaction} to make sure it does what we expect\n+ * so that we can rely on it for the {@link FHIRUserTransactionAdapterTest}\n+ */\n+public class MockUserTransactionTest {\n+\n+    @Test(groups = {\"jdbc\"})\n+    public void test() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        tx.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        tx.commit();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+\n+        // try another transaction, but roll it back\n+        tx.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        tx.setRollbackOnly();\n+        assertEquals(tx.getStatus(), Status.STATUS_MARKED_ROLLBACK);\n+        tx.rollback();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+        \n+        // straight rollback\n+        tx.begin();\n+        assertEquals(tx.getStatus(), Status.STATUS_ACTIVE);\n+        tx.rollback();\n+        assertEquals(tx.getStatus(), Status.STATUS_NO_TRANSACTION);\n+    }\n+\n+    \n+    @Test(groups = {\"jdbc\"}, expectedExceptions = RollbackException.class)\n+    public void rollbackOnlyCommit() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        tx.begin();\n+        tx.setRollbackOnly();\n+        tx.commit();\n+    }\n+\n+    @Test(groups = {\"jdbc\"}, expectedExceptions = IllegalStateException.class)\n+    public void commitNoTransaction() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        tx.commit();\n+    }\n+\n+    @Test(groups = {\"jdbc\"}, expectedExceptions = IllegalStateException.class)\n+    public void rollbackNoTransaction() throws Exception {\n+        MockUserTransaction tx = new MockUserTransaction();\n+        tx.rollback();\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTI1NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585255", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * \n          \n          \n            \n             */", "author": "prb112", "createdAt": "2020-06-28T01:01:49Z", "path": "fhir-persistence-jdbc/src/test/java/com/ibm/fhir/persistence/jdbc/test/util/PopulateStaticTablesDerbyTest.java", "diffHunk": "@@ -12,62 +12,74 @@\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n-import java.sql.SQLException;\n import java.util.Properties;\n \n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Test;\n \n+import com.ibm.fhir.database.utils.api.ITransaction;\n import com.ibm.fhir.model.test.TestUtil;\n-import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n-import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n-import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.connection.Action;\n+import com.ibm.fhir.persistence.jdbc.connection.DisableAutocommitAction;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy;\n+import com.ibm.fhir.persistence.jdbc.connection.FHIRDbTestConnectionStrategy;\n+import com.ibm.fhir.persistence.jdbc.connection.SetSchemaAction;\n \n /**\n  * \n  */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTM0MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2017, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2020", "author": "prb112", "createdAt": "2020-06-28T01:03:27Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRDebugXADataSource.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright IBM Corp. 2017, 2020", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0NzkyOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447947929", "bodyText": "new file", "author": "prb112", "createdAt": "2020-06-30T20:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NzQzOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447967439", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTQxMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585411", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T01:04:54Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyConnection.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.CallableStatement;\n+import java.sql.Clob;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.NClob;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLClientInfoException;\n+import java.sql.SQLException;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Savepoint;\n+import java.sql.Statement;\n+import java.sql.Struct;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Executor;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Wrapping of a real database connection so that we can intercept the close call\n+ * and therefore reuse the connection. Note that we also listen for any exceptions\n+ * generated, and assume (for better or for worse) that something might be broken\n+ * so call back to the connection provider so that it can decide whether or not\n+ * to abandon the underlying connection.\n+ */\n+public class FHIRProxyConnection implements Connection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyConnection.class.getName());\n+\n+    // The actual connection we're wrapping (decorating)\n+    private final Connection wrapped;\n+    \n+    // Remember the stack from the last usage\n+    private Exception lastStack;\n+    \n+    /**\n+     * Public constructor\n+     * @param wrappee\n+     */\n+    public FHIRProxyConnection(Connection wrappee) {\n+        this.wrapped = wrappee;\n+    }\n+\n+    @Override\n+    public void clearWarnings() throws SQLException {\n+        wrapped.clearWarnings();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+        if (lastStack != null) {\n+            logger.log(Level.INFO, \"LAST USAGE\", lastStack);\n+            lastStack = null;\n+        }\n+        wrapped.close();\n+    }\n+\n+    @Override\n+    public void commit() throws SQLException {\n+        wrapped.commit();\n+    }\n+\n+    @Override\n+    public Array createArrayOf(String typeName, Object[] elements)\n+                    throws SQLException {\n+\n+        ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTQ5OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.sql.PooledConnection#getConnection()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T01:05:42Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+\n+/**\n+ * Proxy/wrapper for XAConnection objects obtained via the FHIRProxyXADataSource.\n+ * Provides additional tracing for connection/transaction/pooling issues\n+ */\n+public class FHIRProxyXAConnection implements XAConnection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyXAConnection.class.getName());\n+    private final XAConnection delegate;\n+    \n+    public FHIRProxyXAConnection(XAConnection delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#getConnection()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NzY5NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447967694", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTUxMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585511", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.sql.PooledConnection#close()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T01:05:56Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+\n+/**\n+ * Proxy/wrapper for XAConnection objects obtained via the FHIRProxyXADataSource.\n+ * Provides additional tracing for connection/transaction/pooling issues\n+ */\n+public class FHIRProxyXAConnection implements XAConnection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyXAConnection.class.getName());\n+    private final XAConnection delegate;\n+    \n+    public FHIRProxyXAConnection(XAConnection delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws SQLException {\n+        // dump the stack showing who's calling\n+        Exception x = new Exception(\"stack\");\n+        logger.log(Level.INFO, \"PROXY XA CONNECTION\", x);\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // Wrap the connection so that we can really see what's going on\n+            return new FHIRProxyConnection(delegate.getConnection());\n+        } else {\n+            return delegate.getConnection();\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#close()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2Nzc5NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447967795", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTUxNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585516", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.sql.PooledConnection#addConnectionEventListener(javax.sql.ConnectionEventListener)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T01:06:10Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+\n+/**\n+ * Proxy/wrapper for XAConnection objects obtained via the FHIRProxyXADataSource.\n+ * Provides additional tracing for connection/transaction/pooling issues\n+ */\n+public class FHIRProxyXAConnection implements XAConnection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyXAConnection.class.getName());\n+    private final XAConnection delegate;\n+    \n+    public FHIRProxyXAConnection(XAConnection delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws SQLException {\n+        // dump the stack showing who's calling\n+        Exception x = new Exception(\"stack\");\n+        logger.log(Level.INFO, \"PROXY XA CONNECTION\", x);\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // Wrap the connection so that we can really see what's going on\n+            return new FHIRProxyConnection(delegate.getConnection());\n+        } else {\n+            return delegate.getConnection();\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#close()\n+     */\n+    @Override\n+    public void close() throws SQLException {\n+        this.delegate.close();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NzkyOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447967929", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTU0NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446585544", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see javax.sql.PooledConnection#removeConnectionEventListener(javax.sql.ConnectionEventListener)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T01:06:34Z", "path": "fhir-persistence-proxy/src/main/java/com/ibm/fhir/persistence/proxy/FHIRProxyXAConnection.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.proxy;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.ConnectionEventListener;\n+import javax.sql.StatementEventListener;\n+import javax.sql.XAConnection;\n+import javax.transaction.xa.XAResource;\n+\n+\n+/**\n+ * Proxy/wrapper for XAConnection objects obtained via the FHIRProxyXADataSource.\n+ * Provides additional tracing for connection/transaction/pooling issues\n+ */\n+public class FHIRProxyXAConnection implements XAConnection {\n+    private static final Logger logger = Logger.getLogger(FHIRProxyXAConnection.class.getName());\n+    private final XAConnection delegate;\n+    \n+    public FHIRProxyXAConnection(XAConnection delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws SQLException {\n+        // dump the stack showing who's calling\n+        Exception x = new Exception(\"stack\");\n+        logger.log(Level.INFO, \"PROXY XA CONNECTION\", x);\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // Wrap the connection so that we can really see what's going on\n+            return new FHIRProxyConnection(delegate.getConnection());\n+        } else {\n+            return delegate.getConnection();\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#close()\n+     */\n+    @Override\n+    public void close() throws SQLException {\n+        this.delegate.close();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#addConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */\n+    @Override\n+    public void addConnectionEventListener(ConnectionEventListener listener) {\n+        this.delegate.addConnectionEventListener(listener);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see javax.sql.PooledConnection#removeConnectionEventListener(javax.sql.ConnectionEventListener)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2Nzk5Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447967993", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyODgzOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446928839", "bodyText": "very helpful comment", "author": "prb112", "createdAt": "2020-06-29T12:23:50Z", "path": "fhir-bulkimportexport-webapp/src/main/java/com/ibm/fhir/jbatch/bulkdata/load/ChunkWriter.java", "diffHunk": "@@ -183,41 +183,44 @@ public void writeItems(List<java.lang.Object> arg0) throws Exception {\n         // Acquire a DB connection which will be used in the batch.\n         // This doesn't really start the transaction, because the transaction has already been started by the JavaBatch\n         // framework at this time point.\n-        txn.enroll();\n-        for (Object objResJsonList : arg0) {\n-            @SuppressWarnings(\"unchecked\")\n-            List<Resource> fhirResourceList = (List<Resource>) objResJsonList;\n-\n-            for (Resource fhirResource : fhirResourceList) {\n-                try {\n-                    String id = fhirResource.getId();\n-                    processedNum++;\n-                    // Skip the resources which failed the validation\n-                    if (failValidationIds.contains(id)) {\n-                        continue;\n-                    }\n-                    OperationOutcome operationOutcome =\n-                            fhirPersistence.update(persistenceContext, id, fhirResource).getOutcome();\n-                    succeededNum++;\n-                    if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES && operationOutcome != null) {\n-                        FHIRGenerator.generator(Format.JSON).generate(operationOutcome, chunkData.getBufferStreamForImport());\n-                        chunkData.getBufferStreamForImport().write(Constants.NDJSON_LINESEPERATOR);\n-                    }\n-                } catch (FHIROperationException e) {\n-                    logger.warning(\"Failed to import '\" + fhirResource.getId() + \"' due to error: \" + e.getMessage());\n-                    failedNum++;\n-                    if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES) {\n-                        OperationOutcome operationOutCome = FHIRUtil.buildOperationOutcome(e, false);\n-                        FHIRGenerator.generator(Format.JSON).generate(operationOutCome, chunkData.getBufferStreamForImportError());\n-                        chunkData.getBufferStreamForImportError().write(Constants.NDJSON_LINESEPERATOR);\n+        txn.begin();\n+        try {\n+            for (Object objResJsonList : arg0) {\n+                @SuppressWarnings(\"unchecked\")\n+                List<Resource> fhirResourceList = (List<Resource>) objResJsonList;\n+    \n+                for (Resource fhirResource : fhirResourceList) {\n+                    try {\n+                        String id = fhirResource.getId();\n+                        processedNum++;\n+                        // Skip the resources which failed the validation\n+                        if (failValidationIds.contains(id)) {\n+                            continue;\n+                        }\n+                        OperationOutcome operationOutcome =\n+                                fhirPersistence.update(persistenceContext, id, fhirResource).getOutcome();\n+                        succeededNum++;\n+                        if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES && operationOutcome != null) {\n+                            FHIRGenerator.generator(Format.JSON).generate(operationOutcome, chunkData.getBufferStreamForImport());\n+                            chunkData.getBufferStreamForImport().write(Constants.NDJSON_LINESEPERATOR);\n+                        }\n+                    } catch (FHIROperationException e) {\n+                        logger.warning(\"Failed to import '\" + fhirResource.getId() + \"' due to error: \" + e.getMessage());\n+                        failedNum++;\n+                        if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES) {\n+                            OperationOutcome operationOutCome = FHIRUtil.buildOperationOutcome(e, false);\n+                            FHIRGenerator.generator(Format.JSON).generate(operationOutCome, chunkData.getBufferStreamForImportError());\n+                            chunkData.getBufferStreamForImportError().write(Constants.NDJSON_LINESEPERATOR);\n+                        }\n                     }\n                 }\n             }\n+        } finally {\n+            // Release the DB connection.", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyOTc1OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446929759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param connection\n          \n      \n    \n    \n  \n\nNo connection is passed", "author": "prb112", "createdAt": "2020-06-29T12:25:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SchemaNameImpl.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Supplier which tries to obtain the schema name from the given delegate,\n+ * falling back to calling getSchema() from the connection if the supplier\n+ * returns a null\n+ */\n+public class SchemaNameImpl implements SchemaNameSupplier { \n+    private static final Logger logger = Logger.getLogger(SchemaNameImpl.class.getName());\n+    \n+    // the delegate we use ask for the schema name\n+    private final SchemaNameSupplier delegate;\n+\n+    /**\n+     * Public constructor\n+     * @param delegate\n+     * @param connection", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMDQ3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446930476", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T12:26:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SchemaNameImpl.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMDczMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446930733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws FHIRPersistenceException\n          \n          \n            \n                 * @throws FHIRPersistenceDBConnectException", "author": "prb112", "createdAt": "2020-06-29T12:26:57Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SchemaNameSupplier.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+/**\n+ * Provides the schema name for the current request context\n+ */\n+@FunctionalInterface\n+public interface SchemaNameSupplier {\n+\n+    /**\n+     * Get the schema name for the current request context\n+     * @param c the connection for which we want to obtain the schema name\n+     * @return the main schema name to use for the given connection\n+     * @throws FHIRPersistenceException", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMTEzMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446931133", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param schemaName\n          \n          \n            \n                 * @param schemaName\n          \n          \n            \n                 * @param next", "author": "prb112", "createdAt": "2020-06-29T12:27:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetSchemaAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to set the named schema on a connection\n+ */\n+public class SetSchemaAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetSchemaAction.class.getName());\n+\n+    // supplier to obtain the schema name when we need it\n+    private final SchemaNameSupplier schemaNameSupplier;\n+    \n+    /**\n+     * Use a provided schema name (handy for testing)\n+     * @param schemaName", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2ODM0OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447968348", "bodyText": "should be correct now", "author": "punktilious", "createdAt": "2020-06-30T20:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMTIzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446931237", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T12:27:43Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetSchemaAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMzE4NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446933185", "bodyText": "is this necessary to have here? it reads as if this can be refactored out, which would make this interface cleaner", "author": "prb112", "createdAt": "2020-06-29T12:30:48Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/api/FHIRDbDAO.java", "diffHunk": "@@ -21,32 +21,18 @@\n     public static final String PROPERTY_DB2_PSWD = \"password\";\n \n     /**\n-     * Acquires and returns a JDBC database connection to the FHIR database.\n-     * If no DB Properties are available, an attempt is made to acquire the connection via a Datasource obtained via\n-     * JNDI. If DB Properties are present, those properties are used to build the Connection.\n+     * Obtains a database connection. Connection is configured and ready to use. Its\n+     * schema will be set to the configured FHIR data schema (usually 'FHIRDATA') and\n+     * if multi-tenant, the tenant property will have been set.\n      * \n      * @return Connection - A connection to the FHIR database.\n      * @throws FHIRPersistenceDBConnectException\n      */\n     Connection getConnection() throws FHIRPersistenceDBConnectException;\n \n-    /**\n-     * Returns a previously set externally managed DB connection, used by the DAO for all DB activity.\n-     * \n-     * @return Connection\n-     */\n-    Connection getExternalConnection();\n-\n-    /**\n-     * Sets an externally managed DB connection, used by the DAO for all DB activity.\n-     * \n-     * @param connection\n-     */\n-    void setExternalConnection(Connection connection);\n-\n     /**\n      * @return true if this DAO is connected to a DB2 database.\n      * @throws Exception\n      */\n-    boolean isDb2Database() throws Exception;\n+    boolean isDb2Database();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyOTEzOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447029138", "bodyText": "Do you mean the isDb2Database? We can look at removing as part of the FhirDbDAO property cleanup.", "author": "punktilious", "createdAt": "2020-06-29T14:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMzE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NDU1Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447774557", "bodyText": "It's used by some of the query constructor classes to tweak syntax. This should be handled by the translator, but it's inline for now - and not something that's part of issue-1144.", "author": "punktilious", "createdAt": "2020-06-30T15:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMzE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNzg4MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447907881", "bodyText": "Right, it didn't seem necessary after the code changes.", "author": "prb112", "createdAt": "2020-06-30T18:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMzM0Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446933343", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T12:31:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SchemaNameFromProps.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Properties;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNDMzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446934337", "bodyText": "Please update the copyright header", "author": "prb112", "createdAt": "2020-06-29T12:32:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/CodeSystemDAOImpl.java", "diffHunk": "@@ -38,12 +38,16 @@\n \n     // The JDBC connection used by this DAO instance\n     private final Connection connection;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NTQ0NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447775445", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-06-30T15:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNDMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNTMyNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446935326", "bodyText": "So this can be picked up in ParameterDaoImpl?", "author": "prb112", "createdAt": "2020-06-29T12:34:22Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/CodeSystemDAOImpl.java", "diffHunk": "@@ -54,6 +58,14 @@ protected Connection getConnection() {\n         return this.connection;\n     }\n \n+    /**\n+     * Getter for the FHIR data schema\n+     * @return\n+     */\n+    protected String getSchemaName() {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMTUzNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447031536", "bodyText": "Pls explain", "author": "punktilious", "createdAt": "2020-06-29T14:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNTMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NjgyOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447896829", "bodyText": "Why is this here?  Why is it used for?", "author": "prb112", "createdAt": "2020-06-30T18:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNjg1Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446936853", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T12:36:50Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbPropsConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This class implements the old way to obtain DB connections using a {@link Properties} instance\n+ */\n+@Deprecated\n+public class FHIRDbPropsConnectionStrategy implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbPropsConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = \"FHIRDbPropsConnectionStrategy\";\n+\n+    // Contains the connection properties\n+    private final Properties dbProps;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRDbPropsConnectionStrategy(Properties dbProps) throws FHIRPersistenceDBConnectException {\n+        this.dbProps = dbProps;\n+\n+        // ensure the driver is loaded\n+        String dbDriverName = this.dbProps.getProperty(FHIRDbConstants.PROPERTY_DB_DRIVER);\n+        try {\n+            Class.forName(dbDriverName);\n+        } catch (ClassNotFoundException e) {\n+            // Not concerned about revealing a classname in the exception\n+            throw new FHIRPersistenceDBConnectException(\"Failed to load driver: \" + dbDriverName, e);\n+        }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMDQ1Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447010452", "bodyText": "file will be removed", "author": "punktilious", "createdAt": "2020-06-29T14:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNjg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzODU3MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446938571", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param c\n          \n          \n            \n                 * @param connection", "author": "prb112", "createdAt": "2020-06-29T12:39:36Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbHelper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Helper functions used for managing FHIR database interactions\n+ */\n+public class FHIRDbHelper {\n+    private static final Logger log = Logger.getLogger(FHIRDbHelper.class.getName());\n+    \n+    /**\n+     * Convenience function to log the cause of an exception about to be thrown. This\n+     * is useful when avoiding chaining the cause with the persistence exception, which\n+     * could inadvertently leak sensitive information (details of the schema, for example)\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, Throwable cause) {\n+        logger.log(Level.SEVERE, fx.getMessage(), cause);\n+        return fx;\n+    }\n+    \n+    /**\n+     * Log the exception message here along with the cause stack. Return the\n+     * exception fx to the caller so that it can be thrown easily.\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param errorMessage\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, String errorMessage,\n+            Throwable cause) {\n+        if (cause != null) {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage), cause);\n+        } else {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage));\n+        }\n+        return fx;\n+    }\n+    \n+    public static FHIRPersistenceDataAccessException buildExceptionWithIssue(String msg, IssueType issueType)\n+            throws FHIRPersistenceDataAccessException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDataAccessException(msg).withIssue(ooi);\n+    }\n+\n+    public static FHIRPersistenceDBConnectException buildFHIRPersistenceDBConnectException(String msg, IssueType issueType)\n+            throws FHIRPersistenceDBConnectException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDBConnectException(msg).withIssue(ooi);\n+    }\n+\n+    /**\n+     * Close the connection if not null.\n+     * @implNote This connection object is just a wrapper. If we're in a \n+     *           transaction, then closing it doesn't do much, other than tell\n+     *           the transaction manager that the connection is no longer in\n+     *           use. The transaction manager still holds the underlying \n+     *           database connection open, and will use that connection the \n+     *           next time getConnection() is called for the same datasource \n+     *           within this thread. Only when the transaction commits \n+     *           will the connection be returned to the pool (or closed). \n+     *           If connections remain open when commit() is called, the \n+     *           transaction will fail.\n+     * @param c", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDAyMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446940021", "bodyText": "you pass in some methods, and not in others.\nI do like the concept of the helper, I just prefer the traceability of a logged message being identified in the originating class.", "author": "prb112", "createdAt": "2020-06-29T12:41:55Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbHelper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Helper functions used for managing FHIR database interactions\n+ */\n+public class FHIRDbHelper {\n+    private static final Logger log = Logger.getLogger(FHIRDbHelper.class.getName());\n+    \n+    /**\n+     * Convenience function to log the cause of an exception about to be thrown. This\n+     * is useful when avoiding chaining the cause with the persistence exception, which\n+     * could inadvertently leak sensitive information (details of the schema, for example)\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, Throwable cause) {\n+        logger.log(Level.SEVERE, fx.getMessage(), cause);\n+        return fx;\n+    }\n+    \n+    /**\n+     * Log the exception message here along with the cause stack. Return the\n+     * exception fx to the caller so that it can be thrown easily.\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param errorMessage\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, String errorMessage,\n+            Throwable cause) {\n+        if (cause != null) {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage), cause);\n+        } else {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage));\n+        }\n+        return fx;\n+    }\n+    \n+    public static FHIRPersistenceDataAccessException buildExceptionWithIssue(String msg, IssueType issueType)\n+            throws FHIRPersistenceDataAccessException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDataAccessException(msg).withIssue(ooi);\n+    }\n+\n+    public static FHIRPersistenceDBConnectException buildFHIRPersistenceDBConnectException(String msg, IssueType issueType)\n+            throws FHIRPersistenceDBConnectException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDBConnectException(msg).withIssue(ooi);\n+    }\n+\n+    /**\n+     * Close the connection if not null.\n+     * @implNote This connection object is just a wrapper. If we're in a \n+     *           transaction, then closing it doesn't do much, other than tell\n+     *           the transaction manager that the connection is no longer in\n+     *           use. The transaction manager still holds the underlying \n+     *           database connection open, and will use that connection the \n+     *           next time getConnection() is called for the same datasource \n+     *           within this thread. Only when the transaction commits \n+     *           will the connection be returned to the pool (or closed). \n+     *           If connections remain open when commit() is called, the \n+     *           transaction will fail.\n+     * @param c\n+     */\n+    public static void close(Connection connection) {\n+        if (connection != null) {\n+            try {\n+                connection.close();\n+            } catch (Throwable e) {\n+                // log the failure, but suppress the exception\n+                FHIRPersistenceDBCleanupException ce = new FHIRPersistenceDBCleanupException(\"Failure closing Connection.\", e);\n+                log.log(Level.SEVERE, ce.getMessage(), ce);", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwNjI1NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447006255", "bodyText": "Agreed. There may have been some cases where we didn't have a logger at hand when wanting to make this call. In this case, there's probably plenty of drama logged already before the close is called, so we won't be left wanting for context.", "author": "punktilious", "createdAt": "2020-06-29T14:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1NTk3Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447755973", "bodyText": "removed method", "author": "punktilious", "createdAt": "2020-06-30T15:04:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDE3NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446940175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n                }\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-29T12:42:09Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbHelper.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Helper functions used for managing FHIR database interactions\n+ */\n+public class FHIRDbHelper {\n+    private static final Logger log = Logger.getLogger(FHIRDbHelper.class.getName());\n+    \n+    /**\n+     * Convenience function to log the cause of an exception about to be thrown. This\n+     * is useful when avoiding chaining the cause with the persistence exception, which\n+     * could inadvertently leak sensitive information (details of the schema, for example)\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, Throwable cause) {\n+        logger.log(Level.SEVERE, fx.getMessage(), cause);\n+        return fx;\n+    }\n+    \n+    /**\n+     * Log the exception message here along with the cause stack. Return the\n+     * exception fx to the caller so that it can be thrown easily.\n+     *\n+     * @param logger\n+     * @param fx\n+     * @param errorMessage\n+     * @param cause\n+     * @return\n+     */\n+    public static <XT extends FHIRPersistenceException> XT severe(Logger logger, XT fx, String errorMessage,\n+            Throwable cause) {\n+        if (cause != null) {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage), cause);\n+        } else {\n+            logger.log(Level.SEVERE, fx.addProbeId(errorMessage));\n+        }\n+        return fx;\n+    }\n+    \n+    public static FHIRPersistenceDataAccessException buildExceptionWithIssue(String msg, IssueType issueType)\n+            throws FHIRPersistenceDataAccessException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDataAccessException(msg).withIssue(ooi);\n+    }\n+\n+    public static FHIRPersistenceDBConnectException buildFHIRPersistenceDBConnectException(String msg, IssueType issueType)\n+            throws FHIRPersistenceDBConnectException {\n+        Issue ooi = FHIRUtil.buildOperationOutcomeIssue(msg, issueType);\n+        return new FHIRPersistenceDBConnectException(msg).withIssue(ooi);\n+    }\n+\n+    /**\n+     * Close the connection if not null.\n+     * @implNote This connection object is just a wrapper. If we're in a \n+     *           transaction, then closing it doesn't do much, other than tell\n+     *           the transaction manager that the connection is no longer in\n+     *           use. The transaction manager still holds the underlying \n+     *           database connection open, and will use that connection the \n+     *           next time getConnection() is called for the same datasource \n+     *           within this thread. Only when the transaction commits \n+     *           will the connection be returned to the pool (or closed). \n+     *           If connections remain open when commit() is called, the \n+     *           transaction will fail.\n+     * @param c\n+     */\n+    public static void close(Connection connection) {\n+        if (connection != null) {\n+            try {\n+                connection.close();\n+            } catch (Throwable e) {\n+                // log the failure, but suppress the exception\n+                FHIRPersistenceDBCleanupException ce = new FHIRPersistenceDBCleanupException(\"Failure closing Connection.\", e);\n+                log.log(Level.SEVERE, ce.getMessage(), ce);\n+            }\n+        }\n+        \n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDQyMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446940423", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T12:42:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbPropsConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDc4Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446940783", "bodyText": "Can you explain why this new class is already deprecated?\nIt seems like it should just not be included or the @deprecated tag should be removed", "author": "prb112", "createdAt": "2020-06-29T12:43:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbPropsConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This class implements the old way to obtain DB connections using a {@link Properties} instance\n+ */\n+@Deprecated", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwOTk5Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447009997", "bodyText": "Yes, this class represents one of the three methods we had for constructing the FHIRPersistenceJDBCImpl. It was used to support getting connections to Derby based on configuration data passed as properties. As the refactor progressed, all the unit tests were updated to use the IConnectionProvider approach. This class was created in case we needed to support the old properties-based connection configuration for any reason. Now the refactor is complete, we can remove it.", "author": "punktilious", "createdAt": "2020-06-29T14:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2ODYyMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447968622", "bodyText": "class has been removed", "author": "punktilious", "createdAt": "2020-06-30T20:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MDc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MTQ5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446941496", "bodyText": "Please fix the copyright", "author": "prb112", "createdAt": "2020-06-29T12:44:11Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTranslator.java", "diffHunk": "@@ -9,6 +9,8 @@\n import java.sql.SQLException;\n import java.util.Properties;\n \n+import com.ibm.fhir.database.utils.model.DbType;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxOTE1Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447719157", "bodyText": "Fixed", "author": "punktilious", "createdAt": "2020-06-30T14:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0MTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0NTM5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446945396", "bodyText": "Where is this used? it's implemented in 3 spots, and not used.  Please add a backlog issue to implement something that uses it, or remove the unused code.", "author": "prb112", "createdAt": "2020-06-29T12:50:17Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTranslator.java", "diffHunk": "@@ -145,4 +156,16 @@\n      * @return\n      */\n     boolean clobSupportsInline();\n+    \n+    /**\n+     * The main type of the database\n+     * @return\n+     */\n+    DbType getType();\n+    \n+    /**\n+     * The name of the \"DUAL\" table...that special table giving us one row/column.\n+     * @return\n+     */\n+    String dualTableName();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NTk4NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446955984", "bodyText": "Are you referring to getType or dualTableName? They are framework/utility methods. I don't think everything has to be used today if it might be useful in the future. It was in use at one point during the refactor, but if it's no longer used, I don't think we should remove it, only to have to implement it again in the future should it be needed.", "author": "punktilious", "createdAt": "2020-06-29T13:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0NTM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0NTYyOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446945629", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T12:50:38Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/CommonDatabaseAdapter.java", "diffHunk": "@@ -55,7 +55,7 @@\n \n     // The translator used to to tweak the syntax for the database\n     private final IDatabaseTranslator translator;\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0NTgxNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446945814", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T12:50:56Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/CommonDatabaseAdapter.java", "diffHunk": "@@ -46,7 +46,7 @@\n  */\n public abstract class CommonDatabaseAdapter implements IDatabaseAdapter, IDatabaseTypeAdapter {\n     private static final Logger logger = Logger.getLogger(CommonDatabaseAdapter.class.getName());\n-\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NzgzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447897831", "bodyText": "it's best to change your eclipse settings to remove whitespace at end of lines", "author": "prb112", "createdAt": "2020-06-30T18:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0NTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0NzA3MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446947070", "bodyText": "This comment seems no longer applicable.", "author": "prb112", "createdAt": "2020-06-29T12:52:51Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/CommonDatabaseAdapter.java", "diffHunk": "@@ -514,7 +515,7 @@ public void createSequence(String schemaName, String sequenceName, int cache) {\n          */\n         // The move to start with 1000 gives room for manual creation and update of sequences.", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2OTY5OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447969699", "bodyText": "updated", "author": "punktilious", "createdAt": "2020-06-30T20:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0NzA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0ODY5Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446948693", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            import java.util.HashSet;\n          \n          \n            \n            import java.util.Set;", "author": "prb112", "createdAt": "2020-06-29T12:55:24Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaVersion.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.util.HashSet;\n+import java.util.Set;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDc0OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447970748", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0ODY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0OTY4Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446949683", "bodyText": "Why should this be programmatically accessible?  Wouldn't a comment suffice?", "author": "prb112", "createdAt": "2020-06-29T12:56:57Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaVersion.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Tracks the incremental changes to the FHIR schema as it evolves. Incremental\n+ * changes to the schema should be recorded here to create a new version number\n+ * and this enum can then be used to identify the schema objects associated with\n+ * a particular version.\n+ */\n+public enum FhirSchemaVersion {\n+    \n+    // Make sure the vid values are unique...this cannot be done programmatically with an enum\n+     V0001(1, \"Initial version\")\n+    ,V0002(2, \"Composite search value support\")\n+    ,V0003(3, \"issue-1263 fhir_ref_sequence start with 20000\")", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Njk2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447976963", "bodyText": "Useful in info/error messages to see which updates are being applied.", "author": "punktilious", "createdAt": "2020-06-30T21:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk0OTY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MTczNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446951737", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (Throwable t) {\n          \n          \n            \n                        } catch (Throwable t) {", "author": "prb112", "createdAt": "2020-06-29T13:00:05Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/derby/DerbyFhirDatabase.java", "diffHunk": "@@ -73,8 +82,19 @@ public DerbyFhirDatabase(String dbPath) throws SQLException {\n \n         // apply the model we've defined to the new Derby database\n         VersionHistoryService vhs = createVersionHistoryService();\n-        derby.createSchema(vhs, pdm);\n-\n+        \n+        // Create the schema in a managed transaction\n+        try (ITransaction tx = transactionProvider.getTransaction()) {\n+            try {\n+                derby.createSchema(connectionPool, vhs, pdm);\n+            }\n+            catch (Throwable t) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTA1NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447971054", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MjgyNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446952825", "bodyText": "Remove this code as it is not needed", "author": "prb112", "createdAt": "2020-06-29T13:01:46Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/derby/DerbyFhirDatabase.java", "diffHunk": "@@ -44,10 +44,17 @@\n     private static final String BATCH_SCHEMANAME = Main.BATCH_SCHEMANAME;\n \n     // The translator to help us out with Derby syntax\n-    private static final IDatabaseTranslator DERBY_TRANSLATOR = new DerbyTranslator();\n+    // private static final IDatabaseTranslator DERBY_TRANSLATOR = new DerbyTranslator();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTM5OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447971399", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MzE1OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446953158", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (SQLException x) {\n          \n          \n            \n                        } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-29T13:02:21Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/derby/DerbyFhirDatabase.java", "diffHunk": "@@ -89,59 +109,69 @@ public void populateResourceTypeAndParameterNameTableEntries() throws SQLExcepti\n         // Prepopulate the Resource Type Tables and Parameters Name/Code Table\n         logger.info(\"started prepopulating lookup table data.\");\n         DerbyTranslator translator = new DerbyTranslator();\n-        Connection connection = getConnection();\n-\n-        // Ensures we don't double up the generated derby db prepopulation.\n-        // Docs for the table are at https://db.apache.org/derby/docs/10.5/ref/rrefsistabs24269.html\n-        boolean process = true;\n-        final String sql = \"SELECT COUNT(TABLENAME) AS CNT FROM SYS.SYSTABLES WHERE TABLENAME = 'PARAMETER_NAMES'\";\n-        try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n-            stmt.execute();\n-            ResultSet set = stmt.getResultSet();\n-            if (set.next()) {\n-                int val = set.getInt(\"CNT\");\n-                if (val > 0) {\n-                    process = false;\n+        try (Connection connection = getConnection()) {\n+\n+            // Ensures we don't double up the generated derby db prepopulation.\n+            // Docs for the table are at https://db.apache.org/derby/docs/10.5/ref/rrefsistabs24269.html\n+            boolean process = true;\n+            final String sql = \"SELECT COUNT(TABLENAME) AS CNT FROM SYS.SYSTABLES WHERE TABLENAME = 'PARAMETER_NAMES'\";\n+            try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n+                stmt.execute();\n+                ResultSet set = stmt.getResultSet();\n+                if (set.next()) {\n+                    int val = set.getInt(\"CNT\");\n+                    if (val > 0) {\n+                        process = false;\n+                    }\n                 }\n             }\n-        }\n-\n-        if (process) {\n-            PopulateResourceTypes populateResourceTypes =\n-                    new PopulateResourceTypes(ADMIN_SCHEMA_NAME, SCHEMA_NAME, null);\n-            populateResourceTypes.run(translator, connection);\n-\n-            PopulateParameterNames populateParameterNames =\n-                    new PopulateParameterNames(ADMIN_SCHEMA_NAME, SCHEMA_NAME, null);\n-            populateParameterNames.run(translator, connection);\n+    \n+            if (process) {\n+                PopulateResourceTypes populateResourceTypes =\n+                        new PopulateResourceTypes(ADMIN_SCHEMA_NAME, SCHEMA_NAME, null);\n+                populateResourceTypes.run(translator, connection);\n+    \n+                PopulateParameterNames populateParameterNames =\n+                        new PopulateParameterNames(ADMIN_SCHEMA_NAME, SCHEMA_NAME, null);\n+                populateParameterNames.run(translator, connection);\n+                logger.info(\"Finished prepopulating the resource type and search parameter code/name tables tables\");\n+            } else {\n+                logger.info(\"Skipped prepopulating the resource type and search parameter code/name tables tables\");\n+            }\n+            \n+            // always commit here before we close the connection.\n             connection.commit();\n-            logger.info(\"Finished prepopulating the resource type and search parameter code/name tables tables\");\n-        } else {\n-            logger.info(\"Skipped prepopulating the resource type and search parameter code/name tables tables\");\n         }\n     }\n \n     /**\n-     * Configure the TransactionProvider\n+     * Create the version history table and a simple service which is used to\n+     * access information from it.\n      * \n      * @throws SQLException\n      */\n     public VersionHistoryService createVersionHistoryService() throws SQLException {\n-        Connection c = derby.getConnection();\n-        JdbcTarget target = new JdbcTarget(c);\n-\n-        JdbcPropertyAdapter jdbcAdapter = new JdbcPropertyAdapter(new Properties());\n-        JdbcConnectionProvider cp = new JdbcConnectionProvider(DERBY_TRANSLATOR, jdbcAdapter);\n-        PoolConnectionProvider connectionPool = new PoolConnectionProvider(cp, 200);\n-        ITransactionProvider transactionProvider = new SimpleTransactionProvider(connectionPool);\n-\n-        DerbyAdapter derbyAdapter = new DerbyAdapter(target);\n-        CreateVersionHistory.createTableIfNeeded(ADMIN_SCHEMA_NAME, derbyAdapter);\n \n-        // Current version history for the data schema\n+        // No complex transaction handling required here. Simply check if the versions\n+        // table exists, and if not, create it.\n+        try (Connection c = derby.getConnection()) {\n+            try {\n+                JdbcTarget target = new JdbcTarget(c);\n+                DerbyAdapter derbyAdapter = new DerbyAdapter(target);\n+                CreateVersionHistory.createTableIfNeeded(ADMIN_SCHEMA_NAME, derbyAdapter);\n+                c.commit();\n+            }\n+            catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTY1MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447971651", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MzE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NzMyNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446957326", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-29T13:08:54Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IDatabaseTarget} which uses an {@link IConnectionProvider}\n+ * to obtain a connection which is then closed immediately for\n+ * each statement. Each run statement is committed before the\n+ * connection is closed. This target is not intended for use\n+ * with the ITransactionProvider/ITransaction implementation.\n+ */\n+public class ConnectionProviderTarget implements IDatabaseTarget {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp provides connections used for running statements\n+     */\n+    public ConnectionProviderTarget(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        // Execute the DDL (no parameters)\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (Statement s = connection.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatementWithInt(IDatabaseTranslator translator, String sql, int value) {\n+        // convenience for running a statement requiring a single int parameter\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (PreparedStatement ps = connection.prepareStatement(sql)) {\n+                ps.setInt(1, value);\n+                ps.executeUpdate(sql);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, IDatabaseStatement statement) {\n+        \n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try {\n+                statement.run(translator, connection);\n+            }\n+            catch (Throwable t) {\n+                connection.rollback();\n+                throw t;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public <T> T runStatement(IDatabaseTranslator translator, IDatabaseSupplier<T> supplier) {\n+        // execute the statement using the given translator and a fresh connection\n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            \n+            T result;\n+            try {\n+                result = supplier.run(translator, connection);\n+            }\n+            catch (Throwable t) {\n+                connection.rollback();\n+                throw t;\n+            }\n+            connection.commit();\n+            return result;\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+            \n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MjE1MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447972150", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NzMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1ODk0Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446958946", "bodyText": "not sure if this can work well, need to be verified by the minio enabled build pipeline.", "author": "albertwang-ibm", "createdAt": "2020-06-29T13:11:16Z", "path": "fhir-bulkimportexport-webapp/src/main/java/com/ibm/fhir/jbatch/bulkdata/export/group/ChunkReader.java", "diffHunk": "@@ -85,10 +85,13 @@ private Group findGroupByID(String groupId) throws Exception{\n         searchContext = SearchUtil.parseQueryParameters(Group.class, queryParameters);\n         List<Resource> resources = null;\n         FHIRTransactionHelper txn = new FHIRTransactionHelper(fhirPersistence.getTransaction());\n-        txn.enroll();\n-        persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n-        resources = fhirPersistence.search(persistenceContext, Group.class).getResource();\n-        txn.unenroll();\n+        txn.begin();\n+        try {\n+            persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n+            resources = fhirPersistence.search(persistenceContext, Group.class).getResource();\n+        } finally {\n+            txn.end();\n+        }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTA4NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446959084", "bodyText": "not sure if this can work well, need to be verified by the minio enabled build pipeline.", "author": "albertwang-ibm", "createdAt": "2020-06-29T13:11:27Z", "path": "fhir-bulkimportexport-webapp/src/main/java/com/ibm/fhir/jbatch/bulkdata/export/group/ChunkReader.java", "diffHunk": "@@ -108,10 +111,13 @@ private Group findGroupByID(String groupId) throws Exception{\n         searchContext.setPageSize(pageSize);\n         FHIRTransactionHelper txn = new FHIRTransactionHelper(fhirPersistence.getTransaction());\n \n-        txn.enroll();\n-        persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n-        patients = fhirPersistence.search(persistenceContext, Patient.class).getResource();\n-        txn.unenroll();\n+        txn.begin();\n+        try {\n+            persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n+            patients = fhirPersistence.search(persistenceContext, Patient.class).getResource();\n+        } finally {\n+            txn.end();\n+        }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTE4Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446959183", "bodyText": "not sure if this can work well, need to be verified by the minio enabled build pipeline.", "author": "albertwang-ibm", "createdAt": "2020-06-29T13:11:36Z", "path": "fhir-bulkimportexport-webapp/src/main/java/com/ibm/fhir/jbatch/bulkdata/export/patient/ChunkReader.java", "diffHunk": "@@ -175,10 +175,15 @@ protected void fillChunkDataBuffer(List<String> patientIds) throws Exception {\n                         searchContext.setPageSize(pageSize);\n                         searchContext.setPageNumber(compartmentPageNum);\n                         FHIRTransactionHelper txn = new FHIRTransactionHelper(fhirPersistence.getTransaction());\n-                        txn.enroll();\n                         FHIRPersistenceContext persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n-                        List<Resource> resources = fhirPersistence.search(persistenceContext, resourceType).getResource();\n-                        txn.unenroll();\n+\n+                        List<Resource> resources;\n+                        txn.begin();\n+                        try {\n+                            resources = fhirPersistence.search(persistenceContext, resourceType).getResource();\n+                        } finally {\n+                            txn.end();\n+                        }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTE5OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446959198", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws IllegalArgumentException if the value contains risky characters\n          \n          \n            \n                 * @throws IllegalArgumentException if the value contains unapproved characters", "author": "prb112", "createdAt": "2020-06-29T13:11:38Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -160,6 +160,7 @@ public static void assertValidNames(String... names) {\n      * as part of a larger CREATE/ALTER statement. Note: none of the input\n      * being dealt with here is external input...so it should be safe already.\n      * @param value\n+     * @throws IllegalArgumentException if the value contains risky characters", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MjcyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447972728", "bodyText": "I don't see anything wrong with saying risky here, especially given that this relates to security", "author": "punktilious", "createdAt": "2020-06-30T20:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTI4Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446959282", "bodyText": "not sure if this can work well, need to be verified by the minio enabled build pipeline.", "author": "albertwang-ibm", "createdAt": "2020-06-29T13:11:44Z", "path": "fhir-bulkimportexport-webapp/src/main/java/com/ibm/fhir/jbatch/bulkdata/export/patient/ChunkReader.java", "diffHunk": "@@ -297,10 +302,14 @@ public Object readItem() throws Exception {\n         searchContext.setPageNumber(pageNum);\n         List<Resource> resources = null;\n         FHIRTransactionHelper txn = new FHIRTransactionHelper(fhirPersistence.getTransaction());\n-        txn.enroll();\n-        persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n-        resources = fhirPersistence.search(persistenceContext, Patient.class).getResource();\n-        txn.unenroll();\n+        txn.begin();\n+        \n+        try {\n+            persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n+            resources = fhirPersistence.search(persistenceContext, Patient.class).getResource();\n+        } finally {\n+            txn.end();\n+        }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTM3Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446959377", "bodyText": "not sure if this can work well, need to be verified by the minio enabled build pipeline.", "author": "albertwang-ibm", "createdAt": "2020-06-29T13:11:52Z", "path": "fhir-bulkimportexport-webapp/src/main/java/com/ibm/fhir/jbatch/bulkdata/export/system/ChunkReader.java", "diffHunk": "@@ -210,10 +210,13 @@ public Object readItem() throws Exception {\n         searchContext.setPageNumber(pageNum);\n         List<Resource> resources = null;\n         FHIRTransactionHelper txn = new FHIRTransactionHelper(fhirPersistence.getTransaction());\n-        txn.enroll();\n-        persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n-        resources = fhirPersistence.search(persistenceContext, resourceType).getResource();\n-        txn.unenroll();\n+        txn.begin();\n+        try {\n+            persistenceContext = FHIRPersistenceContextFactory.createPersistenceContext(null, searchContext);\n+            resources = fhirPersistence.search(persistenceContext, resourceType).getResource();\n+        } finally {\n+            txn.end();\n+        }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTY2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446959663", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-29T13:12:18Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DropIndex.java", "diffHunk": "@@ -40,6 +42,8 @@ public void run(IDatabaseTranslator translator, Connection c) {\n             s.executeUpdate(\"DROP INDEX \" + qname);\n         }\n         catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MzExOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447973119", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1OTcwOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446959709", "bodyText": "not sure if this can work well, need to be verified by the minio enabled build pipeline.", "author": "albertwang-ibm", "createdAt": "2020-06-29T13:12:23Z", "path": "fhir-bulkimportexport-webapp/src/main/java/com/ibm/fhir/jbatch/bulkdata/load/ChunkWriter.java", "diffHunk": "@@ -183,41 +183,44 @@ public void writeItems(List<java.lang.Object> arg0) throws Exception {\n         // Acquire a DB connection which will be used in the batch.\n         // This doesn't really start the transaction, because the transaction has already been started by the JavaBatch\n         // framework at this time point.\n-        txn.enroll();\n-        for (Object objResJsonList : arg0) {\n-            @SuppressWarnings(\"unchecked\")\n-            List<Resource> fhirResourceList = (List<Resource>) objResJsonList;\n-\n-            for (Resource fhirResource : fhirResourceList) {\n-                try {\n-                    String id = fhirResource.getId();\n-                    processedNum++;\n-                    // Skip the resources which failed the validation\n-                    if (failValidationIds.contains(id)) {\n-                        continue;\n-                    }\n-                    OperationOutcome operationOutcome =\n-                            fhirPersistence.update(persistenceContext, id, fhirResource).getOutcome();\n-                    succeededNum++;\n-                    if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES && operationOutcome != null) {\n-                        FHIRGenerator.generator(Format.JSON).generate(operationOutcome, chunkData.getBufferStreamForImport());\n-                        chunkData.getBufferStreamForImport().write(Constants.NDJSON_LINESEPERATOR);\n-                    }\n-                } catch (FHIROperationException e) {\n-                    logger.warning(\"Failed to import '\" + fhirResource.getId() + \"' due to error: \" + e.getMessage());\n-                    failedNum++;\n-                    if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES) {\n-                        OperationOutcome operationOutCome = FHIRUtil.buildOperationOutcome(e, false);\n-                        FHIRGenerator.generator(Format.JSON).generate(operationOutCome, chunkData.getBufferStreamForImportError());\n-                        chunkData.getBufferStreamForImportError().write(Constants.NDJSON_LINESEPERATOR);\n+        txn.begin();\n+        try {\n+            for (Object objResJsonList : arg0) {\n+                @SuppressWarnings(\"unchecked\")\n+                List<Resource> fhirResourceList = (List<Resource>) objResJsonList;\n+    \n+                for (Resource fhirResource : fhirResourceList) {\n+                    try {\n+                        String id = fhirResource.getId();\n+                        processedNum++;\n+                        // Skip the resources which failed the validation\n+                        if (failValidationIds.contains(id)) {\n+                            continue;\n+                        }\n+                        OperationOutcome operationOutcome =\n+                                fhirPersistence.update(persistenceContext, id, fhirResource).getOutcome();\n+                        succeededNum++;\n+                        if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES && operationOutcome != null) {\n+                            FHIRGenerator.generator(Format.JSON).generate(operationOutcome, chunkData.getBufferStreamForImport());\n+                            chunkData.getBufferStreamForImport().write(Constants.NDJSON_LINESEPERATOR);\n+                        }\n+                    } catch (FHIROperationException e) {\n+                        logger.warning(\"Failed to import '\" + fhirResource.getId() + \"' due to error: \" + e.getMessage());\n+                        failedNum++;\n+                        if (Constants.IMPORT_IS_COLLECT_OPERATIONOUTCOMES) {\n+                            OperationOutcome operationOutCome = FHIRUtil.buildOperationOutcome(e, false);\n+                            FHIRGenerator.generator(Format.JSON).generate(operationOutCome, chunkData.getBufferStreamForImportError());\n+                            chunkData.getBufferStreamForImportError().write(Constants.NDJSON_LINESEPERATOR);\n+                        }\n                     }\n                 }\n             }\n+        } finally {\n+            // Release the DB connection.", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MDM2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446970363", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param vhs\n          \n          \n            \n                 * @param pdm\n          \n          \n            \n                 * @param pool\n          \n          \n            \n                 * @param vhs\n          \n          \n            \n                 * @param pdm", "author": "prb112", "createdAt": "2020-06-29T13:27:23Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -166,75 +213,122 @@ public IDatabaseTranslator getTranslator() {\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param pdm\n      */\n-    public void createSchema(PhysicalDataModel pdm) {\n-        createSchema(vhs, pdm);\n+    public void createSchema(IConnectionProvider pool, PhysicalDataModel pdm) {\n+        createSchema(pool, vhs, pdm);\n     }\n \n     /**\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param vhs\n      * @param pdm", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NDE5Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447974193", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MDM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MTYzNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446971635", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException e) {\n          \n          \n            \n                    } catch (SQLException e) {", "author": "prb112", "createdAt": "2020-06-29T13:29:14Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -166,75 +213,122 @@ public IDatabaseTranslator getTranslator() {\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param pdm\n      */\n-    public void createSchema(PhysicalDataModel pdm) {\n-        createSchema(vhs, pdm);\n+    public void createSchema(IConnectionProvider pool, PhysicalDataModel pdm) {\n+        createSchema(pool, vhs, pdm);\n     }\n \n     /**\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param vhs\n      * @param pdm\n      */\n-    public void createSchema(IVersionHistoryService vhs, PhysicalDataModel pdm) {\n-        runWithAdapter(target -> pdm.applyWithHistory(target, vhs));\n+    public void createSchema(IConnectionProvider pool, IVersionHistoryService vhs, PhysicalDataModel pdm) {\n+        runWithAdapter(pool, target -> pdm.applyWithHistory(target, vhs));\n     }\n+    \n+    public void runWithAdapter(IConnectionProvider pool, java.util.function.Consumer<IDatabaseAdapter> fn) {\n+\n+        // We need to obtain connections from the same pool as the version history service\n+        // so we can avoid deadlocks for certain DDL like DROP INDEX\n+        try {\n+            // wrap the connection pool in an adapter for the Derby database\n+            DerbyAdapter adapter = new DerbyAdapter(pool);\n+            \n+            // call the Function we've been given using the adapter we just wrapped\n+            // around the connection.\n+            fn.accept(adapter);\n+        } catch (DataAccessException x) {\n+            logger.log(Level.SEVERE, \"Error while running\", x);\n+            throw x;\n+        }\n+    }\n+\n \n     /**\n      * Run the function with an adapter configured for this database\n      * \n      * @param fn\n      */\n     public void runWithAdapter(java.util.function.Consumer<IDatabaseAdapter> fn) {\n-        try {\n-            Connection c = getConnection();\n-            try {\n-                JdbcTarget target = new JdbcTarget(c);\n-                DerbyAdapter adapter = new DerbyAdapter(target);\n \n-                // Replace the target with a decorated output, so that we print all the DDL before executing\n-                // The output is very FINE and logs out a lot. \n-                if (logger.isLoggable(Level.FINE)) {\n-                    PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n-                    adapter = new DerbyAdapter(printer);\n-                }\n-                fn.accept(adapter);\n-            } catch (DataAccessException x) {\n-                logger.log(Level.SEVERE, \"Error while running\", x);\n-                c.rollback();\n-                throw x;\n-            }\n-            c.commit();\n-        } catch (SQLException e) {\n-            logger.log(Level.SEVERE, \"Error while running\", e);\n-            throw DERBY_TRANSLATOR.translate(e);\n-        } finally {\n-            logger.info(\"connection was closed\");\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+\n+        // Replace the target with a decorated output, so that we print all the DDL before executing\n+        // The output is very FINE and logs out a lot. \n+        if (logger.isLoggable(Level.FINE)) {\n+            PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n+            adapter = new DerbyAdapter(printer);\n         }\n+      \n+        // call the Function we've been given using the adapter we just wrapped\n+        // around the connection. Each statement executes in its own connection/transaction.\n+        fn.accept(adapter);\n     }\n \n+    /**\n+     * Diagnostic utility to display all the current locks in the Derby database\n+     */\n+    public void dumpLockInfo() {\n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        System.out.println(LockInfo.header());\n+        locks.forEach(System.out::println);\n+    }\n+    \n+    /**\n+     * Dump locks using the given connection\n+     * @param c\n+     */\n+    public static void dumpLockInfo(Connection c) {\n+        // wrap the connection so that we can run our lock diag DAO\n+        JdbcTarget target = new JdbcTarget(c);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        \n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        \n+        // render\n+        System.out.println(LockInfo.header());\n+        locks.forEach(System.out::println);\n+    }\n+    \n+    /**\n+     * @implNote this drop is only relevant for in-memory Derby databases, which we no\n+     *           longer use due to the size of the tests. This does not remove any\n+     *           files on disk.\n+     */\n     @Override\n     public void close() throws Exception {\n-        // Drop the database we created\n-        boolean dropped = false;\n+        shutdown(database);\n+    }\n+    \n+    public static void shutdown(String databaseName) {\n+        boolean shutdown = false;\n         try {\n-            if (connection != null && !connection.isClosed()) {\n-                connection.close();\n-            }\n             Properties properties = new Properties();\n             DerbyPropertyAdapter adapter = new DerbyPropertyAdapter(properties);\n-            adapter.setDatabase(database);\n+            adapter.setDatabase(databaseName);\n \n-            final String dropper = DERBY_TRANSLATOR.getUrl(properties) + \";drop=true\";\n-            logger.info(\"Dropping derby DB with: \" + dropper);\n+            final String dropper = DERBY_TRANSLATOR.getUrl(properties) + \";shutdown=true\";\n+            logger.info(\"Shutting down Derby DB '\" + databaseName + \"' with: \" + dropper);\n+            \n+            // should throw an exception if successful\n             DriverManager.getConnection(dropper);\n         }\n         catch (SQLException e) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NDQ1MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447974451", "bodyText": "ok", "author": "punktilious", "createdAt": "2020-06-30T20:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MTYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MTg4NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446971884", "bodyText": "I do not follow this message", "author": "prb112", "createdAt": "2020-06-29T13:29:36Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -166,75 +213,122 @@ public IDatabaseTranslator getTranslator() {\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param pdm\n      */\n-    public void createSchema(PhysicalDataModel pdm) {\n-        createSchema(vhs, pdm);\n+    public void createSchema(IConnectionProvider pool, PhysicalDataModel pdm) {\n+        createSchema(pool, vhs, pdm);\n     }\n \n     /**\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param vhs\n      * @param pdm\n      */\n-    public void createSchema(IVersionHistoryService vhs, PhysicalDataModel pdm) {\n-        runWithAdapter(target -> pdm.applyWithHistory(target, vhs));\n+    public void createSchema(IConnectionProvider pool, IVersionHistoryService vhs, PhysicalDataModel pdm) {\n+        runWithAdapter(pool, target -> pdm.applyWithHistory(target, vhs));\n     }\n+    \n+    public void runWithAdapter(IConnectionProvider pool, java.util.function.Consumer<IDatabaseAdapter> fn) {\n+\n+        // We need to obtain connections from the same pool as the version history service\n+        // so we can avoid deadlocks for certain DDL like DROP INDEX\n+        try {\n+            // wrap the connection pool in an adapter for the Derby database\n+            DerbyAdapter adapter = new DerbyAdapter(pool);\n+            \n+            // call the Function we've been given using the adapter we just wrapped\n+            // around the connection.\n+            fn.accept(adapter);\n+        } catch (DataAccessException x) {\n+            logger.log(Level.SEVERE, \"Error while running\", x);\n+            throw x;\n+        }\n+    }\n+\n \n     /**\n      * Run the function with an adapter configured for this database\n      * \n      * @param fn\n      */\n     public void runWithAdapter(java.util.function.Consumer<IDatabaseAdapter> fn) {\n-        try {\n-            Connection c = getConnection();\n-            try {\n-                JdbcTarget target = new JdbcTarget(c);\n-                DerbyAdapter adapter = new DerbyAdapter(target);\n \n-                // Replace the target with a decorated output, so that we print all the DDL before executing\n-                // The output is very FINE and logs out a lot. \n-                if (logger.isLoggable(Level.FINE)) {\n-                    PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n-                    adapter = new DerbyAdapter(printer);\n-                }\n-                fn.accept(adapter);\n-            } catch (DataAccessException x) {\n-                logger.log(Level.SEVERE, \"Error while running\", x);\n-                c.rollback();\n-                throw x;\n-            }\n-            c.commit();\n-        } catch (SQLException e) {\n-            logger.log(Level.SEVERE, \"Error while running\", e);\n-            throw DERBY_TRANSLATOR.translate(e);\n-        } finally {\n-            logger.info(\"connection was closed\");\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+\n+        // Replace the target with a decorated output, so that we print all the DDL before executing\n+        // The output is very FINE and logs out a lot. \n+        if (logger.isLoggable(Level.FINE)) {\n+            PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n+            adapter = new DerbyAdapter(printer);\n         }\n+      \n+        // call the Function we've been given using the adapter we just wrapped\n+        // around the connection. Each statement executes in its own connection/transaction.\n+        fn.accept(adapter);\n     }\n \n+    /**\n+     * Diagnostic utility to display all the current locks in the Derby database\n+     */\n+    public void dumpLockInfo() {\n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        System.out.println(LockInfo.header());\n+        locks.forEach(System.out::println);\n+    }\n+    \n+    /**\n+     * Dump locks using the given connection\n+     * @param c\n+     */\n+    public static void dumpLockInfo(Connection c) {\n+        // wrap the connection so that we can run our lock diag DAO\n+        JdbcTarget target = new JdbcTarget(c);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        \n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        \n+        // render\n+        System.out.println(LockInfo.header());\n+        locks.forEach(System.out::println);\n+    }\n+    \n+    /**\n+     * @implNote this drop is only relevant for in-memory Derby databases, which we no\n+     *           longer use due to the size of the tests. This does not remove any\n+     *           files on disk.\n+     */\n     @Override\n     public void close() throws Exception {\n-        // Drop the database we created\n-        boolean dropped = false;\n+        shutdown(database);\n+    }\n+    \n+    public static void shutdown(String databaseName) {\n+        boolean shutdown = false;\n         try {\n-            if (connection != null && !connection.isClosed()) {\n-                connection.close();\n-            }\n             Properties properties = new Properties();\n             DerbyPropertyAdapter adapter = new DerbyPropertyAdapter(properties);\n-            adapter.setDatabase(database);\n+            adapter.setDatabase(databaseName);\n \n-            final String dropper = DERBY_TRANSLATOR.getUrl(properties) + \";drop=true\";\n-            logger.info(\"Dropping derby DB with: \" + dropper);\n+            final String dropper = DERBY_TRANSLATOR.getUrl(properties) + \";shutdown=true\";\n+            logger.info(\"Shutting down Derby DB '\" + databaseName + \"' with: \" + dropper);\n+            \n+            // should throw an exception if successful\n             DriverManager.getConnection(dropper);\n         }\n         catch (SQLException e) {\n-            logger.info(\"Expected error while closing the database: \" + e.getMessage());\n-            dropped = true;\n+            // should say \"Database 'target/derby/...' shutdown.\"", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczOTI1Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447739253", "bodyText": "When you shut down a Derby database, it throws an exception to indicate that the shutdown was successful.", "author": "punktilious", "createdAt": "2020-06-30T14:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMDU0MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447900540", "bodyText": "I think it's a confusing message.", "author": "prb112", "createdAt": "2020-06-30T18:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MjQzMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446972430", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:30:24Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyTranslator.java", "diffHunk": "@@ -163,4 +165,30 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.DERBY;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */\n+    @Override\n+    public String dualTableName() {\n+        return \"SYSIBM.SYSDUMMY1\";\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n+     */\n+    @Override\n+    public String selectSequenceNextValue(String schemaName, String sequenceName) {\n+        String qname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        return \"SELECT NEXT VALUE FOR \" + qname + \" FROM SYSIBM.SYSDUMMY1\";\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0MDg1MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447740850", "bodyText": "fixed in my next commit", "author": "punktilious", "createdAt": "2020-06-30T14:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MjQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MzY3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446973676", "bodyText": "please fix the javadoc", "author": "prb112", "createdAt": "2020-06-29T13:32:06Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/AlterSequenceStartWith.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.model;\n+\n+import java.util.Set;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseAdapter;\n+\n+/**\n+ * Modify an existing sequence to start with a higher value\n+ */\n+public class AlterSequenceStartWith extends BaseObject {\n+    // the value we want the sequence to start with\n+    private final long startWith;\n+    \n+    // caching sequence values for tuning\n+    private final int cache;\n+\n+    /**\n+     * Public constructor\n+     * \n+     * @param schemaName\n+     * @param sequenceName\n+     * @param cache\n+     */\n+    public AlterSequenceStartWith(String schemaName, String sequenceName, int version, long startWith, int cache) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0MjA0OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447742048", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T14:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MzY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NDAwNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446974004", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-29T13:32:35Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/AlterSequenceStartWith.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.model;\n+\n+import java.util.Set;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseAdapter;\n+\n+/**\n+ * Modify an existing sequence to start with a higher value\n+ */\n+public class AlterSequenceStartWith extends BaseObject {\n+    // the value we want the sequence to start with\n+    private final long startWith;\n+    \n+    // caching sequence values for tuning\n+    private final int cache;\n+\n+    /**\n+     * Public constructor\n+     * \n+     * @param schemaName\n+     * @param sequenceName\n+     * @param cache\n+     */\n+    public AlterSequenceStartWith(String schemaName, String sequenceName, int version, long startWith, int cache) {\n+        super(schemaName, sequenceName, DatabaseObjectType.SEQUENCE, version);\n+        this.startWith = startWith;\n+        this.cache = cache;\n+    }\n+\n+    @Override\n+    public void apply(IDatabaseAdapter target) {\n+        target.alterSequenceRestartWith(getSchemaName(), getObjectName(), startWith, this.cache);\n+    }\n+\n+    @Override\n+    public void apply(Integer priorVersion, IDatabaseAdapter target) {\n+        apply(target);\n+    }\n+\n+    @Override\n+    public void drop(IDatabaseAdapter target) {\n+        target.dropSequence(getSchemaName(), getObjectName());\n+    }\n+\n+    @Override\n+    protected void grantGroupPrivileges(IDatabaseAdapter target, Set<Privilege> group, String toUser) {\n+        target.grantSequencePrivileges(getSchemaName(), getObjectName(), group, toUser);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.model.IDatabaseObject#visit(com.ibm.fhir.database.utils.model.DataModelVisitor)\n+     */\n+    @Override\n+    public void visit(DataModelVisitor v) {\n+        v.visited(this);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.model.IDatabaseObject#visitReverse(com.ibm.fhir.database.utils.model.DataModelVisitor)\n+     */\n+    @Override\n+    public void visitReverse(DataModelVisitor v) {\n+        v.visited(this);\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0MjU4Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447742586", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T14:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NDAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NTUyNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446975525", "bodyText": "does this signature change impact anything in prior releases?\ne.g. what's stored in the version history table?", "author": "prb112", "createdAt": "2020-06-29T13:34:55Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/IDatabaseObject.java", "diffHunk": "@@ -108,11 +108,11 @@\n     public String getName();\n \n     /**\n-     * Get the qualified name for this object prefixed with the object type\n-     * which acts as a namespace\n+     * Get the qualified name for this object:\n+     *   objectType:objectName:objectVersion\n      * @return\n      */\n-    public String getTypeAndName();\n+    public String getTypeNameVersion();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0NTc0NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447745744", "bodyText": "No, this doesn't change the semantics of the version history table. Its primary use is to provide a unique name describing the object/change in the task list (which can apply schema changes in parallel).", "author": "punktilious", "createdAt": "2020-06-30T14:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NjQ4Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446976487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param sequenceName\n          \n          \n            \n                 * @param cache\n          \n          \n            \n                 * @param sequenceName\n          \n          \n            \n                 * @param version\n          \n          \n            \n                 * @param startWith\n          \n          \n            \n                 * @param cache", "author": "prb112", "createdAt": "2020-06-29T13:36:22Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/Sequence.java", "diffHunk": "@@ -23,14 +27,15 @@\n      * @param sequenceName\n      * @param cache", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0NjU5OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447746599", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T14:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NjQ4Nw=="}], "type": "inlineReview"}, {"oid": "243856da5ef61561ca96c3fa777741ee94aa7aa8", "url": "https://github.com/IBM/FHIR/commit/243856da5ef61561ca96c3fa777741ee94aa7aa8", "message": "issue-1144 refactor of jdbc connection handling phase before DAO change\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-16T13:32:09Z", "type": "commit"}, {"oid": "b54bab634bbf178b49745220a80b870a862fb268", "url": "https://github.com/IBM/FHIR/commit/b54bab634bbf178b49745220a80b870a862fb268", "message": "issue-1144 refactor of jdbc persistence eliminated slow getSchema calls\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-16T20:25:05Z", "type": "commit"}, {"oid": "fb55438576a5e2e85b3c9beab999fef42c3d4516", "url": "https://github.com/IBM/FHIR/commit/fb55438576a5e2e85b3c9beab999fef42c3d4516", "message": "issue-1144 eliminated schema migration deadlock by coalescing DDL and version history transactions\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-17T18:39:28Z", "type": "commit"}, {"oid": "2bfec59a7840e98372b928a5801e0837ee636612", "url": "https://github.com/IBM/FHIR/commit/2bfec59a7840e98372b928a5801e0837ee636612", "message": "issue-1144 fixed JDBC persistence unit tests using new transaction mechanism\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-18T21:13:24Z", "type": "commit"}, {"oid": "4acab8f08f5c617d916a5f9a4dfc5cbb1cc0e6f9", "url": "https://github.com/IBM/FHIR/commit/4acab8f08f5c617d916a5f9a4dfc5cbb1cc0e6f9", "message": "issue-1144 better error when fhir-server-test fails\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-19T14:59:01Z", "type": "commit"}, {"oid": "95a63ed4310f20dc71caa6add081439a36d233f0", "url": "https://github.com/IBM/FHIR/commit/95a63ed4310f20dc71caa6add081439a36d233f0", "message": "Merge remote-tracking branch 'origin/HEAD' into issue-1144", "committedDate": "2020-06-19T15:00:08Z", "type": "commit"}, {"oid": "cbb33c44539d9f42642f5dd1d2b5498d56820992", "url": "https://github.com/IBM/FHIR/commit/cbb33c44539d9f42642f5dd1d2b5498d56820992", "message": "issue-1144 consume response body in fhir-server-test requests\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-19T17:34:00Z", "type": "commit"}, {"oid": "4b97db1c746c4699bbfcd91a9b04c560d4214c20", "url": "https://github.com/IBM/FHIR/commit/4b97db1c746c4699bbfcd91a9b04c560d4214c20", "message": "Merge remote-tracking branch 'origin/HEAD' into issue-1144", "committedDate": "2020-06-19T17:34:58Z", "type": "commit"}, {"oid": "130ee61c106cda5fb9dd88625179da01b947e703", "url": "https://github.com/IBM/FHIR/commit/130ee61c106cda5fb9dd88625179da01b947e703", "message": "issue-1144 fixed parameter_names duplicate after preload. issue-1263\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-22T20:09:15Z", "type": "commit"}, {"oid": "b03cb96b3374049f1797ef0761a6ad2e4a033dfb", "url": "https://github.com/IBM/FHIR/commit/b03cb96b3374049f1797ef0761a6ad2e4a033dfb", "message": "issue-1144 log DDL when altering sequence\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-22T20:30:21Z", "type": "commit"}, {"oid": "9348e76a297b89b336b2e60a877031fc89287ce3", "url": "https://github.com/IBM/FHIR/commit/9348e76a297b89b336b2e60a877031fc89287ce3", "message": "Merge remote-tracking branch 'origin/HEAD' into issue-1144", "committedDate": "2020-06-22T20:31:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE5MzM5NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r444193394", "bodyText": "here is the problem", "author": "prb112", "createdAt": "2020-06-23T12:43:58Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategyBase.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.api.DatabaseType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Common base for multi-tenant connection strategy implementations\n+ */\n+public abstract class FHIRDbConnectionStrategyBase implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbConnectionStrategyBase.class.getName());\n+    // We use the sync registry to remember connections we've configured in the current transaction.\n+    private final TransactionSynchronizationRegistry trxSyncRegistry;\n+\n+    // the action chain to be applied to new connections\n+    private final Action newConnectionAction;\n+    \n+    // The transaction handler\n+    private final UserTransaction userTransaction;\n+    \n+    private boolean rollbackOnly;\n+    \n+    // Type and capability \n+    private final FHIRDbFlavor flavor;\n+\n+    /**\n+     * Protected constructor\n+     * @param userTx the transaction handler\n+     * @param trxSyncRegistry\n+     * @param newConnectionAction\n+     */\n+    protected FHIRDbConnectionStrategyBase(UserTransaction userTx, TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRPersistenceDataAccessException {\n+        this.userTransaction = userTx;\n+        this.trxSyncRegistry = trxSyncRegistry;\n+        this.newConnectionAction = newConnectionAction;\n+        \n+        // initialize the flavor from the configuration\n+        this.flavor = createFlavor();\n+    }\n+\n+    /**\n+     * Check with the transaction sync registry to see if this is the first time\n+     * we've worked with this connection in the current transaction.\n+     * @param c the new connection\n+     * @param tenantId the tenant to which the connection belongs\n+     * @param dsId the datasource in the tenant to which the connection belongs\n+     */\n+    protected void configure(Connection connection, String tenantId, String dsId) throws FHIRPersistenceException {\n+        // We prefix the  key with the name of this class to avoid any potential conflict with other\n+        // users of the sync registry.        \n+        final String key = this.getClass().getName() + \"/\" + tenantId + \"/\" + dsId;\n+        if (trxSyncRegistry.getResource(key) == null) {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Configuring new connection in this transaction. Key='\" + key + \"'\");\n+            }\n+            \n+            // first time...so we need to apply actions. Will be cleared when the transaction commits\n+            newConnectionAction.performOn(connection);\n+            \n+            // and register the key so we don't do this again\n+            trxSyncRegistry.putResource(key, new Object());\n+        } else {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Connection already configured. Key='\" + key + \"'\");\n+            }\n+        }\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#txBegin()\n+     */\n+    @Override\n+    public void txBegin() throws FHIRPersistenceException {\n+        try {\n+            this.rollbackOnly = false;\n+            userTransaction.begin();\n+        } catch (Throwable e) {\n+            String errorMessage = \"Unexpected error while rolling a transaction.\";\n+            FHIRPersistenceException fx = new FHIRPersistenceException(errorMessage);\n+            log.log(Level.SEVERE, fx.getMessage(), e);\n+            throw fx;\n+        }\n+\n+    }\n+\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#commit()\n+     */\n+    @Override\n+    public void txEnd() throws FHIRPersistenceException {\n+        try {\n+            if (this.rollbackOnly) {\n+                userTransaction.rollback();\n+            } else {\n+                userTransaction.commit();\n+            }\n+        } catch (Throwable e) {\n+            FHIRPersistenceException fx = new FHIRPersistenceException(\"Unexpected error while committing a transaction.\");\n+            log.log(Level.SEVERE, fx.getMessage(), e);\n+            throw fx;\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#setRollbackOnly()\n+     */\n+    @Override\n+    public void txSetRollbackOnly() throws FHIRPersistenceException {\n+\n+        try {\n+            this.rollbackOnly = true;\n+            userTransaction.setRollbackOnly();\n+        } catch (Throwable e) {\n+            String errorMessage = \"Unexpected error while rolling a transaction.\";\n+            FHIRPersistenceException fx = new FHIRPersistenceException(errorMessage);\n+            log.log(Level.SEVERE, fx.getMessage(), e);\n+            throw fx;\n+        }\n+        \n+    }\n+    \n+    /**\n+     * Identify the flavor of the database using information from the\n+     * datasource configuration.\n+     * @return\n+     * @throws FHIRPersistenceException\n+     */\n+    private FHIRDbFlavor createFlavor() throws FHIRPersistenceDataAccessException {\n+        FHIRDbFlavor result;\n+        \n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        // Find and set the tenantKey for the request, otherwise subsequent pulls from the pool\n+        // miss the tenantKey.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            \n+            try {\n+                boolean multitenant = false;\n+                String typeValue = dsPG.getStringProperty(\"type\");\n+                \n+                DatabaseType type = DatabaseType.valueOf(typeValue);", "originalCommit": "9348e76a297b89b336b2e60a877031fc89287ce3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0f3440632f2969fb4c620d1f8098c8695e38ad0", "url": "https://github.com/IBM/FHIR/commit/d0f3440632f2969fb4c620d1f8098c8695e38ad0", "message": "issue-1144 fixed DatabaseType enum handling causing pipeline SIT failure\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-23T14:05:43Z", "type": "commit"}, {"oid": "776c89a05fc9449abaeed32d41e831d6501d3df9", "url": "https://github.com/IBM/FHIR/commit/776c89a05fc9449abaeed32d41e831d6501d3df9", "message": "Merge remote-tracking branch 'origin/HEAD' into issue-1144", "committedDate": "2020-06-23T14:43:11Z", "type": "commit"}, {"oid": "87a4296864020ddd99ff2f7dbb396ff8b5c3fa01", "url": "https://github.com/IBM/FHIR/commit/87a4296864020ddd99ff2f7dbb396ff8b5c3fa01", "message": "issue-1144 fixed sequence syntax for postgres\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-23T16:05:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyMjE2Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r444422167", "bodyText": "I think this should print a warning.", "author": "prb112", "createdAt": "2020-06-23T18:25:04Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/SetSchemaAction.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to set the named schema on a connection\n+ */\n+public class SetSchemaAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(SetSchemaAction.class.getName());\n+    \n+    private final String schemaName;\n+    /**\n+     * Public constructor\n+     */\n+    public SetSchemaAction() {\n+        this.schemaName = null;\n+    }\n+\n+    /**\n+     * Use a provided schema name (handy for testing)\n+     * @param schemaName\n+     */\n+    public SetSchemaAction(String schemaName) {\n+        this.schemaName = schemaName;\n+    }\n+\n+    /**\n+     * Public constructor\n+     * @param next action in a chain\n+     */\n+    public SetSchemaAction(Action next) {\n+        super(next);\n+        this.schemaName = null;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n+     */\n+    @Override\n+    public void performOn(Connection c) throws FHIRPersistenceDBConnectException {\n+        // this is being called the first time we've seen a connection for this\n+        // particular datastore. Find out which schema is configured, and make\n+        // sure it is set as the current schema.\n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            String schemaName;\n+            \n+            try {\n+                // Schema name can be given for unit-tests. At runtime, we always use the schema name property from the configuration\n+                if (this.schemaName != null) {\n+                    schemaName = this.schemaName;\n+                }\n+                else {\n+                    schemaName = dsPG.getStringProperty(\"currentSchema\", \"FHIRDATA\");\n+                }", "originalCommit": "87a4296864020ddd99ff2f7dbb396ff8b5c3fa01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "071291da2a9ddd8d704c5b4ed3ae89380756a4cf", "url": "https://github.com/IBM/FHIR/commit/071291da2a9ddd8d704c5b4ed3ae89380756a4cf", "message": "issue-1144 refactored to remove setSchema which exposes a transaction handling bug in Liberty\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-26T19:08:00Z", "type": "commit"}, {"oid": "237b3c7a25bb86d9d01cab9bffa56bf31941fe94", "url": "https://github.com/IBM/FHIR/commit/237b3c7a25bb86d9d01cab9bffa56bf31941fe94", "message": "Merge remote-tracking branch 'origin/HEAD' into issue-1144", "committedDate": "2020-06-26T19:11:47Z", "type": "commit"}, {"oid": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "url": "https://github.com/IBM/FHIR/commit/11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "message": "issue-1144 fixed transaction handling and added unit test for FHIRUserTransactionAdapter\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-06-27T04:17:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDQ5Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580497", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \n          \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseAdapter#alterSequenceRestartWith(java.lang.String, java.lang.String, long)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-27T23:56:01Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/CommonDatabaseAdapter.java", "diffHunk": "@@ -530,6 +531,29 @@ public void dropSequence(String schemaName, String sequenceName) {\n             logger.warning(ddl + \"; Sequence not found\");\n         }\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseAdapter#alterSequenceRestartWith(java.lang.String, java.lang.String, long)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDUxOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580518", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2019\n          \n          \n            \n             * (C) Copyright IBM Corp. 2020", "author": "prb112", "createdAt": "2020-06-27T23:56:17Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDU2NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-27T23:56:50Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IDatabaseTarget} which uses an {@link IConnectionProvider}\n+ * to obtain a connection which is then closed immediately for\n+ * each statement. Each run statement is committed before the\n+ * connection is closed. This target is not intended for use\n+ * with the ITransactionProvider/ITransaction implementation.\n+ */\n+public class ConnectionProviderTarget implements IDatabaseTarget {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp provides connections used for running statements\n+     */\n+    public ConnectionProviderTarget(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        // Execute the DDL (no parameters)\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (Statement s = connection.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatementWithInt(IDatabaseTranslator translator, String sql, int value) {\n+        // convenience for running a statement requiring a single int parameter\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (PreparedStatement ps = connection.prepareStatement(sql)) {\n+                ps.setInt(1, value);\n+                ps.executeUpdate(sql);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDU4NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-27T23:57:06Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IDatabaseTarget} which uses an {@link IConnectionProvider}\n+ * to obtain a connection which is then closed immediately for\n+ * each statement. Each run statement is committed before the\n+ * connection is closed. This target is not intended for use\n+ * with the ITransactionProvider/ITransaction implementation.\n+ */\n+public class ConnectionProviderTarget implements IDatabaseTarget {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp provides connections used for running statements\n+     */\n+    public ConnectionProviderTarget(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        // Execute the DDL (no parameters)\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (Statement s = connection.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDYwNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580604", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (Throwable t) {\n          \n          \n            \n                        } catch (Throwable t) {", "author": "prb112", "createdAt": "2020-06-27T23:57:28Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IDatabaseTarget} which uses an {@link IConnectionProvider}\n+ * to obtain a connection which is then closed immediately for\n+ * each statement. Each run statement is committed before the\n+ * connection is closed. This target is not intended for use\n+ * with the ITransactionProvider/ITransaction implementation.\n+ */\n+public class ConnectionProviderTarget implements IDatabaseTarget {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp provides connections used for running statements\n+     */\n+    public ConnectionProviderTarget(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        // Execute the DDL (no parameters)\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (Statement s = connection.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatementWithInt(IDatabaseTranslator translator, String sql, int value) {\n+        // convenience for running a statement requiring a single int parameter\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (PreparedStatement ps = connection.prepareStatement(sql)) {\n+                ps.setInt(1, value);\n+                ps.executeUpdate(sql);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, IDatabaseStatement statement) {\n+        \n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try {\n+                statement.run(translator, connection);\n+            }\n+            catch (Throwable t) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDYyMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580620", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-27T23:57:43Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IDatabaseTarget} which uses an {@link IConnectionProvider}\n+ * to obtain a connection which is then closed immediately for\n+ * each statement. Each run statement is committed before the\n+ * connection is closed. This target is not intended for use\n+ * with the ITransactionProvider/ITransaction implementation.\n+ */\n+public class ConnectionProviderTarget implements IDatabaseTarget {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp provides connections used for running statements\n+     */\n+    public ConnectionProviderTarget(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        // Execute the DDL (no parameters)\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (Statement s = connection.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatementWithInt(IDatabaseTranslator translator, String sql, int value) {\n+        // convenience for running a statement requiring a single int parameter\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (PreparedStatement ps = connection.prepareStatement(sql)) {\n+                ps.setInt(1, value);\n+                ps.executeUpdate(sql);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, IDatabaseStatement statement) {\n+        \n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try {\n+                statement.run(translator, connection);\n+            }\n+            catch (Throwable t) {\n+                connection.rollback();\n+                throw t;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDYzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580637", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (Throwable t) {\n          \n          \n            \n                        } catch (Throwable t) {", "author": "prb112", "createdAt": "2020-06-27T23:57:56Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IDatabaseTarget} which uses an {@link IConnectionProvider}\n+ * to obtain a connection which is then closed immediately for\n+ * each statement. Each run statement is committed before the\n+ * connection is closed. This target is not intended for use\n+ * with the ITransactionProvider/ITransaction implementation.\n+ */\n+public class ConnectionProviderTarget implements IDatabaseTarget {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp provides connections used for running statements\n+     */\n+    public ConnectionProviderTarget(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        // Execute the DDL (no parameters)\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (Statement s = connection.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatementWithInt(IDatabaseTranslator translator, String sql, int value) {\n+        // convenience for running a statement requiring a single int parameter\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (PreparedStatement ps = connection.prepareStatement(sql)) {\n+                ps.setInt(1, value);\n+                ps.executeUpdate(sql);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, IDatabaseStatement statement) {\n+        \n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try {\n+                statement.run(translator, connection);\n+            }\n+            catch (Throwable t) {\n+                connection.rollback();\n+                throw t;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public <T> T runStatement(IDatabaseTranslator translator, IDatabaseSupplier<T> supplier) {\n+        // execute the statement using the given translator and a fresh connection\n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            \n+            T result;\n+            try {\n+                result = supplier.run(translator, connection);\n+            }\n+            catch (Throwable t) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDY1Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580653", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-27T23:58:11Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/ConnectionProviderTarget.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IDatabaseTarget} which uses an {@link IConnectionProvider}\n+ * to obtain a connection which is then closed immediately for\n+ * each statement. Each run statement is committed before the\n+ * connection is closed. This target is not intended for use\n+ * with the ITransactionProvider/ITransaction implementation.\n+ */\n+public class ConnectionProviderTarget implements IDatabaseTarget {\n+\n+    private final IConnectionProvider connectionProvider;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp provides connections used for running statements\n+     */\n+    public ConnectionProviderTarget(IConnectionProvider cp) {\n+        this.connectionProvider = cp;\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, String ddl) {\n+        // Execute the DDL (no parameters)\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (Statement s = connection.createStatement()) {\n+                s.executeUpdate(ddl);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatementWithInt(IDatabaseTranslator translator, String sql, int value) {\n+        // convenience for running a statement requiring a single int parameter\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try (PreparedStatement ps = connection.prepareStatement(sql)) {\n+                ps.setInt(1, value);\n+                ps.executeUpdate(sql);\n+            } catch (SQLException x) {\n+                connection.rollback();\n+                throw x;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public void runStatement(IDatabaseTranslator translator, IDatabaseStatement statement) {\n+        \n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            try {\n+                statement.run(translator, connection);\n+            }\n+            catch (Throwable t) {\n+                connection.rollback();\n+                throw t;\n+            }\n+            connection.commit();\n+        }\n+        catch (SQLException x) {\n+            throw translator.translate(x);\n+        }\n+    }\n+\n+    @Override\n+    public <T> T runStatement(IDatabaseTranslator translator, IDatabaseSupplier<T> supplier) {\n+        // execute the statement using the given translator and a fresh connection\n+        // run the statement on a fresh connection and commit right away\n+        try (Connection connection = connectionProvider.getConnection()) {\n+            \n+            T result;\n+            try {\n+                result = supplier.run(translator, connection);\n+            }\n+            catch (Throwable t) {\n+                connection.rollback();\n+                throw t;\n+            }\n+            connection.commit();\n+            return result;\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDc0MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580740", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2019\n          \n          \n            \n             * (C) Copyright IBM Corp. 2020", "author": "prb112", "createdAt": "2020-06-27T23:59:33Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/GetSequenceNextValueDAO.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDc1OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580759", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-27T23:59:51Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/GetSequenceNextValueDAO.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * DAO to create a free tenant slot (to align with a new partition)\n+ */\n+public class GetSequenceNextValueDAO implements IDatabaseSupplier<Long> {\n+\n+    // the name of the schema with the sequence\n+    private final String schemaName;\n+    \n+    // the name of the sequence\n+    private final String sequenceName;\n+    \n+    /**\n+     * DAO to get the next value from the named sequence\n+     * @param schemaName\n+     * @param sequenceName\n+     */\n+    public GetSequenceNextValueDAO(String schemaName, String sequenceName) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        DataDefinitionUtil.assertValidName(sequenceName);\n+        this.schemaName = schemaName;\n+        this.sequenceName = sequenceName;\n+    }\n+    \n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDgwMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580803", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "author": "prb112", "createdAt": "2020-06-28T00:00:06Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/GetSequenceNextValueDAO.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * DAO to create a free tenant slot (to align with a new partition)\n+ */\n+public class GetSequenceNextValueDAO implements IDatabaseSupplier<Long> {\n+\n+    // the name of the schema with the sequence\n+    private final String schemaName;\n+    \n+    // the name of the sequence\n+    private final String sequenceName;\n+    \n+    /**\n+     * DAO to get the next value from the named sequence\n+     * @param schemaName\n+     * @param sequenceName\n+     */\n+    public GetSequenceNextValueDAO(String schemaName, String sequenceName) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        DataDefinitionUtil.assertValidName(sequenceName);\n+        this.schemaName = schemaName;\n+        this.sequenceName = sequenceName;\n+    }\n+    \n+    \n+    /**\n+     * Execute the encapsulated query against the database and stream the result data to the\n+     * configured target\n+     * @param c\n+     */\n+    @Override\n+    public Long run(IDatabaseTranslator translator, Connection c) {\n+        // you can't get the current value before calling next value in a given session,\n+        // so we simply bump the sequence number. The translator is used to support\n+        // our different database flavors (e.g. Derby, DB2 and PostgreSQL)\n+        final String SQL = translator.selectSequenceNextValue(schemaName, sequenceName);\n+\n+        try (PreparedStatement ps = c.prepareStatement(SQL)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                long currentValue = rs.getInt(1);\n+                if (rs.wasNull()) {\n+                    return null;\n+                }\n+                else {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDgzNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580835", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "prb112", "createdAt": "2020-06-28T00:00:19Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/GetSequenceNextValueDAO.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * DAO to create a free tenant slot (to align with a new partition)\n+ */\n+public class GetSequenceNextValueDAO implements IDatabaseSupplier<Long> {\n+\n+    // the name of the schema with the sequence\n+    private final String schemaName;\n+    \n+    // the name of the sequence\n+    private final String sequenceName;\n+    \n+    /**\n+     * DAO to get the next value from the named sequence\n+     * @param schemaName\n+     * @param sequenceName\n+     */\n+    public GetSequenceNextValueDAO(String schemaName, String sequenceName) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        DataDefinitionUtil.assertValidName(sequenceName);\n+        this.schemaName = schemaName;\n+        this.sequenceName = sequenceName;\n+    }\n+    \n+    \n+    /**\n+     * Execute the encapsulated query against the database and stream the result data to the\n+     * configured target\n+     * @param c\n+     */\n+    @Override\n+    public Long run(IDatabaseTranslator translator, Connection c) {\n+        // you can't get the current value before calling next value in a given session,\n+        // so we simply bump the sequence number. The translator is used to support\n+        // our different database flavors (e.g. Derby, DB2 and PostgreSQL)\n+        final String SQL = translator.selectSequenceNextValue(schemaName, sequenceName);\n+\n+        try (PreparedStatement ps = c.prepareStatement(SQL)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                long currentValue = rs.getInt(1);\n+                if (rs.wasNull()) {\n+                    return null;\n+                }\n+                else {\n+                    return currentValue;\n+                }\n+            }\n+            else {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDg0OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580849", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-28T00:00:36Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/GetSequenceNextValueDAO.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * DAO to create a free tenant slot (to align with a new partition)\n+ */\n+public class GetSequenceNextValueDAO implements IDatabaseSupplier<Long> {\n+\n+    // the name of the schema with the sequence\n+    private final String schemaName;\n+    \n+    // the name of the sequence\n+    private final String sequenceName;\n+    \n+    /**\n+     * DAO to get the next value from the named sequence\n+     * @param schemaName\n+     * @param sequenceName\n+     */\n+    public GetSequenceNextValueDAO(String schemaName, String sequenceName) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        DataDefinitionUtil.assertValidName(sequenceName);\n+        this.schemaName = schemaName;\n+        this.sequenceName = sequenceName;\n+    }\n+    \n+    \n+    /**\n+     * Execute the encapsulated query against the database and stream the result data to the\n+     * configured target\n+     * @param c\n+     */\n+    @Override\n+    public Long run(IDatabaseTranslator translator, Connection c) {\n+        // you can't get the current value before calling next value in a given session,\n+        // so we simply bump the sequence number. The translator is used to support\n+        // our different database flavors (e.g. Derby, DB2 and PostgreSQL)\n+        final String SQL = translator.selectSequenceNextValue(schemaName, sequenceName);\n+\n+        try (PreparedStatement ps = c.prepareStatement(SQL)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                long currentValue = rs.getInt(1);\n+                if (rs.wasNull()) {\n+                    return null;\n+                }\n+                else {\n+                    return currentValue;\n+                }\n+            }\n+            else {\n+                // Something broken with the SQL engine if this happens!\n+                throw new IllegalStateException(SQL + \" returned nothing\");\n+            }\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDkxNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580917", "bodyText": "Should we be throwing the SQL here? could it ever include private identifiers?", "author": "prb112", "createdAt": "2020-06-28T00:01:38Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/GetSequenceNextValueDAO.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.common;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * DAO to create a free tenant slot (to align with a new partition)\n+ */\n+public class GetSequenceNextValueDAO implements IDatabaseSupplier<Long> {\n+\n+    // the name of the schema with the sequence\n+    private final String schemaName;\n+    \n+    // the name of the sequence\n+    private final String sequenceName;\n+    \n+    /**\n+     * DAO to get the next value from the named sequence\n+     * @param schemaName\n+     * @param sequenceName\n+     */\n+    public GetSequenceNextValueDAO(String schemaName, String sequenceName) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        DataDefinitionUtil.assertValidName(sequenceName);\n+        this.schemaName = schemaName;\n+        this.sequenceName = sequenceName;\n+    }\n+    \n+    \n+    /**\n+     * Execute the encapsulated query against the database and stream the result data to the\n+     * configured target\n+     * @param c\n+     */\n+    @Override\n+    public Long run(IDatabaseTranslator translator, Connection c) {\n+        // you can't get the current value before calling next value in a given session,\n+        // so we simply bump the sequence number. The translator is used to support\n+        // our different database flavors (e.g. Derby, DB2 and PostgreSQL)\n+        final String SQL = translator.selectSequenceNextValue(schemaName, sequenceName);\n+\n+        try (PreparedStatement ps = c.prepareStatement(SQL)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                long currentValue = rs.getInt(1);\n+                if (rs.wasNull()) {\n+                    return null;\n+                }\n+                else {\n+                    return currentValue;\n+                }\n+            }\n+            else {\n+                // Something broken with the SQL engine if this happens!\n+                throw new IllegalStateException(SQL + \" returned nothing\");", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk2MTgyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446961828", "bodyText": "No risk here. It's just the SQL for getting the next value from a sequence, and the chance of this actually being thrown is practically 0.", "author": "punktilious", "createdAt": "2020-06-29T13:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDk3MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580971", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:02:16Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Translator.java", "diffHunk": "@@ -233,4 +235,29 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return true;\n     }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MDk5MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446580990", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:02:31Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Translator.java", "diffHunk": "@@ -233,4 +235,29 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return true;\n     }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.DB2;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTAwNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581005", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:02:43Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Translator.java", "diffHunk": "@@ -233,4 +235,29 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return true;\n     }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.DB2;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */\n+    @Override\n+    public String dualTableName() {\n+        return \"SYSIBM.SYSDUMMY1\";\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTA5Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581093", "bodyText": "the above CREATE sequence seems out of place. - I suggest putting it where fhir_sequence is actually created or in a unit test", "author": "prb112", "createdAt": "2020-06-28T00:03:58Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyAdapter.java", "diffHunk": "@@ -181,20 +183,57 @@ public boolean doesTableExist(String schemaName, String tableName) {\n     }\n \n     @Override\n-    public void createSequence(String schemaName, String sequenceName, int cache) {\n+    public void createSequence(String schemaName, String sequenceName, long startWith, int cache) {\n         /* CREATE SEQUENCE fhir_sequence\n          *     AS BIGINT\n          *     START WITH 1\n          *     CACHE 1000\n          *     NO CYCLE;\n-        */\n+         */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk2Mzg2NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446963864", "bodyText": "It's just an example of the syntax we need to build. Comment will be made more generic.", "author": "punktilious", "createdAt": "2020-06-29T13:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTEwMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581101", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (UndefinedNameException x) {\n          \n          \n            \n                    } catch (UndefinedNameException x) {", "author": "prb112", "createdAt": "2020-06-28T00:04:11Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyAdapter.java", "diffHunk": "@@ -181,20 +183,57 @@ public boolean doesTableExist(String schemaName, String tableName) {\n     }\n \n     @Override\n-    public void createSequence(String schemaName, String sequenceName, int cache) {\n+    public void createSequence(String schemaName, String sequenceName, long startWith, int cache) {\n         /* CREATE SEQUENCE fhir_sequence\n          *     AS BIGINT\n          *     START WITH 1\n          *     CACHE 1000\n          *     NO CYCLE;\n-        */\n+         */\n         // Derby doesn't support CACHE\n         final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n-        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH \" + startWith + \" NO CYCLE\";\n         runStatement(ddl);\n+    }\n+    \n+    @Override\n+    public void dropSequence(String schemaName, String sequenceName) {\n+        // the \"RESTRICT\" keyword is mandatory in Derby\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"DROP SEQUENCE \" + sname + \" RESTRICT\";\n+\n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (UndefinedNameException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTEyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseAdapter#alterSequenceRestartWith(java.lang.String, java.lang.String, long)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:04:27Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyAdapter.java", "diffHunk": "@@ -181,20 +183,57 @@ public boolean doesTableExist(String schemaName, String tableName) {\n     }\n \n     @Override\n-    public void createSequence(String schemaName, String sequenceName, int cache) {\n+    public void createSequence(String schemaName, String sequenceName, long startWith, int cache) {\n         /* CREATE SEQUENCE fhir_sequence\n          *     AS BIGINT\n          *     START WITH 1\n          *     CACHE 1000\n          *     NO CYCLE;\n-        */\n+         */\n         // Derby doesn't support CACHE\n         final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n-        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH \" + startWith + \" NO CYCLE\";\n         runStatement(ddl);\n+    }\n+    \n+    @Override\n+    public void dropSequence(String schemaName, String sequenceName) {\n+        // the \"RESTRICT\" keyword is mandatory in Derby\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"DROP SEQUENCE \" + sname + \" RESTRICT\";\n+\n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (UndefinedNameException x) {\n+            logger.warning(ddl + \"; Sequence not found\");\n+        }\n+    }\n \n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseAdapter#alterSequenceRestartWith(java.lang.String, java.lang.String, long)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTE1OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581158", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:04:48Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyAdapter.java", "diffHunk": "@@ -313,4 +352,5 @@ public void setIntegrityUnchecked(String schemaName, String tableName) {\n         // not expecting this to be called for this adapter\n         throw new UnsupportedOperationException(\"Set integrity unchecked not supported for this adapter.\");\n     }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTE3Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581173", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2020", "author": "prb112", "createdAt": "2020-06-28T00:05:00Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyConnectionProvider.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTIxOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581218", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:05:30Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyConnectionProvider.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.derby;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IConnectionProvider} wrapper around DerbyMaster\n+ */\n+public class DerbyConnectionProvider implements IConnectionProvider {\n+    private static final Logger logger = Logger.getLogger(DerbyConnectionProvider.class.getName());\n+\n+    // The wrapper for managing a derby in-memory instance\n+    private final DerbyMaster derby;\n+    \n+    // The schema name to set as current for each new connection\n+    private final String schemaName;\n+\n+    /**\n+     * Wrap the derby database\n+     * @param derby the Derby database instance to wrap and provide connections for\n+     * @param the schema name to set as current on each connection, or null to not set the schema\n+     */\n+    public DerbyConnectionProvider(DerbyMaster derby, String schemaName) {\n+        this.derby = derby;\n+        this.schemaName = schemaName;\n+    }\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTI1NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581255", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void describe(String arg0, StringBuilder arg1, String arg2) {\n          \n          \n            \n                }\n          \n          \n            \n                public void describe(String arg0, StringBuilder arg1, String arg2) {\n          \n          \n            \n                    // NOP\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-28T00:06:05Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyConnectionProvider.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.derby;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * An {@link IConnectionProvider} wrapper around DerbyMaster\n+ */\n+public class DerbyConnectionProvider implements IConnectionProvider {\n+    private static final Logger logger = Logger.getLogger(DerbyConnectionProvider.class.getName());\n+\n+    // The wrapper for managing a derby in-memory instance\n+    private final DerbyMaster derby;\n+    \n+    // The schema name to set as current for each new connection\n+    private final String schemaName;\n+\n+    /**\n+     * Wrap the derby database\n+     * @param derby the Derby database instance to wrap and provide connections for\n+     * @param the schema name to set as current on each connection, or null to not set the schema\n+     */\n+    public DerbyConnectionProvider(DerbyMaster derby, String schemaName) {\n+        this.derby = derby;\n+        this.schemaName = schemaName;\n+    }\n+\n+\n+    @Override\n+    public void commitTransaction() throws SQLException {\n+        // NOP\n+    }\n+\n+    @Override\n+    public void describe(String arg0, StringBuilder arg1, String arg2) {\n+    }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTMwNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2019\n          \n          \n            \n             * (C) Copyright IBM Corp. 2020\n          \n      \n    \n    \n  \n\nPlease fix your copyright headers", "author": "prb112", "createdAt": "2020-06-28T00:06:40Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyLockDiag.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk2ODgyNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446968825", "bodyText": "The template is this:\n/*\n * (C) Copyright IBM Corp. 2020\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nnot sure where the 2019 is coming from", "author": "punktilious", "createdAt": "2020-06-29T13:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTMyNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581325", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public DerbyLockDiag() {\n          \n          \n            \n                public DerbyLockDiag() {\n          \n          \n            \n                    // NOP", "author": "prb112", "createdAt": "2020-06-28T00:07:02Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyLockDiag.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.derby;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * Fetch all the rows from the SYSCS_DIAG.LOCK_TABLE\n+ */\n+public class DerbyLockDiag implements IDatabaseSupplier<List<LockInfo>> {\n+\n+    private final String SQL = \"\"\n+            + \" SELECT xid, type, mode, tablename, lockname, state, tabletype, lockcount, indexname \"\n+            + \"   FROM SYSCS_DIAG.LOCK_TABLE\";\n+    \n+    /**\n+     * Public constructor\n+     */\n+    public DerbyLockDiag() {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTM2Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581362", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-28T00:07:16Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyLockDiag.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.derby;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+\n+/**\n+ * Fetch all the rows from the SYSCS_DIAG.LOCK_TABLE\n+ */\n+public class DerbyLockDiag implements IDatabaseSupplier<List<LockInfo>> {\n+\n+    private final String SQL = \"\"\n+            + \" SELECT xid, type, mode, tablename, lockname, state, tabletype, lockcount, indexname \"\n+            + \"   FROM SYSCS_DIAG.LOCK_TABLE\";\n+    \n+    /**\n+     * Public constructor\n+     */\n+    public DerbyLockDiag() {\n+    }\n+\n+    @Override\n+    public List<LockInfo> run(IDatabaseTranslator translator, Connection c) {\n+\n+        List<LockInfo> result = new ArrayList<>();\n+        try (PreparedStatement ps = c.prepareStatement(SQL)) {\n+            ResultSet rs = ps.executeQuery();\n+            while (rs.next()) {\n+                LockInfo info = new LockInfo(\n+                    rs.getString(1),\n+                    rs.getString(2),\n+                    rs.getString(3),\n+                    rs.getString(4),\n+                    rs.getString(5),\n+                    rs.getString(6),\n+                    rs.getString(7),\n+                    rs.getString(8),\n+                    rs.getString(9));\n+                result.add(info);\n+            }\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTQzOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581438", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            catch (SQLException x) {\n          \n          \n            \n                            } catch (SQLException x) {\n          \n      \n    \n    \n  \n\nThis is just messy to look at", "author": "prb112", "createdAt": "2020-06-28T00:07:52Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -64,11 +66,46 @@ public DerbyMaster(String database) {\n         }\n \n         // Derby Server Properties are now set using the System Stored procedures.\n-        try {\n-            DerbyServerPropertiesMgr.setServerProperties(DEBUG, getConnection());\n+        try (Connection c = getConnection()) {\n+            DerbyServerPropertiesMgr.setServerProperties(DEBUG, c);\n+            c.commit();\n+        } catch (SQLException e) {\n+            logger.log(Level.WARNING, \"Derby Server Properties not set\", e);\n+        }\n+    }\n+    \n+    /**\n+     * Derby setSchema fails if the schema doesn't exist, so we need to create that\n+     * now in order for our connections to succeed when we build out the FHIR database\n+     * @param schemaName\n+     */\n+    public void createSchemaIfNeeded(String schemaName) {\n+        DataDefinitionUtil.assertSecure(schemaName);\n+        boolean createSchema = false;\n+        try (Connection c = getConnection()) {\n+            try {\n+                c.setSchema(schemaName);\n+            } catch (SQLException x) {\n+                // schema doesn't exist, so we need to create it\n+                createSchema = true;\n+            }\n+\n+            if (createSchema) {\n+                final String createSchemaDDL = \"CREATE SCHEMA \" + schemaName;\n+                JdbcTarget target = new JdbcTarget(c);\n+                target.runStatement(DERBY_TRANSLATOR, createSchemaDDL);\n+                \n+                try {\n+                    c.commit();\n+                }\n+                catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MjAzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446972031", "bodyText": "What is?", "author": "punktilious", "createdAt": "2020-06-29T13:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTQ1OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581459", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (IllegalStateException x) {\n          \n          \n            \n                    } catch (IllegalStateException x) {", "author": "prb112", "createdAt": "2020-06-28T00:08:08Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -80,7 +117,15 @@ public static void dropDatabase(String database) {\n         if (!database.contains(DERBY_DIR)) {\n             throw new IllegalArgumentException(\"Derby databases must start with: \" + DERBY_DIR);\n         }\n-\n+        \n+        // Make sure the database is shut down before we try to drop it\n+        try {\n+            shutdown(database);\n+        }\n+        catch (IllegalStateException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTQ4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581480", "bodyText": "please add a logger statement here", "author": "prb112", "createdAt": "2020-06-28T00:08:29Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -80,7 +117,15 @@ public static void dropDatabase(String database) {\n         if (!database.contains(DERBY_DIR)) {\n             throw new IllegalArgumentException(\"Derby databases must start with: \" + DERBY_DIR);\n         }\n-\n+        \n+        // Make sure the database is shut down before we try to drop it\n+        try {\n+            shutdown(database);\n+        }\n+        catch (IllegalStateException x) {\n+            // NOP - database doesn't exist anyway", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NjIwMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447956203", "bodyText": "added logger.info(\"DROP DATABASE - database does not exist: \" + database);", "author": "punktilious", "createdAt": "2020-06-30T20:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTUwNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581507", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "author": "prb112", "createdAt": "2020-06-28T00:08:57Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -131,27 +176,29 @@ private static void delete(File file) throws IOException {\n \n     /**\n      * Get a connection to the configured Derby database, creating the database if necessary.\n+     * @implNote creates a new connection each time. Should be wrapped in an IConnectionProvider\n+     *           implementation for use where a transaction might scope multiple open/close\n+     *           connections. This class returns the driver's connection. For proper transaction\n+     *           handling, the connection needs to be wrapped, which IConnectionProvider can\n+     *           take care of.\n      * @return\n      * @throws SQLException\n-     * @implNote currently this returns the same connection each time, so don't close it!\n      */\n-    public synchronized Connection getConnection() throws SQLException {\n+    public Connection getConnection() throws SQLException {\n         logger.info(\"Opening connection to Derby database: \" + database);\n-        if (connection == null) {\n-            try {\n-                // Make sure the Derby driver is loaded\n-                Properties properties = new Properties();\n-                DerbyPropertyAdapter adapter = new DerbyPropertyAdapter(properties);\n-                adapter.setDatabase(database);\n-                adapter.setAutoCreate(true);\n-                connection = DriverManager.getConnection(DERBY_TRANSLATOR.getUrl(properties));\n-                connection.setAutoCommit(false);\n-            }\n-            catch (SQLException x) {\n-                throw DERBY_TRANSLATOR.translate(x);\n-            }\n+        try {\n+            // Make sure the Derby driver is loaded\n+            Properties properties = new Properties();\n+            DerbyPropertyAdapter adapter = new DerbyPropertyAdapter(properties);\n+            adapter.setDatabase(database);\n+            adapter.setAutoCreate(true);\n+            Connection connection = DriverManager.getConnection(DERBY_TRANSLATOR.getUrl(properties));\n+            connection.setAutoCommit(false);\n+            return connection;\n+        }\n+        catch (SQLException x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTU1Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581557", "bodyText": "Why the full package name is specified?", "author": "prb112", "createdAt": "2020-06-28T00:09:26Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -166,75 +213,122 @@ public IDatabaseTranslator getTranslator() {\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param pdm\n      */\n-    public void createSchema(PhysicalDataModel pdm) {\n-        createSchema(vhs, pdm);\n+    public void createSchema(IConnectionProvider pool, PhysicalDataModel pdm) {\n+        createSchema(pool, vhs, pdm);\n     }\n \n     /**\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param vhs\n      * @param pdm\n      */\n-    public void createSchema(IVersionHistoryService vhs, PhysicalDataModel pdm) {\n-        runWithAdapter(target -> pdm.applyWithHistory(target, vhs));\n+    public void createSchema(IConnectionProvider pool, IVersionHistoryService vhs, PhysicalDataModel pdm) {\n+        runWithAdapter(pool, target -> pdm.applyWithHistory(target, vhs));\n     }\n+    \n+    public void runWithAdapter(IConnectionProvider pool, java.util.function.Consumer<IDatabaseAdapter> fn) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NDg5NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446974894", "bodyText": "Probably to help Eclipse find the right Consumer more quickly when typing. No other reason.", "author": "punktilious", "createdAt": "2020-06-29T13:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NjM4Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447956383", "bodyText": "added import", "author": "punktilious", "createdAt": "2020-06-30T20:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTYwOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581609", "bodyText": "I think you should use a logger", "author": "prb112", "createdAt": "2020-06-28T00:09:57Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -166,75 +213,122 @@ public IDatabaseTranslator getTranslator() {\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param pdm\n      */\n-    public void createSchema(PhysicalDataModel pdm) {\n-        createSchema(vhs, pdm);\n+    public void createSchema(IConnectionProvider pool, PhysicalDataModel pdm) {\n+        createSchema(pool, vhs, pdm);\n     }\n \n     /**\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param vhs\n      * @param pdm\n      */\n-    public void createSchema(IVersionHistoryService vhs, PhysicalDataModel pdm) {\n-        runWithAdapter(target -> pdm.applyWithHistory(target, vhs));\n+    public void createSchema(IConnectionProvider pool, IVersionHistoryService vhs, PhysicalDataModel pdm) {\n+        runWithAdapter(pool, target -> pdm.applyWithHistory(target, vhs));\n     }\n+    \n+    public void runWithAdapter(IConnectionProvider pool, java.util.function.Consumer<IDatabaseAdapter> fn) {\n+\n+        // We need to obtain connections from the same pool as the version history service\n+        // so we can avoid deadlocks for certain DDL like DROP INDEX\n+        try {\n+            // wrap the connection pool in an adapter for the Derby database\n+            DerbyAdapter adapter = new DerbyAdapter(pool);\n+            \n+            // call the Function we've been given using the adapter we just wrapped\n+            // around the connection.\n+            fn.accept(adapter);\n+        } catch (DataAccessException x) {\n+            logger.log(Level.SEVERE, \"Error while running\", x);\n+            throw x;\n+        }\n+    }\n+\n \n     /**\n      * Run the function with an adapter configured for this database\n      * \n      * @param fn\n      */\n     public void runWithAdapter(java.util.function.Consumer<IDatabaseAdapter> fn) {\n-        try {\n-            Connection c = getConnection();\n-            try {\n-                JdbcTarget target = new JdbcTarget(c);\n-                DerbyAdapter adapter = new DerbyAdapter(target);\n \n-                // Replace the target with a decorated output, so that we print all the DDL before executing\n-                // The output is very FINE and logs out a lot. \n-                if (logger.isLoggable(Level.FINE)) {\n-                    PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n-                    adapter = new DerbyAdapter(printer);\n-                }\n-                fn.accept(adapter);\n-            } catch (DataAccessException x) {\n-                logger.log(Level.SEVERE, \"Error while running\", x);\n-                c.rollback();\n-                throw x;\n-            }\n-            c.commit();\n-        } catch (SQLException e) {\n-            logger.log(Level.SEVERE, \"Error while running\", e);\n-            throw DERBY_TRANSLATOR.translate(e);\n-        } finally {\n-            logger.info(\"connection was closed\");\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+\n+        // Replace the target with a decorated output, so that we print all the DDL before executing\n+        // The output is very FINE and logs out a lot. \n+        if (logger.isLoggable(Level.FINE)) {\n+            PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n+            adapter = new DerbyAdapter(printer);\n         }\n+      \n+        // call the Function we've been given using the adapter we just wrapped\n+        // around the connection. Each statement executes in its own connection/transaction.\n+        fn.accept(adapter);\n     }\n \n+    /**\n+     * Diagnostic utility to display all the current locks in the Derby database\n+     */\n+    public void dumpLockInfo() {\n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        System.out.println(LockInfo.header());", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3NzYxOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446977619", "bodyText": "I considered logger output, but it ruins the tabular formatting. It's targeted as a development-time feature, which is why System.out in this case is appropriate.", "author": "punktilious", "createdAt": "2020-06-29T13:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTY1OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581658", "bodyText": "the comment isn't needed", "author": "prb112", "createdAt": "2020-06-28T00:10:19Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -166,75 +213,122 @@ public IDatabaseTranslator getTranslator() {\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param pdm\n      */\n-    public void createSchema(PhysicalDataModel pdm) {\n-        createSchema(vhs, pdm);\n+    public void createSchema(IConnectionProvider pool, PhysicalDataModel pdm) {\n+        createSchema(pool, vhs, pdm);\n     }\n \n     /**\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param vhs\n      * @param pdm\n      */\n-    public void createSchema(IVersionHistoryService vhs, PhysicalDataModel pdm) {\n-        runWithAdapter(target -> pdm.applyWithHistory(target, vhs));\n+    public void createSchema(IConnectionProvider pool, IVersionHistoryService vhs, PhysicalDataModel pdm) {\n+        runWithAdapter(pool, target -> pdm.applyWithHistory(target, vhs));\n     }\n+    \n+    public void runWithAdapter(IConnectionProvider pool, java.util.function.Consumer<IDatabaseAdapter> fn) {\n+\n+        // We need to obtain connections from the same pool as the version history service\n+        // so we can avoid deadlocks for certain DDL like DROP INDEX\n+        try {\n+            // wrap the connection pool in an adapter for the Derby database\n+            DerbyAdapter adapter = new DerbyAdapter(pool);\n+            \n+            // call the Function we've been given using the adapter we just wrapped\n+            // around the connection.\n+            fn.accept(adapter);\n+        } catch (DataAccessException x) {\n+            logger.log(Level.SEVERE, \"Error while running\", x);\n+            throw x;\n+        }\n+    }\n+\n \n     /**\n      * Run the function with an adapter configured for this database\n      * \n      * @param fn\n      */\n     public void runWithAdapter(java.util.function.Consumer<IDatabaseAdapter> fn) {\n-        try {\n-            Connection c = getConnection();\n-            try {\n-                JdbcTarget target = new JdbcTarget(c);\n-                DerbyAdapter adapter = new DerbyAdapter(target);\n \n-                // Replace the target with a decorated output, so that we print all the DDL before executing\n-                // The output is very FINE and logs out a lot. \n-                if (logger.isLoggable(Level.FINE)) {\n-                    PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n-                    adapter = new DerbyAdapter(printer);\n-                }\n-                fn.accept(adapter);\n-            } catch (DataAccessException x) {\n-                logger.log(Level.SEVERE, \"Error while running\", x);\n-                c.rollback();\n-                throw x;\n-            }\n-            c.commit();\n-        } catch (SQLException e) {\n-            logger.log(Level.SEVERE, \"Error while running\", e);\n-            throw DERBY_TRANSLATOR.translate(e);\n-        } finally {\n-            logger.info(\"connection was closed\");\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+\n+        // Replace the target with a decorated output, so that we print all the DDL before executing\n+        // The output is very FINE and logs out a lot. \n+        if (logger.isLoggable(Level.FINE)) {\n+            PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n+            adapter = new DerbyAdapter(printer);\n         }\n+      \n+        // call the Function we've been given using the adapter we just wrapped\n+        // around the connection. Each statement executes in its own connection/transaction.\n+        fn.accept(adapter);\n     }\n \n+    /**\n+     * Diagnostic utility to display all the current locks in the Derby database\n+     */\n+    public void dumpLockInfo() {\n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        System.out.println(LockInfo.header());\n+        locks.forEach(System.out::println);\n+    }\n+    \n+    /**\n+     * Dump locks using the given connection\n+     * @param c\n+     */\n+    public static void dumpLockInfo(Connection c) {\n+        // wrap the connection so that we can run our lock diag DAO\n+        JdbcTarget target = new JdbcTarget(c);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        \n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        \n+        // render", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTY2NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581665", "bodyText": "Fix the logger", "author": "prb112", "createdAt": "2020-06-28T00:10:28Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyMaster.java", "diffHunk": "@@ -166,75 +213,122 @@ public IDatabaseTranslator getTranslator() {\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param pdm\n      */\n-    public void createSchema(PhysicalDataModel pdm) {\n-        createSchema(vhs, pdm);\n+    public void createSchema(IConnectionProvider pool, PhysicalDataModel pdm) {\n+        createSchema(pool, vhs, pdm);\n     }\n \n     /**\n      * Ask the schema to apply itself to our target (adapter pattern)\n      * @param vhs\n      * @param pdm\n      */\n-    public void createSchema(IVersionHistoryService vhs, PhysicalDataModel pdm) {\n-        runWithAdapter(target -> pdm.applyWithHistory(target, vhs));\n+    public void createSchema(IConnectionProvider pool, IVersionHistoryService vhs, PhysicalDataModel pdm) {\n+        runWithAdapter(pool, target -> pdm.applyWithHistory(target, vhs));\n     }\n+    \n+    public void runWithAdapter(IConnectionProvider pool, java.util.function.Consumer<IDatabaseAdapter> fn) {\n+\n+        // We need to obtain connections from the same pool as the version history service\n+        // so we can avoid deadlocks for certain DDL like DROP INDEX\n+        try {\n+            // wrap the connection pool in an adapter for the Derby database\n+            DerbyAdapter adapter = new DerbyAdapter(pool);\n+            \n+            // call the Function we've been given using the adapter we just wrapped\n+            // around the connection.\n+            fn.accept(adapter);\n+        } catch (DataAccessException x) {\n+            logger.log(Level.SEVERE, \"Error while running\", x);\n+            throw x;\n+        }\n+    }\n+\n \n     /**\n      * Run the function with an adapter configured for this database\n      * \n      * @param fn\n      */\n     public void runWithAdapter(java.util.function.Consumer<IDatabaseAdapter> fn) {\n-        try {\n-            Connection c = getConnection();\n-            try {\n-                JdbcTarget target = new JdbcTarget(c);\n-                DerbyAdapter adapter = new DerbyAdapter(target);\n \n-                // Replace the target with a decorated output, so that we print all the DDL before executing\n-                // The output is very FINE and logs out a lot. \n-                if (logger.isLoggable(Level.FINE)) {\n-                    PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n-                    adapter = new DerbyAdapter(printer);\n-                }\n-                fn.accept(adapter);\n-            } catch (DataAccessException x) {\n-                logger.log(Level.SEVERE, \"Error while running\", x);\n-                c.rollback();\n-                throw x;\n-            }\n-            c.commit();\n-        } catch (SQLException e) {\n-            logger.log(Level.SEVERE, \"Error while running\", e);\n-            throw DERBY_TRANSLATOR.translate(e);\n-        } finally {\n-            logger.info(\"connection was closed\");\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+\n+        // Replace the target with a decorated output, so that we print all the DDL before executing\n+        // The output is very FINE and logs out a lot. \n+        if (logger.isLoggable(Level.FINE)) {\n+            PrintTarget printer = new PrintTarget(target, logger.isLoggable(Level.FINE));\n+            adapter = new DerbyAdapter(printer);\n         }\n+      \n+        // call the Function we've been given using the adapter we just wrapped\n+        // around the connection. Each statement executes in its own connection/transaction.\n+        fn.accept(adapter);\n     }\n \n+    /**\n+     * Diagnostic utility to display all the current locks in the Derby database\n+     */\n+    public void dumpLockInfo() {\n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        IConnectionProvider cp = new DerbyConnectionProvider(this, null);\n+        ConnectionProviderTarget target = new ConnectionProviderTarget(cp);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        System.out.println(LockInfo.header());\n+        locks.forEach(System.out::println);\n+    }\n+    \n+    /**\n+     * Dump locks using the given connection\n+     * @param c\n+     */\n+    public static void dumpLockInfo(Connection c) {\n+        // wrap the connection so that we can run our lock diag DAO\n+        JdbcTarget target = new JdbcTarget(c);\n+        DerbyAdapter adapter = new DerbyAdapter(target);\n+        \n+        DerbyLockDiag diag = new DerbyLockDiag();\n+        List<LockInfo> locks = adapter.runStatement(diag);\n+        \n+        // render\n+        System.out.println(LockInfo.header());", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3ODcwOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446978708", "bodyText": "I don't want to use a logger in this case.", "author": "punktilious", "createdAt": "2020-06-29T13:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTczMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:11:28Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyTranslator.java", "diffHunk": "@@ -163,4 +165,30 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTc0Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581742", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:11:39Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyTranslator.java", "diffHunk": "@@ -163,4 +165,30 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.DERBY;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTc3MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581771", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:11:51Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyTranslator.java", "diffHunk": "@@ -163,4 +165,30 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.DERBY;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */\n+    @Override\n+    public String dualTableName() {\n+        return \"SYSIBM.SYSDUMMY1\";\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTgwNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581805", "bodyText": "In other. spots you use a final String, seems a bit inconsistent.", "author": "prb112", "createdAt": "2020-06-28T00:12:19Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/DerbyTranslator.java", "diffHunk": "@@ -163,4 +165,30 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.DERBY;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */\n+    @Override\n+    public String dualTableName() {\n+        return \"SYSIBM.SYSDUMMY1\";\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n+     */\n+    @Override\n+    public String selectSequenceNextValue(String schemaName, String sequenceName) {\n+        String qname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        return \"SELECT NEXT VALUE FOR \" + qname + \" FROM SYSIBM.SYSDUMMY1\";", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MTg5Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446981897", "bodyText": "In general we should do a better job of using final where appropriate throughout the code. When usage is obvious, it's less of an issue. But we could certainly benefit from it in more complex methods.", "author": "punktilious", "createdAt": "2020-06-29T13:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0MDQ2NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447740465", "bodyText": "made it final in the next commit", "author": "punktilious", "createdAt": "2020-06-30T14:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTgzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581831", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see java.lang.Object#toString()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:12:41Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/derby/LockInfo.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.derby;\n+\n+\n+/**\n+ * DTO representing a row from the Derby lock diagnostic table SYSCS_DIAG.LOCK_TABLE\n+ */\n+public class LockInfo {\n+\n+    private final String xid;\n+    private final String type;\n+    private final String mode;\n+    private final String tablename;\n+    private final String lockname;\n+    private final String state;\n+    private final String tabletype;\n+    private final String lockcount;\n+    private final String indexname;\n+\n+    /**\n+     * Public constructor\n+     * @param xid\n+     * @param type\n+     * @param mode\n+     * @param tablename\n+     * @param lockname\n+     * @param state\n+     * @param tabletype\n+     * @param lockcount\n+     * @param indexname\n+     */\n+    public LockInfo(String xid, String type, String mode, String tablename, String lockname, String state,\n+        String tabletype, String lockcount, String indexname) {\n+        this.xid = xid;\n+        this.type = type;\n+        this.mode = mode;\n+        this.tablename = tablename;\n+        this.lockname = lockname;\n+        this.state = state;\n+        this.tabletype = tabletype;\n+        this.lockcount = lockcount;\n+        this.indexname = indexname;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see java.lang.Object#toString()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTg1Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581852", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * (C) Copyright IBM Corp. 2019, 2020\n          \n          \n            \n             * (C) Copyright IBM Corp. 2020", "author": "prb112", "createdAt": "2020-06-28T00:12:59Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/AlterSequenceStartWith.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTg2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581863", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.model.IDatabaseObject#visit(com.ibm.fhir.database.utils.model.DataModelVisitor)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:13:18Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/AlterSequenceStartWith.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.model;\n+\n+import java.util.Set;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseAdapter;\n+\n+/**\n+ * Modify an existing sequence to start with a higher value\n+ */\n+public class AlterSequenceStartWith extends BaseObject {\n+    // the value we want the sequence to start with\n+    private final long startWith;\n+    \n+    // caching sequence values for tuning\n+    private final int cache;\n+\n+    /**\n+     * Public constructor\n+     * \n+     * @param schemaName\n+     * @param sequenceName\n+     * @param cache\n+     */\n+    public AlterSequenceStartWith(String schemaName, String sequenceName, int version, long startWith, int cache) {\n+        super(schemaName, sequenceName, DatabaseObjectType.SEQUENCE, version);\n+        this.startWith = startWith;\n+        this.cache = cache;\n+    }\n+\n+    @Override\n+    public void apply(IDatabaseAdapter target) {\n+        target.alterSequenceRestartWith(getSchemaName(), getObjectName(), startWith, this.cache);\n+    }\n+\n+    @Override\n+    public void apply(Integer priorVersion, IDatabaseAdapter target) {\n+        apply(target);\n+    }\n+\n+    @Override\n+    public void drop(IDatabaseAdapter target) {\n+        target.dropSequence(getSchemaName(), getObjectName());\n+    }\n+\n+    @Override\n+    protected void grantGroupPrivileges(IDatabaseAdapter target, Set<Privilege> group, String toUser) {\n+        target.grantSequencePrivileges(getSchemaName(), getObjectName(), group, toUser);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.model.IDatabaseObject#visit(com.ibm.fhir.database.utils.model.DataModelVisitor)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTg4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581880", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.model.IDatabaseObject#visitReverse(com.ibm.fhir.database.utils.model.DataModelVisitor)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:13:33Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/AlterSequenceStartWith.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.model;\n+\n+import java.util.Set;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseAdapter;\n+\n+/**\n+ * Modify an existing sequence to start with a higher value\n+ */\n+public class AlterSequenceStartWith extends BaseObject {\n+    // the value we want the sequence to start with\n+    private final long startWith;\n+    \n+    // caching sequence values for tuning\n+    private final int cache;\n+\n+    /**\n+     * Public constructor\n+     * \n+     * @param schemaName\n+     * @param sequenceName\n+     * @param cache\n+     */\n+    public AlterSequenceStartWith(String schemaName, String sequenceName, int version, long startWith, int cache) {\n+        super(schemaName, sequenceName, DatabaseObjectType.SEQUENCE, version);\n+        this.startWith = startWith;\n+        this.cache = cache;\n+    }\n+\n+    @Override\n+    public void apply(IDatabaseAdapter target) {\n+        target.alterSequenceRestartWith(getSchemaName(), getObjectName(), startWith, this.cache);\n+    }\n+\n+    @Override\n+    public void apply(Integer priorVersion, IDatabaseAdapter target) {\n+        apply(target);\n+    }\n+\n+    @Override\n+    public void drop(IDatabaseAdapter target) {\n+        target.dropSequence(getSchemaName(), getObjectName());\n+    }\n+\n+    @Override\n+    protected void grantGroupPrivileges(IDatabaseAdapter target, Set<Privilege> group, String toUser) {\n+        target.grantSequencePrivileges(getSchemaName(), getObjectName(), group, toUser);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.model.IDatabaseObject#visit(com.ibm.fhir.database.utils.model.DataModelVisitor)\n+     */\n+    @Override\n+    public void visit(DataModelVisitor v) {\n+        v.visited(this);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.model.IDatabaseObject#visitReverse(com.ibm.fhir.database.utils.model.DataModelVisitor)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTkxMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581910", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.model.DataModelVisitor#visited(com.ibm.fhir.database.utils.model.AlterSequenceStartWith)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:14:04Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DataModelVisitorBase.java", "diffHunk": "@@ -94,4 +94,13 @@ public void visited(FunctionDef functionDef) {\n         // NOP\n     }\n \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.model.DataModelVisitor#visited(com.ibm.fhir.database.utils.model.AlterSequenceStartWith)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTkzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581931", "bodyText": "make abstract?", "author": "prb112", "createdAt": "2020-06-28T00:14:18Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DataModelVisitorBase.java", "diffHunk": "@@ -94,4 +94,13 @@ public void visited(FunctionDef functionDef) {\n         // NOP\n     }\n \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.model.DataModelVisitor#visited(com.ibm.fhir.database.utils.model.AlterSequenceStartWith)\n+     */\n+    @Override\n+    public void visited(AlterSequenceStartWith alterSequence) {\n+        // TODO Auto-generated method stub\n+        ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NjkwMg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447956902", "bodyText": "Just a NOP like the others. This is a helper class, because implementations probably only need to implement one or two methods.", "author": "punktilious", "createdAt": "2020-06-30T20:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTk1Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581953", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                }\n          \n          \n            \n                                else {\n          \n          \n            \n                                } else {", "author": "prb112", "createdAt": "2020-06-28T00:14:38Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DatabaseObject.java", "diffHunk": "@@ -156,21 +156,21 @@ public void applyTx(IDatabaseAdapter target, ITransactionProvider tp, IVersionHi\n                     // Either a deadlock, or lock timeout, we allow the transaction to be\n                     // tried again.\n                     if (x.isDeadlock()) {\n-                        logger.warning(\"Deadlock detected processing: \" + this.getTypeAndName() + \" [remaining=\" + remainingAttempts + \"]\");\n+                        logger.warning(\"Deadlock detected processing: \" + this.getTypeNameVersion() + \" [remaining=\" + remainingAttempts + \"]\");\n                     }\n                     else {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MTk4NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446581985", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            catch (Exception x) {\n          \n          \n            \n                            } catch (Exception x) {", "author": "prb112", "createdAt": "2020-06-28T00:14:54Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DatabaseObject.java", "diffHunk": "@@ -156,21 +156,21 @@ public void applyTx(IDatabaseAdapter target, ITransactionProvider tp, IVersionHi\n                     // Either a deadlock, or lock timeout, we allow the transaction to be\n                     // tried again.\n                     if (x.isDeadlock()) {\n-                        logger.warning(\"Deadlock detected processing: \" + this.getTypeAndName() + \" [remaining=\" + remainingAttempts + \"]\");\n+                        logger.warning(\"Deadlock detected processing: \" + this.getTypeNameVersion() + \" [remaining=\" + remainingAttempts + \"]\");\n                     }\n                     else {\n-                        logger.warning(\"Lock timeout detected processing: \" + this.getTypeAndName() + \" [remaining=\" + remainingAttempts + \"]\");\n+                        logger.warning(\"Lock timeout detected processing: \" + this.getTypeNameVersion() + \" [remaining=\" + remainingAttempts + \"]\");\n                     }\n                     tx.setRollbackOnly();\n \n                     if (remainingAttempts == 0) {\n                         // end of the road on this one\n-                        logger.log(Level.SEVERE, \"[FAILED] retries exhausted for: \" + this.getTypeAndName());\n+                        logger.log(Level.SEVERE, \"[FAILED] retries exhausted for: \" + this.getTypeNameVersion());\n                         throw x;\n                     }\n                 }\n                 catch (Exception x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjExNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582116", "bodyText": "Have you tried deploying the 4.1.0 schema jar, and upgrade. from there?  I'm curious if we have any latent issues.", "author": "prb112", "createdAt": "2020-06-28T00:16:15Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DatabaseObject.java", "diffHunk": "@@ -195,7 +195,7 @@ public void applyTx(IDatabaseAdapter target, ITransactionProvider tp, IVersionHi\n     public void applyVersion(IDatabaseAdapter target, IVersionHistoryService vhs) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4NTAxNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446985016", "bodyText": "I updated Lee's unit test which performs the migration.", "author": "punktilious", "createdAt": "2020-06-29T13:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMTk2OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447901969", "bodyText": "Yes, it's also covered in the CI, which has passed from 4.2.3 to this", "author": "prb112", "createdAt": "2020-06-30T18:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjE5Nw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582197", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:17:33Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -368,5 +367,5 @@ public void setIntegrityUnchecked(String schemaName, String tableName) {\n         // not expecting this to be called for this adapter\n         throw new UnsupportedOperationException(\"Set integrity unchecked not supported for this adapter.\");\n     }\n-    \n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjIzMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582231", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:17:46Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -163,4 +165,32 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjIzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:17:58Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -163,4 +165,32 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.POSTGRESQL;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjMxMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582311", "bodyText": "it's kind of messy to return null, I realize there is overhead for this, but return empty I think is preferred.", "author": "prb112", "createdAt": "2020-06-28T00:19:29Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -163,4 +165,32 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.POSTGRESQL;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */\n+    @Override\n+    public String dualTableName() {\n+        // PostgreSQL does not support a \"DUAL\" table because the FROM clause is optional.\n+        return null;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5NDM2MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446994360", "bodyText": "I find null here a useful flag to indicate no such value exists for this implementation. This should be used consistently, to distinguish between no value and an actual value which happens to be an empty string (something which databases don't handle consistently).", "author": "punktilious", "createdAt": "2020-06-29T14:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMjkzNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447902937", "bodyText": "Right... it's actually just SELECT 1 in postgres.   I think the concept shouldn't be so much focused on a 'dualTableName' rather connectivityCheck.", "author": "prb112", "createdAt": "2020-06-30T18:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzA1Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447903053", "bodyText": "I'm leaving this as resolved", "author": "prb112", "createdAt": "2020-06-30T18:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjMxOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:19:42Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -163,4 +165,32 @@ public String getUrl(Properties connectionProperties) {\n     public boolean clobSupportsInline() {\n         return false;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return DbType.POSTGRESQL;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#dualTableName()\n+     */\n+    @Override\n+    public String dualTableName() {\n+        // PostgreSQL does not support a \"DUAL\" table because the FROM clause is optional.\n+        return null;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.database.utils.api.IDatabaseTranslator#selectSequenceNextValue(java.lang.String, java.lang.String)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjQxMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582410", "bodyText": "Why are you. clearing this?", "author": "prb112", "createdAt": "2020-06-28T00:20:42Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/version/VersionHistoryService.java", "diffHunk": "@@ -98,6 +98,7 @@ public void init() {\n     private void getLatestVersionHistoryForSchema() {\n         // Note how we don't care about connections here...that is all\n         // hidden inside the target adapter implementation\n+        versionHistoryMap.clear();", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5NjQ4NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446996485", "bodyText": "Because the database table contains the \"truth\" and we are about to read all of it. The data in the database should replace everything in the map, which is just being used as a cache.", "author": "punktilious", "createdAt": "2020-06-29T14:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjQ4MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582480", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:21:47Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/ChainedAction.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Base for chaining actions together\n+ */\n+public class ChainedAction implements Action {\n+\n+    // the next action in the chain\n+    private final Action next;\n+\n+    /**\n+     * Public constructor\n+     * @param next the next action in the chain\n+     */\n+    public ChainedAction(Action next) {\n+        this.next = next;\n+    }\n+\n+    /**\n+     * Public constructor where this action is the end of the chain\n+     */\n+    public ChainedAction() {\n+        this.next = null;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n+     */\n+    @Override\n+    public void performOn(Connection c) throws FHIRPersistenceDBConnectException {\n+        if (next != null) {\n+            next.performOn(c);\n+        }\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjQ5NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582495", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:22:04Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/DisableAutocommitAction.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjQ5OA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582498", "bodyText": "Fix formatting please", "author": "prb112", "createdAt": "2020-06-28T00:22:15Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/DisableAutocommitAction.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to turn off autocommit\n+ */\n+public class DisableAutocommitAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(DisableAutocommitAction.class.getName());\n+        /**\n+     * Public constructor\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NzMwOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447957309", "bodyText": "done", "author": "punktilious", "createdAt": "2020-06-30T20:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjUzOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582539", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public DisableAutocommitAction() {\n          \n          \n            \n                }\n          \n          \n            \n                public DisableAutocommitAction() {\n          \n          \n            \n                    // No Op\n          \n          \n            \n                }", "author": "prb112", "createdAt": "2020-06-28T00:22:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/DisableAutocommitAction.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to turn off autocommit\n+ */\n+public class DisableAutocommitAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(DisableAutocommitAction.class.getName());\n+        /**\n+     * Public constructor\n+     */\n+    public DisableAutocommitAction() {\n+    }", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjU0MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582541", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:22:52Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/DisableAutocommitAction.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to turn off autocommit\n+ */\n+public class DisableAutocommitAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(DisableAutocommitAction.class.getName());\n+        /**\n+     * Public constructor\n+     */\n+    public DisableAutocommitAction() {\n+    }\n+\n+    /**\n+     * Public constructor\n+     * @param next action in a chain\n+     */\n+    public DisableAutocommitAction(Action next) {\n+        super(next);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n+     */\n+    @Override\n+    public void performOn(Connection c) throws FHIRPersistenceDBConnectException {\n+            \n+        try {\n+            c.setAutoCommit(false);\n+        } catch (SQLException x) {\n+            log.log(Level.SEVERE, \"failed to set autocommit (false)\", x);\n+            \n+            // schemaName is a secret, so don't emit in the exception to avoid propagating to client\n+            throw new FHIRPersistenceDBConnectException(\"Failed disabling autocommit on connection\");\n+        }\n+        \n+        // call the next action in the chain\n+        super.performOn(c);\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjU3Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582573", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:23:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/DisableAutocommitAction.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Command to turn off autocommit\n+ */\n+public class DisableAutocommitAction extends ChainedAction {\n+    private static final Logger log = Logger.getLogger(DisableAutocommitAction.class.getName());\n+        /**\n+     * Public constructor\n+     */\n+    public DisableAutocommitAction() {\n+    }\n+\n+    /**\n+     * Public constructor\n+     * @param next action in a chain\n+     */\n+    public DisableAutocommitAction(Action next) {\n+        super(next);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.Action#performOn(java.sql.Connection)\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjU5MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582590", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:23:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjYwNg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582606", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:23:37Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Abstraction used to obtain JDBC connections. The database being connected\n+ * is determined by the datasource currently referenced by the {@link FHIRRequestContext}\n+ * (which is a ThreadLocal thing, and not obvious).\n+ * \n+ * @implNote Refactor of the getConnection logic from {@link FHIRDbDAOImpl}. This\n+ * isolates connection logic from the DAO implementations, promoting separation of\n+ * concerns, and makes it possible to use different strategies in the future,\n+ * without having to disrupt the (complex) DAO code again.\n+ */\n+public interface FHIRDbConnectionStrategy {\n+\n+    /**\n+     * Get a connection to the desired data source identified by the current {@link FHIRRequestContext}\n+     * @return a {@link Connection}. Never null.\n+     */\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException;\n+\n+    /**\n+     * Get the flavor of the database we are working with to reveal its capabilities\n+     * @return the datastore/source flavor from the FHIR configuration\n+     * @throws FHIRPersistenceDataAccessException if there is an issue with the configuration\n+     */\n+    public FHIRDbFlavor getFlavor() throws FHIRPersistenceDataAccessException;\n+        ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjY0Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582642", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        catch (Exception x) {\n          \n          \n            \n                        } catch (Exception x) {", "author": "prb112", "createdAt": "2020-06-28T00:24:00Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategyBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Common base for multi-tenant connection strategy implementations\n+ */\n+public abstract class FHIRDbConnectionStrategyBase implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbConnectionStrategyBase.class.getName());\n+    // We use the sync registry to remember connections we've configured in the current transaction.\n+    private final TransactionSynchronizationRegistry trxSyncRegistry;\n+\n+    // the action chain to be applied to new connections\n+    private final Action newConnectionAction;\n+    \n+    // Type and capability \n+    private final FHIRDbFlavor flavor;\n+    \n+    /**\n+     * Protected constructor\n+     * @param userTx the transaction handler\n+     * @param trxSyncRegistry\n+     * @param newConnectionAction\n+     */\n+    protected FHIRDbConnectionStrategyBase(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRPersistenceDataAccessException {\n+        this.trxSyncRegistry = trxSyncRegistry;\n+        this.newConnectionAction = newConnectionAction;\n+        \n+        // initialize the flavor from the configuration\n+        this.flavor = createFlavor();\n+    }\n+\n+    /**\n+     * Check with the transaction sync registry to see if this is the first time\n+     * we've worked with this connection in the current transaction.\n+     * @param c the new connection\n+     * @param tenantId the tenant to which the connection belongs\n+     * @param dsId the datasource in the tenant to which the connection belongs\n+     */\n+    protected void configure(Connection connection, String tenantId, String dsId) throws FHIRPersistenceException {\n+        // We prefix the  key with the name of this class to avoid any potential conflict with other\n+        // users of the sync registry.        \n+        final String key = this.getClass().getName() + \"/\" + tenantId + \"/\" + dsId;\n+        if (trxSyncRegistry.getResource(key) == null) {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Configuring new connection in this transaction. Key='\" + key + \"'\");\n+            }\n+            \n+            // first time...so we need to apply actions. Will be cleared when the transaction commits\n+            newConnectionAction.performOn(connection);\n+            \n+            // and register the key so we don't do this again\n+            trxSyncRegistry.putResource(key, new Object());\n+        } else {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Connection already configured. Key='\" + key + \"'\");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Identify the flavor of the database using information from the\n+     * datasource configuration.\n+     * @return\n+     * @throws FHIRPersistenceException\n+     */\n+    private FHIRDbFlavor createFlavor() throws FHIRPersistenceDataAccessException {\n+        FHIRDbFlavor result;\n+        \n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        // Find and set the tenantKey for the request, otherwise subsequent pulls from the pool\n+        // miss the tenantKey.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            \n+            try {\n+                boolean multitenant = false;\n+                String typeValue = dsPG.getStringProperty(\"type\");\n+                \n+                DbType type = DbType.from(typeValue);\n+                if (type == DbType.DB2) {\n+                    // We make this absolute for now. May change in the future if we\n+                    // support a single-tenant schema in DB2.\n+                    multitenant = true;\n+                }\n+                \n+                result = new FHIRDbFlavorImpl(type, multitenant);\n+            }\n+            catch (Exception x) {", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjY1OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582659", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#getFlavor()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:24:18Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategyBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Common base for multi-tenant connection strategy implementations\n+ */\n+public abstract class FHIRDbConnectionStrategyBase implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbConnectionStrategyBase.class.getName());\n+    // We use the sync registry to remember connections we've configured in the current transaction.\n+    private final TransactionSynchronizationRegistry trxSyncRegistry;\n+\n+    // the action chain to be applied to new connections\n+    private final Action newConnectionAction;\n+    \n+    // Type and capability \n+    private final FHIRDbFlavor flavor;\n+    \n+    /**\n+     * Protected constructor\n+     * @param userTx the transaction handler\n+     * @param trxSyncRegistry\n+     * @param newConnectionAction\n+     */\n+    protected FHIRDbConnectionStrategyBase(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRPersistenceDataAccessException {\n+        this.trxSyncRegistry = trxSyncRegistry;\n+        this.newConnectionAction = newConnectionAction;\n+        \n+        // initialize the flavor from the configuration\n+        this.flavor = createFlavor();\n+    }\n+\n+    /**\n+     * Check with the transaction sync registry to see if this is the first time\n+     * we've worked with this connection in the current transaction.\n+     * @param c the new connection\n+     * @param tenantId the tenant to which the connection belongs\n+     * @param dsId the datasource in the tenant to which the connection belongs\n+     */\n+    protected void configure(Connection connection, String tenantId, String dsId) throws FHIRPersistenceException {\n+        // We prefix the  key with the name of this class to avoid any potential conflict with other\n+        // users of the sync registry.        \n+        final String key = this.getClass().getName() + \"/\" + tenantId + \"/\" + dsId;\n+        if (trxSyncRegistry.getResource(key) == null) {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Configuring new connection in this transaction. Key='\" + key + \"'\");\n+            }\n+            \n+            // first time...so we need to apply actions. Will be cleared when the transaction commits\n+            newConnectionAction.performOn(connection);\n+            \n+            // and register the key so we don't do this again\n+            trxSyncRegistry.putResource(key, new Object());\n+        } else {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Connection already configured. Key='\" + key + \"'\");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Identify the flavor of the database using information from the\n+     * datasource configuration.\n+     * @return\n+     * @throws FHIRPersistenceException\n+     */\n+    private FHIRDbFlavor createFlavor() throws FHIRPersistenceDataAccessException {\n+        FHIRDbFlavor result;\n+        \n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        // Find and set the tenantKey for the request, otherwise subsequent pulls from the pool\n+        // miss the tenantKey.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            \n+            try {\n+                boolean multitenant = false;\n+                String typeValue = dsPG.getStringProperty(\"type\");\n+                \n+                DbType type = DbType.from(typeValue);\n+                if (type == DbType.DB2) {\n+                    // We make this absolute for now. May change in the future if we\n+                    // support a single-tenant schema in DB2.\n+                    multitenant = true;\n+                }\n+                \n+                result = new FHIRDbFlavorImpl(type, multitenant);\n+            }\n+            catch (Exception x) {\n+                log.log(Level.SEVERE, \"No type property found for datastore '\" + datastoreId + \"'\", x);\n+                throw new FHIRPersistenceDataAccessException(\"Datastore configuration issue. Details in server logs\");\n+            }\n+        } else {\n+            log.log(Level.SEVERE, \"Missing datastore configuration for '\" + datastoreId + \"'\");\n+            throw new FHIRPersistenceDataAccessException(\"Datastore configuration issue. Details in server logs\");\n+        }\n+        \n+        return result;\n+    }\n+    \n+    /**\n+     * Get a connection configured for the given tenant and datasourceId\n+     * @param datasource\n+     * @param tenantId\n+     * @param dsId\n+     * @return\n+     */\n+    protected Connection getConnection(DataSource datasource, String tenantId, String dsId) throws SQLException, FHIRPersistenceException {\n+        // Now use the dsId/tenantId specific JEE datasource to get a connection\n+        Connection connection = datasource.getConnection();\n+        \n+        try {\n+            // always\n+            connection.setAutoCommit(false);\n+            \n+            // configure the connection if it's the first time we've accessed it in this transaction\n+            configure(connection, tenantId, dsId);\n+        } catch (Throwable t) {\n+            // clean up if something goes wrong during configuration\n+            try {\n+                connection.close();\n+            } catch (Throwable x) {\n+                // NOP...something bad is going on anyway, so don't confuse things\n+                // by throwing a different exception and hiding the original\n+            } finally {\n+                // just to prevent future coding mistakes\n+                connection = null;\n+            }\n+            throw t;\n+        }\n+        \n+        return connection;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#getFlavor()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjY3Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582672", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:24:27Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConnectionStrategyBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+/**\n+ * Common base for multi-tenant connection strategy implementations\n+ */\n+public abstract class FHIRDbConnectionStrategyBase implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbConnectionStrategyBase.class.getName());\n+    // We use the sync registry to remember connections we've configured in the current transaction.\n+    private final TransactionSynchronizationRegistry trxSyncRegistry;\n+\n+    // the action chain to be applied to new connections\n+    private final Action newConnectionAction;\n+    \n+    // Type and capability \n+    private final FHIRDbFlavor flavor;\n+    \n+    /**\n+     * Protected constructor\n+     * @param userTx the transaction handler\n+     * @param trxSyncRegistry\n+     * @param newConnectionAction\n+     */\n+    protected FHIRDbConnectionStrategyBase(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRPersistenceDataAccessException {\n+        this.trxSyncRegistry = trxSyncRegistry;\n+        this.newConnectionAction = newConnectionAction;\n+        \n+        // initialize the flavor from the configuration\n+        this.flavor = createFlavor();\n+    }\n+\n+    /**\n+     * Check with the transaction sync registry to see if this is the first time\n+     * we've worked with this connection in the current transaction.\n+     * @param c the new connection\n+     * @param tenantId the tenant to which the connection belongs\n+     * @param dsId the datasource in the tenant to which the connection belongs\n+     */\n+    protected void configure(Connection connection, String tenantId, String dsId) throws FHIRPersistenceException {\n+        // We prefix the  key with the name of this class to avoid any potential conflict with other\n+        // users of the sync registry.        \n+        final String key = this.getClass().getName() + \"/\" + tenantId + \"/\" + dsId;\n+        if (trxSyncRegistry.getResource(key) == null) {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Configuring new connection in this transaction. Key='\" + key + \"'\");\n+            }\n+            \n+            // first time...so we need to apply actions. Will be cleared when the transaction commits\n+            newConnectionAction.performOn(connection);\n+            \n+            // and register the key so we don't do this again\n+            trxSyncRegistry.putResource(key, new Object());\n+        } else {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Connection already configured. Key='\" + key + \"'\");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Identify the flavor of the database using information from the\n+     * datasource configuration.\n+     * @return\n+     * @throws FHIRPersistenceException\n+     */\n+    private FHIRDbFlavor createFlavor() throws FHIRPersistenceDataAccessException {\n+        FHIRDbFlavor result;\n+        \n+        String datastoreId = FHIRRequestContext.get().getDataStoreId();\n+\n+        // Retrieve the property group pertaining to the specified datastore.\n+        // Find and set the tenantKey for the request, otherwise subsequent pulls from the pool\n+        // miss the tenantKey.\n+        String dsPropertyName = FHIRConfiguration.PROPERTY_DATASOURCES + \"/\" + datastoreId;\n+        PropertyGroup dsPG = FHIRConfigHelper.getPropertyGroup(dsPropertyName);\n+        if (dsPG != null) {\n+            \n+            try {\n+                boolean multitenant = false;\n+                String typeValue = dsPG.getStringProperty(\"type\");\n+                \n+                DbType type = DbType.from(typeValue);\n+                if (type == DbType.DB2) {\n+                    // We make this absolute for now. May change in the future if we\n+                    // support a single-tenant schema in DB2.\n+                    multitenant = true;\n+                }\n+                \n+                result = new FHIRDbFlavorImpl(type, multitenant);\n+            }\n+            catch (Exception x) {\n+                log.log(Level.SEVERE, \"No type property found for datastore '\" + datastoreId + \"'\", x);\n+                throw new FHIRPersistenceDataAccessException(\"Datastore configuration issue. Details in server logs\");\n+            }\n+        } else {\n+            log.log(Level.SEVERE, \"Missing datastore configuration for '\" + datastoreId + \"'\");\n+            throw new FHIRPersistenceDataAccessException(\"Datastore configuration issue. Details in server logs\");\n+        }\n+        \n+        return result;\n+    }\n+    \n+    /**\n+     * Get a connection configured for the given tenant and datasourceId\n+     * @param datasource\n+     * @param tenantId\n+     * @param dsId\n+     * @return\n+     */\n+    protected Connection getConnection(DataSource datasource, String tenantId, String dsId) throws SQLException, FHIRPersistenceException {\n+        // Now use the dsId/tenantId specific JEE datasource to get a connection\n+        Connection connection = datasource.getConnection();\n+        \n+        try {\n+            // always\n+            connection.setAutoCommit(false);\n+            \n+            // configure the connection if it's the first time we've accessed it in this transaction\n+            configure(connection, tenantId, dsId);\n+        } catch (Throwable t) {\n+            // clean up if something goes wrong during configuration\n+            try {\n+                connection.close();\n+            } catch (Throwable x) {\n+                // NOP...something bad is going on anyway, so don't confuse things\n+                // by throwing a different exception and hiding the original\n+            } finally {\n+                // just to prevent future coding mistakes\n+                connection = null;\n+            }\n+            throw t;\n+        }\n+        \n+        return connection;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionStrategy#getFlavor()\n+     */\n+    @Override\n+    public FHIRDbFlavor getFlavor() throws FHIRPersistenceDataAccessException {\n+        return this.flavor;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mjc5Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582793", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String PROPERTY_DB2_USER = \"user\";\n          \n          \n            \n                public static final String PROPERTY_DB_USER = \"user\";", "author": "prb112", "createdAt": "2020-06-28T00:26:10Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConstants.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+\n+/**\n+ * Constants used with FHIR DB datasources and connections\n+ * \n+ * @implNote extracted from FHIRDbDAO\n+ */\n+public class FHIRDbConstants {\n+    public static final String FHIRDB_JNDI_NAME_DEFAULT = \"jdbc/fhirProxyDataSource\";\n+    public static final String PROPERTY_DB_DRIVER = \"dbDriverName\";\n+    public static final String PROPERTY_DB_URL = \"dbUrl\";\n+    public static final String PROPERTY_DB2_USER = \"user\";", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMjAyOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447002028", "bodyText": "agreed, although these were taken directly from the old FHIRDbDao.java.", "author": "punktilious", "createdAt": "2020-06-29T14:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mjc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjgwOQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582809", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String PROPERTY_DB2_PSWD = \"password\";\n          \n          \n            \n                public static final String PROPERTY_DB_PSWD = \"password\";", "author": "prb112", "createdAt": "2020-06-28T00:26:23Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbConstants.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+\n+/**\n+ * Constants used with FHIR DB datasources and connections\n+ * \n+ * @implNote extracted from FHIRDbDAO\n+ */\n+public class FHIRDbConstants {\n+    public static final String FHIRDB_JNDI_NAME_DEFAULT = \"jdbc/fhirProxyDataSource\";\n+    public static final String PROPERTY_DB_DRIVER = \"dbDriverName\";\n+    public static final String PROPERTY_DB_URL = \"dbUrl\";\n+    public static final String PROPERTY_DB2_USER = \"user\";\n+    public static final String PROPERTY_DB2_PSWD = \"password\";", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjgzOA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582838", "bodyText": "We're doing more than just db2", "author": "prb112", "createdAt": "2020-06-28T00:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Mjg2NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582865", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:26:55Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbFlavor.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.model.DbType;\n+\n+/**\n+ * Capabilities supported by the different flavors of database we connect to.\n+ * The flavor is a combination of the database type (e.g. DB2/Derby etc) and\n+ * the capabilities of the installed schema\n+ */\n+public interface FHIRDbFlavor {\n+\n+    /**\n+     * Does the database support multi-tenancy?\n+     * @return\n+     */\n+    public boolean isMultitenant();\n+\n+    /**\n+     * What type of database is this?\n+     * @return\n+     */\n+    public DbType getType();\n+    ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjkwMQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582901", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor#isMultitenant()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:27:19Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbFlavorImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.model.DbType;\n+\n+/**\n+ * Describes the capability of the underlying database and the schema it has\n+ * been configured with.\n+ */\n+public class FHIRDbFlavorImpl implements FHIRDbFlavor {\n+    \n+    // does the database schema support multi-tenancy\n+    private final boolean multitenant;\n+\n+    // basic type of the database (DB2, Derby etc)\n+    private final DbType type;\n+    \n+    public FHIRDbFlavorImpl(DbType type, boolean multitenant) {\n+        this.type = type;\n+        this.multitenant = multitenant;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor#isMultitenant()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjkwNw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582907", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor#getType()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:27:29Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbFlavorImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.model.DbType;\n+\n+/**\n+ * Describes the capability of the underlying database and the schema it has\n+ * been configured with.\n+ */\n+public class FHIRDbFlavorImpl implements FHIRDbFlavor {\n+    \n+    // does the database schema support multi-tenancy\n+    private final boolean multitenant;\n+\n+    // basic type of the database (DB2, Derby etc)\n+    private final DbType type;\n+    \n+    public FHIRDbFlavorImpl(DbType type, boolean multitenant) {\n+        this.type = type;\n+        this.multitenant = multitenant;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor#isMultitenant()\n+     */\n+    @Override\n+    public boolean isMultitenant() {\n+        return this.multitenant;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor#getType()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MjkxNQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446582915", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:27:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbFlavorImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import com.ibm.fhir.database.utils.model.DbType;\n+\n+/**\n+ * Describes the capability of the underlying database and the schema it has\n+ * been configured with.\n+ */\n+public class FHIRDbFlavorImpl implements FHIRDbFlavor {\n+    \n+    // does the database schema support multi-tenancy\n+    private final boolean multitenant;\n+\n+    // basic type of the database (DB2, Derby etc)\n+    private final DbType type;\n+    \n+    public FHIRDbFlavorImpl(DbType type, boolean multitenant) {\n+        this.type = type;\n+        this.multitenant = multitenant;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor#isMultitenant()\n+     */\n+    @Override\n+    public boolean isMultitenant() {\n+        return this.multitenant;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbFlavor#getType()\n+     */\n+    @Override\n+    public DbType getType() {\n+        return this.type;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzAzMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583033", "bodyText": "I think we should assume it's null by default.  If null, then we throw an exception.\nIt seems dangerous to set a default", "author": "prb112", "createdAt": "2020-06-28T00:29:26Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbPropsConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This class implements the old way to obtain DB connections using a {@link Properties} instance\n+ */\n+@Deprecated\n+public class FHIRDbPropsConnectionStrategy implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbPropsConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = \"FHIRDbPropsConnectionStrategy\";\n+\n+    // Contains the connection properties\n+    private final Properties dbProps;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRDbPropsConnectionStrategy(Properties dbProps) throws FHIRPersistenceDBConnectException {\n+        this.dbProps = dbProps;\n+\n+        // ensure the driver is loaded\n+        String dbDriverName = this.dbProps.getProperty(FHIRDbConstants.PROPERTY_DB_DRIVER);\n+        try {\n+            Class.forName(dbDriverName);\n+        } catch (ClassNotFoundException e) {\n+            // Not concerned about revealing a classname in the exception\n+            throw new FHIRPersistenceDBConnectException(\"Failed to load driver: \" + dbDriverName, e);\n+        }\n+\n+    }\n+\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        // TODO we need to wrap the connection to simplify transaction handling\n+        final String METHODNAME = \"getConnection()\";\n+        \n+        Connection connection = null;\n+        String dbUrl;\n+    \n+        dbUrl = this.dbProps.getProperty(FHIRDbConstants.PROPERTY_DB_URL);\n+        try {\n+            connection = DriverManager.getConnection(dbUrl, this.dbProps);\n+    \n+            // Most queries assume the current schema is set up properly\n+            String schemaName = dbProps.getProperty(FHIRDbConstants.PROPERTY_SCHEMA_NAME, \"FHIRDATA\");", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMTQ3Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447011476", "bodyText": "yes, FHIRDATA should no longer be considered default anywhere. But it's moot here, because this class will be removed as it's no longer required.", "author": "punktilious", "createdAt": "2020-06-29T14:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NzY1NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447957654", "bodyText": "this class has been deleted", "author": "punktilious", "createdAt": "2020-06-30T20:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzA0NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583045", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:29:36Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbPropsConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This class implements the old way to obtain DB connections using a {@link Properties} instance\n+ */\n+@Deprecated\n+public class FHIRDbPropsConnectionStrategy implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbPropsConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = \"FHIRDbPropsConnectionStrategy\";\n+\n+    // Contains the connection properties\n+    private final Properties dbProps;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRDbPropsConnectionStrategy(Properties dbProps) throws FHIRPersistenceDBConnectException {\n+        this.dbProps = dbProps;\n+\n+        // ensure the driver is loaded\n+        String dbDriverName = this.dbProps.getProperty(FHIRDbConstants.PROPERTY_DB_DRIVER);\n+        try {\n+            Class.forName(dbDriverName);\n+        } catch (ClassNotFoundException e) {\n+            // Not concerned about revealing a classname in the exception\n+            throw new FHIRPersistenceDBConnectException(\"Failed to load driver: \" + dbDriverName, e);\n+        }\n+\n+    }\n+\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        // TODO we need to wrap the connection to simplify transaction handling\n+        final String METHODNAME = \"getConnection()\";\n+        \n+        Connection connection = null;\n+        String dbUrl;\n+    \n+        dbUrl = this.dbProps.getProperty(FHIRDbConstants.PROPERTY_DB_URL);\n+        try {\n+            connection = DriverManager.getConnection(dbUrl, this.dbProps);\n+    \n+            // Most queries assume the current schema is set up properly\n+            String schemaName = dbProps.getProperty(FHIRDbConstants.PROPERTY_SCHEMA_NAME, \"FHIRDATA\");\n+            connection.setSchema(schemaName);\n+            \n+            return connection;\n+        } catch (Throwable e) {\n+            // Don't emit secrets like the dbUrl in case they are returned to a client\n+            FHIRPersistenceDBConnectException fx =\n+                    new FHIRPersistenceDBConnectException(\"Failed to acquire DB connection\");\n+            throw FHIRDbHelper.severe(log, fx, \"Failed to acquire DB connection. dbUrl=\" + dbUrl, e);\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public FHIRDbFlavor getFlavor() throws FHIRPersistenceDataAccessException {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMTg5Ng==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447011896", "bodyText": "file will be removed", "author": "punktilious", "createdAt": "2020-06-29T14:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzA3Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583072", "bodyText": "? should be implemented or commented on?", "author": "prb112", "createdAt": "2020-06-28T00:30:10Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbPropsConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Properties;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This class implements the old way to obtain DB connections using a {@link Properties} instance\n+ */\n+@Deprecated\n+public class FHIRDbPropsConnectionStrategy implements FHIRDbConnectionStrategy {\n+    private static final Logger log = Logger.getLogger(FHIRDbPropsConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = \"FHIRDbPropsConnectionStrategy\";\n+\n+    // Contains the connection properties\n+    private final Properties dbProps;\n+    \n+    /**\n+     * Public constructor\n+     * @param cp\n+     */\n+    public FHIRDbPropsConnectionStrategy(Properties dbProps) throws FHIRPersistenceDBConnectException {\n+        this.dbProps = dbProps;\n+\n+        // ensure the driver is loaded\n+        String dbDriverName = this.dbProps.getProperty(FHIRDbConstants.PROPERTY_DB_DRIVER);\n+        try {\n+            Class.forName(dbDriverName);\n+        } catch (ClassNotFoundException e) {\n+            // Not concerned about revealing a classname in the exception\n+            throw new FHIRPersistenceDBConnectException(\"Failed to load driver: \" + dbDriverName, e);\n+        }\n+\n+    }\n+\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        // TODO we need to wrap the connection to simplify transaction handling\n+        final String METHODNAME = \"getConnection()\";\n+        \n+        Connection connection = null;\n+        String dbUrl;\n+    \n+        dbUrl = this.dbProps.getProperty(FHIRDbConstants.PROPERTY_DB_URL);\n+        try {\n+            connection = DriverManager.getConnection(dbUrl, this.dbProps);\n+    \n+            // Most queries assume the current schema is set up properly\n+            String schemaName = dbProps.getProperty(FHIRDbConstants.PROPERTY_SCHEMA_NAME, \"FHIRDATA\");\n+            connection.setSchema(schemaName);\n+            \n+            return connection;\n+        } catch (Throwable e) {\n+            // Don't emit secrets like the dbUrl in case they are returned to a client\n+            FHIRPersistenceDBConnectException fx =\n+                    new FHIRPersistenceDBConnectException(\"Failed to acquire DB connection\");\n+            throw FHIRDbHelper.severe(log, fx, \"Failed to acquire DB connection. dbUrl=\" + dbUrl, e);\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public FHIRDbFlavor getFlavor() throws FHIRPersistenceDataAccessException {\n+        // TODO Auto-generated method stub\n+        return null;", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMTY3OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447011679", "bodyText": "file will be removed", "author": "punktilious", "createdAt": "2020-06-29T14:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1Nzc4OQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447957789", "bodyText": "class deleted", "author": "punktilious", "createdAt": "2020-06-30T20:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzA5NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583095", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:30:30Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbProxyDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy is used for configurations using the FHIR proxy datasource, \n+ * which supports dynamic configurations of datasources without requiring\n+ * the application server to restart.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbProxyDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbProxyDatasourceConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final double NANOMS = 1e6;\n+    \n+    // The (proxy) datasource\n+    private final DataSource datasource;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceJndiName;\n+\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzE0NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583145", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:30:47Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbProxyDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy is used for configurations using the FHIR proxy datasource, \n+ * which supports dynamic configurations of datasources without requiring\n+ * the application server to restart.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbProxyDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbProxyDatasourceConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final double NANOMS = 1e6;\n+    \n+    // The (proxy) datasource\n+    private final DataSource datasource;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceJndiName;\n+\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbProxyDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+        final String METHODNAME = \"FHIRDbProxyDatasourceConnectionProvider()\";\n+        \n+        ", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzE2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583163", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-06-28T00:31:09Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbProxyDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy is used for configurations using the FHIR proxy datasource, \n+ * which supports dynamic configurations of datasources without requiring\n+ * the application server to restart.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbProxyDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbProxyDatasourceConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final double NANOMS = 1e6;\n+    \n+    // The (proxy) datasource\n+    private final DataSource datasource;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceJndiName;\n+\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbProxyDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+        final String METHODNAME = \"FHIRDbProxyDatasourceConnectionProvider()\";\n+        \n+        \n+        // Find the JNDI name of the datasource we want to use\n+        try {\n+            this.datasourceJndiName =\n+                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);\n+            \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Using datasource JNDI name: \" + datasourceJndiName);\n+            }\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure to find proxy datasource in FHIR server configuration\"), e);\n+            throw fx;\n+        }\n+        \n+        // JNDI lookup. May fail if the server configuration is incorrect\n+        try {\n+            InitialContext ctxt = new InitialContext();\n+            datasource = (DataSource) ctxt.lookup(datasourceJndiName);\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure acquiring datasource: \" + datasourceJndiName), e);\n+            throw fx;\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n+     */", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzE4MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583181", "bodyText": "Suggested change", "author": "prb112", "createdAt": "2020-06-28T00:31:34Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbProxyDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy is used for configurations using the FHIR proxy datasource, \n+ * which supports dynamic configurations of datasources without requiring\n+ * the application server to restart.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbProxyDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbProxyDatasourceConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final double NANOMS = 1e6;\n+    \n+    // The (proxy) datasource\n+    private final DataSource datasource;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceJndiName;\n+\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbProxyDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+        final String METHODNAME = \"FHIRDbProxyDatasourceConnectionProvider()\";\n+        \n+        \n+        // Find the JNDI name of the datasource we want to use\n+        try {\n+            this.datasourceJndiName =\n+                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);\n+            \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Using datasource JNDI name: \" + datasourceJndiName);\n+            }\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure to find proxy datasource in FHIR server configuration\"), e);\n+            throw fx;\n+        }\n+        \n+        // JNDI lookup. May fail if the server configuration is incorrect\n+        try {\n+            InitialContext ctxt = new InitialContext();\n+            datasource = (DataSource) ctxt.lookup(datasourceJndiName);\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure acquiring datasource: \" + datasourceJndiName), e);\n+            throw fx;\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        Connection connection;\n+        final String METHODNAME = \"getConnection\";\n+\n+        if (log.isLoggable(Level.FINE)) {\n+            log.entering(CLASSNAME, METHODNAME);\n+        }\n+\n+        try {\n+            // Resources can be routed to different databases using the dsId currently\n+            // set on the context.\n+            String tenantId = FHIRRequestContext.get().getTenantId();\n+            String dsId = FHIRRequestContext.get().getDataStoreId();\n+            \n+            long start = System.nanoTime();\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Getting connection for tenantId/dsId: [\" + tenantId + \"/\" + dsId + \"]...\");\n+            }\n+\n+            // Use the username/password interface to pass the tenantId and datasource id\n+            // paramters into the proxy datasource so that it can find the correct connection\n+            connection = getConnection(datasource, tenantId, dsId);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                double deltams = (System.nanoTime() - start) / NANOMS;\n+                log.fine(\"Got the connection for [\" + tenantId + \"/\" + dsId + \"]. Took \" + deltams + \" ms\");\n+            }\n+        } catch (Throwable e) {\n+            // Don't emit secrets in case they are returned to a client\n+            FHIRPersistenceDBConnectException fx =\n+                    new FHIRPersistenceDBConnectException(\"Failure acquiring connection for datasource\");\n+            throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceJndiName, e);\n+        } finally {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+        \n+        return connection;\n+    }\n+    \n+    @Override\n+    protected Connection getConnection(DataSource datasource, String tenantId, String dsId) throws SQLException, FHIRPersistenceException {\n+        // Now use the dsId/tenantId specific JEE datasource to get a connection\n+        Connection connection = datasource.getConnection(tenantId, dsId);\n+        \n+        try {\n+            // always\n+            connection.setAutoCommit(false);\n+            \n+            // configure the connection if it's the first time we've accessed it in this transaction\n+            configure(connection, tenantId, dsId);\n+        } catch (Throwable t) {\n+            // clean up if something goes wrong during configuration\n+            try {\n+                connection.close();\n+            } catch (Throwable x) {\n+                // NOP...something bad is going on anyway, so don't confuse things\n+                // by throwing a different exception and hiding the original\n+            } finally {\n+                // just to prevent future coding mistakes\n+                connection = null;\n+            }\n+            throw t;\n+        }\n+        \n+        return connection;\n+    }\n+", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzIxNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583214", "bodyText": "I still think it's appropriate to log finest", "author": "prb112", "createdAt": "2020-06-28T00:32:08Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbProxyDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * This strategy is used for configurations using the FHIR proxy datasource, \n+ * which supports dynamic configurations of datasources without requiring\n+ * the application server to restart.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbProxyDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbProxyDatasourceConnectionStrategy.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final double NANOMS = 1e6;\n+    \n+    // The (proxy) datasource\n+    private final DataSource datasource;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceJndiName;\n+\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbProxyDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+        final String METHODNAME = \"FHIRDbProxyDatasourceConnectionProvider()\";\n+        \n+        \n+        // Find the JNDI name of the datasource we want to use\n+        try {\n+            this.datasourceJndiName =\n+                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);\n+            \n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Using datasource JNDI name: \" + datasourceJndiName);\n+            }\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure to find proxy datasource in FHIR server configuration\"), e);\n+            throw fx;\n+        }\n+        \n+        // JNDI lookup. May fail if the server configuration is incorrect\n+        try {\n+            InitialContext ctxt = new InitialContext();\n+            datasource = (DataSource) ctxt.lookup(datasourceJndiName);\n+        } catch (Throwable e) {\n+            FHIRException fx = new FHIRPersistenceDBConnectException(\"Failure acquiring datasource\");\n+            log.log(Level.SEVERE, fx.addProbeId(\"Failure acquiring datasource: \" + datasourceJndiName), e);\n+            throw fx;\n+        } finally {\n+            if (log.isLoggable(Level.FINEST)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.jdbc.connection.FHIRDbConnectionProvider#getConnection()\n+     */\n+    @Override\n+    public Connection getConnection() throws FHIRPersistenceDBConnectException {\n+        Connection connection;\n+        final String METHODNAME = \"getConnection\";\n+\n+        if (log.isLoggable(Level.FINE)) {\n+            log.entering(CLASSNAME, METHODNAME);\n+        }\n+\n+        try {\n+            // Resources can be routed to different databases using the dsId currently\n+            // set on the context.\n+            String tenantId = FHIRRequestContext.get().getTenantId();\n+            String dsId = FHIRRequestContext.get().getDataStoreId();\n+            \n+            long start = System.nanoTime();\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Getting connection for tenantId/dsId: [\" + tenantId + \"/\" + dsId + \"]...\");\n+            }\n+\n+            // Use the username/password interface to pass the tenantId and datasource id\n+            // paramters into the proxy datasource so that it can find the correct connection\n+            connection = getConnection(datasource, tenantId, dsId);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                double deltams = (System.nanoTime() - start) / NANOMS;\n+                log.fine(\"Got the connection for [\" + tenantId + \"/\" + dsId + \"]. Took \" + deltams + \" ms\");\n+            }\n+        } catch (Throwable e) {\n+            // Don't emit secrets in case they are returned to a client\n+            FHIRPersistenceDBConnectException fx =\n+                    new FHIRPersistenceDBConnectException(\"Failure acquiring connection for datasource\");\n+            throw FHIRDbHelper.severe(log, fx, \"Failure acquiring connection for datasource: \" + datasourceJndiName, e);\n+        } finally {\n+            if (log.isLoggable(Level.FINE)) {\n+                log.exiting(CLASSNAME, METHODNAME);\n+            }\n+        }\n+        \n+        return connection;\n+    }\n+    \n+    @Override\n+    protected Connection getConnection(DataSource datasource, String tenantId, String dsId) throws SQLException, FHIRPersistenceException {\n+        // Now use the dsId/tenantId specific JEE datasource to get a connection\n+        Connection connection = datasource.getConnection(tenantId, dsId);\n+        \n+        try {\n+            // always\n+            connection.setAutoCommit(false);\n+            \n+            // configure the connection if it's the first time we've accessed it in this transaction\n+            configure(connection, tenantId, dsId);\n+        } catch (Throwable t) {\n+            // clean up if something goes wrong during configuration\n+            try {\n+                connection.close();\n+            } catch (Throwable x) {\n+                // NOP...something bad is going on anyway, so don't confuse things\n+                // by throwing a different exception and hiding the original", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMzcyNA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447013724", "bodyText": "which bit? Perhaps we should create some guidelines for FINE/FINER/FINEST.", "author": "punktilious", "createdAt": "2020-06-29T14:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1NjQ2Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447056463", "bodyText": "if you are catching a throwable here, it'd be a great think to have a log statement at least announcing.  I say FINEST as it is not FINER which is our default, and allows us to turn it higher to see what's happening.", "author": "prb112", "createdAt": "2020-06-29T15:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1OTY5NQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447759695", "bodyText": "fixed in next commit", "author": "punktilious", "createdAt": "2020-06-30T15:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI3MQ==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r446583271", "bodyText": "OK, what is this code block doing?  it seems unused", "author": "prb112", "createdAt": "2020-06-28T00:32:52Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/connection/FHIRDbTenantDatasourceConnectionStrategy.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.connection;\n+\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+import javax.transaction.UserTransaction;\n+\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.database.utils.model.DbType;\n+import com.ibm.fhir.exception.FHIRException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FHIRDbDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.FHIRDbDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+\n+/**\n+ * Hides the logic behind obtaining a JDBC {@link Connection} from the DAO code.\n+ * \n+ * Uses datasource and tenant ids configured in the fhir-server-config to\n+ * map directly to a managed datasource. All managed datasources must be\n+ * available when the server starts. This differs from the proxy\n+ * datasource strategy {@link FHIRDbPropsConnectionStrategy} which supports\n+ * dynamic (programmatic) definition of managed datasources.\n+ * \n+ * @implNote Refactored from {@link FHIRDbDAOImpl}. Improves separation of\n+ *           concerns by removing connection management code from the DAO\n+ *           and injecting it as a strategy instead. This not only simplifies\n+ *           things, but also makes it easier to implement new strategies,\n+ *           such as using a JEE datasource directly instead of the FHIR\n+ *           proxy datasource used here.\n+ */\n+public class FHIRDbTenantDatasourceConnectionStrategy extends FHIRDbConnectionStrategyBase {\n+    private static final Logger log = Logger.getLogger(FHIRDbDAOImpl.class.getName());\n+    private static final String CLASSNAME = FHIRDbDAOImpl.class.getName();\n+\n+    // number of nanoseconds in a millisecond\n+    private static final long NANOMS = 1000000;\n+    \n+    // JNDI address of the (proxy) datasource\n+    private final String datasourceBaseName = \"jdbc/fhir_\";\n+\n+    // Cache of datasources we've found\n+    private final Map<String, DataSource> datasourceMap = new ConcurrentHashMap<>();\n+    \n+    // the flavor of the database we are configured to represent\n+    private final FHIRDbFlavor flavor;\n+\n+    /**\n+     * Public constructor. The proxy datasource must be present (registered in JNDI)\n+     * at server startup.\n+     * @throws FHIRPersistenceDBConnectException if the proxy datasource is not configured\n+     */\n+    public FHIRDbTenantDatasourceConnectionStrategy(TransactionSynchronizationRegistry trxSyncRegistry, Action newConnectionAction) throws FHIRException {\n+        super(trxSyncRegistry, newConnectionAction);\n+\n+        // Find the base JNDI name of the datasource we want to use\n+        try {\n+//            this.datasourceBaseName =\n+//                    FHIRConfiguration.getInstance().loadConfiguration().getStringProperty(\n+//                        FHIRConfiguration.PROPERTY_JDBC_DATASOURCE_JNDINAME, FHIRDbDAO.FHIRDB_JNDI_NAME_DEFAULT);", "originalCommit": "11d46a2b46e45dcd95d487a27f6b051e73ec38d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxODc3Mw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447018773", "bodyText": "This is a new datasource strategy Lee and I discussed. It will allow us to create simpler database configurations using datasources directly from JNDI instead of our more complex proxy configuration. I used it temporarily when I was debugging the setSchema issue. The strategy implementation works, but needs some extra support from the FHIR server config side of things to make it usable.", "author": "punktilious", "createdAt": "2020-06-29T14:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1Njk4Mg==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447056982", "bodyText": "let's take the code out or add a comment", "author": "prb112", "createdAt": "2020-06-29T15:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc2MDI1NA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447760254", "bodyText": "I'll add a comment", "author": "punktilious", "createdAt": "2020-06-30T15:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNTAyMw==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447905023", "bodyText": "I'm sorry I don't see the comment", "author": "prb112", "createdAt": "2020-06-30T18:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1ODM2MA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447958360", "bodyText": "Currently not used - just needs some additional integration\n\n\n\n      with the fhir-server-configuration to be supported.\n\n\n\nlines 48-49", "author": "punktilious", "createdAt": "2020-06-30T20:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MDYzMA==", "url": "https://github.com/IBM/FHIR/pull/1267#discussion_r447960630", "bodyText": "thank you", "author": "prb112", "createdAt": "2020-06-30T20:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4MzI3MQ=="}], "type": "inlineReview"}]}