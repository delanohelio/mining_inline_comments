{"pr_number": 779, "pr_title": "Shared Kube/Titus job reconciler", "pr_createdAt": "2020-02-18T02:52:08Z", "pr_url": "https://github.com/Netflix/titus-control-plane/pull/779", "timeline": [{"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e", "url": "https://github.com/Netflix/titus-control-plane/commit/de8d3abd05944231e679ec6378d89d8670a91d1e", "message": "Shared Kube/Titus job reconciler", "committedDate": "2020-02-18T02:42:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwODcwMg==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380808702", "bodyText": "please add javadocs", "author": "corindwyer", "createdAt": "2020-02-18T17:03:18Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/KubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import reactor.core.publisher.Flux;\n+\n+public interface KubeJobManagementReconciler {", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTg1OA==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380809858", "bodyText": "Instead of doing this, I suggest looking up the pod object and then using the pods nodeName so nodeName can change.", "author": "corindwyer", "createdAt": "2020-02-18T17:05:13Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";\n+                        break;\n+                    case UNKNOWN:\n+                    default:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Task lost between control plane and machine\";\n+                        break;\n+                }\n+\n+                publishEvent(task,\n+                        TaskStatus.newBuilder()\n+                                .withState(TaskState.Finished)\n+                                .withReasonCode(reasonCode)\n+                                .withReasonMessage(reasonMessage)\n+                                .withTimestamp(clock.wallTime())\n+                                .build()\n+                );\n+            }\n+            logger.info(\"Finished orphaned task transitions to finished ({})\", kind);\n+        });\n+    }\n+\n+    private Optional<V1Node> findNode(Task task, Map<String, V1Node> nodes) {\n+        String instanceId = task.getTaskContext().get(TaskAttributes.TASK_ATTRIBUTES_AGENT_INSTANCE_ID);", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0MDgyMg==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380840822", "bodyText": "Is it something that may happen today, or the goal is to make the code more flexible.\nIf instance id in the task context is different from node instance id, it is a major consistency issue.", "author": "tbak", "createdAt": "2020-02-18T18:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0MjAyMA==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380842020", "bodyText": "It is to make it more flexible as the nodeName in the future may not match the instance id.", "author": "corindwyer", "createdAt": "2020-02-18T18:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2OTk1OQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380869959", "bodyText": "Adding a new task attribute:\npublic static final String TASK_ATTRIBUTES_KUBE_NODE_NAME = \"kube.nodeName\"", "author": "tbak", "createdAt": "2020-02-18T18:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQ5OQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380810499", "bodyText": "I think there should be a better message here. Maybe Agent terminated due to underlying issue?", "author": "corindwyer", "createdAt": "2020-02-18T17:06:14Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyOTIwMA==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380829200", "bodyText": "\ud83d\udc4d, something like: Terminated due to an issue with the underlying host machine", "author": "fabiokung", "createdAt": "2020-02-18T17:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjU3NA==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380812574", "bodyText": "If there are many Accepted entries in the status history then you might not get the correct one.", "author": "corindwyer", "createdAt": "2020-02-18T17:09:43Z", "path": "titus-api/src/main/java/com/netflix/titus/api/jobmanager/model/job/TaskStatus.java", "diffHunk": "@@ -153,6 +153,14 @@ public static boolean isEvicted(Task task) {\n                 ).orElse(false);\n     }\n \n+    public static boolean hasPod(Task task) {\n+        TaskStatus acceptedStatus = JobFunctions.findTaskStatus(task, TaskState.Accepted).orElse(null);", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyNTc5MQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380825791", "bodyText": "minor: add (matcher, reasonString) pairs to a collection and findFirst() on it to reduce duplication here", "author": "fabiokung", "createdAt": "2020-02-18T17:32:50Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultContainerResultCodeResolver.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.common.util.RegExpExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Singleton\n+public class DefaultContainerResultCodeResolver implements ContainerResultCodeResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultContainerResultCodeResolver.class);\n+\n+    private final Function<String, Matcher> invalidRequestMessageMatcherFactory;\n+    private final Function<String, Matcher> crashedMessageMatcherFactory;\n+    private final Function<String, Matcher> transientSystemErrorMessageMatcherFactory;\n+    private final Function<String, Matcher> localSystemErrorMessageMatcherFactory;\n+    private final Function<String, Matcher> unknownSystemErrorMessageMatcherFactory;\n+\n+    @Inject\n+    public DefaultContainerResultCodeResolver(MesosConfiguration mesosConfiguration) {\n+        this.invalidRequestMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getInvalidRequestMessagePattern, \"invalidRequestMessagePattern\", Pattern.DOTALL, logger);\n+        this.crashedMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getCrashedMessagePattern, \"crashedMessagePattern\", Pattern.DOTALL, logger);\n+        this.transientSystemErrorMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getTransientSystemErrorMessagePattern, \"transientSystemErrorMessagePattern\", Pattern.DOTALL, logger);\n+        this.localSystemErrorMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getLocalSystemErrorMessagePattern, \"localSystemErrorMessagePattern\", Pattern.DOTALL, logger);\n+        this.unknownSystemErrorMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getUnknownSystemErrorMessagePattern, \"unknownSystemErrorMessagePattern\", Pattern.DOTALL, logger);\n+    }\n+\n+    public Optional<String> resolve(TaskState taskState, String reasonMessage) {\n+        if (taskState != com.netflix.titus.api.jobmanager.model.job.TaskState.Finished || StringExt.isEmpty(reasonMessage)) {\n+            return Optional.empty();\n+        }\n+\n+        if (invalidRequestMessageMatcherFactory.apply(reasonMessage).matches()) {", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0NzQyMA==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380847420", "bodyText": "I would prefer to keep it as it is, in case in the future we need more complex logic when parsing reason messages or checking additional information in the task state.", "author": "tbak", "createdAt": "2020-02-18T18:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyNTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyODM2MA==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380828360", "bodyText": "log something and/or emit a metric so we know when reconciliation is not running? Or alternatively, emit a metric when it runs", "author": "fabiokung", "createdAt": "2020-02-18T17:37:43Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzMDEwMw==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380830103", "bodyText": "suggestion, something like: Abandoned with unknown state due to lack of status updates from the host machine", "author": "fabiokung", "createdAt": "2020-02-18T17:40:55Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";\n+                        break;\n+                    case UNKNOWN:\n+                    default:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Task lost between control plane and machine\";", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzMTY2NA==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380831664", "bodyText": "In the TaskState.Accepted && hasPod() case, I think we need a grace time to allow state propagation through kube-apiserver and our informers, otherwise we may be killing tasks prematurely", "author": "fabiokung", "createdAt": "2020-02-18T17:43:45Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";\n+                        break;\n+                    case UNKNOWN:\n+                    default:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Task lost between control plane and machine\";\n+                        break;\n+                }\n+\n+                publishEvent(task,\n+                        TaskStatus.newBuilder()\n+                                .withState(TaskState.Finished)\n+                                .withReasonCode(reasonCode)\n+                                .withReasonMessage(reasonMessage)\n+                                .withTimestamp(clock.wallTime())\n+                                .build()\n+                );\n+            }\n+            logger.info(\"Finished orphaned task transitions to finished ({})\", kind);\n+        });\n+    }\n+\n+    private Optional<V1Node> findNode(Task task, Map<String, V1Node> nodes) {\n+        String instanceId = task.getTaskContext().get(TaskAttributes.TASK_ATTRIBUTES_AGENT_INSTANCE_ID);\n+        if (instanceId == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(nodes.get(instanceId));\n+    }\n+\n+    private boolean shouldTaskBeInApiServer(Task task) {\n+        boolean isRunning = TaskState.isRunning(task.getStatus().getState());\n+\n+        if (JobFunctions.isOwnedByKubeScheduler(task)) {\n+            return isRunning || (task.getStatus().getState() == TaskState.Accepted && TaskStatus.hasPod(task));", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzNTAxNQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380835015", "bodyText": "minor: maybe s/pod/task/ since this is an user facing message", "author": "fabiokung", "createdAt": "2020-02-18T17:49:51Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/direct/DefaultDirectKubeApiServerIntegrator.java", "diffHunk": "@@ -146,7 +150,14 @@ public void shutdown() {\n                 metrics.terminateError(task, e, timer.elapsed(TimeUnit.MILLISECONDS));\n \n                 if (e.getMessage().equalsIgnoreCase(NOT_FOUND) && task.getStatus().getState() == TaskState.Accepted) {\n-                    sendEvent(PodEvent.onPodNotFound(task));\n+                    sendEvent(PodEvent.onPodNotFound(task,\n+                            TaskStatus.newBuilder()\n+                                    .withState(TaskState.Finished)\n+                                    .withReasonCode(TaskStatus.REASON_TASK_LOST)\n+                                    .withReasonMessage(\"Pod terminate requested, but the pod is not found\")", "originalCommit": "de8d3abd05944231e679ec6378d89d8670a91d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2NDA3Mw==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380864073", "bodyText": "Here the task exists in Titus, but there is no pod. Maybe something like this:\nTask terminate requested, but its container is not found", "author": "tbak", "createdAt": "2020-02-18T18:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzNTAxNQ=="}], "type": "inlineReview"}, {"oid": "76ce8e4091510dd56da59c41019caf8918a3390c", "url": "https://github.com/Netflix/titus-control-plane/commit/76ce8e4091510dd56da59c41019caf8918a3390c", "message": "Code review updates, bug fixes and improvements", "committedDate": "2020-02-18T19:01:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzE4Mw==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r381543183", "bodyText": "minor: I know it is not related to your PR, but what is agent.res? A comment here may help", "author": "fabiokung", "createdAt": "2020-02-19T21:04:13Z", "path": "titus-api/src/main/java/com/netflix/titus/api/jobmanager/TaskAttributes.java", "diffHunk": "@@ -22,15 +22,19 @@\n      */\n     public static final String TASK_ATTRIBUTES_AGENT_REGION = \"agent.region\";\n     public static final String TASK_ATTRIBUTES_AGENT_ZONE = \"agent.zone\";\n+    public static final String TASK_ATTRIBUTES_AGENT_AMI = \"agent.ami\";\n     public static final String TASK_ATTRIBUTES_AGENT_ASG = \"agent.asg\";\n     public static final String TASK_ATTRIBUTES_AGENT_HOST = \"agent.host\";\n+    public static final String TASK_ATTRIBUTES_AGENT_CLUSTER = \"agent.cluster\";\n     public static final String TASK_ATTRIBUTES_AGENT_INSTANCE_ID = \"agent.instanceId\";\n     public static final String TASK_ATTRIBUTES_AGENT_ITYPE = \"agent.itype\";\n+    public static final String TASK_ATTRIBUTES_AGENT_RES = \"agent.res\";", "originalCommit": "76ce8e4091510dd56da59c41019caf8918a3390c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODU4NQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r381548585", "bodyText": "Adding a comment now in another PR. This attributes holds agent ENI resources.", "author": "tbak", "createdAt": "2020-02-19T21:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzE4Mw=="}], "type": "inlineReview"}]}