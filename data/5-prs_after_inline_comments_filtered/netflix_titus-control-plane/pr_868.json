{"pr_number": 868, "pr_title": "Read archived data from active job/task tables if not found in the archive tables", "pr_createdAt": "2020-06-10T22:03:25Z", "pr_url": "https://github.com/Netflix/titus-control-plane/pull/868", "timeline": [{"oid": "ed6bcebd02563745cdac5c01c132e9d375b77413", "url": "https://github.com/Netflix/titus-control-plane/commit/ed6bcebd02563745cdac5c01c132e9d375b77413", "message": "Read archived data from active job/task tables if not found in the archive tables\n\nIt is possible that finished jobs/tasks are not moved after they are finished to\nthe archive tables. This may happen during failover which happens\nimmediately after a job completes, but is not archived yet. To read such\nabandoned items (which are ignored when loading active data into memory), we\nhave to make a fallback query in case the primary archive table does not contain\nan entry.", "committedDate": "2020-06-10T21:57:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjE2NA==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438466164", "bodyText": "please add some documentation here (and consider renaming the method) since now it will also always returns active tasks for the job. It seems to be handled correctly by the only current caller, but it may cause confusion in the future", "author": "fabiokung", "createdAt": "2020-06-10T23:45:16Z", "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {", "originalCommit": "ed6bcebd02563745cdac5c01c132e9d375b77413", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTYzOQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438955639", "bodyText": "Active state should never be read like that (all of it is read on startup). But technically you are right that we could read active data with this method. I will add a comment documenting this.", "author": "tbak", "createdAt": "2020-06-11T17:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MDM4Mw==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438480383", "bodyText": "Is the variable name correct? Seems like these could be active or archived depending on the statement provided.", "author": "andrew-leung", "createdAt": "2020-06-11T00:36:46Z", "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {\n-        return Observable.fromCallable(() -> retrieveArchivedTaskIdsForJobStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n-                .flatMap(retrieveActiveTaskIdsForJob -> execute(retrieveActiveTaskIdsForJob).flatMap(taskIdsResultSet -> {\n-                    List<String> taskIds = taskIdsResultSet.all().stream().map(row -> row.getString(0)).collect(Collectors.toList());\n-                    List<Observable<ResultSet>> observables = taskIds.stream().map(retrieveArchivedTaskStatement::bind).map(this::execute).collect(Collectors.toList());\n-                    return Observable.merge(observables, getConcurrencyLimit()).flatMapIterable(tasksResultSet -> tasksResultSet.all().stream()\n-                            .map(row -> row.getString(0))\n-                            .map(value -> deserializeTask(value))\n-                            .collect(Collectors.toList()));\n-                }));\n+        return retrieveArchivedTasksForJob(jobId, retrieveArchivedTaskIdsForJobStatement, retrieveArchivedTaskStatement)\n+                .switchIfEmpty(retrieveArchivedTasksForJob(jobId, retrieveActiveTaskIdsForJobStatement, retrieveActiveTaskStatement));\n+    }\n+\n+    private Observable<Task> retrieveArchivedTasksForJob(String jobId, PreparedStatement taskIdStatement, PreparedStatement taskStatement) {\n+        return Observable.fromCallable(() -> taskIdStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n+                .flatMap(retrieveActiveTaskIdsForJob ->", "originalCommit": "ed6bcebd02563745cdac5c01c132e9d375b77413", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTkzNw==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438955937", "bodyText": "I will change this, and add a comment.", "author": "tbak", "createdAt": "2020-06-11T17:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MDM4Mw=="}], "type": "inlineReview"}, {"oid": "3f3afdc6bd660b3f03485a3f04a78b2441d81d8a", "url": "https://github.com/Netflix/titus-control-plane/commit/3f3afdc6bd660b3f03485a3f04a78b2441d81d8a", "message": "Code review updates", "committedDate": "2020-06-11T17:43:45Z", "type": "commit"}]}