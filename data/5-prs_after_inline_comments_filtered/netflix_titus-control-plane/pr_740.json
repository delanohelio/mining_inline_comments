{"pr_number": 740, "pr_title": "Add PaginationEvaluator to simplify the pagination processing", "pr_createdAt": "2020-01-02T20:38:50Z", "pr_url": "https://github.com/Netflix/titus-control-plane/pull/740", "timeline": [{"oid": "186ae9fb67404d745067051aa6db3969b095768d", "url": "https://github.com/Netflix/titus-control-plane/commit/186ae9fb67404d745067051aa6db3969b095768d", "message": "Add PaginationEvaluator to simplify the pagination processing", "committedDate": "2020-01-02T20:22:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODEzNg==", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362688136", "bodyText": "Do we validate somewhere that the user hasn't set pageSize to 0?", "author": "andrew-leung", "createdAt": "2020-01-03T01:46:35Z", "path": "titus-common-api/src/main/java/com/netflix/titus/api/model/PaginationEvaluator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.api.model;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.titus.common.util.CollectionsExt;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.tuple.Pair;\n+\n+public class PaginationEvaluator<T> {\n+\n+    private static final Pattern CURSOR_RE = Pattern.compile(\"(.*)@(\\\\d+)\");\n+\n+    private final Function<T, String> idExtractor;\n+    private final Function<T, Long> timestampExtractor;\n+\n+    private final Comparator<T> dataComparator;\n+\n+    public PaginationEvaluator(Function<T, String> idExtractor, Function<T, Long> timestampExtractor) {\n+        this.idExtractor = idExtractor;\n+        this.timestampExtractor = timestampExtractor;\n+\n+        this.dataComparator = (first, second) -> {\n+            long firstTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(first), 0L);\n+            long secondTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(second), 0L);\n+            int timestampCmp = Long.compare(firstTimestamp, secondTimestamp);\n+            if (timestampCmp != 0) {\n+                return timestampCmp;\n+            }\n+\n+            String firstId = idExtractor.apply(first);\n+            String secondId = idExtractor.apply(second);\n+            return firstId.compareTo(secondId);\n+        };\n+    }\n+\n+    public PageResult<T> takePage(Page page, List<T> items) {\n+        List<T> itemsCopy = new ArrayList<>(items);\n+        itemsCopy.sort(dataComparator);\n+\n+        if (StringExt.isEmpty(page.getCursor())) {\n+            return takePageWithoutCursor(page, itemsCopy);\n+        }\n+\n+        Pair<String, Long> decodedCursor = decode(page.getCursor());\n+        return takePageWithCursor(page, itemsCopy, decodedCursor.getLeft(), decodedCursor.getRight());\n+    }\n+\n+    /**\n+     * {@link Page#getPageNumber() Number} (index) based pagination.\n+     * <p>\n+     * Please consider using {@link PaginationUtil#takePageWithCursor(Page, List, Comparator, PaginationUtil.CursorIndexOf, Function) cursor-based}\n+     * pagination instead. This mode will be deprecated soon.\n+     */\n+    private PageResult<T> takePageWithoutCursor(Page page, List<T> items) {\n+        int totalItems = items.size();\n+        if (totalItems <= 0 || page.getPageSize() <= 0) {\n+            return PageResult.pageOf(Collections.emptyList(), new Pagination(page, false, 0, 0, \"\", 0));\n+        }\n+\n+        int firstItem = page.getPageNumber() * page.getPageSize();\n+        int lastItem = Math.min(totalItems, firstItem + page.getPageSize());\n+        boolean more = totalItems > lastItem;\n+        int totalPages = numberOfPages(page, totalItems);\n+\n+        List<T> pageItems = firstItem < lastItem\n+                ? items.subList(firstItem, lastItem)\n+                : Collections.emptyList();\n+\n+        int cursorPosition = pageItems.isEmpty() ? 0 : lastItem - 1;\n+\n+        return PageResult.pageOf(pageItems, new Pagination(page, more, totalPages, totalItems, encode(pageItems.get(cursorPosition)), cursorPosition));\n+    }\n+\n+    private PageResult<T> takePageWithCursor(Page page, List<T> itemsCopy, String cursorId, long cursorTimestamp) {\n+        int offset = getOffset(itemsCopy, cursorId, cursorTimestamp);\n+\n+        int totalItems = itemsCopy.size();\n+        boolean isEmptyResult = offset >= totalItems;\n+        boolean hasMore = totalItems > (offset + page.getPageSize());\n+        int endOffset = Math.min(totalItems, offset + page.getPageSize());\n+        int cursorPosition = endOffset - 1;\n+        int numberOfPages = numberOfPages(page, totalItems);\n+        int pageNumber = Math.min(numberOfPages, offset / page.getPageSize());\n+\n+        Pagination pagination = new Pagination(\n+                page.toBuilder().withPageNumber(pageNumber).build(),\n+                hasMore,\n+                numberOfPages,\n+                totalItems,\n+                totalItems == 0 ? \"\" : encode(itemsCopy.get(cursorPosition)),\n+                totalItems == 0 ? 0 : cursorPosition\n+        );\n+\n+        List<T> pageItems = isEmptyResult ? Collections.emptyList() : itemsCopy.subList(offset, endOffset);\n+        return PageResult.pageOf(pageItems, pagination);\n+    }\n+\n+    /**\n+     * Offset is a position of an element after the one pointed by the cursor. If cursor does not point to any\n+     * existing element, the offset points to the smallest element larger than cursor.\n+     */\n+    private int getOffset(List<T> itemsCopy, String cursorId, long cursorTimestamp) {\n+        if (itemsCopy.isEmpty()) {\n+            return 0;\n+        }\n+\n+        Function<T, Integer> comparator = item -> {\n+            long itemTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(item), 0L);\n+            int timestampCmp = Long.compare(cursorTimestamp, itemTimestamp);\n+            if (timestampCmp != 0) {\n+                return timestampCmp;\n+            }\n+\n+            String itemId = idExtractor.apply(item);\n+            return cursorId.compareTo(itemId);\n+        };\n+\n+        int pos = CollectionsExt.binarySearchLeftMost(itemsCopy, comparator);\n+        return pos >= 0 ? (pos + 1) : -(pos + 1);\n+    }\n+\n+    @VisibleForTesting\n+    String encode(T value) {\n+        String id = idExtractor.apply(value);\n+        long timeStamp = Evaluators.getOrDefault(timestampExtractor.apply(value), 0L);\n+        return Base64.getEncoder().encodeToString((id + '@' + timeStamp).getBytes());\n+    }\n+\n+    private static Pair<String, Long> decode(String encoded) {\n+        String decoded = new String(Base64.getDecoder().decode(encoded.getBytes()));\n+\n+        Matcher matcher = CURSOR_RE.matcher(decoded);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Not a valid cursor value: encoded=%s, decoded=%s\", encoded, decoded)\n+            );\n+        }\n+\n+        String jobId = matcher.group(1);\n+        long timestamp = Long.parseLong(matcher.group(2));\n+\n+        return Pair.of(jobId, timestamp);\n+    }\n+\n+    private static int numberOfPages(Page page, int totalItems) {\n+        return (totalItems + page.getPageSize() - 1) / page.getPageSize();", "originalCommit": "186ae9fb67404d745067051aa6db3969b095768d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODQwMg==", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362688402", "bodyText": "Also, I'm a little confused about the calculation here. If totalItems is 10 and pageSize is 4, I would expect there to be 3 pages. Seems like this would return 4.", "author": "andrew-leung", "createdAt": "2020-01-03T01:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY5NDU4MQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362694581", "bodyText": "No, we do not do that. I will add this check.\n(10 + 4  - 1)/4 = 3. The calculation is correct.", "author": "tbak", "createdAt": "2020-01-03T02:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjcwNDU4NA==", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362704584", "bodyText": "I will support page size 0 as a special case, which returns empty list. This is useful if a client is interested only in the pagination data (mostly total items).", "author": "tbak", "createdAt": "2020-01-03T04:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjgwNDc1Ng==", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362804756", "bodyText": "Yeah, I must have misread it before. Looks correct.", "author": "andrew-leung", "createdAt": "2020-01-03T13:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODQ1Mw==", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362688453", "bodyText": "2020?", "author": "andrew-leung", "createdAt": "2020-01-03T01:49:38Z", "path": "titus-common-api/src/main/java/com/netflix/titus/api/model/PaginationEvaluator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.", "originalCommit": "186ae9fb67404d745067051aa6db3969b095768d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "37c45fd2a871619c18a45eccdbb44e865d084e60", "url": "https://github.com/Netflix/titus-control-plane/commit/37c45fd2a871619c18a45eccdbb44e865d084e60", "message": "Code review updates", "committedDate": "2020-01-03T04:38:19Z", "type": "commit"}]}