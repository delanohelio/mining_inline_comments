{"pr_number": 3877, "pr_title": "Reworking GeoPoint Widget", "pr_createdAt": "2020-05-27T21:35:39Z", "pr_url": "https://github.com/getodk/collect/pull/3877", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzU2Mw==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r432237563", "bodyText": "Hi @seadowg! I had some doubts. As here, GeoPointWidgetTest does not inherit from any other tests. Should I go about it, or maintain the already implemented hierarchy. Also, I wanted to ask, is there any drawback when running tests having some hierarchy (in terms of running time, or some other factor)?", "author": "SaumiaSinghal", "createdAt": "2020-05-29T03:34:26Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,27 +1,41 @@\n package org.odk.collect.android.widgets;\n \n-import android.content.Intent;\n+import android.view.View;\n \n-import org.javarosa.core.model.QuestionDef;\n import org.javarosa.core.model.data.GeoPointData;\n-import org.junit.Before;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n-import org.odk.collect.android.activities.GeoPointActivity;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n-\n-import static org.mockito.Mockito.when;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n \n /**\n  * @author James Knight\n  */\n \n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n+\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {\n+        GeoPointWidget widget = createWidget(promptWithReadOnly());\n+        assertThat(widget.findViewById(R.id.simple_button).getVisibility(), equalTo(View.GONE));\n+    }\n+\n+    private GeoPointWidget createWidget(FormEntryPrompt prompt) {\n+        return new GeoPointWidget(widgetTestActivity(), new QuestionDetails(prompt, \"formAnalyticsID\"));\n+    }\n+}\n+", "originalCommit": "2a98bca100d7b001ead78aa04f1ecd369a38d6e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0MzQ2MA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r433343460", "bodyText": "I think we should go for the tests not having a hierarchy i.e. GeoPointWidgetTest should not extend anything.\nAs far as implementation goes I think it's a harder decision. I think a good way to start would be to rewrite the tests for these widgets (GeoPointWidget, GeoShapeWidget and GeoTraceWidget) as one PR. Then we can discuss how to rewrite the widgets using the new \"framework\".", "author": "seadowg", "createdAt": "2020-06-01T16:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzU2Mw=="}], "type": "inlineReview"}, {"oid": "0432135ccd93c2bcf6ce9daa49bf64a0129b6828", "url": "https://github.com/getodk/collect/commit/0432135ccd93c2bcf6ce9daa49bf64a0129b6828", "message": "add unit tests", "committedDate": "2020-06-03T13:21:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2MTMxOA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r435161318", "bodyText": "Instead of building an expectedIntent here I would just assert that the startedIntent has the correct component and extras. It makes it easier to see what is missing when there is a fail and I'm not sure equals on Intent is very good. Are you familiar with how equality works in Java (equals vs == etc)?", "author": "seadowg", "createdAt": "2020-06-04T10:45:10Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,217 @@\n package org.odk.collect.android.widgets;\n \n import android.content.Intent;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.TextView;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n-\n-import androidx.annotation.NonNull;\n-\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.robolectric.RobolectricTestRunner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n \n-    @Mock\n-    QuestionDef questionDef;\n+    private final FakePermissionUtils permissionUtils = new FakePermissionUtils();\n+    private final List<double[]> answerDoubles = getRandomDoubleArrayList();\n+    private final String answer = stringFromDoubleList(answerDoubles);\n \n-    private double[] initialDoubles;\n-    private double[] answerDoubles;\n+    private QuestionDef questionDef;\n+    private MapConfigurator mapConfigurator;\n \n-    @Override\n-    public GeoPointData getInitialAnswer() {\n-        return new GeoPointData(initialDoubles);\n+    @Before\n+    public void setup() {\n+        questionDef = mock(QuestionDef.class);\n+        mapConfigurator = mock(MapConfigurator.class);\n+        when(questionDef.getAdditionalAttribute(anyString(), anyString())).thenReturn(null);\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointWidget createWidget() {\n-        return new GeoPointWidget(activity, new QuestionDetails(formEntryPrompt, \"formAnalyticsID\"));\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveAnswer_returnsNull() {\n+        assertThat(createWidget(promptWithAnswer(null)).getAnswer(), equalTo(null));\n     }\n \n-    @Override\n-    public Object createBinaryData(GeoPointData answerData) {\n-        return stringFromDoubles(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveConvertibleString_returnsNull() throws NumberFormatException {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointData getNextAnswer() {\n-        return new GeoPointData(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptHasAnswer_returnsAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.getAnswer().getDisplayText(), equalTo(answer));\n     }\n \n-    @Before\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        when(formEntryPrompt.getQuestion()).thenReturn(questionDef);\n+    @Test\n+    public void clearAnswer_clearsWidgetAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        widget.clearAnswer();\n \n-        initialDoubles = getRandomDoubleArray();\n-        answerDoubles = getRandomDoubleArray();\n+        assertThat(widget.getAnswer(), nullValue());\n     }\n \n-    @Override\n-    public void getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer() {\n-        when(formEntryPrompt.getAnswerText()).thenReturn(stringFromDoubles(initialDoubles));\n-        super.getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer();\n+    @Test\n+    public void clearAnswer_callsValueChangeListeners() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        WidgetValueChangedListener valueChangedListener = mockValueChangedListener(widget);\n+        widget.clearAnswer();\n+\n+        verify(valueChangedListener).widgetValueChanged(widget);\n     }\n \n-    private double[] getRandomDoubleArray() {\n-        return new double[]{\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble()\n-        };\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {\n+        GeoPointWidget widget = createWidget(promptWithReadOnly());\n+        assertThat(widget.findViewById(R.id.geo_button).getVisibility(), equalTo(View.GONE));\n+    }\n+\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        TextView textView = widget.findViewById(R.id.geo_answer_text);\n+\n+        assertThat(textView.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_textViewDisplaysAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        TextView textView = widget.findViewById(R.id.geo_answer_text);\n+        String[] parts = answer.split(\" \");\n+\n+        assertThat(textView.getText().toString(), equalTo(widget.getContext().getString(\n+                R.string.gps_result,\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                GeoWidgetUtils.truncateDouble(parts[2]),\n+                GeoWidgetUtils.truncateDouble(parts[3])\n+        )));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndIsReadOnly_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(PLACEMENT_MAP, true));\n+\n+        assertThat(((Button) widget.findViewById(R.id.geo_button)).getText(),\n+                equalTo(widget.getContext().getString(R.string.geopoint_view_read_only)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndNullAsAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(PLACEMENT_MAP, null));\n+\n+        assertThat(((Button) widget.findViewById(R.id.geo_button)).getText(),\n+                equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, new StringData(answer)));\n+\n+        assertThat(((Button) widget.findViewById(R.id.geo_button)).getText(),\n+                equalTo(widget.getContext().getString(R.string.view_change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+\n+        assertThat(((Button) widget.findViewById(R.id.geo_button)).getText(),\n+                equalTo(widget.getContext().getString(R.string.change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasNullAsAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+\n+        assertThat(((Button) widget.findViewById(R.id.geo_button)).getText(),\n+                equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void buttonsShouldLaunchCorrectIntents() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        stubAllRuntimePermissionsGranted(widget, true);\n+        (widget.findViewById(R.id.geo_button)).performClick();\n+\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+        Intent expectedIntent = new Intent(widgetTestActivity(), GeoPointActivity.class);\n+\n+        expectedIntent.putExtra(READ_ONLY, false);\n+        expectedIntent.putExtra(DRAGGABLE_ONLY, false);\n+        expectedIntent.putExtra(ACCURACY_THRESHOLD, DEFAULT_LOCATION_ACCURACY);\n+        assertEquals(startedIntent, expectedIntent);", "originalCommit": "766a9fc82a6c3dfaf35072541a9fda5fd984900a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5ODQ2Mw==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r435198463", "bodyText": "By building a new Intent, I might get an intent with same component name and extra values, but the nextStartedActivity() will not return the same intent. I think that's why the test is failing.", "author": "SaumiaSinghal", "createdAt": "2020-06-04T11:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2MTMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk5MDcyNg==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r437990726", "bodyText": "I think it's be good to write tests for the different appearances here. Right now they show the same thing but I think it'd be nice. The behaviour we think about from the outside is \"if it has placement-map it's this and if it's maps it's this\".\nTry to write the tests you want to describe the behaviour rather than writing tests that match the current implementation! This is definitely a lot easier when writing new code than backfilling tests.", "author": "seadowg", "createdAt": "2020-06-10T09:32:19Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,248 @@\n package org.odk.collect.android.widgets;\n \n+import android.content.ComponentName;\n import android.content.Intent;\n+import android.os.Bundle;\n+import android.view.View;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.LOCATION;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n \n-    @Mock\n-    QuestionDef questionDef;\n+    private final FakePermissionUtils permissionUtils = new FakePermissionUtils();\n+    private final List<double[]> answerDoubles = getRandomDoubleArrayList();\n+    private final String answer = stringFromDoubleList(answerDoubles);\n \n-    private double[] initialDoubles;\n-    private double[] answerDoubles;\n+    private QuestionDef questionDef;\n+    private MapConfigurator mapConfigurator;\n \n-    @Override\n-    public GeoPointData getInitialAnswer() {\n-        return new GeoPointData(initialDoubles);\n+    @Before\n+    public void setup() {\n+        questionDef = mock(QuestionDef.class);\n+        mapConfigurator = mock(MapConfigurator.class);\n+        when(questionDef.getAdditionalAttribute(anyString(), anyString())).thenReturn(null);\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointWidget createWidget() {\n-        return new GeoPointWidget(activity, new QuestionDetails(formEntryPrompt, \"formAnalyticsID\"));\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveAnswer_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @Override\n-    public Object createBinaryData(GeoPointData answerData) {\n-        return stringFromDoubles(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveConvertibleString_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointData getNextAnswer() {\n-        return new GeoPointData(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptHasAnswer_returnsAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.getAnswer().getDisplayText(), equalTo(answer));\n     }\n \n-    @Before\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        when(formEntryPrompt.getQuestion()).thenReturn(questionDef);\n+    @Test\n+    public void clearAnswer_clearsWidgetAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        widget.clearAnswer();\n+        assertThat(widget.getAnswer(), nullValue());\n+    }\n \n-        initialDoubles = getRandomDoubleArray();\n-        answerDoubles = getRandomDoubleArray();\n+    @Test\n+    public void clearAnswer_callsValueChangeListeners() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        WidgetValueChangedListener valueChangedListener = mockValueChangedListener(widget);\n+        widget.clearAnswer();\n+        verify(valueChangedListener).widgetValueChanged(widget);\n     }\n \n-    @Override\n-    public void getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer() {\n-        when(formEntryPrompt.getAnswerText()).thenReturn(stringFromDoubles(initialDoubles));\n-        super.getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer();\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {\n+        GeoPointWidget widget = createWidget(promptWithReadOnly());\n+        assertThat(widget.startGeoButton.getVisibility(), equalTo(View.GONE));\n     }\n \n-    private double[] getRandomDoubleArray() {\n-        return new double[]{\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble()\n-        };\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_textViewDisplaysAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        String[] parts = answer.split(\" \");\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(widget.getContext().getString(\n+                R.string.gps_result,\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                GeoWidgetUtils.truncateDouble(parts[2]),\n+                GeoWidgetUtils.truncateDouble(parts[3])\n+        )));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndIsReadOnly_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(PLACEMENT_MAP, true));\n+        assertThat(widget.startGeoButton.getText().toString(), equalTo(widget.getContext().getString(R.string.geopoint_view_read_only)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndNullAsAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(PLACEMENT_MAP, null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndAnswer_buttonShowsCorrectText() {", "originalCommit": "3e19147aa20087fd6d83cf4275f9b2da0816297d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0Mzg1Ng==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r438143856", "bodyText": "Oh okay @seadowg. Yes, I'll change the tests", "author": "SaumiaSinghal", "createdAt": "2020-06-10T13:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk5MDcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk5MTgxNg==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r437991816", "bodyText": "I think we're missing tests for setOnLongClickListener and cancelLongPress. Should be very similar to the URLWidget ones I'd imagine!", "author": "seadowg", "createdAt": "2020-06-10T09:34:19Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,248 @@\n package org.odk.collect.android.widgets;\n \n+import android.content.ComponentName;\n import android.content.Intent;\n+import android.os.Bundle;\n+import android.view.View;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.LOCATION;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {", "originalCommit": "3e19147aa20087fd6d83cf4275f9b2da0816297d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4NDE0OA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r438084148", "bodyText": "This method should really be called stubLocationPermissions. It's probably also good to have a test that checks what happens when location permissions are denied.", "author": "seadowg", "createdAt": "2020-06-10T12:31:01Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,248 @@\n package org.odk.collect.android.widgets;\n \n+import android.content.ComponentName;\n import android.content.Intent;\n+import android.os.Bundle;\n+import android.view.View;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.LOCATION;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n \n-    @Mock\n-    QuestionDef questionDef;\n+    private final FakePermissionUtils permissionUtils = new FakePermissionUtils();\n+    private final List<double[]> answerDoubles = getRandomDoubleArrayList();\n+    private final String answer = stringFromDoubleList(answerDoubles);\n \n-    private double[] initialDoubles;\n-    private double[] answerDoubles;\n+    private QuestionDef questionDef;\n+    private MapConfigurator mapConfigurator;\n \n-    @Override\n-    public GeoPointData getInitialAnswer() {\n-        return new GeoPointData(initialDoubles);\n+    @Before\n+    public void setup() {\n+        questionDef = mock(QuestionDef.class);\n+        mapConfigurator = mock(MapConfigurator.class);\n+        when(questionDef.getAdditionalAttribute(anyString(), anyString())).thenReturn(null);\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointWidget createWidget() {\n-        return new GeoPointWidget(activity, new QuestionDetails(formEntryPrompt, \"formAnalyticsID\"));\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveAnswer_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @Override\n-    public Object createBinaryData(GeoPointData answerData) {\n-        return stringFromDoubles(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveConvertibleString_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointData getNextAnswer() {\n-        return new GeoPointData(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptHasAnswer_returnsAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.getAnswer().getDisplayText(), equalTo(answer));\n     }\n \n-    @Before\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        when(formEntryPrompt.getQuestion()).thenReturn(questionDef);\n+    @Test\n+    public void clearAnswer_clearsWidgetAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        widget.clearAnswer();\n+        assertThat(widget.getAnswer(), nullValue());\n+    }\n \n-        initialDoubles = getRandomDoubleArray();\n-        answerDoubles = getRandomDoubleArray();\n+    @Test\n+    public void clearAnswer_callsValueChangeListeners() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        WidgetValueChangedListener valueChangedListener = mockValueChangedListener(widget);\n+        widget.clearAnswer();\n+        verify(valueChangedListener).widgetValueChanged(widget);\n     }\n \n-    @Override\n-    public void getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer() {\n-        when(formEntryPrompt.getAnswerText()).thenReturn(stringFromDoubles(initialDoubles));\n-        super.getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer();\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {\n+        GeoPointWidget widget = createWidget(promptWithReadOnly());\n+        assertThat(widget.startGeoButton.getVisibility(), equalTo(View.GONE));\n     }\n \n-    private double[] getRandomDoubleArray() {\n-        return new double[]{\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble()\n-        };\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_textViewDisplaysAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        String[] parts = answer.split(\" \");\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(widget.getContext().getString(\n+                R.string.gps_result,\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                GeoWidgetUtils.truncateDouble(parts[2]),\n+                GeoWidgetUtils.truncateDouble(parts[3])\n+        )));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndIsReadOnly_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(PLACEMENT_MAP, true));\n+        assertThat(widget.startGeoButton.getText().toString(), equalTo(widget.getContext().getString(R.string.geopoint_view_read_only)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndNullAsAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(PLACEMENT_MAP, null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAppearanceAndAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.view_change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasNullAsAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_buttonShouldLaunchCorrectIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        stubAllRuntimePermissionsGranted(widget, true);", "originalCommit": "3e19147aa20087fd6d83cf4275f9b2da0816297d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMDM4NA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r438930384", "bodyText": "This can be defined in the layout", "author": "seadowg", "createdAt": "2020-06-11T16:51:58Z", "path": "collect_app/src/main/java/org/odk/collect/android/widgets/GeoPointWidget.java", "diffHunk": "@@ -41,118 +54,172 @@\n  * @author Jon Nordling (jonnordling@gmail.com)\n  */\n @SuppressLint(\"ViewConstructor\")\n-public class GeoPointWidget extends BaseGeoWidget {\n+public class GeoPointWidget extends QuestionWidget implements BinaryDataReceiver {\n     public static final String LOCATION = \"gp\";\n     public static final String ACCURACY_THRESHOLD = \"accuracyThreshold\";\n     public static final String READ_ONLY = \"readOnly\";\n     public static final String DRAGGABLE_ONLY = \"draggable\";\n-\n     public static final double DEFAULT_LOCATION_ACCURACY = 5.0;\n+    private final MapConfigurator mapConfigurator;\n+    private final WaitingForDataRegistry waitingForDataRegistry;\n+\n+    protected Button startGeoButton;\n+    protected TextView answerDisplay;\n+\n+    private boolean readOnly;\n+    private boolean draggable = true;\n     private boolean useMap;\n     private double accuracyThreshold;\n-    private boolean draggable = true;\n     private String stringAnswer;\n \n-    public GeoPointWidget(Context context, QuestionDetails questionDetails) {\n+    public GeoPointWidget(Context context, QuestionDetails questionDetails, QuestionDef questionDef, MapConfigurator mapConfigurator, WaitingForDataRegistry waitingForDataRegistry) {\n         super(context, questionDetails);\n-        determineMapProperties();\n-    }\n-\n-    private void determineMapProperties() {\n-        // Determine the accuracy threshold to use.\n-        String acc = getFormEntryPrompt().getQuestion().getAdditionalAttribute(null, ACCURACY_THRESHOLD);\n-        accuracyThreshold = acc != null && !acc.isEmpty() ? Double.parseDouble(acc) : DEFAULT_LOCATION_ACCURACY;\n+        this.mapConfigurator = mapConfigurator;\n+        this.waitingForDataRegistry = waitingForDataRegistry;\n+        determineMapProperties(questionDef);\n \n-        // Determine whether to use the map and whether the point should be draggable.\n-        if (MapProvider.getConfigurator().isAvailable(getContext())) {\n-            if (hasAppearance(getFormEntryPrompt(), PLACEMENT_MAP)) {\n-                draggable = true;\n-                useMap = true;\n-            } else if (hasAppearance(getFormEntryPrompt(), MAPS)) {\n-                draggable = false;\n-                useMap = true;\n-            }\n+        stringAnswer = getFormEntryPrompt().getAnswerText();\n+        boolean dataAvailable = false;\n+        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n+            dataAvailable = true;\n+            setBinaryData(stringAnswer);\n         }\n+        updateButtonLabelsAndVisibility(dataAvailable);\n     }\n \n-    public void updateButtonLabelsAndVisibility(boolean dataAvailable) {\n-        if (useMap) {\n-            if (readOnly) {\n-                startGeoButton.setText(R.string.geopoint_view_read_only);\n-            } else {\n-                startGeoButton.setText(\n-                    dataAvailable ? R.string.view_change_location : R.string.get_point);\n-            }\n+    @Override\n+    protected View onCreateAnswerView(Context context, FormEntryPrompt prompt, int answerFontSize) {\n+        ViewGroup answerView = (ViewGroup) LayoutInflater.from(context).inflate(R.layout.base_geo_widget_layout, null);\n+\n+        answerDisplay = answerView.findViewById(R.id.geo_answer_text);\n+        answerDisplay.setTextColor(new ThemeUtils(context).getColorOnSurface());", "originalCommit": "2a9d522fa3c77f847bd20148d9c19f549419f662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxMjI1Nw==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r439012257", "bodyText": "Ahhh...Sorry I forgot", "author": "SaumiaSinghal", "createdAt": "2020-06-11T19:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NDc4NA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449184784", "bodyText": "I don't think there's any reason for the FormController to be involved in this. I think that a single WaitingForDataRegistry object that keeps track of the state itself and is tied to the FormEntryActivity lifecycle would help reduce what the FormController deals with. Doesn't have to be done here but might be a nice next step if I'm not missing anything.", "author": "lognaturel", "createdAt": "2020-07-02T18:01:06Z", "path": "collect_app/src/main/java/org/odk/collect/android/widgets/utilities/FormControllerWaitingForDataRegistry.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package org.odk.collect.android.widgets.utilities;\n+\n+import org.javarosa.core.model.FormIndex;\n+import org.odk.collect.android.application.Collect;\n+import org.odk.collect.android.javarosawrapper.FormController;\n+\n+public class FormControllerWaitingForDataRegistry implements WaitingForDataRegistry {", "originalCommit": "943a88c769e6916b6eeceac334d535140c1d3726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NzA3Mg==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449187072", "bodyText": "This doesn't much matter for tests but note that there's only ever one widget waiting for data.", "author": "lognaturel", "createdAt": "2020-07-02T18:05:49Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/support/FakeWaitingForDataRegistry.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.odk.collect.android.widgets.support;\n+\n+import org.javarosa.core.model.FormIndex;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FakeWaitingForDataRegistry implements WaitingForDataRegistry {\n+\n+    public List<FormIndex> waiting = new ArrayList<>();", "originalCommit": "943a88c769e6916b6eeceac334d535140c1d3726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MDg3MQ==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449190871", "bodyText": "This null check seems unrelated now that the data is set by the activity. FormEntryActivity.setBinaryWidgetData does that check anyway so I think it's clearer to remove it.", "author": "lognaturel", "createdAt": "2020-07-02T18:13:53Z", "path": "collect_app/src/main/java/org/odk/collect/android/tasks/MediaLoadingTask.java", "diffHunk": "@@ -97,7 +97,7 @@ protected void onPostExecute(File result) {\n \n         ODKView odkView = formEntryActivity.get().getCurrentViewIfODKView();", "originalCommit": "943a88c769e6916b6eeceac334d535140c1d3726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NDIxMA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449194210", "bodyText": "Test and name don't match -- we decided the button should be gone, right? So the test name should reflect that.", "author": "lognaturel", "createdAt": "2020-07-02T18:20:48Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,301 @@\n package org.odk.collect.android.widgets;\n \n+import android.content.ComponentName;\n import android.content.Intent;\n+import android.os.Bundle;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.TextView;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.LOCATION;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n \n-    @Mock\n-    QuestionDef questionDef;\n+    private final FakePermissionUtils permissionUtils = new FakePermissionUtils();\n+    private final List<double[]> answerDoubles = getRandomDoubleArrayList();\n+    private final String answer = stringFromDoubleList(answerDoubles);\n \n-    private double[] initialDoubles;\n-    private double[] answerDoubles;\n+    private QuestionDef questionDef;\n+    private MapConfigurator mapConfigurator;\n+    private WaitingForDataRegistry waitingForDataRegistry;\n \n-    @Override\n-    public GeoPointData getInitialAnswer() {\n-        return new GeoPointData(initialDoubles);\n+    @Before\n+    public void setup() {\n+        questionDef = mock(QuestionDef.class);\n+        mapConfigurator = mock(MapConfigurator.class);\n+        waitingForDataRegistry = mock(WaitingForDataRegistry.class);\n+        when(questionDef.getAdditionalAttribute(anyString(), anyString())).thenReturn(null);\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointWidget createWidget() {\n-        return new GeoPointWidget(activity, new QuestionDetails(formEntryPrompt, \"formAnalyticsID\"));\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {", "originalCommit": "943a88c769e6916b6eeceac334d535140c1d3726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg4MjkyNg==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449882926", "bodyText": "Right sorry! I will correct it.", "author": "SaumiaSinghal", "createdAt": "2020-07-05T14:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NjQ5OA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449196498", "bodyText": "A more accurate name might be buttonClickLaunchesIntentAndWaitsForLocationData.", "author": "lognaturel", "createdAt": "2020-07-02T18:25:34Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,301 @@\n package org.odk.collect.android.widgets;\n \n+import android.content.ComponentName;\n import android.content.Intent;\n+import android.os.Bundle;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.TextView;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.LOCATION;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n \n-    @Mock\n-    QuestionDef questionDef;\n+    private final FakePermissionUtils permissionUtils = new FakePermissionUtils();\n+    private final List<double[]> answerDoubles = getRandomDoubleArrayList();\n+    private final String answer = stringFromDoubleList(answerDoubles);\n \n-    private double[] initialDoubles;\n-    private double[] answerDoubles;\n+    private QuestionDef questionDef;\n+    private MapConfigurator mapConfigurator;\n+    private WaitingForDataRegistry waitingForDataRegistry;\n \n-    @Override\n-    public GeoPointData getInitialAnswer() {\n-        return new GeoPointData(initialDoubles);\n+    @Before\n+    public void setup() {\n+        questionDef = mock(QuestionDef.class);\n+        mapConfigurator = mock(MapConfigurator.class);\n+        waitingForDataRegistry = mock(WaitingForDataRegistry.class);\n+        when(questionDef.getAdditionalAttribute(anyString(), anyString())).thenReturn(null);\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointWidget createWidget() {\n-        return new GeoPointWidget(activity, new QuestionDetails(formEntryPrompt, \"formAnalyticsID\"));\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {\n+        GeoPointWidget widget = createWidget(promptWithReadOnly());\n+        assertThat(widget.startGeoButton.getVisibility(), equalTo(View.GONE));\n     }\n \n-    @Override\n-    public Object createBinaryData(GeoPointData answerData) {\n-        return stringFromDoubles(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveAnswer_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointData getNextAnswer() {\n-        return new GeoPointData(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveConvertibleString_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @Before\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        when(formEntryPrompt.getQuestion()).thenReturn(questionDef);\n+    @Test\n+    public void getAnswer_whenPromptHasAnswer_returnsAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.getAnswer().toString(), equalTo(answer));\n+    }\n \n-        initialDoubles = getRandomDoubleArray();\n-        answerDoubles = getRandomDoubleArray();\n+    @Test\n+    public void clearAnswer_clearsWidgetAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        widget.clearAnswer();\n+        assertThat(widget.getAnswer(), nullValue());\n     }\n \n-    @Override\n-    public void getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer() {\n-        when(formEntryPrompt.getAnswerText()).thenReturn(stringFromDoubles(initialDoubles));\n-        super.getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer();\n+    @Test\n+    public void clearAnswer_callsValueChangeListeners() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        WidgetValueChangedListener valueChangedListener = mockValueChangedListener(widget);\n+        widget.clearAnswer();\n+        verify(valueChangedListener).widgetValueChanged(widget);\n     }\n \n-    private double[] getRandomDoubleArray() {\n-        return new double[]{\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble()\n-        };\n+    @Test\n+    public void clickingButtonForLong_callsLongClickListener() {\n+        View.OnLongClickListener listener = mock(View.OnLongClickListener.class);\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        widget.setOnLongClickListener(listener);\n+        widget.startGeoButton.performLongClick();\n+\n+        verify(listener).onLongClick(widget.startGeoButton);\n+    }\n+\n+    @Test\n+    public void cancelLongPress_callsCancelLongPressForButtonAndTextView() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        widget.startGeoButton = mock(Button.class);\n+        widget.answerDisplay = mock(TextView.class);\n+        widget.cancelLongPress();\n+\n+        verify(widget.startGeoButton).cancelLongPress();\n+        verify(widget.answerDisplay).cancelLongPress();\n+    }\n+\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptAnswerDoesNotHaveConvertibleString_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_textViewDisplaysAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        String[] parts = answer.split(\" \");\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(widget.getContext().getString(\n+                R.string.gps_result,\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                GeoWidgetUtils.truncateDouble(parts[2]),\n+                GeoWidgetUtils.truncateDouble(parts[3])\n+        )));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndIsReadOnly_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(MAPS, true));\n+        assertThat(widget.startGeoButton.getText().toString(), equalTo(widget.getContext().getString(R.string.geopoint_view_read_only)));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndNullAsAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.view_change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasNullAsAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void whenPermissionIsNotGranted_buttonShouldNotLaunchAnyIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        stubLocationPermissions(widget, false);\n+        widget.startGeoButton.performClick();\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+\n+        assertNull(startedIntent);\n+    }\n+\n+    @Test\n+    public void whenPermissionIsGranted_buttonClickShouldSetTheLocationSavedOnTheMap() {", "originalCommit": "943a88c769e6916b6eeceac334d535140c1d3726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NzUwNA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449197504", "bodyText": "Would be good to also set a non-default accuracy threshhold in the form entry prompt and verify that goes through to the intent.", "author": "lognaturel", "createdAt": "2020-07-02T18:27:43Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,301 @@\n package org.odk.collect.android.widgets;\n \n+import android.content.ComponentName;\n import android.content.Intent;\n+import android.os.Bundle;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.TextView;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.LOCATION;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n \n-    @Mock\n-    QuestionDef questionDef;\n+    private final FakePermissionUtils permissionUtils = new FakePermissionUtils();\n+    private final List<double[]> answerDoubles = getRandomDoubleArrayList();\n+    private final String answer = stringFromDoubleList(answerDoubles);\n \n-    private double[] initialDoubles;\n-    private double[] answerDoubles;\n+    private QuestionDef questionDef;\n+    private MapConfigurator mapConfigurator;\n+    private WaitingForDataRegistry waitingForDataRegistry;\n \n-    @Override\n-    public GeoPointData getInitialAnswer() {\n-        return new GeoPointData(initialDoubles);\n+    @Before\n+    public void setup() {\n+        questionDef = mock(QuestionDef.class);\n+        mapConfigurator = mock(MapConfigurator.class);\n+        waitingForDataRegistry = mock(WaitingForDataRegistry.class);\n+        when(questionDef.getAdditionalAttribute(anyString(), anyString())).thenReturn(null);\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointWidget createWidget() {\n-        return new GeoPointWidget(activity, new QuestionDetails(formEntryPrompt, \"formAnalyticsID\"));\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {\n+        GeoPointWidget widget = createWidget(promptWithReadOnly());\n+        assertThat(widget.startGeoButton.getVisibility(), equalTo(View.GONE));\n     }\n \n-    @Override\n-    public Object createBinaryData(GeoPointData answerData) {\n-        return stringFromDoubles(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveAnswer_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointData getNextAnswer() {\n-        return new GeoPointData(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveConvertibleString_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @Before\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        when(formEntryPrompt.getQuestion()).thenReturn(questionDef);\n+    @Test\n+    public void getAnswer_whenPromptHasAnswer_returnsAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.getAnswer().toString(), equalTo(answer));\n+    }\n \n-        initialDoubles = getRandomDoubleArray();\n-        answerDoubles = getRandomDoubleArray();\n+    @Test\n+    public void clearAnswer_clearsWidgetAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        widget.clearAnswer();\n+        assertThat(widget.getAnswer(), nullValue());\n     }\n \n-    @Override\n-    public void getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer() {\n-        when(formEntryPrompt.getAnswerText()).thenReturn(stringFromDoubles(initialDoubles));\n-        super.getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer();\n+    @Test\n+    public void clearAnswer_callsValueChangeListeners() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        WidgetValueChangedListener valueChangedListener = mockValueChangedListener(widget);\n+        widget.clearAnswer();\n+        verify(valueChangedListener).widgetValueChanged(widget);\n     }\n \n-    private double[] getRandomDoubleArray() {\n-        return new double[]{\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble()\n-        };\n+    @Test\n+    public void clickingButtonForLong_callsLongClickListener() {\n+        View.OnLongClickListener listener = mock(View.OnLongClickListener.class);\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        widget.setOnLongClickListener(listener);\n+        widget.startGeoButton.performLongClick();\n+\n+        verify(listener).onLongClick(widget.startGeoButton);\n+    }\n+\n+    @Test\n+    public void cancelLongPress_callsCancelLongPressForButtonAndTextView() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        widget.startGeoButton = mock(Button.class);\n+        widget.answerDisplay = mock(TextView.class);\n+        widget.cancelLongPress();\n+\n+        verify(widget.startGeoButton).cancelLongPress();\n+        verify(widget.answerDisplay).cancelLongPress();\n+    }\n+\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptAnswerDoesNotHaveConvertibleString_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_textViewDisplaysAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        String[] parts = answer.split(\" \");\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(widget.getContext().getString(\n+                R.string.gps_result,\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                GeoWidgetUtils.truncateDouble(parts[2]),\n+                GeoWidgetUtils.truncateDouble(parts[3])\n+        )));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndIsReadOnly_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(MAPS, true));\n+        assertThat(widget.startGeoButton.getText().toString(), equalTo(widget.getContext().getString(R.string.geopoint_view_read_only)));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndNullAsAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.view_change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasNullAsAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void whenPermissionIsNotGranted_buttonShouldNotLaunchAnyIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        stubLocationPermissions(widget, false);\n+        widget.startGeoButton.performClick();\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+\n+        assertNull(startedIntent);\n+    }\n+\n+    @Test\n+    public void whenPermissionIsGranted_buttonClickShouldSetTheLocationSavedOnTheMap() {\n+        FormEntryPrompt prompt = promptWithAnswer(null);\n+        GeoPointWidget widget = createWidget(prompt);\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        verify(waitingForDataRegistry).waitForData(prompt.getIndex());\n+    }\n+\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_buttonShouldLaunchCorrectIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+        Bundle bundle = startedIntent.getExtras();\n+\n+        assertThat(startedIntent.getComponent(), equalTo(new ComponentName(widgetTestActivity(), GeoPointActivity.class)));\n+        assertBundleArgumentEquals(bundle, null, DEFAULT_LOCATION_ACCURACY, false, true);\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_buttonShouldLaunchCorrectIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+        Bundle bundle = startedIntent.getExtras();\n+\n+        assertThat(startedIntent.getComponent(), equalTo(new ComponentName(widgetTestActivity(), GeoPointActivity.class)));\n+        assertBundleArgumentEquals(bundle, GeoWidgetUtils.getLocationParamsFromStringAnswer(answer), DEFAULT_LOCATION_ACCURACY, false, true);", "originalCommit": "943a88c769e6916b6eeceac334d535140c1d3726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg4Mjc2Mg==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449882762", "bodyText": "Ohh totally forgot that!", "author": "SaumiaSinghal", "createdAt": "2020-07-05T14:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NzUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5OTYzNw==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449199637", "bodyText": "I think there's a test missing here for if there's a map and it's read-only.", "author": "lognaturel", "createdAt": "2020-07-02T18:32:14Z", "path": "collect_app/src/test/java/org/odk/collect/android/widgets/GeoPointWidgetTest.java", "diffHunk": "@@ -1,85 +1,301 @@\n package org.odk.collect.android.widgets;\n \n+import android.content.ComponentName;\n import android.content.Intent;\n+import android.os.Bundle;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.TextView;\n \n import org.javarosa.core.model.QuestionDef;\n-import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.StringData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.junit.runner.RunWith;\n import org.odk.collect.android.R;\n-import org.odk.collect.android.ShadowPlayServicesUtil;\n import org.odk.collect.android.activities.GeoPointActivity;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.fakes.FakePermissionUtils;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.widgets.base.BaseGeoWidgetTest;\n-import org.robolectric.annotation.Config;\n+import org.odk.collect.android.geo.MapConfigurator;\n+import org.odk.collect.android.listeners.WidgetValueChangedListener;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+import org.robolectric.RobolectricTestRunner;\n \n-import androidx.annotation.NonNull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.widgets.GeoPointWidget.ACCURACY_THRESHOLD;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DEFAULT_LOCATION_ACCURACY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.DRAGGABLE_ONLY;\n+import static org.odk.collect.android.widgets.GeoPointWidget.LOCATION;\n+import static org.odk.collect.android.widgets.GeoPointWidget.READ_ONLY;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.mockValueChangedListener;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearance;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithAppearanceAndAnswer;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.promptWithReadOnly;\n+import static org.odk.collect.android.widgets.support.QuestionWidgetHelpers.widgetTestActivity;\n+import static org.robolectric.Shadows.shadowOf;\n \n /**\n  * @author James Knight\n  */\n \n-@Config(shadows = {ShadowPlayServicesUtil.class})\n-public class GeoPointWidgetTest extends BaseGeoWidgetTest<GeoPointWidget, GeoPointData> {\n+@RunWith(RobolectricTestRunner.class)\n+public class GeoPointWidgetTest {\n \n-    @Mock\n-    QuestionDef questionDef;\n+    private final FakePermissionUtils permissionUtils = new FakePermissionUtils();\n+    private final List<double[]> answerDoubles = getRandomDoubleArrayList();\n+    private final String answer = stringFromDoubleList(answerDoubles);\n \n-    private double[] initialDoubles;\n-    private double[] answerDoubles;\n+    private QuestionDef questionDef;\n+    private MapConfigurator mapConfigurator;\n+    private WaitingForDataRegistry waitingForDataRegistry;\n \n-    @Override\n-    public GeoPointData getInitialAnswer() {\n-        return new GeoPointData(initialDoubles);\n+    @Before\n+    public void setup() {\n+        questionDef = mock(QuestionDef.class);\n+        mapConfigurator = mock(MapConfigurator.class);\n+        waitingForDataRegistry = mock(WaitingForDataRegistry.class);\n+        when(questionDef.getAdditionalAttribute(anyString(), anyString())).thenReturn(null);\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointWidget createWidget() {\n-        return new GeoPointWidget(activity, new QuestionDetails(formEntryPrompt, \"formAnalyticsID\"));\n+    @Test\n+    public void usingReadOnlyOption_makesAllClickableElementsDisabled() {\n+        GeoPointWidget widget = createWidget(promptWithReadOnly());\n+        assertThat(widget.startGeoButton.getVisibility(), equalTo(View.GONE));\n     }\n \n-    @Override\n-    public Object createBinaryData(GeoPointData answerData) {\n-        return stringFromDoubles(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveAnswer_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @NonNull\n-    @Override\n-    public GeoPointData getNextAnswer() {\n-        return new GeoPointData(answerDoubles);\n+    @Test\n+    public void getAnswer_whenPromptAnswerDoesNotHaveConvertibleString_returnsNull() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.getAnswer(), equalTo(null));\n     }\n \n-    @Before\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        when(formEntryPrompt.getQuestion()).thenReturn(questionDef);\n+    @Test\n+    public void getAnswer_whenPromptHasAnswer_returnsAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.getAnswer().toString(), equalTo(answer));\n+    }\n \n-        initialDoubles = getRandomDoubleArray();\n-        answerDoubles = getRandomDoubleArray();\n+    @Test\n+    public void clearAnswer_clearsWidgetAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        widget.clearAnswer();\n+        assertThat(widget.getAnswer(), nullValue());\n     }\n \n-    @Override\n-    public void getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer() {\n-        when(formEntryPrompt.getAnswerText()).thenReturn(stringFromDoubles(initialDoubles));\n-        super.getAnswerShouldReturnExistingAnswerIfPromptHasExistingAnswer();\n+    @Test\n+    public void clearAnswer_callsValueChangeListeners() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        WidgetValueChangedListener valueChangedListener = mockValueChangedListener(widget);\n+        widget.clearAnswer();\n+        verify(valueChangedListener).widgetValueChanged(widget);\n     }\n \n-    private double[] getRandomDoubleArray() {\n-        return new double[]{\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble(),\n-                random.nextDouble()\n-        };\n+    @Test\n+    public void clickingButtonForLong_callsLongClickListener() {\n+        View.OnLongClickListener listener = mock(View.OnLongClickListener.class);\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        widget.setOnLongClickListener(listener);\n+        widget.startGeoButton.performLongClick();\n+\n+        verify(listener).onLongClick(widget.startGeoButton);\n+    }\n+\n+    @Test\n+    public void cancelLongPress_callsCancelLongPressForButtonAndTextView() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        widget.startGeoButton = mock(Button.class);\n+        widget.answerDisplay = mock(TextView.class);\n+        widget.cancelLongPress();\n+\n+        verify(widget.startGeoButton).cancelLongPress();\n+        verify(widget.answerDisplay).cancelLongPress();\n+    }\n+\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptAnswerDoesNotHaveConvertibleString_textViewDisplaysEmptyString() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(\"blah\")));\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(\"\"));\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_textViewDisplaysAnswer() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        String[] parts = answer.split(\" \");\n+        assertThat(widget.answerDisplay.getText().toString(), equalTo(widget.getContext().getString(\n+                R.string.gps_result,\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(widget.getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                GeoWidgetUtils.truncateDouble(parts[2]),\n+                GeoWidgetUtils.truncateDouble(parts[3])\n+        )));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndIsReadOnly_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(MAPS, true));\n+        assertThat(widget.startGeoButton.getText().toString(), equalTo(widget.getContext().getString(R.string.geopoint_view_read_only)));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndNullAsAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMapsAndAnswer_buttonShowsCorrectText() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearanceAndAnswer(MAPS, new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.view_change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.change_location)));\n+    }\n+\n+    @Test\n+    public void whenWidgetHasNullAsAnswer_buttonShowsCorrectText() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        assertThat(widget.startGeoButton.getText(), equalTo(widget.getContext().getString(R.string.get_point)));\n+    }\n+\n+    @Test\n+    public void whenPermissionIsNotGranted_buttonShouldNotLaunchAnyIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        stubLocationPermissions(widget, false);\n+        widget.startGeoButton.performClick();\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+\n+        assertNull(startedIntent);\n+    }\n+\n+    @Test\n+    public void whenPermissionIsGranted_buttonClickShouldSetTheLocationSavedOnTheMap() {\n+        FormEntryPrompt prompt = promptWithAnswer(null);\n+        GeoPointWidget widget = createWidget(prompt);\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        verify(waitingForDataRegistry).waitForData(prompt.getIndex());\n+    }\n+\n+    @Test\n+    public void whenPromptDoesNotHaveAnswer_buttonShouldLaunchCorrectIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(null));\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+        Bundle bundle = startedIntent.getExtras();\n+\n+        assertThat(startedIntent.getComponent(), equalTo(new ComponentName(widgetTestActivity(), GeoPointActivity.class)));\n+        assertBundleArgumentEquals(bundle, null, DEFAULT_LOCATION_ACCURACY, false, true);\n+    }\n+\n+    @Test\n+    public void whenPromptHasAnswer_buttonShouldLaunchCorrectIntent() {\n+        GeoPointWidget widget = createWidget(promptWithAnswer(new StringData(answer)));\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+        Bundle bundle = startedIntent.getExtras();\n+\n+        assertThat(startedIntent.getComponent(), equalTo(new ComponentName(widgetTestActivity(), GeoPointActivity.class)));\n+        assertBundleArgumentEquals(bundle, GeoWidgetUtils.getLocationParamsFromStringAnswer(answer), DEFAULT_LOCATION_ACCURACY, false, true);\n+    }\n+\n+    @Test\n+    public void ifWidgetHasPlacementMaps_buttonShouldLaunchCorrectIntent() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(PLACEMENT_MAP, false));\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+        Bundle bundle = startedIntent.getExtras();\n+\n+        assertThat(startedIntent.getComponent(), equalTo(new ComponentName(widgetTestActivity(), GeoPointMapActivity.class)));\n+        assertBundleArgumentEquals(bundle, null, DEFAULT_LOCATION_ACCURACY, false, true);\n+    }\n+\n+    @Test\n+    public void ifWidgetHasMaps_buttonShouldLaunchCorrectIntent() {\n+        when(mapConfigurator.isAvailable(any())).thenReturn(true);\n+        GeoPointWidget widget = createWidget(promptWithAppearance(MAPS, false));\n+        stubLocationPermissions(widget, true);\n+        widget.startGeoButton.performClick();\n+\n+        Intent startedIntent = shadowOf(widgetTestActivity()).getNextStartedActivity();\n+        Bundle bundle = startedIntent.getExtras();\n+\n+        assertThat(startedIntent.getComponent(), equalTo(new ComponentName(widgetTestActivity(), GeoPointMapActivity.class)));\n+        assertBundleArgumentEquals(bundle, null, DEFAULT_LOCATION_ACCURACY, false, false);\n+    }\n+", "originalCommit": "943a88c769e6916b6eeceac334d535140c1d3726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg4NDU2Mg==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r449884562", "bodyText": "Sorry @lognaturel I'm not understanding how I would confirm here if the map is read only.", "author": "SaumiaSinghal", "createdAt": "2020-07-05T14:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5OTYzNw=="}], "type": "inlineReview"}, {"oid": "66aea3d2a9b94e6c67d769675f2c8e637457a394", "url": "https://github.com/getodk/collect/commit/66aea3d2a9b94e6c67d769675f2c8e637457a394", "message": "fix getAnswer_whenPromptHasAnswer unit test", "committedDate": "2020-07-05T16:38:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5MzYyMQ==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r451893621", "bodyText": "There's no map so the name isn't right. I think that here the code can either go directly in the constructor or be renamed to something like getAccuracyThreshold. If it's the later, then I think the method should return a double.", "author": "lognaturel", "createdAt": "2020-07-09T00:16:08Z", "path": "collect_app/src/main/java/org/odk/collect/android/widgets/GeoPointWidget.java", "diffHunk": "@@ -18,152 +18,183 @@\n import android.app.Activity;\n import android.content.Context;\n import android.content.Intent;\n+import android.util.TypedValue;\n+import android.view.View;\n \n+import org.javarosa.core.model.QuestionDef;\n import org.javarosa.core.model.data.GeoPointData;\n import org.javarosa.core.model.data.IAnswerData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.odk.collect.android.R;\n import org.odk.collect.android.activities.GeoPointActivity;\n-import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.databinding.GeoWidgetAnswerBinding;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.geo.MapProvider;\n+import org.odk.collect.android.listeners.PermissionListener;\n+import org.odk.collect.android.utilities.MultiClickGuard;\n+import org.odk.collect.android.widgets.interfaces.BinaryDataReceiver;\n import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n \n import static org.odk.collect.android.utilities.ApplicationConstants.RequestCodes;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.hasAppearance;\n \n-/**\n- * GeoPointWidget is the widget that allows the user to get GPS readings.\n- *\n- * @author Carl Hartung (carlhartung@gmail.com)\n- * @author Yaw Anokwa (yanokwa@gmail.com)\n- * @author Jon Nordling (jonnordling@gmail.com)\n- */\n @SuppressLint(\"ViewConstructor\")\n-public class GeoPointWidget extends BaseGeoWidget {\n+public class GeoPointWidget extends QuestionWidget implements BinaryDataReceiver {\n     public static final String LOCATION = \"gp\";\n     public static final String ACCURACY_THRESHOLD = \"accuracyThreshold\";\n     public static final String READ_ONLY = \"readOnly\";\n     public static final String DRAGGABLE_ONLY = \"draggable\";\n-\n     public static final double DEFAULT_LOCATION_ACCURACY = 5.0;\n-    private boolean useMap;\n+\n+    private final WaitingForDataRegistry waitingForDataRegistry;\n+\n+    private GeoWidgetAnswerBinding binding;\n+\n+    private boolean readOnly;\n     private double accuracyThreshold;\n-    private boolean draggable = true;\n     private String stringAnswer;\n \n-    public GeoPointWidget(Context context, QuestionDetails questionDetails) {\n+    public GeoPointWidget(Context context, QuestionDetails questionDetails, QuestionDef questionDef, WaitingForDataRegistry waitingForDataRegistry) {\n         super(context, questionDetails);\n-        determineMapProperties();\n-    }\n-\n-    private void determineMapProperties() {\n-        // Determine the accuracy threshold to use.\n-        String acc = getFormEntryPrompt().getQuestion().getAdditionalAttribute(null, ACCURACY_THRESHOLD);\n-        accuracyThreshold = acc != null && !acc.isEmpty() ? Double.parseDouble(acc) : DEFAULT_LOCATION_ACCURACY;\n+        this.waitingForDataRegistry = waitingForDataRegistry;\n+        determineMapProperties(questionDef);\n \n-        // Determine whether to use the map and whether the point should be draggable.\n-        if (MapProvider.getConfigurator().isAvailable(getContext())) {\n-            if (hasAppearance(getFormEntryPrompt(), PLACEMENT_MAP)) {\n-                draggable = true;\n-                useMap = true;\n-            } else if (hasAppearance(getFormEntryPrompt(), MAPS)) {\n-                draggable = false;\n-                useMap = true;\n-            }\n+        stringAnswer = getFormEntryPrompt().getAnswerText();\n+        boolean dataAvailable = false;\n+        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n+            dataAvailable = true;\n+            setBinaryData(stringAnswer);\n         }\n+        updateButtonLabelsAndVisibility(dataAvailable);\n     }\n \n-    public void updateButtonLabelsAndVisibility(boolean dataAvailable) {\n-        if (useMap) {\n-            if (readOnly) {\n-                startGeoButton.setText(R.string.geopoint_view_read_only);\n-            } else {\n-                startGeoButton.setText(\n-                    dataAvailable ? R.string.view_change_location : R.string.get_point);\n-            }\n+    @Override\n+    protected View onCreateAnswerView(Context context, FormEntryPrompt prompt, int answerFontSize) {\n+        binding = GeoWidgetAnswerBinding.inflate(((Activity) context).getLayoutInflater());\n+        View answerView = binding.getRoot();\n+\n+        binding.geoAnswerText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+        readOnly = prompt.isReadOnly();\n+        if (readOnly) {\n+            binding.simpleButton.setVisibility(GONE);\n         } else {\n-            if (!readOnly) {\n-                startGeoButton.setText(\n-                    dataAvailable ? R.string.change_location : R.string.get_point);\n-            }\n+            binding.simpleButton.setText(getDefaultButtonLabel());\n+            binding.simpleButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+            binding.simpleButton.setOnClickListener(v -> onButtonClick());\n         }\n+        return answerView;\n     }\n \n     @Override\n     public IAnswerData getAnswer() {\n         if (stringAnswer == null || stringAnswer.isEmpty()) {\n             return null;\n         } else {\n-            try {\n-                return new GeoPointData(GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n-            } catch (Exception numberFormatException) {\n-                return null;\n-            }\n+            return new GeoPointData(GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n         }\n     }\n \n     @Override\n     public void clearAnswer() {\n         stringAnswer = null;\n-        super.clearAnswer();\n+        binding.geoAnswerText.setText(null);\n+        updateButtonLabelsAndVisibility(false);\n+        widgetValueChanged();\n+    }\n+\n+    @Override\n+    public void setOnLongClickListener(OnLongClickListener l) {\n+        binding.simpleButton.setOnLongClickListener(l);\n+        binding.geoAnswerText.setOnLongClickListener(l);\n+    }\n+\n+    @Override\n+    public void cancelLongPress() {\n+        super.cancelLongPress();\n+        binding.simpleButton.cancelLongPress();\n+        binding.geoAnswerText.cancelLongPress();\n     }\n \n     @Override\n     public void setBinaryData(Object answer) {\n         stringAnswer = (String) answer;\n+        binding.geoAnswerText.setText(getAnswerToDisplay(stringAnswer));\n \n-        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n-            String[] parts = stringAnswer.split(\" \");\n-            answerDisplay.setText(getContext().getString(\n-                R.string.gps_result,\n-                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n-                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n-                    GeoWidgetUtils.truncateDouble(parts[2]),\n-                    GeoWidgetUtils.truncateDouble(parts[3])\n-            ));\n-        } else {\n-            answerDisplay.setText(\"\");\n+        if (binding.geoAnswerText.getText().toString().equals(\"\")) {\n+            stringAnswer = \"\";\n         }\n \n-        updateButtonLabelsAndVisibility(true);\n+        updateButtonLabelsAndVisibility(stringAnswer != null);\n         widgetValueChanged();\n     }\n \n-    @Override\n-    public String getAnswerToDisplay(String answer) {\n-        if (!answer.isEmpty()) {\n-            String[] parts = answer.split(\" \");\n-            return getContext().getString(\n-                    R.string.gps_result,\n-                    GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n-                    GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n-                    GeoWidgetUtils.truncateDouble(parts[2]),\n-                    GeoWidgetUtils.truncateDouble(parts[3])\n-            );\n-        } else {\n+    protected GeoWidgetAnswerBinding getBinding() {\n+        return binding;\n+    }\n+\n+    private void determineMapProperties(QuestionDef questionDef) {", "originalCommit": "8e532a66298d3af58344858c13b73ab0e787f7ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5Mzc4NA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r451893784", "bodyText": "I think this can just be removed.", "author": "lognaturel", "createdAt": "2020-07-09T00:16:40Z", "path": "collect_app/src/main/java/org/odk/collect/android/widgets/GeoPointWidget.java", "diffHunk": "@@ -18,152 +18,183 @@\n import android.app.Activity;\n import android.content.Context;\n import android.content.Intent;\n+import android.util.TypedValue;\n+import android.view.View;\n \n+import org.javarosa.core.model.QuestionDef;\n import org.javarosa.core.model.data.GeoPointData;\n import org.javarosa.core.model.data.IAnswerData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.odk.collect.android.R;\n import org.odk.collect.android.activities.GeoPointActivity;\n-import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.databinding.GeoWidgetAnswerBinding;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.geo.MapProvider;\n+import org.odk.collect.android.listeners.PermissionListener;\n+import org.odk.collect.android.utilities.MultiClickGuard;\n+import org.odk.collect.android.widgets.interfaces.BinaryDataReceiver;\n import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n \n import static org.odk.collect.android.utilities.ApplicationConstants.RequestCodes;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.hasAppearance;\n \n-/**\n- * GeoPointWidget is the widget that allows the user to get GPS readings.\n- *\n- * @author Carl Hartung (carlhartung@gmail.com)\n- * @author Yaw Anokwa (yanokwa@gmail.com)\n- * @author Jon Nordling (jonnordling@gmail.com)\n- */\n @SuppressLint(\"ViewConstructor\")\n-public class GeoPointWidget extends BaseGeoWidget {\n+public class GeoPointWidget extends QuestionWidget implements BinaryDataReceiver {\n     public static final String LOCATION = \"gp\";\n     public static final String ACCURACY_THRESHOLD = \"accuracyThreshold\";\n     public static final String READ_ONLY = \"readOnly\";\n     public static final String DRAGGABLE_ONLY = \"draggable\";\n-\n     public static final double DEFAULT_LOCATION_ACCURACY = 5.0;\n-    private boolean useMap;\n+\n+    private final WaitingForDataRegistry waitingForDataRegistry;\n+\n+    private GeoWidgetAnswerBinding binding;\n+\n+    private boolean readOnly;\n     private double accuracyThreshold;\n-    private boolean draggable = true;\n     private String stringAnswer;\n \n-    public GeoPointWidget(Context context, QuestionDetails questionDetails) {\n+    public GeoPointWidget(Context context, QuestionDetails questionDetails, QuestionDef questionDef, WaitingForDataRegistry waitingForDataRegistry) {\n         super(context, questionDetails);\n-        determineMapProperties();\n-    }\n-\n-    private void determineMapProperties() {\n-        // Determine the accuracy threshold to use.\n-        String acc = getFormEntryPrompt().getQuestion().getAdditionalAttribute(null, ACCURACY_THRESHOLD);\n-        accuracyThreshold = acc != null && !acc.isEmpty() ? Double.parseDouble(acc) : DEFAULT_LOCATION_ACCURACY;\n+        this.waitingForDataRegistry = waitingForDataRegistry;\n+        determineMapProperties(questionDef);\n \n-        // Determine whether to use the map and whether the point should be draggable.\n-        if (MapProvider.getConfigurator().isAvailable(getContext())) {\n-            if (hasAppearance(getFormEntryPrompt(), PLACEMENT_MAP)) {\n-                draggable = true;\n-                useMap = true;\n-            } else if (hasAppearance(getFormEntryPrompt(), MAPS)) {\n-                draggable = false;\n-                useMap = true;\n-            }\n+        stringAnswer = getFormEntryPrompt().getAnswerText();\n+        boolean dataAvailable = false;\n+        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n+            dataAvailable = true;\n+            setBinaryData(stringAnswer);\n         }\n+        updateButtonLabelsAndVisibility(dataAvailable);\n     }\n \n-    public void updateButtonLabelsAndVisibility(boolean dataAvailable) {\n-        if (useMap) {\n-            if (readOnly) {\n-                startGeoButton.setText(R.string.geopoint_view_read_only);\n-            } else {\n-                startGeoButton.setText(\n-                    dataAvailable ? R.string.view_change_location : R.string.get_point);\n-            }\n+    @Override\n+    protected View onCreateAnswerView(Context context, FormEntryPrompt prompt, int answerFontSize) {\n+        binding = GeoWidgetAnswerBinding.inflate(((Activity) context).getLayoutInflater());\n+        View answerView = binding.getRoot();\n+\n+        binding.geoAnswerText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+        readOnly = prompt.isReadOnly();\n+        if (readOnly) {\n+            binding.simpleButton.setVisibility(GONE);\n         } else {\n-            if (!readOnly) {\n-                startGeoButton.setText(\n-                    dataAvailable ? R.string.change_location : R.string.get_point);\n-            }\n+            binding.simpleButton.setText(getDefaultButtonLabel());\n+            binding.simpleButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+            binding.simpleButton.setOnClickListener(v -> onButtonClick());\n         }\n+        return answerView;\n     }\n \n     @Override\n     public IAnswerData getAnswer() {\n         if (stringAnswer == null || stringAnswer.isEmpty()) {\n             return null;\n         } else {\n-            try {\n-                return new GeoPointData(GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n-            } catch (Exception numberFormatException) {\n-                return null;\n-            }\n+            return new GeoPointData(GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n         }\n     }\n \n     @Override\n     public void clearAnswer() {\n         stringAnswer = null;\n-        super.clearAnswer();\n+        binding.geoAnswerText.setText(null);\n+        updateButtonLabelsAndVisibility(false);\n+        widgetValueChanged();\n+    }\n+\n+    @Override\n+    public void setOnLongClickListener(OnLongClickListener l) {\n+        binding.simpleButton.setOnLongClickListener(l);\n+        binding.geoAnswerText.setOnLongClickListener(l);\n+    }\n+\n+    @Override\n+    public void cancelLongPress() {\n+        super.cancelLongPress();\n+        binding.simpleButton.cancelLongPress();\n+        binding.geoAnswerText.cancelLongPress();\n     }\n \n     @Override\n     public void setBinaryData(Object answer) {\n         stringAnswer = (String) answer;\n+        binding.geoAnswerText.setText(getAnswerToDisplay(stringAnswer));\n \n-        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n-            String[] parts = stringAnswer.split(\" \");\n-            answerDisplay.setText(getContext().getString(\n-                R.string.gps_result,\n-                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n-                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n-                    GeoWidgetUtils.truncateDouble(parts[2]),\n-                    GeoWidgetUtils.truncateDouble(parts[3])\n-            ));\n-        } else {\n-            answerDisplay.setText(\"\");\n+        if (binding.geoAnswerText.getText().toString().equals(\"\")) {\n+            stringAnswer = \"\";\n         }\n \n-        updateButtonLabelsAndVisibility(true);\n+        updateButtonLabelsAndVisibility(stringAnswer != null);\n         widgetValueChanged();\n     }\n \n-    @Override\n-    public String getAnswerToDisplay(String answer) {\n-        if (!answer.isEmpty()) {\n-            String[] parts = answer.split(\" \");\n-            return getContext().getString(\n-                    R.string.gps_result,\n-                    GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n-                    GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n-                    GeoWidgetUtils.truncateDouble(parts[2]),\n-                    GeoWidgetUtils.truncateDouble(parts[3])\n-            );\n-        } else {\n+    protected GeoWidgetAnswerBinding getBinding() {\n+        return binding;\n+    }\n+\n+    private void determineMapProperties(QuestionDef questionDef) {\n+        // Determine the accuracy threshold to use.\n+        String acc = questionDef.getAdditionalAttribute(null, ACCURACY_THRESHOLD);\n+        accuracyThreshold = acc != null && !acc.isEmpty() ? Double.parseDouble(acc) : DEFAULT_LOCATION_ACCURACY;\n+    }\n+\n+    private String getAnswerToDisplay(String answer) {\n+        try {\n+            if (answer != null && !answer.isEmpty()) {\n+                String[] parts = answer.split(\" \");\n+                return getContext().getString(\n+                        R.string.gps_result,\n+                        GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                        GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                        GeoWidgetUtils.truncateDouble(parts[2]),\n+                        GeoWidgetUtils.truncateDouble(parts[3])\n+                );\n+            }\n+        } catch (NumberFormatException e) {\n             return \"\";\n         }\n+        return \"\";\n     }\n \n-    @Override\n-    public String getDefaultButtonLabel() {\n-        return getContext().getString(R.string.get_location);\n+    private void updateButtonLabelsAndVisibility(boolean dataAvailable) {\n+        if (!readOnly) {\n+            binding.simpleButton.setText(\n+                    dataAvailable ? R.string.change_location : R.string.get_point);\n+        }\n     }\n \n-    public void startGeoActivity() {\n+    private void onButtonClick() {\n+        if (MultiClickGuard.allowClick(QuestionWidget.class.getName())) {\n+            getPermissionUtils().requestLocationPermissions((Activity) getContext(), new PermissionListener() {\n+                @Override\n+                public void granted() {\n+                    waitingForDataRegistry.waitForData(getFormEntryPrompt().getIndex());\n+                    startGeoActivity();\n+                }\n+\n+                @Override\n+                public void denied() {\n+                }\n+            });\n+        }\n+    }\n+\n+    private void startGeoActivity() {\n         Context context = getContext();\n-        Intent intent = new Intent(\n-            context, useMap ? GeoPointMapActivity.class : GeoPointActivity.class);\n+        Intent intent = new Intent(context, GeoPointActivity.class);\n \n         if (stringAnswer != null && !stringAnswer.isEmpty()) {\n             intent.putExtra(LOCATION, GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n         }\n         intent.putExtra(READ_ONLY, readOnly);\n-        intent.putExtra(DRAGGABLE_ONLY, draggable);\n+        intent.putExtra(DRAGGABLE_ONLY, false);", "originalCommit": "8e532a66298d3af58344858c13b73ab0e787f7ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5NjkzMw==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r451896933", "bodyText": "I think this changes the behavior that was there before. Before your changes I see:\nif (useMap) {\n            if (readOnly) {\n                startGeoButton.setText(R.string.geopoint_view_read_only);\n\nwhich implies that if the question is read-only, the map should open and show the point but not allow it to be changed. Can you verify what the prior behavior was with a readonly geopoint with map and a default value, make sure it's still the same, and that there's a test for it?\nThis is the case I was referring to at https://github.com/getodk/collect/pull/3877/files#r449199637.", "author": "lognaturel", "createdAt": "2020-07-09T00:28:14Z", "path": "collect_app/src/main/java/org/odk/collect/android/widgets/GeoPointMapWidget.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright (C) 2009 University of Washington\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.odk.collect.android.widgets;\n+\n+import android.annotation.SuppressLint;\n+import android.app.Activity;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.util.TypedValue;\n+import android.view.View;\n+\n+import org.javarosa.core.model.QuestionDef;\n+import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.IAnswerData;\n+import org.javarosa.form.api.FormEntryPrompt;\n+import org.odk.collect.android.R;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.databinding.GeoWidgetAnswerBinding;\n+import org.odk.collect.android.formentry.questions.QuestionDetails;\n+import org.odk.collect.android.listeners.PermissionListener;\n+import org.odk.collect.android.utilities.MultiClickGuard;\n+import org.odk.collect.android.widgets.interfaces.BinaryDataReceiver;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+\n+import static org.odk.collect.android.utilities.ApplicationConstants.RequestCodes;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.hasAppearance;\n+\n+@SuppressLint(\"ViewConstructor\")\n+public class GeoPointMapWidget extends QuestionWidget implements BinaryDataReceiver {\n+    public static final String LOCATION = \"gp\";\n+    public static final String ACCURACY_THRESHOLD = \"accuracyThreshold\";\n+    public static final String READ_ONLY = \"readOnly\";\n+    public static final String DRAGGABLE_ONLY = \"draggable\";\n+    public static final double DEFAULT_LOCATION_ACCURACY = 5.0;\n+\n+    private final WaitingForDataRegistry waitingForDataRegistry;\n+\n+    private GeoWidgetAnswerBinding binding;\n+\n+    private boolean readOnly;\n+    private boolean draggable = true;\n+    private double accuracyThreshold;\n+    private String stringAnswer;\n+\n+    public GeoPointMapWidget(Context context, QuestionDetails questionDetails,\n+                             QuestionDef questionDef, WaitingForDataRegistry waitingForDataRegistry) {\n+        super(context, questionDetails);\n+        this.waitingForDataRegistry = waitingForDataRegistry;\n+        determineMapProperties(questionDef);\n+\n+        stringAnswer = getFormEntryPrompt().getAnswerText();\n+        boolean dataAvailable = false;\n+        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n+            dataAvailable = true;\n+            setBinaryData(stringAnswer);\n+        }\n+        updateButtonLabelsAndVisibility(dataAvailable);\n+    }\n+\n+    @Override\n+    protected View onCreateAnswerView(Context context, FormEntryPrompt prompt, int answerFontSize) {\n+        binding = GeoWidgetAnswerBinding.inflate(((Activity) context).getLayoutInflater());\n+        View answerView = binding.getRoot();\n+\n+        binding.geoAnswerText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+        readOnly = prompt.isReadOnly();\n+        if (readOnly) {\n+            binding.simpleButton.setVisibility(GONE);", "originalCommit": "8e532a66298d3af58344858c13b73ab0e787f7ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5242dd37f3138b47c085a28c0e9121e340955392", "url": "https://github.com/getodk/collect/commit/5242dd37f3138b47c085a28c0e9121e340955392", "message": "shifted UI of base geo widget to xml file", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "875a42cb1b8ef93c2b358b2a9ee96066c822993d", "url": "https://github.com/getodk/collect/commit/875a42cb1b8ef93c2b358b2a9ee96066c822993d", "message": "updated code to fix unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "4e978ce326d8a217680927910a88521bbe7292a8", "url": "https://github.com/getodk/collect/commit/4e978ce326d8a217680927910a88521bbe7292a8", "message": "added first unit test", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "d5707aea3b97a8a5cce6800ebc22d0186ba5cdbf", "url": "https://github.com/getodk/collect/commit/d5707aea3b97a8a5cce6800ebc22d0186ba5cdbf", "message": "refcator code", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "16e7346831693778ed3e818846dde865a3e6abb8", "url": "https://github.com/getodk/collect/commit/16e7346831693778ed3e818846dde865a3e6abb8", "message": "add unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "7d95616432fe5a849451880610f1b4e12e2407d5", "url": "https://github.com/getodk/collect/commit/7d95616432fe5a849451880610f1b4e12e2407d5", "message": "add unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "dd5a679ed02005fe771b9e4f9e4b15fce39ce1da", "url": "https://github.com/getodk/collect/commit/dd5a679ed02005fe771b9e4f9e4b15fce39ce1da", "message": "resolve merge conflict in WidgetFactory", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "b09540129586e2e3f62cd0f182a21f904c1c38f2", "url": "https://github.com/getodk/collect/commit/b09540129586e2e3f62cd0f182a21f904c1c38f2", "message": "add unit tests and code refactor", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "4ae5701898bfaf150324f1d36e99a70091dcd3d0", "url": "https://github.com/getodk/collect/commit/4ae5701898bfaf150324f1d36e99a70091dcd3d0", "message": "revert accidental change in build.gradle", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "e4bb806c37243c46898e52eba90bc0a32130fcab", "url": "https://github.com/getodk/collect/commit/e4bb806c37243c46898e52eba90bc0a32130fcab", "message": "fix pmd", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "92d2cbba25f116a050d77a421d102979904e4c77", "url": "https://github.com/getodk/collect/commit/92d2cbba25f116a050d77a421d102979904e4c77", "message": "fix buttonsShouldShowCorrectText() unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "976bfba511eed29fd8201f879a156217dabb81bf", "url": "https://github.com/getodk/collect/commit/976bfba511eed29fd8201f879a156217dabb81bf", "message": "fix buttonShouldLaunchCorrectIntents() unit test", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "9cacf0d7f6d3708b72d70992c09a343b62a6408f", "url": "https://github.com/getodk/collect/commit/9cacf0d7f6d3708b72d70992c09a343b62a6408f", "message": "update buttonShouldLaunchCorrectIntents()", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "7702959e4987ef2b47b4e2ca3de463bbd80245ea", "url": "https://github.com/getodk/collect/commit/7702959e4987ef2b47b4e2ca3de463bbd80245ea", "message": "fix red unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "379bf43c489994f0f1d6269e03d83264e3452731", "url": "https://github.com/getodk/collect/commit/379bf43c489994f0f1d6269e03d83264e3452731", "message": "remove view bindings in unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "7e64f443d61e74d99989b64ccab34597695b2da0", "url": "https://github.com/getodk/collect/commit/7e64f443d61e74d99989b64ccab34597695b2da0", "message": "replace readOnly by getFormEntryPrompt().isReadOnly() to avoid NPE", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "3c6b16780847f0ac009e8092bcf2c9ed5aa0de60", "url": "https://github.com/getodk/collect/commit/3c6b16780847f0ac009e8092bcf2c9ed5aa0de60", "message": "change button id to avoid NPE", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "5aa3b4648d504c7ef54021ad59141750d9fd3c87", "url": "https://github.com/getodk/collect/commit/5aa3b4648d504c7ef54021ad59141750d9fd3c87", "message": "make QuestionWidget as base class instead of BaseGeoWidget for GeoPointWidget", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "c66e31d45ea354b6aca54cfe1cf3aea2ae2277eb", "url": "https://github.com/getodk/collect/commit/c66e31d45ea354b6aca54cfe1cf3aea2ae2277eb", "message": "resolve conflict in UrlWidget", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "284d159c28776f4e0d73df7cdaadd87c2b342739", "url": "https://github.com/getodk/collect/commit/284d159c28776f4e0d73df7cdaadd87c2b342739", "message": "Remove waitForData from widget interface", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "904f18b537bbbb48f83cca8e8614c363449a0f09", "url": "https://github.com/getodk/collect/commit/904f18b537bbbb48f83cca8e8614c363449a0f09", "message": "Extract waiting for data component from QuestionWidget", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "82f2d5c2c16fd4f93cab3ae60618df80726a5649", "url": "https://github.com/getodk/collect/commit/82f2d5c2c16fd4f93cab3ae60618df80726a5649", "message": "Detach BinaryWidget interface from Widget hierarchy", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "6e74cd86824ede106dc7826dc2cc035264660365", "url": "https://github.com/getodk/collect/commit/6e74cd86824ede106dc7826dc2cc035264660365", "message": "add unit tests and refactor", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "fc0f00568919902079f03d4bb87fc8dda06fef4d", "url": "https://github.com/getodk/collect/commit/fc0f00568919902079f03d4bb87fc8dda06fef4d", "message": "add unit tests and implement BinaryDataReceiver", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "fe33e2ce19ed48b796ed5db6363a14de55c99774", "url": "https://github.com/getodk/collect/commit/fe33e2ce19ed48b796ed5db6363a14de55c99774", "message": "update xml file", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "25255081254e0e76c18b2df00463ed271e0d5d7a", "url": "https://github.com/getodk/collect/commit/25255081254e0e76c18b2df00463ed271e0d5d7a", "message": "use view binding in GeoPointWidget", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "f77533666a2681065127b35ac384a517aba746a6", "url": "https://github.com/getodk/collect/commit/f77533666a2681065127b35ac384a517aba746a6", "message": "remove null check in MediaLoadingTask", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "5faa224f4658dd2568330b1f869de4107509e829", "url": "https://github.com/getodk/collect/commit/5faa224f4658dd2568330b1f869de4107509e829", "message": "refactor unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "dcfae600290cc1aaebd54061b9569b98eeda2cee", "url": "https://github.com/getodk/collect/commit/dcfae600290cc1aaebd54061b9569b98eeda2cee", "message": "added check for non default accuracy threshold value in unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "729af00d1739b9fef0d530101c9d525dd4658b6b", "url": "https://github.com/getodk/collect/commit/729af00d1739b9fef0d530101c9d525dd4658b6b", "message": "remove unuse import", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "c0379279d38f7e729e3a54ef870e89993688d3e4", "url": "https://github.com/getodk/collect/commit/c0379279d38f7e729e3a54ef870e89993688d3e4", "message": "fix getAnswer_whenPromptHasAnswer unit test", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "cada8798f827d561029fbfbe64345cbba7a704c4", "url": "https://github.com/getodk/collect/commit/cada8798f827d561029fbfbe64345cbba7a704c4", "message": "fix pmd", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "12f42dfef1f0a1c7a67167bcf4e300b8692c1ef7", "url": "https://github.com/getodk/collect/commit/12f42dfef1f0a1c7a67167bcf4e300b8692c1ef7", "message": "create GeoPointMapWidget class", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "c69111aefed3d6670290e6f502b3d15f0cd22d76", "url": "https://github.com/getodk/collect/commit/c69111aefed3d6670290e6f502b3d15f0cd22d76", "message": "add check for maps appearance in WidgetFactory", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "99063ea02eeb3548d81b30162d3f775bc2e57b7e", "url": "https://github.com/getodk/collect/commit/99063ea02eeb3548d81b30162d3f775bc2e57b7e", "message": "update unit tests", "committedDate": "2020-07-09T16:10:26Z", "type": "commit"}, {"oid": "d2f4e3acfdda50fc06b40a947199939a87343a0f", "url": "https://github.com/getodk/collect/commit/d2f4e3acfdda50fc06b40a947199939a87343a0f", "message": "fix failing unit test", "committedDate": "2020-07-09T16:45:36Z", "type": "commit"}, {"oid": "c195dc02242a0959aa4ec0b742f4399ddb43c57a", "url": "https://github.com/getodk/collect/commit/c195dc02242a0959aa4ec0b742f4399ddb43c57a", "message": "code refactor", "committedDate": "2020-07-09T17:18:46Z", "type": "commit"}, {"oid": "c195dc02242a0959aa4ec0b742f4399ddb43c57a", "url": "https://github.com/getodk/collect/commit/c195dc02242a0959aa4ec0b742f4399ddb43c57a", "message": "code refactor", "committedDate": "2020-07-09T17:18:46Z", "type": "forcePushed"}, {"oid": "27a77161c45d0a3310e99a8d3acff83625d0c8ab", "url": "https://github.com/getodk/collect/commit/27a77161c45d0a3310e99a8d3acff83625d0c8ab", "message": "fix pmd", "committedDate": "2020-07-09T18:11:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMjEzOQ==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r453122139", "bodyText": "Note here that the GeoPointMapActivity accepts an intent extra to represent whether the map should be readonly. So it's very clear that the intended behavior was to show a readonly map.", "author": "lognaturel", "createdAt": "2020-07-10T23:38:36Z", "path": "collect_app/src/main/java/org/odk/collect/android/widgets/GeoPointMapWidget.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright (C) 2009 University of Washington\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.odk.collect.android.widgets;\n+\n+import android.annotation.SuppressLint;\n+import android.app.Activity;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.util.TypedValue;\n+import android.view.View;\n+\n+import org.javarosa.core.model.QuestionDef;\n+import org.javarosa.core.model.data.GeoPointData;\n+import org.javarosa.core.model.data.IAnswerData;\n+import org.javarosa.form.api.FormEntryPrompt;\n+import org.odk.collect.android.R;\n+import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.databinding.GeoWidgetAnswerBinding;\n+import org.odk.collect.android.formentry.questions.QuestionDetails;\n+import org.odk.collect.android.listeners.PermissionListener;\n+import org.odk.collect.android.utilities.MultiClickGuard;\n+import org.odk.collect.android.widgets.interfaces.BinaryDataReceiver;\n+import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n+\n+import static org.odk.collect.android.utilities.ApplicationConstants.RequestCodes;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n+import static org.odk.collect.android.utilities.WidgetAppearanceUtils.hasAppearance;\n+\n+@SuppressLint(\"ViewConstructor\")\n+public class GeoPointMapWidget extends QuestionWidget implements BinaryDataReceiver {\n+    public static final String LOCATION = \"gp\";\n+    public static final String ACCURACY_THRESHOLD = \"accuracyThreshold\";\n+    public static final String READ_ONLY = \"readOnly\";\n+    public static final String DRAGGABLE_ONLY = \"draggable\";\n+    public static final double DEFAULT_LOCATION_ACCURACY = 5.0;\n+\n+    private final WaitingForDataRegistry waitingForDataRegistry;\n+\n+    GeoWidgetAnswerBinding binding;\n+\n+    private boolean readOnly;\n+    private boolean draggable = true;\n+    private double accuracyThreshold;\n+    private String stringAnswer;\n+\n+    public GeoPointMapWidget(Context context, QuestionDetails questionDetails,\n+                             QuestionDef questionDef, WaitingForDataRegistry waitingForDataRegistry) {\n+        super(context, questionDetails);\n+        this.waitingForDataRegistry = waitingForDataRegistry;\n+        determineMapProperties(questionDef);\n+\n+        stringAnswer = getFormEntryPrompt().getAnswerText();\n+        boolean dataAvailable = false;\n+        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n+            dataAvailable = true;\n+            setBinaryData(stringAnswer);\n+        }\n+        updateButtonLabelsAndVisibility(dataAvailable);\n+    }\n+\n+    @Override\n+    protected View onCreateAnswerView(Context context, FormEntryPrompt prompt, int answerFontSize) {\n+        binding = GeoWidgetAnswerBinding.inflate(((Activity) context).getLayoutInflater());\n+        View answerView = binding.getRoot();\n+\n+        binding.geoAnswerText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+        readOnly = prompt.isReadOnly();\n+        if (readOnly) {\n+            binding.simpleButton.setVisibility(GONE);\n+        } else {\n+            binding.simpleButton.setText(getDefaultButtonLabel());\n+            binding.simpleButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+            binding.simpleButton.setOnClickListener(v -> onButtonClick());\n+        }\n+        return answerView;\n+    }\n+\n+    @Override\n+    public IAnswerData getAnswer() {\n+        if (stringAnswer == null || stringAnswer.isEmpty()) {\n+            return null;\n+        } else {\n+            return new GeoPointData(GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n+        }\n+    }\n+\n+    @Override\n+    public void clearAnswer() {\n+        stringAnswer = null;\n+        binding.geoAnswerText.setText(null);\n+        updateButtonLabelsAndVisibility(false);\n+        widgetValueChanged();\n+    }\n+\n+    @Override\n+    public void setOnLongClickListener(OnLongClickListener l) {\n+        binding.simpleButton.setOnLongClickListener(l);\n+        binding.geoAnswerText.setOnLongClickListener(l);\n+    }\n+\n+    @Override\n+    public void cancelLongPress() {\n+        super.cancelLongPress();\n+        binding.simpleButton.cancelLongPress();\n+        binding.geoAnswerText.cancelLongPress();\n+    }\n+\n+    @Override\n+    public void setBinaryData(Object answer) {\n+        stringAnswer = (String) answer;\n+        binding.geoAnswerText.setText(getAnswerToDisplay(stringAnswer));\n+\n+        if (binding.geoAnswerText.getText().toString().equals(\"\")) {\n+            stringAnswer = \"\";\n+        }\n+\n+        updateButtonLabelsAndVisibility(stringAnswer != null);\n+        widgetValueChanged();\n+    }\n+\n+    private void determineMapProperties(QuestionDef questionDef) {\n+        // Determine the accuracy threshold to use.\n+        String acc = questionDef.getAdditionalAttribute(null, ACCURACY_THRESHOLD);\n+        accuracyThreshold = acc != null && !acc.isEmpty() ? Double.parseDouble(acc) : DEFAULT_LOCATION_ACCURACY;\n+\n+        // Determine whether the point should be draggable.\n+        if (hasAppearance(getFormEntryPrompt(), PLACEMENT_MAP)) {\n+            draggable = true;\n+        } else if (hasAppearance(getFormEntryPrompt(), MAPS)) {\n+            draggable = false;\n+        }\n+    }\n+\n+    private String getAnswerToDisplay(String answer) {\n+        try {\n+            if (answer != null && !answer.isEmpty()) {\n+                String[] parts = answer.split(\" \");\n+                return getContext().getString(\n+                        R.string.gps_result,\n+                        GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                        GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                        GeoWidgetUtils.truncateDouble(parts[2]),\n+                        GeoWidgetUtils.truncateDouble(parts[3])\n+                );\n+            }\n+        } catch (NumberFormatException e) {\n+            return \"\";\n+        }\n+        return \"\";\n+    }\n+\n+    private void updateButtonLabelsAndVisibility(boolean dataAvailable) {\n+        if (readOnly) {\n+            binding.simpleButton.setText(R.string.geopoint_view_read_only);\n+        } else {\n+            binding.simpleButton.setText(\n+                    dataAvailable ? R.string.view_change_location : R.string.get_point);\n+        }\n+    }\n+\n+    private void onButtonClick() {\n+        if (MultiClickGuard.allowClick(QuestionWidget.class.getName())) {\n+            getPermissionUtils().requestLocationPermissions((Activity) getContext(), new PermissionListener() {\n+                @Override\n+                public void granted() {\n+                    waitingForDataRegistry.waitForData(getFormEntryPrompt().getIndex());\n+                    startGeoActivity();\n+                }\n+\n+                @Override\n+                public void denied() {\n+                }\n+            });\n+        }\n+    }\n+\n+    private void startGeoActivity() {\n+        Context context = getContext();\n+        Intent intent = new Intent(context, GeoPointMapActivity.class);\n+\n+        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n+            intent.putExtra(LOCATION, GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n+        }\n+        intent.putExtra(READ_ONLY, readOnly);", "originalCommit": "27a77161c45d0a3310e99a8d3acff83625d0c8ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE3NTM1Nw==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r453175357", "bodyText": "@lognaturel Should I remove intent.putExtra(READ_ONLY, readOnly) from here as well? In case of readOnly prompt, the button visibility is set to View.GONE. So, the user will not be launching any intent in that case.", "author": "SaumiaSinghal", "createdAt": "2020-07-11T09:13:22Z", "path": "collect_app/src/main/java/org/odk/collect/android/widgets/GeoPointWidget.java", "diffHunk": "@@ -18,152 +18,174 @@\n import android.app.Activity;\n import android.content.Context;\n import android.content.Intent;\n+import android.util.TypedValue;\n+import android.view.View;\n \n+import org.javarosa.core.model.QuestionDef;\n import org.javarosa.core.model.data.GeoPointData;\n import org.javarosa.core.model.data.IAnswerData;\n+import org.javarosa.form.api.FormEntryPrompt;\n import org.odk.collect.android.R;\n import org.odk.collect.android.activities.GeoPointActivity;\n-import org.odk.collect.android.activities.GeoPointMapActivity;\n+import org.odk.collect.android.databinding.GeoWidgetAnswerBinding;\n import org.odk.collect.android.formentry.questions.QuestionDetails;\n-import org.odk.collect.android.geo.MapProvider;\n+import org.odk.collect.android.listeners.PermissionListener;\n+import org.odk.collect.android.utilities.MultiClickGuard;\n+import org.odk.collect.android.widgets.interfaces.BinaryDataReceiver;\n import org.odk.collect.android.widgets.utilities.GeoWidgetUtils;\n+import org.odk.collect.android.widgets.utilities.WaitingForDataRegistry;\n \n import static org.odk.collect.android.utilities.ApplicationConstants.RequestCodes;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.MAPS;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.PLACEMENT_MAP;\n-import static org.odk.collect.android.utilities.WidgetAppearanceUtils.hasAppearance;\n \n-/**\n- * GeoPointWidget is the widget that allows the user to get GPS readings.\n- *\n- * @author Carl Hartung (carlhartung@gmail.com)\n- * @author Yaw Anokwa (yanokwa@gmail.com)\n- * @author Jon Nordling (jonnordling@gmail.com)\n- */\n @SuppressLint(\"ViewConstructor\")\n-public class GeoPointWidget extends BaseGeoWidget {\n+public class GeoPointWidget extends QuestionWidget implements BinaryDataReceiver {\n     public static final String LOCATION = \"gp\";\n     public static final String ACCURACY_THRESHOLD = \"accuracyThreshold\";\n     public static final String READ_ONLY = \"readOnly\";\n-    public static final String DRAGGABLE_ONLY = \"draggable\";\n-\n     public static final double DEFAULT_LOCATION_ACCURACY = 5.0;\n-    private boolean useMap;\n-    private double accuracyThreshold;\n-    private boolean draggable = true;\n+\n+    private final WaitingForDataRegistry waitingForDataRegistry;\n+    private final double accuracyThreshold;\n+\n+    GeoWidgetAnswerBinding binding;\n+\n+    private boolean readOnly;\n     private String stringAnswer;\n \n-    public GeoPointWidget(Context context, QuestionDetails questionDetails) {\n+    public GeoPointWidget(Context context, QuestionDetails questionDetails, QuestionDef questionDef, WaitingForDataRegistry waitingForDataRegistry) {\n         super(context, questionDetails);\n-        determineMapProperties();\n-    }\n+        this.waitingForDataRegistry = waitingForDataRegistry;\n \n-    private void determineMapProperties() {\n         // Determine the accuracy threshold to use.\n-        String acc = getFormEntryPrompt().getQuestion().getAdditionalAttribute(null, ACCURACY_THRESHOLD);\n+        String acc = questionDef.getAdditionalAttribute(null, ACCURACY_THRESHOLD);\n         accuracyThreshold = acc != null && !acc.isEmpty() ? Double.parseDouble(acc) : DEFAULT_LOCATION_ACCURACY;\n \n-        // Determine whether to use the map and whether the point should be draggable.\n-        if (MapProvider.getConfigurator().isAvailable(getContext())) {\n-            if (hasAppearance(getFormEntryPrompt(), PLACEMENT_MAP)) {\n-                draggable = true;\n-                useMap = true;\n-            } else if (hasAppearance(getFormEntryPrompt(), MAPS)) {\n-                draggable = false;\n-                useMap = true;\n-            }\n+        stringAnswer = getFormEntryPrompt().getAnswerText();\n+        boolean dataAvailable = false;\n+        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n+            dataAvailable = true;\n+            setBinaryData(stringAnswer);\n         }\n+        updateButtonLabelsAndVisibility(dataAvailable);\n     }\n \n-    public void updateButtonLabelsAndVisibility(boolean dataAvailable) {\n-        if (useMap) {\n-            if (readOnly) {\n-                startGeoButton.setText(R.string.geopoint_view_read_only);\n-            } else {\n-                startGeoButton.setText(\n-                    dataAvailable ? R.string.view_change_location : R.string.get_point);\n-            }\n+    @Override\n+    protected View onCreateAnswerView(Context context, FormEntryPrompt prompt, int answerFontSize) {\n+        binding = GeoWidgetAnswerBinding.inflate(((Activity) context).getLayoutInflater());\n+        View answerView = binding.getRoot();\n+\n+        binding.geoAnswerText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+        readOnly = prompt.isReadOnly();\n+        if (readOnly) {\n+            binding.simpleButton.setVisibility(GONE);\n         } else {\n-            if (!readOnly) {\n-                startGeoButton.setText(\n-                    dataAvailable ? R.string.change_location : R.string.get_point);\n-            }\n+            binding.simpleButton.setText(getDefaultButtonLabel());\n+            binding.simpleButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, answerFontSize);\n+\n+            binding.simpleButton.setOnClickListener(v -> onButtonClick());\n         }\n+        return answerView;\n     }\n \n     @Override\n     public IAnswerData getAnswer() {\n         if (stringAnswer == null || stringAnswer.isEmpty()) {\n             return null;\n         } else {\n-            try {\n-                return new GeoPointData(GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n-            } catch (Exception numberFormatException) {\n-                return null;\n-            }\n+            return new GeoPointData(GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n         }\n     }\n \n     @Override\n     public void clearAnswer() {\n         stringAnswer = null;\n-        super.clearAnswer();\n+        binding.geoAnswerText.setText(null);\n+        updateButtonLabelsAndVisibility(false);\n+        widgetValueChanged();\n+    }\n+\n+    @Override\n+    public void setOnLongClickListener(OnLongClickListener l) {\n+        binding.simpleButton.setOnLongClickListener(l);\n+        binding.geoAnswerText.setOnLongClickListener(l);\n+    }\n+\n+    @Override\n+    public void cancelLongPress() {\n+        super.cancelLongPress();\n+        binding.simpleButton.cancelLongPress();\n+        binding.geoAnswerText.cancelLongPress();\n     }\n \n     @Override\n     public void setBinaryData(Object answer) {\n         stringAnswer = (String) answer;\n+        binding.geoAnswerText.setText(getAnswerToDisplay(stringAnswer));\n \n-        if (stringAnswer != null && !stringAnswer.isEmpty()) {\n-            String[] parts = stringAnswer.split(\" \");\n-            answerDisplay.setText(getContext().getString(\n-                R.string.gps_result,\n-                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n-                GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n-                    GeoWidgetUtils.truncateDouble(parts[2]),\n-                    GeoWidgetUtils.truncateDouble(parts[3])\n-            ));\n-        } else {\n-            answerDisplay.setText(\"\");\n+        if (binding.geoAnswerText.getText().toString().equals(\"\")) {\n+            stringAnswer = \"\";\n         }\n \n-        updateButtonLabelsAndVisibility(true);\n+        updateButtonLabelsAndVisibility(stringAnswer != null);\n         widgetValueChanged();\n     }\n \n-    @Override\n-    public String getAnswerToDisplay(String answer) {\n-        if (!answer.isEmpty()) {\n-            String[] parts = answer.split(\" \");\n-            return getContext().getString(\n-                    R.string.gps_result,\n-                    GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n-                    GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n-                    GeoWidgetUtils.truncateDouble(parts[2]),\n-                    GeoWidgetUtils.truncateDouble(parts[3])\n-            );\n-        } else {\n+    private String getAnswerToDisplay(String answer) {\n+        try {\n+            if (answer != null && !answer.isEmpty()) {\n+                String[] parts = answer.split(\" \");\n+                return getContext().getString(\n+                        R.string.gps_result,\n+                        GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[0]), \"lat\"),\n+                        GeoWidgetUtils.convertCoordinatesIntoDegreeFormat(getContext(), Double.parseDouble(parts[1]), \"lon\"),\n+                        GeoWidgetUtils.truncateDouble(parts[2]),\n+                        GeoWidgetUtils.truncateDouble(parts[3])\n+                );\n+            }\n+        } catch (NumberFormatException e) {\n             return \"\";\n         }\n+        return \"\";\n     }\n \n-    @Override\n-    public String getDefaultButtonLabel() {\n-        return getContext().getString(R.string.get_location);\n+    private void updateButtonLabelsAndVisibility(boolean dataAvailable) {\n+        if (!readOnly) {\n+            binding.simpleButton.setText(\n+                    dataAvailable ? R.string.change_location : R.string.get_point);\n+        }\n     }\n \n-    public void startGeoActivity() {\n+    private void onButtonClick() {\n+        if (MultiClickGuard.allowClick(QuestionWidget.class.getName())) {\n+            getPermissionUtils().requestLocationPermissions((Activity) getContext(), new PermissionListener() {\n+                @Override\n+                public void granted() {\n+                    waitingForDataRegistry.waitForData(getFormEntryPrompt().getIndex());\n+                    startGeoActivity();\n+                }\n+\n+                @Override\n+                public void denied() {\n+                }\n+            });\n+        }\n+    }\n+\n+    private void startGeoActivity() {\n         Context context = getContext();\n-        Intent intent = new Intent(\n-            context, useMap ? GeoPointMapActivity.class : GeoPointActivity.class);\n+        Intent intent = new Intent(context, GeoPointActivity.class);\n \n         if (stringAnswer != null && !stringAnswer.isEmpty()) {\n             intent.putExtra(LOCATION, GeoWidgetUtils.getLocationParamsFromStringAnswer(stringAnswer));\n         }\n         intent.putExtra(READ_ONLY, readOnly);", "originalCommit": "27a77161c45d0a3310e99a8d3acff83625d0c8ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzI1MTI4NA==", "url": "https://github.com/getodk/collect/pull/3877#discussion_r453251284", "bodyText": "Good catch, yes!", "author": "lognaturel", "createdAt": "2020-07-12T00:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE3NTM1Nw=="}], "type": "inlineReview"}, {"oid": "e545c1338cd3de6fe2dae95c7ad6db14a5bf0736", "url": "https://github.com/getodk/collect/commit/e545c1338cd3de6fe2dae95c7ad6db14a5bf0736", "message": "make the button visible in GeoPointMapWidget when prompt is readonly", "committedDate": "2020-07-11T09:14:44Z", "type": "commit"}, {"oid": "cba67d2be598b56302e0f2a903077e42ef26e438", "url": "https://github.com/getodk/collect/commit/cba67d2be598b56302e0f2a903077e42ef26e438", "message": "remove read only in GeoPointWidget", "committedDate": "2020-07-12T10:01:58Z", "type": "commit"}, {"oid": "99dfac26bbbc23556e9bb06248400ebc9417bb23", "url": "https://github.com/getodk/collect/commit/99dfac26bbbc23556e9bb06248400ebc9417bb23", "message": "code refactor", "committedDate": "2020-07-12T11:27:41Z", "type": "commit"}, {"oid": "389d0aee90f485280f1b2942cc2037572e697fb9", "url": "https://github.com/getodk/collect/commit/389d0aee90f485280f1b2942cc2037572e697fb9", "message": "fix unit tests", "committedDate": "2020-07-12T11:59:55Z", "type": "commit"}, {"oid": "e2670a42bc151ed4d8be623a3cb111586c410af7", "url": "https://github.com/getodk/collect/commit/e2670a42bc151ed4d8be623a3cb111586c410af7", "message": "disable clear button in geopoint map activity when map is readonly", "committedDate": "2020-07-21T17:19:48Z", "type": "commit"}, {"oid": "8e369a0cc80ac273dec108ba9236ced71fe37fe0", "url": "https://github.com/getodk/collect/commit/8e369a0cc80ac273dec108ba9236ced71fe37fe0", "message": "set visibility of button to gone in case the data is not available and is readOnly", "committedDate": "2020-07-22T23:29:51Z", "type": "commit"}]}