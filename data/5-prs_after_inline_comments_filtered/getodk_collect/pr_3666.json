{"pr_number": 3666, "pr_title": "Use an ingestion timestamp to detect whether the search/pulldata handler should re-process new data file", "pr_createdAt": "2020-03-03T05:30:51Z", "pr_url": "https://github.com/getodk/collect/pull/3666", "timeline": [{"oid": "ac5b9add1dd8fb0d61263884e463ee96d5fe38fc", "url": "https://github.com/getodk/collect/commit/ac5b9add1dd8fb0d61263884e463ee96d5fe38fc", "message": "Add tests that validate form loading for search/pulldata using external CSV data", "committedDate": "2020-03-02T23:02:00Z", "type": "commit"}, {"oid": "1dcf966f723b6d661ad67428ecb2230c0fc9dd0e", "url": "https://github.com/getodk/collect/commit/1dcf966f723b6d661ad67428ecb2230c0fc9dd0e", "message": "light refactoring of ExternalDataReaderImpl in prep for code behavior changes", "committedDate": "2020-03-02T23:03:44Z", "type": "commit"}, {"oid": "b97db950cae7f2add7d23227561e2ab1239c49dd", "url": "https://github.com/getodk/collect/commit/b97db950cae7f2add7d23227561e2ab1239c49dd", "message": "Add metadata table when creating external database for search/pulldata\nInitial code and tests. Still need to refactor query building and database helper methods.", "committedDate": "2020-03-02T23:03:59Z", "type": "commit"}, {"oid": "0a022532f4fd3699a47f4ffe82b834f7c921ee90", "url": "https://github.com/getodk/collect/commit/0a022532f4fd3699a47f4ffe82b834f7c921ee90", "message": "Refactor SQLite query builder and execution wrappers.\nSeparated the query string building functionality from the database-aware functionality in CustomSQLiteQueryBuilder.\nRelocate new query and execution functionality introduced for working with CSV external data.", "committedDate": "2020-03-02T23:04:10Z", "type": "commit"}, {"oid": "66d968763e4380fa64ac25c1a0282a62cd01bc3d", "url": "https://github.com/getodk/collect/commit/66d968763e4380fa64ac25c1a0282a62cd01bc3d", "message": "Fix issue #3335 with renamed CSV files\n\nChange External Data mechanism for importing CSV files for search()/pulldata() functionalty so that it no longer has to rename a file to track file changes. The CSV file timestamp is now captured in a metadata table stored in the SQLite database holding the imported file. Updates to the file will cause the database to be rebuilt the next time the form is loaded. If the timestamp is unchanged, we skip importing the data.\n\nNow that the file is no longer being renamed, other ODK functionality that relies on CSV files can operate as expected without having their files disappear from under them. However, the each CSV file will still be imported into a SQLite database by the External Data functionality, since it is not implemented narrowly enough to understand which CSV files are actually referenced by the form via search()/pulldata().", "committedDate": "2020-03-02T23:27:09Z", "type": "commit"}, {"oid": "67474dc73903eefc8e82dbf4846a237c52657933", "url": "https://github.com/getodk/collect/commit/67474dc73903eefc8e82dbf4846a237c52657933", "message": "Replace database open call introduced in API 27", "committedDate": "2020-03-03T05:15:07Z", "type": "commit"}, {"oid": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "url": "https://github.com/getodk/collect/commit/1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "message": "Merge branch 'master' into issue-3335", "committedDate": "2020-03-04T14:00:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDc2NQ==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387844765", "bodyText": "Is this really ExternalDataReaderTest?", "author": "seadowg", "createdAt": "2020-03-04T18:14:22Z", "path": "collect_app/src/androidTest/java/org/odk/collect/android/external/ExternalDataTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.odk.collect.android.external;\n+\n+import android.Manifest;\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ExternalDataTest {", "originalCommit": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1OTg4Mg==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387859882", "bodyText": "Yes, that sounds right. Will change!", "author": "lognaturel", "createdAt": "2020-03-04T18:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NTc0Mw==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387845743", "bodyText": "Could this run in Robolectric instead?", "author": "seadowg", "createdAt": "2020-03-04T18:16:15Z", "path": "collect_app/src/androidTest/java/org/odk/collect/android/external/ExternalDataTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.odk.collect.android.external;\n+\n+import android.Manifest;\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ExternalDataTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private File csvFile;\n+    private File dbFile;\n+\n+    @Before\n+    public void setUp() {\n+        File formPath = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formPath);\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+    }\n+\n+    @Rule", "originalCommit": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MTUwOA==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387861508", "bodyText": "I think so, good call. Let me explore that...", "author": "lognaturel", "createdAt": "2020-03-04T18:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NzYwNA==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387847604", "bodyText": "These tests are pretty dense and I'm having a hard time understanding what they are driving at. I think using a different style for the names would be helpful. This test could be doImport_createsDataAndMetaDatabaseTables. That way we know what the subject is (ExternalDataReaderImpl#doImport) and what our expectation is pretty clearly.", "author": "seadowg", "createdAt": "2020-03-04T18:19:48Z", "path": "collect_app/src/androidTest/java/org/odk/collect/android/external/ExternalDataTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.odk.collect.android.external;\n+\n+import android.Manifest;\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.test.rule.GrantPermissionRule;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.support.CopyFormRule;\n+import org.odk.collect.android.support.ResetStateRule;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ExternalDataTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private File csvFile;\n+    private File dbFile;\n+\n+    @Before\n+    public void setUp() {\n+        File formPath = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formPath);\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+    }\n+\n+    @Rule\n+    public RuleChain copyFormChain = RuleChain\n+            .outerRule(GrantPermissionRule.grant(\n+                    Manifest.permission.READ_EXTERNAL_STORAGE,\n+                    Manifest.permission.WRITE_EXTERNAL_STORAGE\n+            ))\n+            .around(new ResetStateRule())\n+            .around(new CopyFormRule(SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME, Collections.singletonList(SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME)));\n+\n+    private static Map<String, File> makeExternalDataMap(File csvFile) {\n+        Map<String, File> externalDataMap = new HashMap<>();\n+        externalDataMap.put(SIMPLE_SEARCH_EXTERNAL_CSV_NAME, csvFile);\n+        return externalDataMap;\n+    }\n+\n+    @Test\n+    public void testCreateDBonImportCSV() {", "originalCommit": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MTU3Ng==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387861576", "bodyText": "Yes, sounds good.", "author": "lognaturel", "createdAt": "2020-03-04T18:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NzYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0ODU0MQ==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387848541", "bodyText": "I'd love to say \"this should be Robolectric\" but I think that would involve picking the task apart. The XTaskTest classes are pretty much the prime candidates for moving out of Espresso so I'm confident that will happen later.", "author": "seadowg", "createdAt": "2020-03-04T18:21:31Z", "path": "collect_app/src/androidTest/java/org/odk/collect/android/tasks/FormLoaderTaskTest.java", "diffHunk": "@@ -14,13 +15,19 @@\n \n import java.io.File;\n import java.util.Arrays;\n+import java.util.Collections;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.notNullValue;\n \n public class FormLoaderTaskTest {", "originalCommit": "1b1d4651971fd16a7c62b441c545b4abb2d1c8c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MjM3MA==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387992370", "bodyText": "Yeah, agreed that coming back to this sounds good.\nI think the new Robolectric tests may actually offer sufficient coverage. There is something comforting about knowing that these are even more end-to-end, though.", "author": "lognaturel", "createdAt": "2020-03-04T23:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0ODU0MQ=="}], "type": "inlineReview"}, {"oid": "10ba2ee2e4758363c0cda19b979cec6139253e7d", "url": "https://github.com/getodk/collect/commit/10ba2ee2e4758363c0cda19b979cec6139253e7d", "message": "Replace Espresso tests with Robolectric tests", "committedDate": "2020-03-04T23:14:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MzE5NQ==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387993195", "bodyText": "This work here is basically exactly what CopyFormRule and the methods in FormLoadingUtils do but they're in different sourcesets. Again, maybe a reason to have all tests in one. Or if there is an elegant way to share that code, please feel free to modify, @seadowg.", "author": "lognaturel", "createdAt": "2020-03-04T23:20:50Z", "path": "collect_app/src/test/java/org/odk/collect/android/external/ExternalDataReaderTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.odk.collect.android.external;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.os.Environment;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.storage.StorageInitializer;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.shadows.ShadowEnvironment;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_DATASET_FILENAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_LAST_MODIFIED;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_METADATA_TABLE_NAME;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class ExternalDataReaderTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private static final String SELECT_ALL_DATA_QUERY =  \"SELECT * FROM \" + EXTERNAL_DATA_TABLE_NAME;\n+\n+    private static File csvFile;\n+    private static File dbFile;\n+\n+    private static Map<String, File> formDefToCsvMedia;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);\n+        new StorageInitializer().createOdkDirsOnStorage();\n+\n+        File formFile = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);", "originalCommit": "10ba2ee2e4758363c0cda19b979cec6139253e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MTEyNg==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r388291126", "bodyText": "I'm happy with this for now!", "author": "seadowg", "createdAt": "2020-03-05T13:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MzE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5Mzk5OQ==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r387993999", "bodyText": "Note that this test has changed. It previously faked an update by changing the db timestamp. Now it actually tests a real file change.", "author": "lognaturel", "createdAt": "2020-03-04T23:23:13Z", "path": "collect_app/src/test/java/org/odk/collect/android/external/ExternalDataReaderTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.odk.collect.android.external;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.os.Environment;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.storage.StorageInitializer;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.shadows.ShadowEnvironment;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_DATASET_FILENAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_LAST_MODIFIED;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_METADATA_TABLE_NAME;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class ExternalDataReaderTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private static final String SELECT_ALL_DATA_QUERY =  \"SELECT * FROM \" + EXTERNAL_DATA_TABLE_NAME;\n+\n+    private static File csvFile;\n+    private static File dbFile;\n+\n+    private static Map<String, File> formDefToCsvMedia;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);\n+        new StorageInitializer().createOdkDirsOnStorage();\n+\n+        File formFile = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formFile);\n+        mediaDir.mkdir();\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+        formDefToCsvMedia = makeExternalDataMap();\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"forms\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+             OutputStream output = new FileOutputStream(formFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"media\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+            OutputStream output = new FileOutputStream(csvFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+    }\n+\n+    @Test\n+    public void doImport_createsDataAndMetadataTables() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(db, is(notNullValue()));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_DATA_TABLE_NAME), is(true));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME), is(true));\n+    }\n+\n+    /**\n+     * There are multiple features that ingest CSV files so the original file should not be modified.\n+     * https://github.com/opendatakit/collect/issues/3335\n+     */\n+    @Test\n+    public void doImport_doesNotModifyOriginalCsv() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+        assertThat(csvFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void createAndPopulateMetadataTable_createsMetadataTableWithExpectedTimestamp() {\n+        final String testMetadataTable = \"testMetadataTable\";\n+\n+        SQLiteDatabase.OpenParams.Builder paramsBuilder = new SQLiteDatabase.OpenParams.Builder();\n+        SQLiteDatabase db = SQLiteDatabase.createInMemory(paramsBuilder.build());\n+        ExternalSQLiteOpenHelper.createAndPopulateMetadataTable(db, testMetadataTable, csvFile);\n+\n+        assertThat(SQLiteUtils.doesTableExist(db, testMetadataTable), is(true));\n+\n+        final String[] columnNames = {COLUMN_LAST_MODIFIED};\n+        final String selectCriteria = CustomSQLiteQueryBuilder.formatCompareEquals(\n+                COLUMN_DATASET_FILENAME,\n+                CustomSQLiteQueryBuilder.quoteStringLiteral(SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME));\n+        Cursor cursor = db.query(testMetadataTable, columnNames, selectCriteria, null, null, null, null);\n+        cursor.moveToFirst();\n+        long fileTimestamp = cursor.getLong(0);\n+\n+        assertThat(fileTimestamp, is(csvFile.lastModified()));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfDatabaseFileIsDeleted() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        dbFile.delete();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfMetadataTableIsMissing() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        // Remove the metadata table (mimicking prior versions without the metadata table)\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        SQLiteUtils.dropTable(db, EXTERNAL_METADATA_TABLE_NAME);\n+        db.close();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+        db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(\"metadata table should be recreated\", SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME));\n+        db.close();\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfFileIsUpdated() throws IOException, InterruptedException {", "originalCommit": "10ba2ee2e4758363c0cda19b979cec6139253e7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NTMxMw==", "url": "https://github.com/getodk/collect/pull/3666#discussion_r388295313", "bodyText": "I think there is a way to fake this with fake file layer. Can't remember the name of the framework though. We can stick with this right now as I'm pretty sure it's still deterministic.", "author": "seadowg", "createdAt": "2020-03-05T13:35:07Z", "path": "collect_app/src/test/java/org/odk/collect/android/external/ExternalDataReaderTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.odk.collect.android.external;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.os.Environment;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.odk.collect.android.storage.StorageInitializer;\n+import org.odk.collect.android.storage.StoragePathProvider;\n+import org.odk.collect.android.storage.StorageSubdirectory;\n+import org.odk.collect.android.utilities.CustomSQLiteQueryBuilder;\n+import org.odk.collect.android.utilities.FileUtils;\n+import org.odk.collect.android.utilities.SQLiteUtils;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.shadows.ShadowEnvironment;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_DATASET_FILENAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.COLUMN_LAST_MODIFIED;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME;\n+import static org.odk.collect.android.external.ExternalDataUtil.EXTERNAL_METADATA_TABLE_NAME;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class ExternalDataReaderTest {\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME = \"simple-search-external-csv.xml\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_NAME = \"simple-search-external-csv-fruits\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME = \"simple-search-external-csv-fruits.csv\";\n+    private static final String SIMPLE_SEARCH_EXTERNAL_DB_FILENAME = \"simple-search-external-csv-fruits.db\";\n+\n+    private static final String SELECT_ALL_DATA_QUERY =  \"SELECT * FROM \" + EXTERNAL_DATA_TABLE_NAME;\n+\n+    private static File csvFile;\n+    private static File dbFile;\n+\n+    private static Map<String, File> formDefToCsvMedia;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);\n+        new StorageInitializer().createOdkDirsOnStorage();\n+\n+        File formFile = new File(new StoragePathProvider().getDirPath(StorageSubdirectory.FORMS) + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+        File mediaDir = FileUtils.getFormMediaDir(formFile);\n+        mediaDir.mkdir();\n+        csvFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+        dbFile = new File(mediaDir + File.separator + SIMPLE_SEARCH_EXTERNAL_DB_FILENAME);\n+        formDefToCsvMedia = makeExternalDataMap();\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"forms\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FORM_FILENAME);\n+             OutputStream output = new FileOutputStream(formFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+\n+        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"media\" + File.separator + SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME);\n+            OutputStream output = new FileOutputStream(csvFile)) {\n+            IOUtils.copy(input, output);\n+        }\n+    }\n+\n+    @Test\n+    public void doImport_createsDataAndMetadataTables() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(db, is(notNullValue()));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_DATA_TABLE_NAME), is(true));\n+        assertThat(SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME), is(true));\n+    }\n+\n+    /**\n+     * There are multiple features that ingest CSV files so the original file should not be modified.\n+     * https://github.com/opendatakit/collect/issues/3335\n+     */\n+    @Test\n+    public void doImport_doesNotModifyOriginalCsv() {\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+\n+        assertThat(dbFile.exists(), is(true));\n+        assertThat(csvFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void createAndPopulateMetadataTable_createsMetadataTableWithExpectedTimestamp() {\n+        final String testMetadataTable = \"testMetadataTable\";\n+\n+        SQLiteDatabase.OpenParams.Builder paramsBuilder = new SQLiteDatabase.OpenParams.Builder();\n+        SQLiteDatabase db = SQLiteDatabase.createInMemory(paramsBuilder.build());\n+        ExternalSQLiteOpenHelper.createAndPopulateMetadataTable(db, testMetadataTable, csvFile);\n+\n+        assertThat(SQLiteUtils.doesTableExist(db, testMetadataTable), is(true));\n+\n+        final String[] columnNames = {COLUMN_LAST_MODIFIED};\n+        final String selectCriteria = CustomSQLiteQueryBuilder.formatCompareEquals(\n+                COLUMN_DATASET_FILENAME,\n+                CustomSQLiteQueryBuilder.quoteStringLiteral(SIMPLE_SEARCH_EXTERNAL_CSV_FILENAME));\n+        Cursor cursor = db.query(testMetadataTable, columnNames, selectCriteria, null, null, null, null);\n+        cursor.moveToFirst();\n+        long fileTimestamp = cursor.getLong(0);\n+\n+        assertThat(fileTimestamp, is(csvFile.lastModified()));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfDatabaseFileIsDeleted() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        dbFile.delete();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfMetadataTableIsMissing() {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        // Remove the metadata table (mimicking prior versions without the metadata table)\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        SQLiteUtils.dropTable(db, EXTERNAL_METADATA_TABLE_NAME);\n+        db.close();\n+\n+        // Reimport\n+        externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+        db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(\"metadata table should be recreated\", SQLiteUtils.doesTableExist(db, EXTERNAL_METADATA_TABLE_NAME));\n+        db.close();\n+    }\n+\n+    @Test\n+    public void doImport_reimportsCsvIfFileIsUpdated() throws IOException, InterruptedException {\n+        // Create the DB file with an initial import\n+        ExternalDataReader externalDataReader = new ExternalDataReaderImpl(null);\n+        externalDataReader.doImport(formDefToCsvMedia);\n+        assertThat(dbFile.exists(), is(true));\n+\n+        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), null, SQLiteDatabase.OPEN_READWRITE);\n+        assertThat(db.rawQuery(SELECT_ALL_DATA_QUERY, null).getCount(), is(3));\n+\n+        long originalTimestamp = csvFile.lastModified();\n+        long metadataLastModified = ExternalSQLiteOpenHelper.getLastImportTimestamp(db, EXTERNAL_METADATA_TABLE_NAME, csvFile);\n+        assertThat(metadataLastModified, is(originalTimestamp));\n+\n+        Thread.sleep(1000); // this test is so fast that we need to guarantee the modified time changes", "originalCommit": "10ba2ee2e4758363c0cda19b979cec6139253e7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}