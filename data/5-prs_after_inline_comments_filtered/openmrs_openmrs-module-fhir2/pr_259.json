{"pr_number": 259, "pr_title": "FM2-246: Add search for _include using Location:partof", "pr_createdAt": "2020-07-17T14:03:21Z", "pr_url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMzQ2NA==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458113464", "bodyText": "This could be \"Location:\" + Location.SP_PARTOF. Also I don't love following the convention of theIncludes. HAPI seems to use this convention so that they can unambiguously write:\nmyIncludes = theIncludes;\nBut this isn't generally what code in OpenMRS looks like. I would just call them includes.", "author": "ibacher", "createdAt": "2020-07-21T13:52:29Z", "path": "api/src/main/java/org/openmrs/module/fhir2/providers/r3/LocationFhirResourceProvider.java", "diffHunk": "@@ -84,8 +88,13 @@ public IBundleProvider searchLocations(@OptionalParam(name = Location.SP_NAME) S\n \t                Location.SP_ADDRESS_STATE, Location.SP_ADDRESS_COUNTRY,\n \t                Location.SP_ADDRESS_POSTALCODE }, targetTypes = Location.class) ReferenceAndListParam parent,\n \t        @OptionalParam(name = Location.SP_RES_ID) TokenAndListParam id,\n-\t        @OptionalParam(name = \"_lastUpdated\") DateRangeParam lastUpdated, @Sort SortSpec sort) {\n+\t        @OptionalParam(name = \"_lastUpdated\") DateRangeParam lastUpdated,\n+\t        @IncludeParam(allow = \"Location:partof\") HashSet<Include> theIncludes, @Sort SortSpec sort) {", "originalCommit": "731e4f1013adae4b7269f8920195fa662d4bc126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0OTI1OA==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458149258", "bodyText": "I actually used theIncludes because we have been using theParams for SearchParameterMap.", "author": "varung-31", "createdAt": "2020-07-21T14:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMzQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNTQ1Mw==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458215453", "bodyText": "Ugh... we should really fix that too. I suppose we can defer it.", "author": "ibacher", "createdAt": "2020-07-21T16:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMzQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMjI0NQ==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458122245", "bodyText": "This seems unnecessarily verbose. Couldn't this whole thing be simplified to something like:\nprivate static Set<Location> handlePartofInclude(List<Location> locations) {\n\tresourceList.stream().map(Location::getPartOf).filter(Objects::nonNull).map(ref -> getIdFromReference(ref)).collect(Collectors.toSet());\n}\n\nI.e., do we actually need a setup similar to what we do for searching (where the point is to be able to combine a series of operations to produce a single Criteria object for running the query) or can we get away with something much simpler?", "author": "ibacher", "createdAt": "2020-07-21T14:04:04Z", "path": "api/src/main/java/org/openmrs/module/fhir2/api/search/SearchQueryIncludeImpl.java", "diffHunk": "@@ -11,23 +11,71 @@\n \n import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Set;\n \n+import ca.uhn.fhir.model.api.Include;\n import lombok.NoArgsConstructor;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Location;\n+import org.hl7.fhir.r4.model.Reference;\n+import org.openmrs.module.fhir2.FhirConstants;\n+import org.openmrs.module.fhir2.api.FhirLocationService;\n+import org.openmrs.module.fhir2.api.search.param.PropParam;\n import org.openmrs.module.fhir2.api.search.param.SearchParameterMap;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Component;\n+import org.springframework.util.CollectionUtils;\n \n @Component\n @NoArgsConstructor\n public class SearchQueryIncludeImpl<U extends IBaseResource> implements SearchQueryInclude<U> {\n \t\n+\t@Autowired\n+\tprivate FhirLocationService locationService;\n+\t\n \t@Override\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic Set<IBaseResource> getIncludedResources(List<U> resourceList, SearchParameterMap theParams) {\n \t\tSet<IBaseResource> includedResourcesSet = new HashSet<>();\n \t\t\n-\t\t// TODO -> Add implementation to compute the included resources\n+\t\tList<PropParam<?>> includeParamList = theParams.getParameters(FhirConstants.INCLUDE_SEARCH_HANDLER);\n+\t\t\n+\t\tif (CollectionUtils.isEmpty(includeParamList)) {\n+\t\t\treturn includedResourcesSet;\n+\t\t}\n+\t\t\n+\t\tSet<Include> includeSet = (HashSet<Include>) includeParamList.get(0).getParam();\n+\t\tincludeSet.forEach(includeParam -> {\n+\t\t\tswitch (includeParam.getParamName()) {\n+\t\t\t\tcase FhirConstants.INCLUDE_PART_OF_PARAM:\n+\t\t\t\t\tincludedResourcesSet.addAll(handlePartofInclude(resourceList, includeParam.getParamType()));\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t});\n \t\t\n \t\treturn includedResourcesSet;\n \t}\n+\t\n+\tprivate Set<IBaseResource> handlePartofInclude(List<U> resourceList, String paramType) {\n+\t\tSet<IBaseResource> includedResources = new HashSet<>();\n+\t\tSet<String> uniqueParentLocationUUIDs = new HashSet<>();\n+\t\t\n+\t\tswitch (paramType) {\n+\t\t\tcase FhirConstants.LOCATION:\n+\t\t\t\tresourceList.forEach(\n+\t\t\t\t    resource -> uniqueParentLocationUUIDs.add(getIdFromReference(((Location) resource).getPartOf())));\n+\t\t\t\t\n+\t\t\t\tuniqueParentLocationUUIDs.removeIf(Objects::isNull);\n+\t\t\t\tincludedResources.addAll(locationService.get(uniqueParentLocationUUIDs));\n+\t\t\t\tbreak;\n+\t\t}\n+\t\t\n+\t\treturn includedResources;\n+\t}", "originalCommit": "731e4f1013adae4b7269f8920195fa662d4bc126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyNzY1MA==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458127650", "bodyText": "No, so the thing here is that we could have partof for multiple resources in the future. Its use is not clearly evident here but let us say we support _include=Location:partof as well as _include=Observation:partof, instead of creating a separate function for each of these, we can just club them together based on the resource type.", "author": "varung-31", "createdAt": "2020-07-21T14:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMjI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzMDE4MA==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458130180", "bodyText": "This would look something like -\n\tprivate Set<IBaseResource> handlePatientInclude(List<U> resourceList, String paramType) {\n\t\tSet<IBaseResource> includedResources = new HashSet<>();\n\t\tSet<String> uniquePatientUUIDs = new HashSet<>();\n\t\t\n\t\tswitch (paramType) {\n\t\t\tcase FhirConstants.OBSERVATION:\n\t\t\t\tresourceList.forEach(\n\t\t\t\t    resource -> uniquePatientUUIDs.add(getIdFromReference(((Observation) resource).getSubject())));\n\t\t\t\tbreak;\n\t\t\tcase FhirConstants.ALLERGY_INTOLERANCE:\n\t\t\t\tresourceList.forEach(\n\t\t\t\t    resource -> uniquePatientUUIDs.add(getIdFromReference(((AllergyIntolerance) resource).getPatient())));\n\t\t\t\tbreak;\n\t\t\tcase FhirConstants.DIAGNOSTIC_REPORT:\n\t\t\t\tresourceList.forEach(\n\t\t\t\t    resource -> uniquePatientUUIDs.add(getIdFromReference(((DiagnosticReport) resource).getSubject())));\n\t\t\t\tbreak;\n\t\t\tcase FhirConstants.ENCOUNTER:\n\t\t\t\tresourceList.forEach(\n\t\t\t\t    resource -> uniquePatientUUIDs.add(getIdFromReference(((Encounter) resource).getSubject())));\n\t\t\t\tbreak;\n\t\t\tcase FhirConstants.PERSON:\n\t\t\t\tresourceList.forEach(resource -> {\n\t\t\t\t\tList<Reference> patientReferenceList = new ArrayList<>();\n\t\t\t\t\t((Person) resource).getLink().forEach(patient -> patientReferenceList.add(patient.getTarget()));\n\t\t\t\t\tuniquePatientUUIDs.addAll(getIdsFromReferenceList(patientReferenceList));\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase FhirConstants.RELATED_PERSON:\n\t\t\t\tresourceList.forEach(resource -> uniquePatientUUIDs.add(getIdFromReference(((RelatedPerson) resource).getPatient())));\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tuniquePatientUUIDs.removeIf(Objects::isNull);\n\t\tincludedResources.addAll(patientService.get(uniquePatientUUIDs));\n\t\t\n\t\treturn includedResources;\n\t}", "author": "varung-31", "createdAt": "2020-07-21T14:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMjI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5OTM1MQ==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458199351", "bodyText": "So, I can get that there are cases where this pattern can be useful, but in the specific case of Location:partof I don't think it is. I think, like with your patient example, it makes sense to group the includes into functions based on the result type rather than the search query.\nFor instance, if we had a handlePartOf() method that handles both Location and Observation, there's essentially no logic shared between those paths. But it would make sense to have a handleLocation() function that takes various parameters to extract Location UUIDs and then runs a single locationService.get() call.", "author": "ibacher", "createdAt": "2020-07-21T15:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMjI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNjU0Mg==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458206542", "bodyText": "Incidentally, functions based on the result type are essentially what your handlePatientInclude() does.", "author": "ibacher", "createdAt": "2020-07-21T15:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMzI3NQ==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458123275", "bodyText": "Does this need to take a set? Could we instead support a list, array, or even generic collection?", "author": "ibacher", "createdAt": "2020-07-21T14:05:24Z", "path": "api/src/main/java/org/openmrs/module/fhir2/api/FhirService.java", "diffHunk": "@@ -11,12 +11,17 @@\n \n import javax.validation.constraints.NotNull;\n \n+import java.util.List;\n+import java.util.Set;\n+\n import org.hl7.fhir.instance.model.api.IAnyResource;\n \n public interface FhirService<T extends IAnyResource> {\n \t\n \tT get(@NotNull String uuid);\n \t\n+\tList<T> get(@NotNull Set<String> distinctUUIDs);", "originalCommit": "731e4f1013adae4b7269f8920195fa662d4bc126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzMTg0Ng==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458131846", "bodyText": "It can have other types as well, but I chose a set so that we only supply distinct uuids. To make the list as unique, we will anyway need to put it in a set, why not just pass that set directly. What do you think?", "author": "varung-31", "createdAt": "2020-07-21T14:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMzI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNTgxNw==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458205817", "bodyText": "So, while we want only the unique list of results, we can also defer the uniqueness part to the database (select * from Concept where uuid in ('e110793d-939b-4661-82c1-b613883ea08d') produces exactly the same output as select * from Concept where uuid in ('e110793d-939b-4661-82c1-b613883ea08d', 'e110793d-939b-4661-82c1-b613883ea08d')).\nBut my real thinking here was that if we build a method that takes a Collection instead of a Set, we can still continue to pass in a set, but we also gain some flexibility in usage (so that if someone has constructed a List, etc., they don't wind up having to convert it to a Set type).", "author": "ibacher", "createdAt": "2020-07-21T15:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMzI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI2MDI4OA==", "url": "https://github.com/openmrs/openmrs-module-fhir2/pull/259#discussion_r458260288", "bodyText": "Yes, that makes sense. I'll change it to collection.", "author": "varung-31", "createdAt": "2020-07-21T17:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMzI3NQ=="}], "type": "inlineReview"}, {"oid": "0de7afa4681b5abb695767aff328e3c705841ef8", "url": "https://github.com/openmrs/openmrs-module-fhir2/commit/0de7afa4681b5abb695767aff328e3c705841ef8", "message": "FM2-246: Add search for _include using Location:partof", "committedDate": "2020-07-21T19:02:10Z", "type": "commit"}, {"oid": "0de7afa4681b5abb695767aff328e3c705841ef8", "url": "https://github.com/openmrs/openmrs-module-fhir2/commit/0de7afa4681b5abb695767aff328e3c705841ef8", "message": "FM2-246: Add search for _include using Location:partof", "committedDate": "2020-07-21T19:02:10Z", "type": "forcePushed"}]}