{"pr_number": 54469, "pr_title": "Add Student's t-test aggregation support", "pr_createdAt": "2020-03-30T22:23:40Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54469", "timeline": [{"oid": "70c36a210a23f726a9094d2510199454a29a1e93", "url": "https://github.com/elastic/elasticsearch/commit/70c36a210a23f726a9094d2510199454a29a1e93", "message": "Add Student's t-test aggregation support\n\nAdds t_test metric aggregation that can perform paired and unpaired two-sample\nt-tests. In this PR support for filters in unpaired is still missing. It will\nbe added in a follow-up PR.\n\nRelates to #53692", "committedDate": "2020-03-30T22:20:49Z", "type": "commit"}, {"oid": "e68c1ad1869e065701dcf66c96388bbfb6a4f311", "url": "https://github.com/elastic/elasticsearch/commit/e68c1ad1869e065701dcf66c96388bbfb6a4f311", "message": "Fix docs", "committedDate": "2020-03-30T22:36:51Z", "type": "commit"}, {"oid": "5c67b6195d381626bee087c74a975fa247ccd68e", "url": "https://github.com/elastic/elasticsearch/commit/5c67b6195d381626bee087c74a975fa247ccd68e", "message": "More doc fixes", "committedDate": "2020-03-30T22:51:07Z", "type": "commit"}, {"oid": "c9b5d1a55afafdbb6239a475c05b5a3a8f9e83bb", "url": "https://github.com/elastic/elasticsearch/commit/c9b5d1a55afafdbb6239a475c05b5a3a8f9e83bb", "message": "Fix testAggregationsVsTransforms", "committedDate": "2020-03-31T14:10:53Z", "type": "commit"}, {"oid": "e294c56f205ed1be7a30d0d1fd8271959994a08c", "url": "https://github.com/elastic/elasticsearch/commit/e294c56f205ed1be7a30d0d1fd8271959994a08c", "message": "Merge remote-tracking branch 'elastic/master' into issue-53692-t-test", "committedDate": "2020-04-01T03:20:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4OTU1NA==", "url": "https://github.com/elastic/elasticsearch/pull/54469#discussion_r401889554", "bodyText": "Hmm, do we know if UnsupportedOpException is a 4xx or 5xx? If it's a 5xx, perhaps we should change this to an IllegalArgumentException?", "author": "polyfractal", "createdAt": "2020-04-01T20:28:34Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/ttest/TTestAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.ttest;\n+\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.AggregatorFactory;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.MultiValuesSource;\n+import org.elasticsearch.search.aggregations.support.MultiValuesSourceAggregatorFactory;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+class TTestAggregatorFactory extends MultiValuesSourceAggregatorFactory {\n+\n+    private final TTestType testType;\n+    private final int tails;\n+\n+    TTestAggregatorFactory(String name, Map<String, ValuesSourceConfig> configs, TTestType testType, int tails,\n+                           DocValueFormat format, QueryShardContext queryShardContext, AggregatorFactory parent,\n+                           AggregatorFactories.Builder subFactoriesBuilder,\n+                           Map<String, Object> metadata) throws IOException {\n+        super(name, configs, format, queryShardContext, parent, subFactoriesBuilder, metadata);\n+        this.testType = testType;\n+        this.tails = tails;\n+    }\n+\n+    @Override\n+    protected Aggregator createUnmapped(SearchContext searchContext,\n+                                        Aggregator parent,\n+                                        List<PipelineAggregator> pipelineAggregators,\n+                                        Map<String, Object> metadata) throws IOException {\n+        switch (testType) {\n+            case PAIRED:\n+                return new PairedTTestAggregator(name, null, tails, format, searchContext, parent, pipelineAggregators, metadata);\n+            case HOMOSCEDASTIC:\n+                return new UnpairedTTestAggregator(name, null, tails, true, format, searchContext, parent, pipelineAggregators, metadata);\n+            case HETEROSCEDASTIC:\n+                return new UnpairedTTestAggregator(name, null, tails, false, format, searchContext, parent, pipelineAggregators, metadata);\n+            default:\n+                throw new UnsupportedOperationException(\"Unsupported t-test type \" + testType);\n+        }\n+    }\n+\n+    @Override\n+    protected Aggregator doCreateInternal(SearchContext searchContext,\n+                                          Map<String, ValuesSourceConfig> configs,\n+                                          DocValueFormat format,\n+                                          Aggregator parent,\n+                                          boolean collectsFromSingleBucket,\n+                                          List<PipelineAggregator> pipelineAggregators,\n+                                          Map<String, Object> metadata) throws IOException {\n+        MultiValuesSource.NumericMultiValuesSource numericMultiVS\n+            = new MultiValuesSource.NumericMultiValuesSource(configs, queryShardContext);\n+        if (numericMultiVS.areValuesSourcesEmpty()) {\n+            return createUnmapped(searchContext, parent, pipelineAggregators, metadata);\n+        }\n+        switch (testType) {\n+            case PAIRED:\n+                return new PairedTTestAggregator(name, numericMultiVS, tails, format, searchContext, parent, pipelineAggregators, metadata);\n+            case HOMOSCEDASTIC:\n+                return new UnpairedTTestAggregator(name, numericMultiVS, tails, true, format, searchContext, parent, pipelineAggregators,\n+                    metadata);\n+            case HETEROSCEDASTIC:\n+                return new UnpairedTTestAggregator(name, numericMultiVS, tails, false, format, searchContext, parent, pipelineAggregators,\n+                    metadata);\n+            default:\n+                throw new UnsupportedOperationException(\"Unsupported t-test type \" + testType);", "originalCommit": "e294c56f205ed1be7a30d0d1fd8271959994a08c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Mzc1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54469#discussion_r401893752", "bodyText": ":D", "author": "polyfractal", "createdAt": "2020-04-01T20:36:37Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/ttest/PairedTTestState.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.ttest;\n+\n+import org.apache.commons.math3.distribution.TDistribution;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+public class PairedTTestState implements TTestState {\n+\n+    public static final String NAME = \"P\";", "originalCommit": "e294c56f205ed1be7a30d0d1fd8271959994a08c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NDgyNw==", "url": "https://github.com/elastic/elasticsearch/pull/54469#discussion_r401894827", "bodyText": "Is it possible for this to ever not match in practice (I mean, I know it shouldn't hence the assertion, but...)?  I wonder if we should actually throw an exception rather than return a really incorrect result if we ever get this messed up?", "author": "polyfractal", "createdAt": "2020-04-01T20:38:36Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/ttest/PairedTTestState.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.ttest;\n+\n+import org.apache.commons.math3.distribution.TDistribution;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+public class PairedTTestState implements TTestState {\n+\n+    public static final String NAME = \"P\";\n+\n+    private final TTestStats stats;\n+\n+    private final int tails;\n+\n+    public PairedTTestState(TTestStats stats, int tails) {\n+        this.stats = stats;\n+        this.tails = tails;\n+    }\n+\n+    public PairedTTestState(StreamInput in) throws IOException {\n+        stats = new TTestStats(in);\n+        tails = in.readVInt();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        stats.writeTo(out);\n+        out.writeVInt(tails);\n+    }\n+\n+    @Override\n+    public double getValue() {\n+        if (stats.count < 2) {\n+            return Double.NaN;\n+        }\n+        long n = stats.count - 1;\n+        double meanDiff = stats.sum / stats.count;\n+        double variance = (stats.sumOfSqrs - ((stats.sum * stats.sum) / stats.count)) / stats.count;\n+        if (variance <= 0.0) {\n+            return meanDiff == 0.0 ? Double.NaN : 0.0;\n+        }\n+        double stdDiv = Math.sqrt(variance);\n+        double stdErr = stdDiv / Math.sqrt(n);\n+        double t = Math.abs(meanDiff / stdErr);\n+        TDistribution dist = new TDistribution(n);\n+        return dist.cumulativeProbability(-t) * tails;\n+    }\n+\n+    @Override\n+    public TTestState reduce(Stream<TTestState> states) {\n+        TTestStats.Reducer reducer = new TTestStats.Reducer();\n+        states.forEach(tTestState -> {\n+            PairedTTestState state = (PairedTTestState) tTestState;\n+            reducer.accept(state.stats);\n+            assert state.tails == tails;", "originalCommit": "e294c56f205ed1be7a30d0d1fd8271959994a08c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTE5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54469#discussion_r401901192", "bodyText": "I think we can move this inside the conditionals below?  Right now we'll end up growing the statsBuilder bigarray even if none of the documents end up satisfying the conditions (e.g. if we are unlucky and they all have only one of the two fields).\nThe size provided to grow() is the min size required, so it's ok to not call grow until we actually need a particular bucket ordinal (and then it will back-fill all the empty bucket ords essentially)", "author": "polyfractal", "createdAt": "2020-04-01T20:50:47Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/ttest/PairedTTestAggregator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.ttest;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\n+import org.elasticsearch.search.DocValueFormat;\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n+import org.elasticsearch.search.aggregations.metrics.CompensatedSum;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.MultiValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.analytics.ttest.TTestAggregationBuilder.A_FIELD;\n+import static org.elasticsearch.xpack.analytics.ttest.TTestAggregationBuilder.B_FIELD;\n+\n+public class PairedTTestAggregator extends TTestAggregator<PairedTTestState> {\n+    private TStatsBuilder statsBuilder;\n+\n+    PairedTTestAggregator(String name, MultiValuesSource.NumericMultiValuesSource valuesSources, int tails, DocValueFormat format,\n+                          SearchContext context, Aggregator parent, List<PipelineAggregator> pipelineAggregators,\n+                          Map<String, Object> metadata) throws IOException {\n+        super(name, valuesSources, tails, format, context, parent, pipelineAggregators, metadata);\n+        statsBuilder = new TStatsBuilder(context.bigArrays());\n+    }\n+\n+    @Override\n+    protected PairedTTestState getState(long bucket) {\n+        return new PairedTTestState(statsBuilder.get(bucket), tails);\n+    }\n+\n+    @Override\n+    protected PairedTTestState getEmptyState() {\n+        return new PairedTTestState(new TTestStats(0, 0, 0), tails);\n+    }\n+\n+    @Override\n+    protected long size() {\n+        return statsBuilder.getSize();\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+                                                final LeafBucketCollector sub) throws IOException {\n+        if (valuesSources == null) {\n+            return LeafBucketCollector.NO_OP_COLLECTOR;\n+        }\n+        final BigArrays bigArrays = context.bigArrays();\n+        final SortedNumericDoubleValues docAValues = valuesSources.getField(A_FIELD.getPreferredName(), ctx);\n+        final SortedNumericDoubleValues docBValues = valuesSources.getField(B_FIELD.getPreferredName(), ctx);\n+        final CompensatedSum compDiffSum = new CompensatedSum(0, 0);\n+        final CompensatedSum compDiffSumOfSqr = new CompensatedSum(0, 0);\n+\n+        return new LeafBucketCollectorBase(sub, docAValues) {\n+            @Override\n+            public void collect(int doc, long bucket) throws IOException {\n+                statsBuilder.grow(bigArrays, bucket + 1);", "originalCommit": "e294c56f205ed1be7a30d0d1fd8271959994a08c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMzk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54469#discussion_r401903966", "bodyText": "TBH, I'm not sure how expensive grow() is... I don't think it's very expensive so it might not matter.  But some aggs that have a lot of big arrays to manage will call BigArrays#overSize() method directly and then resize each of their arrays, instead of grow'ing each.\nStatsAggregator is a good example: https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/search/aggregations/metrics/StatsAggregator.java#L90-L95", "author": "polyfractal", "createdAt": "2020-04-01T20:56:13Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/ttest/TStatsBuilder.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.ttest;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.DoubleArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.search.aggregations.metrics.CompensatedSum;\n+\n+public class TStatsBuilder implements Releasable {\n+\n+    private LongArray counts;\n+    private DoubleArray sums;\n+    private DoubleArray compensations;\n+    private DoubleArray sumOfSqrs;\n+    private DoubleArray sumOfSqrCompensations;\n+\n+    TStatsBuilder(BigArrays bigArrays) {\n+        counts = bigArrays.newLongArray(1, true);\n+        sums = bigArrays.newDoubleArray(1, true);\n+        compensations = bigArrays.newDoubleArray(1, true);\n+        sumOfSqrs = bigArrays.newDoubleArray(1, true);\n+        sumOfSqrCompensations = bigArrays.newDoubleArray(1, true);\n+    }\n+\n+    public TTestStats get(long bucket) {\n+        return new TTestStats(counts.get(bucket), sums.get(bucket), sumOfSqrs.get(bucket));\n+    }\n+\n+    public long build(long bucket) {\n+        return counts.get(bucket);\n+    }\n+\n+    public long getSize() {\n+        return counts.size();\n+    }\n+\n+    public void grow(BigArrays bigArrays, long buckets) {\n+        counts = bigArrays.grow(counts, buckets);", "originalCommit": "e294c56f205ed1be7a30d0d1fd8271959994a08c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cf4e2390e145ec8b128701ee27f6fb27099aa005", "url": "https://github.com/elastic/elasticsearch/commit/cf4e2390e145ec8b128701ee27f6fb27099aa005", "message": "Address review comments and rename TStatsBuilder to TTestStatsBuilder", "committedDate": "2020-04-02T13:59:57Z", "type": "commit"}, {"oid": "ca94074b79cca8b83ec9fa3302ffaf2d049fec9a", "url": "https://github.com/elastic/elasticsearch/commit/ca94074b79cca8b83ec9fa3302ffaf2d049fec9a", "message": "Merge branch 'master' into issue-53692-t-test", "committedDate": "2020-04-02T14:23:49Z", "type": "commit"}, {"oid": "d6f3820a139fd7649d94f7c0f77d4b154acb9a09", "url": "https://github.com/elastic/elasticsearch/commit/d6f3820a139fd7649d94f7c0f77d4b154acb9a09", "message": "Address more review comments", "committedDate": "2020-04-02T14:33:38Z", "type": "commit"}, {"oid": "9d483584a673037fd5125266e14b1297f4ce694c", "url": "https://github.com/elastic/elasticsearch/commit/9d483584a673037fd5125266e14b1297f4ce694c", "message": "Merge branch 'master' into issue-53692-t-test", "committedDate": "2020-04-02T17:15:37Z", "type": "commit"}, {"oid": "33cfe919b924279d248a9a6c648bf950bb72da73", "url": "https://github.com/elastic/elasticsearch/commit/33cfe919b924279d248a9a6c648bf950bb72da73", "message": "Remove pipelines parameters after master merge", "committedDate": "2020-04-02T17:36:50Z", "type": "commit"}, {"oid": "5d52bfc101e693a1ce36e9510f02d2c12694b7f4", "url": "https://github.com/elastic/elasticsearch/commit/5d52bfc101e693a1ce36e9510f02d2c12694b7f4", "message": "Merge branch 'master' into issue-53692-t-test", "committedDate": "2020-04-03T14:07:01Z", "type": "commit"}]}