{"pr_number": 63333, "pr_title": "Add visitor pattern to the triangle tree", "pr_createdAt": "2020-10-06T14:31:30Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63333", "timeline": [{"oid": "d8bd2a3f87e5a4582a945bd1e0add168c58c83f4", "url": "https://github.com/elastic/elasticsearch/commit/d8bd2a3f87e5a4582a945bd1e0add168c58c83f4", "message": "Add visitor pattern to the triangle tree", "committedDate": "2020-10-06T14:26:16Z", "type": "commit"}, {"oid": "c1500e52d02884a2a507ce5de4f2c837de607b98", "url": "https://github.com/elastic/elasticsearch/commit/c1500e52d02884a2a507ce5de4f2c837de607b98", "message": "simplify doc writer", "committedDate": "2020-10-06T14:45:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM1NTIwNw==", "url": "https://github.com/elastic/elasticsearch/pull/63333#discussion_r500355207", "bodyText": "Here is where the meat of the PR is.", "author": "iverase", "createdAt": "2020-10-06T14:51:11Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/fielddata/TriangleTreeReader.java", "diffHunk": "@@ -7,412 +7,140 @@\n package org.elasticsearch.xpack.spatial.index.fielddata;\n \n import org.apache.lucene.store.ByteArrayDataInput;\n-import org.apache.lucene.util.BytesRef;\n-\n-import java.io.IOException;\n-\n-import static org.apache.lucene.geo.GeoUtils.orient;\n \n /**\n- * A tree reusable reader for a previous serialized {@link org.elasticsearch.geometry.Geometry} using\n+ * A tree reader for a previous serialized {@link org.elasticsearch.geometry.Geometry} using\n  * {@link TriangleTreeWriter}.\n  *\n- * This class supports checking bounding box\n- * relations against the serialized triangle tree.\n+ * The tree structure is navigated using a {@link Visitor}.\n  *\n- * -----------------------------------------\n- * |   The binary format of the tree       |\n- * -----------------------------------------\n- * -----------------------------------------  --\n- * |    centroid-x-coord (4 bytes)         |    |\n- * -----------------------------------------    |\n- * |    centroid-y-coord (4 bytes)         |    |\n- * -----------------------------------------    |\n- * |    DimensionalShapeType (1 byte)      |    | Centroid-related header\n- * -----------------------------------------    |\n- * |  Sum of weights (VLong 1-8 bytes)     |    |\n- * -----------------------------------------  --\n- * |         Extent (var-encoding)         |\n- * -----------------------------------------\n- * |         Triangle Tree                 |\n- * -----------------------------------------\n- * -----------------------------------------\n  */\n-public class TriangleTreeReader {\n-    private final ByteArrayDataInput input;\n-    private final CoordinateEncoder coordinateEncoder;\n-    private final Tile2D tile2D;\n-    private final Extent extent;\n-    private int treeOffset;\n-    private int docValueOffset;\n-\n-    public TriangleTreeReader(CoordinateEncoder coordinateEncoder) {\n-        this.coordinateEncoder = coordinateEncoder;\n-        this.tile2D = new Tile2D();\n-        this.extent = new Extent();\n-        this.input = new ByteArrayDataInput();\n-    }\n-\n-    public void reset(BytesRef bytesRef) throws IOException {\n-        this.input.reset(bytesRef.bytes, bytesRef.offset, bytesRef.length);\n-        docValueOffset = bytesRef.offset;\n-        treeOffset = 0;\n-    }\n+class TriangleTreeReader {\n \n-    /**\n-     * returns the bounding box of the geometry in the format [minX, maxX, minY, maxY].\n-     */\n-    public Extent getExtent() {\n-        if (treeOffset == 0) {\n-            getSumCentroidWeight(); // skip CENTROID_HEADER + var-long sum-weight\n-            Extent.readFromCompressed(input, extent);\n-            treeOffset = input.getPosition();\n-        } else {\n-            input.setPosition(treeOffset);\n-        }\n-        return extent;\n+    private TriangleTreeReader() {\n     }\n \n     /**\n-     * returns the X coordinate of the centroid.\n+     * Visit the Triangle tree using the {@link Visitor} provided.\n      */\n-    public double getCentroidX() {\n-        input.setPosition(docValueOffset + 0);\n-        return coordinateEncoder.decodeX(input.readInt());\n+    public static void visit(ByteArrayDataInput input, TriangleTreeReader.Visitor visitor, int thisMaxX, int thisMaxY) {\n+        visit(input, visitor, true, thisMaxX, thisMaxY, true);\n     }\n \n-    /**\n-     * returns the Y coordinate of the centroid.\n-     */\n-    public double getCentroidY() {\n-        input.setPosition(docValueOffset + 4);\n-        return coordinateEncoder.decodeY(input.readInt());\n-    }\n-\n-    public DimensionalShapeType getDimensionalShapeType() {\n-        input.setPosition(docValueOffset + 8);\n-        return DimensionalShapeType.readFrom(input);\n-    }\n-\n-    public double getSumCentroidWeight() {\n-        input.setPosition(docValueOffset + 9);\n-        return Double.longBitsToDouble(input.readVLong());\n-    }\n-\n-    /**\n-     * Compute the relation with the provided bounding box. If the result is CELL_INSIDE_QUERY\n-     * then the bounding box is within the shape.\n-     */\n-    public GeoRelation relateTile(int minX, int minY, int maxX, int maxY) {\n-        Extent extent = getExtent();\n-        int thisMaxX = extent.maxX();\n-        int thisMinX = extent.minX();\n-        int thisMaxY = extent.maxY();\n-        int thisMinY = extent.minY();\n-\n-        // exclude north and east boundary intersections with tiles from intersection consideration\n-        // for consistent tiling definition of shapes on the boundaries of tiles\n-        if ((thisMinX >= maxX || thisMaxX < minX || thisMinY > maxY || thisMaxY <= minY)) {\n-            // shapes are disjoint\n-            return GeoRelation.QUERY_DISJOINT;\n-        }\n-        if (minX <= thisMinX && maxX >= thisMaxX && minY <= thisMinY && maxY >= thisMaxY) {\n-            // the rectangle fully contains the shape\n-            return GeoRelation.QUERY_CROSSES;\n-        }\n-        // quick checks failed, need to traverse the tree\n-        GeoRelation rel = GeoRelation.QUERY_DISJOINT;\n-        tile2D.setValues(minX, maxX, minY, maxY);\n+    private static boolean visit(ByteArrayDataInput input, TriangleTreeReader.Visitor visitor,\n+                                 boolean splitX, int thisMaxX, int thisMaxY, boolean isRoot) {\n         byte metadata = input.readByte();\n+        int thisMinX;\n+        int thisMinY;\n         if ((metadata & 1 << 2) == 1 << 2) { // component in this node is a point\n             int x = Math.toIntExact(thisMaxX - input.readVLong());\n             int y = Math.toIntExact(thisMaxY - input.readVLong());\n-            if (tile2D.contains(x, y)) {\n-                return GeoRelation.QUERY_CROSSES;\n+            visitor.visitPoint(x, y);\n+            if (visitor.push() == false) {\n+                return false;\n             }\n             thisMinX = x;\n-        } else if ((metadata & 1 << 3) == 1 << 3) {  // component in this node is a line\n+            thisMinY = y;\n+        } else if ((metadata & 1 << 3) == 1 << 3) { // component in this node is a line\n             int aX = Math.toIntExact(thisMaxX - input.readVLong());\n             int aY = Math.toIntExact(thisMaxY - input.readVLong());\n             int bX = Math.toIntExact(thisMaxX - input.readVLong());\n             int bY = Math.toIntExact(thisMaxY - input.readVLong());\n-            if (tile2D.intersectsLine(aX, aY, bX, bY)) {\n-                return GeoRelation.QUERY_CROSSES;\n+            visitor.visitLine(aX, aY, bX, bY, metadata);\n+            if (visitor.push() == false) {\n+                return false;\n             }\n             thisMinX = aX;\n-        } else {  // component in this node is a triangle\n+            thisMinY = Math.min(aY, bY);\n+        } else { // component in this node is a triangle\n             int aX = Math.toIntExact(thisMaxX - input.readVLong());\n             int aY = Math.toIntExact(thisMaxY - input.readVLong());\n             int bX = Math.toIntExact(thisMaxX - input.readVLong());\n             int bY = Math.toIntExact(thisMaxY - input.readVLong());\n             int cX = Math.toIntExact(thisMaxX - input.readVLong());\n             int cY = Math.toIntExact(thisMaxY - input.readVLong());\n-            boolean ab = (metadata & 1 << 4) == 1 << 4;\n-            boolean bc = (metadata & 1 << 5) == 1 << 5;\n-            boolean ca = (metadata & 1 << 6) == 1 << 6;\n-            rel = tile2D.relateTriangle(aX, aY, ab, bX, bY, bc, cX, cY, ca);\n-            if (rel == GeoRelation.QUERY_CROSSES) {\n-                return GeoRelation.QUERY_CROSSES;\n+            visitor.visitTriangle(aX, aY, bX, bY, cX, cY, metadata);\n+            if (visitor.push() == false) {\n+                return false;\n             }\n             thisMinX = aX;\n+            thisMinY = Math.min(Math.min(aY, bY), cY);\n         }\n         if ((metadata & 1 << 0) == 1 << 0) { // left != null\n-            GeoRelation left = relateTile(tile2D, false, thisMaxX, thisMaxY);\n-            if (left == GeoRelation.QUERY_CROSSES) {\n-                return GeoRelation.QUERY_CROSSES;\n-            } else if (left == GeoRelation.QUERY_INSIDE) {\n-                rel = left;\n+            if (pushLeft(input, visitor, thisMaxX, thisMaxY, splitX) == false) {\n+                return false;\n             }\n         }\n         if ((metadata & 1 << 1) == 1 << 1) { // right != null\n-            if (tile2D.maxX >= thisMinX) {\n-                GeoRelation right = relateTile(tile2D, false, thisMaxX, thisMaxY);\n-                if (right == GeoRelation.QUERY_CROSSES) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                } else if (right == GeoRelation.QUERY_INSIDE) {\n-                    rel = right;\n-                }\n+            // root node does not have a size\n+            int rightSize = isRoot ? 0 : input.readVInt();\n+            if (pushRight(input, visitor, thisMaxX, thisMaxY, thisMinX, thisMinY, splitX, rightSize) == false) {\n+                return false;\n             }\n         }\n-\n-        return rel;\n+        return visitor.push();\n     }\n \n-    private GeoRelation relateTile(Tile2D tile2D, boolean splitX, int parentMaxX, int parentMaxY) {\n-        int thisMaxX = Math.toIntExact(parentMaxX - input.readVLong());\n-        int thisMaxY = Math.toIntExact(parentMaxY - input.readVLong());\n-        GeoRelation rel = GeoRelation.QUERY_DISJOINT;\n+    private static boolean pushLeft(ByteArrayDataInput input, TriangleTreeReader.Visitor visitor,\n+                                    int thisMaxX, int thisMaxY, boolean splitX) {\n+        int nextMaxX = Math.toIntExact(thisMaxX - input.readVLong());\n+        int nextMaxY = Math.toIntExact(thisMaxY - input.readVLong());\n         int size = input.readVInt();\n-        if (tile2D.minY <= thisMaxY && tile2D.minX <= thisMaxX) {\n-            byte metadata = input.readByte();\n-            int thisMinX;\n-            int thisMinY;\n-            if ((metadata & 1 << 2) == 1 << 2) { // component in this node is a point\n-                int x = Math.toIntExact(thisMaxX - input.readVLong());\n-                int y = Math.toIntExact(thisMaxY - input.readVLong());\n-                if (tile2D.contains(x, y)) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                }\n-                thisMinX = x;\n-                thisMinY = y;\n-            } else if ((metadata & 1 << 3) == 1 << 3) { // component in this node is a line\n-                int aX = Math.toIntExact(thisMaxX - input.readVLong());\n-                int aY = Math.toIntExact(thisMaxY - input.readVLong());\n-                int bX = Math.toIntExact(thisMaxX - input.readVLong());\n-                int bY = Math.toIntExact(thisMaxY - input.readVLong());\n-                if (tile2D.intersectsLine(aX, aY, bX, bY)) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                }\n-                thisMinX = aX;\n-                thisMinY = Math.min(aY, bY);\n-            } else { // component in this node is a triangle\n-                int aX = Math.toIntExact(thisMaxX - input.readVLong());\n-                int aY = Math.toIntExact(thisMaxY - input.readVLong());\n-                int bX = Math.toIntExact(thisMaxX - input.readVLong());\n-                int bY = Math.toIntExact(thisMaxY - input.readVLong());\n-                int cX = Math.toIntExact(thisMaxX - input.readVLong());\n-                int cY = Math.toIntExact(thisMaxY - input.readVLong());\n-                boolean ab = (metadata & 1 << 4) == 1 << 4;\n-                boolean bc = (metadata & 1 << 5) == 1 << 5;\n-                boolean ca = (metadata & 1 << 6) == 1 << 6;\n-                rel = tile2D.relateTriangle(aX, aY, ab, bX, bY, bc, cX, cY, ca);\n-                if (rel == GeoRelation.QUERY_CROSSES) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                }\n-                thisMinX = aX;\n-                thisMinY = Math.min(Math.min(aY, bY), cY);\n-            }\n-            if ((metadata & 1 << 0) == 1 << 0) { // left != null\n-                GeoRelation left = relateTile(tile2D, !splitX, thisMaxX, thisMaxY);\n-                if (left == GeoRelation.QUERY_CROSSES) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                } else if (left == GeoRelation.QUERY_INSIDE) {\n-                    rel = left;\n-                }\n-            }\n-            if ((metadata & 1 << 1) == 1 << 1) { // right != null\n-                int rightSize = input.readVInt();\n-                if ((splitX == false && tile2D.maxY >= thisMinY) || (splitX && tile2D.maxX >= thisMinX)) {\n-                    GeoRelation right = relateTile(tile2D, !splitX, thisMaxX, thisMaxY);\n-                    if (right == GeoRelation.QUERY_CROSSES) {\n-                        return GeoRelation.QUERY_CROSSES;\n-                    } else if (right == GeoRelation.QUERY_INSIDE) {\n-                        rel = right;\n-                    }\n-                } else {\n-                    input.skipBytes(rightSize);\n-                }\n-            }\n+        if (visitor.push(nextMaxX, nextMaxY)) {\n+            return visit(input, visitor, !splitX, nextMaxX, nextMaxY, false);\n         } else {\n             input.skipBytes(size);\n+            return visitor.push();\n         }\n-        return rel;\n     }\n \n-    private static class Tile2D {\n-\n-        protected int minX;\n-        protected int maxX;\n-        protected int minY;\n-        protected int maxY;\n-\n-        Tile2D() {\n-        }\n-\n-        private void setValues(int minX, int maxX, int minY, int maxY) {\n-            this.minX = minX;\n-            this.maxX = maxX;\n-            this.minY = minY;\n-            this.maxY = maxY;\n-        }\n-\n-        /**\n-         * Checks if the rectangle contains the provided point\n-         **/\n-        public boolean contains(int x, int y) {\n-            return (x <= minX || x > maxX || y < minY || y >= maxY) == false;\n-        }\n-\n-        /**\n-         * Checks if the rectangle intersects the provided triangle\n-         **/\n-        private boolean intersectsLine(int aX, int aY, int bX, int bY) {\n-            // 1. query contains any triangle points\n-            if (contains(aX, aY) || contains(bX, bY)) {\n-                return true;\n-            }\n-\n-            // compute bounding box of triangle\n-            int tMinX = StrictMath.min(aX, bX);\n-            int tMaxX = StrictMath.max(aX, bX);\n-            int tMinY = StrictMath.min(aY, bY);\n-            int tMaxY = StrictMath.max(aY, bY);\n-\n-            // 2. check bounding boxes are disjoint\n-            if (tMaxX <= minX || tMinX > maxX || tMinY > maxY || tMaxY <= minY) {\n-                return false;\n-            }\n-\n-            // 4. last ditch effort: check crossings\n-            if (edgeIntersectsQuery(aX, aY, bX, bY)) {\n-                return true;\n+    private static boolean pushRight(ByteArrayDataInput input, TriangleTreeReader.Visitor visitor, int thisMaxX,\n+                                     int thisMaxY, int thisMinX, int thisMinY, boolean splitX, int rightSize) {\n+        if ((splitX == false && visitor.pushY(thisMinY)) || (splitX && visitor.pushX(thisMinX))) {\n+            int nextMaxX = Math.toIntExact(thisMaxX - input.readVLong());\n+            int nextMaxY = Math.toIntExact(thisMaxY - input.readVLong());\n+            int size = input.readVInt();\n+            if (visitor.push(nextMaxX, nextMaxY)) {\n+                return visit(input, visitor, !splitX, nextMaxX, nextMaxY, false);\n+            } else {\n+                input.skipBytes(size);\n             }\n-            return false;\n+        } else {\n+            input.skipBytes(rightSize);\n         }\n+        return visitor.push();\n+    }\n \n-        /**\n-         * Checks if the rectangle intersects the provided triangle\n-         **/\n-        private GeoRelation relateTriangle(int aX, int aY, boolean ab, int bX, int bY, boolean bc, int cX, int cY, boolean ca) {\n-            // compute bounding box of triangle\n-            int tMinX = StrictMath.min(StrictMath.min(aX, bX), cX);\n-            int tMaxX = StrictMath.max(StrictMath.max(aX, bX), cX);\n-            int tMinY = StrictMath.min(StrictMath.min(aY, bY), cY);\n-            int tMaxY = StrictMath.max(StrictMath.max(aY, bY), cY);\n-\n-            // 1. check bounding boxes are disjoint, where north and east boundaries are not considered as crossing\n-            if (tMaxX <= minX || tMinX > maxX || tMinY > maxY || tMaxY <= minY) {\n-                return GeoRelation.QUERY_DISJOINT;\n-            }\n-\n-            // 2. query contains any triangle points\n-            if (contains(aX, aY) || contains(bX, bY) || contains(cX, cY)) {\n-                return GeoRelation.QUERY_CROSSES;\n-            }\n-\n-            boolean within = false;\n-            if (edgeIntersectsQuery(aX, aY, bX, bY)) {\n-                if (ab) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                }\n-                within = true;\n-            }\n-\n-            // right\n-            if (edgeIntersectsQuery(bX, bY, cX, cY)) {\n-                if (bc) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                }\n-                within = true;\n-            }\n-\n-            if (edgeIntersectsQuery(cX, cY, aX, aY)) {\n-                if (ca) {\n-                    return GeoRelation.QUERY_CROSSES;\n-                }\n-                within = true;\n-            }\n+    /** Visitor for triangle interval tree */\n+   interface Visitor {", "originalCommit": "c1500e52d02884a2a507ce5de4f2c837de607b98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "484569f49e00fffb69d02af6a2c98952562a0bc4", "url": "https://github.com/elastic/elasticsearch/commit/484569f49e00fffb69d02af6a2c98952562a0bc4", "message": "make methods protected", "committedDate": "2020-10-06T15:02:22Z", "type": "commit"}, {"oid": "b5d3f0cc8637b13a6f141042d97a6ed238b4595b", "url": "https://github.com/elastic/elasticsearch/commit/b5d3f0cc8637b13a6f141042d97a6ed238b4595b", "message": "remove unused field", "committedDate": "2020-10-06T15:09:15Z", "type": "commit"}, {"oid": "194d4c2b59071d8bc409affd15fd04a3d8a4fd32", "url": "https://github.com/elastic/elasticsearch/commit/194d4c2b59071d8bc409affd15fd04a3d8a4fd32", "message": "Merge branch 'master' into triangleTreeVisitor", "committedDate": "2020-10-21T13:18:29Z", "type": "commit"}, {"oid": "ddf564853c1f043a0308510b0a5b4eaf3186f6fc", "url": "https://github.com/elastic/elasticsearch/commit/ddf564853c1f043a0308510b0a5b4eaf3186f6fc", "message": "Merge branch 'master' into triangleTreeVisitor", "committedDate": "2020-10-22T08:30:12Z", "type": "commit"}]}