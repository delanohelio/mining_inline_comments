{"pr_number": 54020, "pr_title": "EQL: Add wildcard function", "pr_createdAt": "2020-03-23T20:23:35Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54020", "timeline": [{"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "url": "https://github.com/elastic/elasticsearch/commit/c0c7995ed5a01269bcd28fe68efd28e015494fb0", "message": "EQL: Add wildcard function", "committedDate": "2020-03-23T20:18:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396771793", "bodyText": "java.* packages should be imported - the only reason when a class should be fully qualified if there's a class name clash.", "author": "costin", "createdAt": "2020-03-23T21:37:02Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwOTE4MA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396809180", "bodyText": "thanks. I think this was an oversight on my part using IntelliJ's 'automatically import class' functionality. cleaned this up with the array initialization", "author": "rw-access", "createdAt": "2020-03-23T23:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772168", "bodyText": "Easier to do Arrays.asList(args..) directly in the constructor", "author": "costin", "createdAt": "2020-03-23T21:37:52Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwODk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396808991", "bodyText": "I tried to find a way to get src, then all of patterns and couldn't find a good way.\nArrays.asList(src, patterns) didn't seem to work. I'm definitely open to learning a better way", "author": "rw-access", "createdAt": "2020-03-23T23:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772806", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(source, getArguments(field, patterns));\n          \n          \n            \n                    super(source, Arrays.asList(field, patterns));\n          \n      \n    \n    \n  \n\nlike the rest of the subclasses.", "author": "costin", "createdAt": "2020-03-23T21:39:09Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwOTM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396809366", "bodyText": "doesn't seem to work if the first value is a T, and the next is a List<T>", "author": "rw-access", "createdAt": "2020-03-23T23:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0MDcxMg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r399240712", "bodyText": "CollectionUtils.combine(patterns, field) or if you want to preserve the order:\nCollectionUtils.combine(singletonList(field), patterns)", "author": "costin", "createdAt": "2020-03-27T12:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MjgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396782812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean foldable = field.foldable();\n          \n          \n            \n                    for (Expression p : patterns) {\n          \n          \n            \n                        foldable = foldable && p.foldable();\n          \n          \n            \n                    }\n          \n          \n            \n                    return foldable;\n          \n          \n            \n                    return Expressions.foldable(arguments());", "author": "costin", "createdAt": "2020-03-23T22:00:57Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        boolean foldable = field.foldable();\n+        for (Expression p : patterns) {\n+            foldable = foldable && p.foldable();\n+        }\n+        return foldable;", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396783925", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Expression asLikes = asLikes();\n          \n          \n            \n                    if (asLikes instanceof Like) {\n          \n          \n            \n                        return ((Like) asLikes).makePipe();\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return ((Or) asLikes).makePipe();\n          \n          \n            \n                    }\n          \n          \n            \n                return asLike().makePipe();", "author": "costin", "createdAt": "2020-03-23T22:03:24Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjUxMw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792513", "bodyText": "This doesn't seem to be needed and in fact the implementation should be throw new EqlIllegalArgumentException(\"should not call this method\")", "author": "costin", "createdAt": "2020-03-23T22:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMjkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396812901", "bodyText": "awesome. that was my hope.\nI still need to keep fold() though for the optimizer, right?", "author": "rw-access", "createdAt": "2020-03-23T23:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDI2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784265", "bodyText": "Since it's always a Like or an Or, return a ScalarFunction instead. Also the method should be private.", "author": "costin", "createdAt": "2020-03-23T22:04:09Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxOTUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396819516", "bodyText": "Currently accessing via the Optimizer, which is why it was left public:\nhttps://github.com/elastic/elasticsearch/pull/54020/files#diff-cb6f05d0222f3291ea3df5d33525d6f6R71", "author": "rw-access", "createdAt": "2020-03-23T23:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDM5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784395", "bodyText": "Extra new line.", "author": "costin", "createdAt": "2020-03-23T22:04:29Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4ODc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396788782", "bodyText": "Please implement the methods in the order of the super class (which is not alphabetical) which roughly is:\nconstructor\nnodeInfo/replaceChildren\ntype resolution\ngetters\ndatatype/nullable\nfoldable/fold\nscripting & co\nequals/hash", "author": "costin", "createdAt": "2020-03-23T22:14:36Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjI1MA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792250", "bodyText": "Since the optimizer is replacing this function, this method will never be called but rather Like and Or directly", "author": "costin", "createdAt": "2020-03-23T22:22:23Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MzEwMA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396793100", "bodyText": "Make the class abstract or better yet final + private constructor to prevent instantiation/inheritance.", "author": "costin", "createdAt": "2020-03-23T22:24:18Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/utils/StringUtils.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.utils;\n+\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.LikePattern;\n+\n+public class StringUtils {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795034", "bodyText": "How many arguments does wildcard expect?", "author": "costin", "createdAt": "2020-03-23T22:28:46Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "diffHunk": "@@ -421,4 +421,26 @@ public static FunctionDefinition def(Class<? extends Function> function, Functio\n     protected interface CastFunctionBuilder<T> {\n         T build(Source source, Expression expression, DataType dataType);\n     }\n+\n+    @SuppressWarnings(\"overloads\")  // These are ambiguous if you aren't using ctor references but we always do\n+    public static <T extends Function> FunctionDefinition def(Class<T> function,", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMzI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396813255", "bodyText": "at least two, but it's unbounded in the maximum number\nhttps://eql.readthedocs.io/en/latest/query-guide/functions.html#wildcard", "author": "rw-access", "createdAt": "2020-03-23T23:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795064", "bodyText": "Why?", "author": "costin", "createdAt": "2020-03-23T22:28:51Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/logical/BinaryLogic.java", "diffHunk": "@@ -34,7 +34,7 @@ protected TypeResolution resolveInputType(Expression e, Expressions.ParamOrdinal\n     }\n \n     @Override\n-    protected Pipe makePipe() {\n+    public Pipe makePipe() {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMzY3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396813675", "bodyText": "I'll set this back. I was using it within Wildcard.make_pipe, but since that is unreachable, I'll set this back.", "author": "rw-access", "createdAt": "2020-03-23T23:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA2NA=="}], "type": "inlineReview"}, {"oid": "dea1f7baa1fe1cac55fc65e5246af907cb446894", "url": "https://github.com/elastic/elasticsearch/commit/dea1f7baa1fe1cac55fc65e5246af907cb446894", "message": "EQL: Cleanup Wildcard.getArguments", "committedDate": "2020-03-23T22:59:54Z", "type": "commit"}, {"oid": "d87361de121acfc972776d8c173531a40fe7a8a7", "url": "https://github.com/elastic/elasticsearch/commit/d87361de121acfc972776d8c173531a40fe7a8a7", "message": "EQL: Cleanup Wildcard and rearrange methods", "committedDate": "2020-03-23T23:20:48Z", "type": "commit"}, {"oid": "3826eac1904ef22a57b15fa0243fd5fcb497af3e", "url": "https://github.com/elastic/elasticsearch/commit/3826eac1904ef22a57b15fa0243fd5fcb497af3e", "message": "EQL: Wildcard newline lint", "committedDate": "2020-03-23T23:23:43Z", "type": "commit"}, {"oid": "f93d2975112e81d513b6ed835eded45485220846", "url": "https://github.com/elastic/elasticsearch/commit/f93d2975112e81d513b6ed835eded45485220846", "message": "EQL: Make StringUtils function final", "committedDate": "2020-03-23T23:37:51Z", "type": "commit"}, {"oid": "78f4fbdb1c342c729a684e9758994e14c18d367c", "url": "https://github.com/elastic/elasticsearch/commit/78f4fbdb1c342c729a684e9758994e14c18d367c", "message": "EQL: Make Wildcard.asLikes return ScalarFunction", "committedDate": "2020-03-23T23:43:45Z", "type": "commit"}, {"oid": "c93b67c11694dcd2f10cdf5854e00a17192a1b74", "url": "https://github.com/elastic/elasticsearch/commit/c93b67c11694dcd2f10cdf5854e00a17192a1b74", "message": "Merge remote-tracking branch 'origin/master' into eql/wildcard-function", "committedDate": "2020-03-24T15:02:59Z", "type": "commit"}, {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "url": "https://github.com/elastic/elasticsearch/commit/169245d5d956f6ef65a598cecae15a4b5352a4a3", "message": "QL: Restore BinaryLogic.java", "committedDate": "2020-03-24T15:04:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNzAwNw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397237007", "bodyText": "Isn't wildcard a \"string function\"? If so, it should belong to the FunctionDefinition array that, also, has substring in it. In SQL we were grouping these functions by their type: string, grouping, math, conditional, date etc.", "author": "astefan", "createdAt": "2020-03-24T15:21:11Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -17,14 +18,17 @@\n     public EqlFunctionRegistry() {\n         super(functions());\n     }\n-    \n+\n     private static FunctionDefinition[][] functions() {\n         return new FunctionDefinition[][] {\n         // Scalar functions\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n             },\n+            new FunctionDefinition[] {\n+                def(Wildcard.class, Wildcard::new, \"wildcard\"),", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNjk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397426963", "bodyText": "oh right, good catch", "author": "rw-access", "createdAt": "2020-03-24T20:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzODU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397238581", "bodyText": "childrenResolved() == false", "author": "astefan", "createdAt": "2020-03-24T15:23:16Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397243661", "bodyText": "Shouldn't the field be, also, foldable? (ie return Expressions.foldable(children());)", "author": "astefan", "createdAt": "2020-03-24T15:29:36Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Njc5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397296796", "bodyText": "Since wildcard is converted to a bunch of LIKEs, I'm wondering if foldable() shouldn't fall back to the result of the wildcard -> LIKEs transformation foldable() functionality. Basically the Or.foldable().", "author": "astefan", "createdAt": "2020-03-24T16:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNzM0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397427346", "bodyText": "arguments() = field + patterns()\narguments() comes from the super and is identical to children()\nI'll swap to children() since that's more obvious", "author": "rw-access", "createdAt": "2020-03-24T20:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Mjg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397292890", "bodyText": "I don't think isStringAndExact is correct here... \"exact\" refers to a field being of type keyword or having a sub-field of type keyword basically. isString should be enough imo.\nAlso, shouldn't the p.foldable() == false (comparison against variables basically) check be before this one?", "author": "astefan", "createdAt": "2020-03-24T16:31:28Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMzM3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397303377", "bodyText": "Maybe move this method to org.elasticsearch.xpack.ql.util.CollectionUtils and make it more generic?", "author": "astefan", "createdAt": "2020-03-24T16:45:23Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asLikes().fold();\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.makePipe() should not be called directly\");\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.asScript() should not be called directly\");\n+    }\n+\n+    public ScalarFunction asLikes() {\n+        ScalarFunction result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static List<Expression> toArguments(Expression src, List<Expression> patterns) {", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzIzMw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397843233", "bodyText": "saw this kind fo construct used in few places\nCollectionUtils.combine(singletonList(src), patterns))", "author": "aleksmaus", "createdAt": "2020-03-25T13:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMzM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwNDcwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397304705", "bodyText": "return e instanceof Wildcard ? ((Wildcard) e).asLikes() : e; as a shorter (hopefully more elegant) variant?", "author": "astefan", "createdAt": "2020-03-24T16:46:58Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -60,6 +62,20 @@ public LogicalPlan optimize(LogicalPlan verified) {\n     }\n \n \n+    private static class ReplaceWildcardFunction extends OptimizerRule<Filter> {\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                if (e instanceof Wildcard) {\n+                    e = ((Wildcard) e).asLikes();\n+                }\n+\n+                return e;", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzkxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397317911", "bodyText": "I think there are other error messages to check with wildcard: the fact that the field needs to be string and exact and, also, that the \"patterns\" should be all strings, no?", "author": "astefan", "createdAt": "2020-03-24T17:04:51Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -22,4 +24,19 @@ public void testPropertyEquationInClauseFilterUnsupported() {\n         String msg = e.getMessage();\n         assertEquals(\"Line 1:52: Comparisons against variables are not (currently) supported; offender [parent_process_name] in [==]\", msg);\n     }\n+\n+    public void testWildcardNotEnoughArguments() {", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c7e1475a2962cb62776fe4897f6222dba390cc2", "url": "https://github.com/elastic/elasticsearch/commit/5c7e1475a2962cb62776fe4897f6222dba390cc2", "message": "Merge branch 'master' into eql/wildcard-function", "committedDate": "2020-03-24T20:13:15Z", "type": "commit"}, {"oid": "e12a60c5f36e263062a7ed6679e75b122f93c721", "url": "https://github.com/elastic/elasticsearch/commit/e12a60c5f36e263062a7ed6679e75b122f93c721", "message": "EQL: Add Wildcard PR feedback", "committedDate": "2020-03-24T20:27:15Z", "type": "commit"}, {"oid": "e12a60c5f36e263062a7ed6679e75b122f93c721", "url": "https://github.com/elastic/elasticsearch/commit/e12a60c5f36e263062a7ed6679e75b122f93c721", "message": "EQL: Add Wildcard PR feedback", "committedDate": "2020-03-24T20:27:15Z", "type": "forcePushed"}, {"oid": "502ca88d0430d8c252e0c7c2b63d1d259f9dd4e0", "url": "https://github.com/elastic/elasticsearch/commit/502ca88d0430d8c252e0c7c2b63d1d259f9dd4e0", "message": "EQL: Add Wildcard verification tests", "committedDate": "2020-03-24T21:03:44Z", "type": "commit"}, {"oid": "90dc8e035aed864c4dbd247b94301412f1ae4fb1", "url": "https://github.com/elastic/elasticsearch/commit/90dc8e035aed864c4dbd247b94301412f1ae4fb1", "message": "EQL: Switch wildcard to isFoldable test", "committedDate": "2020-03-24T21:25:10Z", "type": "commit"}, {"oid": "d482c472d05af7220ce1896e323deb30769b05f8", "url": "https://github.com/elastic/elasticsearch/commit/d482c472d05af7220ce1896e323deb30769b05f8", "message": "EQL: Change wildcard test to numeric field", "committedDate": "2020-03-24T21:52:53Z", "type": "commit"}, {"oid": "285582f53796dbbafda6c55e5fde528c6bffa740", "url": "https://github.com/elastic/elasticsearch/commit/285582f53796dbbafda6c55e5fde528c6bffa740", "message": "EQL: Remove Wildcard.get_arguments", "committedDate": "2020-03-25T14:53:06Z", "type": "commit"}, {"oid": "167c13a954a21809fce72c602d1c9aee0efa1790", "url": "https://github.com/elastic/elasticsearch/commit/167c13a954a21809fce72c602d1c9aee0efa1790", "message": "Merge remote-tracking branch 'origin/master' into eql/wildcard-function", "committedDate": "2020-03-30T20:21:20Z", "type": "commit"}, {"oid": "d3b1dd1747ddc7c5d663dde21e1bc0a0d99f95a7", "url": "https://github.com/elastic/elasticsearch/commit/d3b1dd1747ddc7c5d663dde21e1bc0a0d99f95a7", "message": "Merge branch 'master' into eql/wildcard-function", "committedDate": "2020-04-02T14:36:38Z", "type": "commit"}]}