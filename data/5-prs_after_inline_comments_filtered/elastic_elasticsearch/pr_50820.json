{"pr_number": 50820, "pr_title": "Refresh cached phase policy definition if possible on new poli\u2026", "pr_createdAt": "2020-01-09T20:43:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50820", "timeline": [{"oid": "a7a2000a30ae561e970015f545fcbe9a0221f444", "url": "https://github.com/elastic/elasticsearch/commit/a7a2000a30ae561e970015f545fcbe9a0221f444", "message": "Refresh cached phase policy definition if possible on new policy\n\nThere are some cases when updating a policy does not change the\nstructure in a significant way. In these cases, we can reread the\npolicy definition for any indices using the updated policy.\n\nThis commit adds this refreshing to the `TransportPutLifecycleAction`\nto allow this. It allows us to do things like change the configuration\nvalues for a particular step, even when on that step (for example,\nchanging the rollover criteria while on the `check-rollover-ready` step).\n\nThere are more cases where the phase definition can be reread that just\nthe ones checked here (for example, removing an action that has already\nbeen passed), and those will be added in subsequent work.\n\nRelates to #48431", "committedDate": "2020-01-09T20:42:33Z", "type": "commit"}, {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "url": "https://github.com/elastic/elasticsearch/commit/3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "message": "Don't double-build cluster state", "committedDate": "2020-01-09T21:59:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTIyMA==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365779220", "bodyText": "would it be clearer to rename this to isIndexPolicyUpdatable or indexPolicyCanBeSafelyUpdated? (to point out we're only looking at the index's ILM policy as opposed to more)", "author": "andreidan", "createdAt": "2020-01-13T12:31:17Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,", "originalCommit": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MjQ3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365892477", "bodyText": "The policy itself isn't really being updated though, only the index's metadata is, I could maybe change it to isIndexPhaseDefinitionUpdatable if that seems better to you?", "author": "dakrone", "createdAt": "2020-01-13T16:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwODI0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365908241", "bodyText": "To me this would be clearer, thanks Lee", "author": "andreidan", "createdAt": "2020-01-13T16:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNDE0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365814146", "bodyText": "is passing null to toSteps safe? (I think it should only be used at execution time, but given that it depends on each action implementing LifecycleAction.toSteps and doing \"the right thing\" this makes me a bit nervous). Would it make sense to update the LifecyclePolicy/LifecyleAction docs to state that the client is nullable (annotate it as well) and maybe add some tests for the actions to make sure the steps are built correctly?", "author": "andreidan", "createdAt": "2020-01-13T13:52:35Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()", "originalCommit": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5NTMzNA==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365895334", "bodyText": "I would be really concerned if the client were used in the actual toSteps method, but you're right, it is possible that it could happen. I can update this to pass the actual Client object instead of null here.", "author": "dakrone", "createdAt": "2020-01-13T16:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNDE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNTg2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365815863", "bodyText": "nit (maybe just personal preference so feel free to ignore) but phaseExecutionInfo is more readble to me (phaseExecutionInfoJson too)", "author": "andreidan", "createdAt": "2020-01-13T13:56:00Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        if (newStepKeys.contains(currentStepKey) == false) {\n+            // The index is on a step that doesn't exist in the new policy, we\n+            // can't safely re-read the JSON\n+            logger.debug(\"[{}] updated policy [{}] does not contain the current step key [{}], so the policy phase will not be refreshed\",\n+                index, policyId, currentStepKey);\n+            return false;\n+        }\n+\n+        final String phaseDef = executionState.getPhaseDefinition();\n+        final Set<Step.StepKey> oldStepKeys = readStepKeys(xContentRegistry, phaseDef, currentPhase);\n+        if (oldStepKeys == null) {\n+            logger.debug(\"[{}] unable to parse phase definition for cached policy [{}], policy phase will not be refreshed\",\n+                index, policyId);\n+            return false;\n+        }\n+\n+        final Set<Step.StepKey> oldPhaseStepKeys = oldStepKeys.stream()\n+            .filter(sk -> currentPhase.equals(sk.getPhase()))\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        final PhaseExecutionInfo pei = new PhaseExecutionInfo(policyId, newPolicy.getPhases().get(currentPhase), 1L, 1L);", "originalCommit": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNzMxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365817315", "bodyText": "can we merge this log and the return statement into the else branch above?", "author": "andreidan", "createdAt": "2020-01-13T13:59:00Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        if (newStepKeys.contains(currentStepKey) == false) {\n+            // The index is on a step that doesn't exist in the new policy, we\n+            // can't safely re-read the JSON\n+            logger.debug(\"[{}] updated policy [{}] does not contain the current step key [{}], so the policy phase will not be refreshed\",\n+                index, policyId, currentStepKey);\n+            return false;\n+        }\n+\n+        final String phaseDef = executionState.getPhaseDefinition();\n+        final Set<Step.StepKey> oldStepKeys = readStepKeys(xContentRegistry, phaseDef, currentPhase);\n+        if (oldStepKeys == null) {\n+            logger.debug(\"[{}] unable to parse phase definition for cached policy [{}], policy phase will not be refreshed\",\n+                index, policyId);\n+            return false;\n+        }\n+\n+        final Set<Step.StepKey> oldPhaseStepKeys = oldStepKeys.stream()\n+            .filter(sk -> currentPhase.equals(sk.getPhase()))\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        final PhaseExecutionInfo pei = new PhaseExecutionInfo(policyId, newPolicy.getPhases().get(currentPhase), 1L, 1L);\n+        final String peiJson = Strings.toString(pei);\n+\n+        final Set<Step.StepKey> newPhaseStepKeys = readStepKeys(xContentRegistry, peiJson, currentPhase);\n+        if (newPhaseStepKeys == null) {\n+            logger.debug(new ParameterizedMessage(\"[{}] unable to parse phase definition for policy [{}] \" +\n+                \"to determine if it could be refreshed\", index, policyId));\n+            return false;\n+        }\n+\n+        if (newPhaseStepKeys.equals(oldPhaseStepKeys)) {\n+            // The new and old phase have the same stepkeys for this current phase, nothing of note has been changed\n+            logger.debug(\"[{}] updated policy [{}] contains the same phase step keys and can be refreshed\", index, policyId);\n+            return true;\n+        } else {\n+            logger.debug(\"[{}] updated policy [{}] has different phase step keys. old: {}, new: {}\",\n+                index, policyId, oldPhaseStepKeys, newPhaseStepKeys);\n+        }\n+\n+        logger.debug(\"[{}] updated policy [{}] will NOT refresh phase definition as it differs too greatly\", index, policyId);", "originalCommit": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxOTg3NA==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365819874", "bodyText": "this comment is a bit confusing as it implies we will not be allowing the update as there is nothing to update. Can we please update it to reflect that we only allow updating of existing steps?", "author": "andreidan", "createdAt": "2020-01-13T14:04:19Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        if (newStepKeys.contains(currentStepKey) == false) {\n+            // The index is on a step that doesn't exist in the new policy, we\n+            // can't safely re-read the JSON\n+            logger.debug(\"[{}] updated policy [{}] does not contain the current step key [{}], so the policy phase will not be refreshed\",\n+                index, policyId, currentStepKey);\n+            return false;\n+        }\n+\n+        final String phaseDef = executionState.getPhaseDefinition();\n+        final Set<Step.StepKey> oldStepKeys = readStepKeys(xContentRegistry, phaseDef, currentPhase);\n+        if (oldStepKeys == null) {\n+            logger.debug(\"[{}] unable to parse phase definition for cached policy [{}], policy phase will not be refreshed\",\n+                index, policyId);\n+            return false;\n+        }\n+\n+        final Set<Step.StepKey> oldPhaseStepKeys = oldStepKeys.stream()\n+            .filter(sk -> currentPhase.equals(sk.getPhase()))\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        final PhaseExecutionInfo pei = new PhaseExecutionInfo(policyId, newPolicy.getPhases().get(currentPhase), 1L, 1L);\n+        final String peiJson = Strings.toString(pei);\n+\n+        final Set<Step.StepKey> newPhaseStepKeys = readStepKeys(xContentRegistry, peiJson, currentPhase);\n+        if (newPhaseStepKeys == null) {\n+            logger.debug(new ParameterizedMessage(\"[{}] unable to parse phase definition for policy [{}] \" +\n+                \"to determine if it could be refreshed\", index, policyId));\n+            return false;\n+        }\n+\n+        if (newPhaseStepKeys.equals(oldPhaseStepKeys)) {\n+            // The new and old phase have the same stepkeys for this current phase, nothing of note has been changed", "originalCommit": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyMTUwMA==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365821500", "bodyText": "Why don't we allow the update of a policy if it's on the ERROR step? would it make sense to allow updating a policy even if on the error step? (I'm guessing this could be a good way to correct possible typos or such in the policy definition that are only caught at runtime - ie. wait-for-snapshot for a wrongly typed slm policy name)", "author": "andreidan", "createdAt": "2020-01-13T14:07:28Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step", "originalCommit": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MTg5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365891897", "bodyText": "The ERROR step automatically refreshes the JSON when it's retried (either manually or automatically). I wanted not to refresh it on the ERROR step because otherwise the actual exception stored in the lifecycle execution state would reference a phase policy definition that could be a newer version than was executed (a user should be able to refer to the definition where the error occurred)", "author": "dakrone", "createdAt": "2020-01-13T16:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyMTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwNzYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365907635", "bodyText": "Makes sense, thanks for the clarification", "author": "andreidan", "createdAt": "2020-01-13T16:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyMTUwMA=="}], "type": "inlineReview"}, {"oid": "74781851c70da12afb5c42d491f8d8a02ee41cf3", "url": "https://github.com/elastic/elasticsearch/commit/74781851c70da12afb5c42d491f8d8a02ee41cf3", "message": "Use a real client instead of null", "committedDate": "2020-01-13T17:25:33Z", "type": "commit"}, {"oid": "7dc759244d9d1c8e1cd7e0e6bcbec74d3658dbaf", "url": "https://github.com/elastic/elasticsearch/commit/7dc759244d9d1c8e1cd7e0e6bcbec74d3658dbaf", "message": "Rename indexCanBeUpdatedSafely -> isIndexPhaseDefinitionUpdatable", "committedDate": "2020-01-13T17:26:34Z", "type": "commit"}, {"oid": "86f9455ba2951490d4876341e2e3aad1c950baa5", "url": "https://github.com/elastic/elasticsearch/commit/86f9455ba2951490d4876341e2e3aad1c950baa5", "message": "pei -> phaseExecutionInfo", "committedDate": "2020-01-13T17:27:28Z", "type": "commit"}, {"oid": "80822e870b44d94a573fd428bed3c261ef4f5219", "url": "https://github.com/elastic/elasticsearch/commit/80822e870b44d94a573fd428bed3c261ef4f5219", "message": "Collapse two logging statements into one", "committedDate": "2020-01-13T17:29:17Z", "type": "commit"}, {"oid": "8eba91bddf050342efe2dc886951a0b6c46d9a5e", "url": "https://github.com/elastic/elasticsearch/commit/8eba91bddf050342efe2dc886951a0b6c46d9a5e", "message": "Fixup the comment to be clearer", "committedDate": "2020-01-13T17:29:27Z", "type": "commit"}, {"oid": "27342f2981046bcf896afb541df2d05748f75c1f", "url": "https://github.com/elastic/elasticsearch/commit/27342f2981046bcf896afb541df2d05748f75c1f", "message": "Add documentation blurb", "committedDate": "2020-01-13T18:16:33Z", "type": "commit"}]}