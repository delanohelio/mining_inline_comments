{"pr_number": 52250, "pr_title": "Resolve application privileges to SP access", "pr_createdAt": "2020-02-12T04:55:08Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52250", "timeline": [{"oid": "d85d4baaa821bafcab23a744d19f36573a6f88ca", "url": "https://github.com/elastic/elasticsearch/commit/d85d4baaa821bafcab23a744d19f36573a6f88ca", "message": "Resolve application privileges to SP access\n\nAdds a new UserPrivilegeResolver class that determines whether a user\nhas access to a service, and with what groups, based on an application\nresource model that represents the service.", "committedDate": "2020-02-12T04:01:13Z", "type": "commit"}, {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "url": "https://github.com/elastic/elasticsearch/commit/9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "message": "Merge branch 'feature-internal-idp' into idp/privileges", "committedDate": "2020-02-12T06:01:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MTQ3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378741474", "bodyText": "Wondering if we can short-circuit here and not check for group actions. If the user can't sso then the groups will never be \"released\" as attributes to the SP so why check them and not return an empty list ? Do we foresee exposing this externally where such answers \"Can't login, but if they could they would be a viewer \" would be useful?", "author": "jkakavas", "createdAt": "2020-02-13T09:28:17Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Determines what privileges a user has within a given {@link ServiceProviderPrivileges service}.\n+ */\n+public class UserPrivilegeResolver {\n+\n+    public class UserPrivileges {\n+        public final String principal;\n+        public final boolean hasAccess;\n+        public final Set<String> groups;\n+\n+        public UserPrivileges(String principal, boolean hasAccess, Set<String> groups) {\n+            this.principal = principal;\n+            this.hasAccess = hasAccess;\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"{\" + principal + \", \" + hasAccess + \", \" + groups + \"}\";\n+        }\n+    }\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final Client client;\n+    private final SecurityContext securityContext;\n+\n+    public UserPrivilegeResolver(Client client, SecurityContext securityContext) {\n+        this.client = client;\n+        this.securityContext = securityContext;\n+    }\n+\n+    /**\n+     * Resolves the user's privileges for the specified service.\n+     * Requires that the active user is set in the {@link org.elasticsearch.xpack.core.security.SecurityContext}.\n+     */\n+    public void resolve(ServiceProviderPrivileges service, ActionListener<UserPrivileges> listener) {\n+        HasPrivilegesRequest request = new HasPrivilegesRequest();\n+        final String username = securityContext.getUser().principal();\n+        request.username(username);\n+        request.applicationPrivileges(buildResourcePrivilege(service));\n+        client.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(\n+            response -> {\n+                logger.debug(\"Checking access for user [{}] to application [{}] resource [{}]\",\n+                    username, service.getApplicationName(), service.getResource());\n+                UserPrivileges privileges = buildResult(response, service);\n+                logger.debug(\"Resolved service privileges [{}]\", privileges);\n+                listener.onResponse(privileges);\n+            },\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private UserPrivileges buildResult(HasPrivilegesResponse response, ServiceProviderPrivileges service) {\n+        final Set<ResourcePrivileges> appPrivileges = response.getApplicationPrivileges().get(service.getApplicationName());\n+        if (appPrivileges == null || appPrivileges.isEmpty()) {\n+            return new UserPrivileges(response.getUsername(), false, Set.of());\n+        }\n+        final boolean hasAccess = checkAccess(appPrivileges, service.getLoginAction(), service.getResource());", "originalCommit": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNDUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r379224501", "bodyText": "We can.\nTo my thinking these were separate checks so the more accurate return value is to populate the groups even if hasAccess is false, but we can document it so that groups will ways be empty is hasAccess is false.\nI think that's a reasonable behaviour.", "author": "tvernum", "createdAt": "2020-02-14T02:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MTQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNDgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r379224812", "bodyText": "I think the logs will need to be super clear though. I can see people getting confused because the logs say groups=[] and they try to chase down that \"problem\" when in fact that's not the relevant piece of information.", "author": "tvernum", "createdAt": "2020-02-14T02:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MTQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyNDM4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r380324385", "bodyText": "I agree that we need to be explicit and somewhat descriptive in the logs eitherway. Even if we did return the group actions we would need to be explicit that the issue is with the login action otherwise the user/admin might think that they just miss the \"necessary\" group", "author": "jkakavas", "createdAt": "2020-02-17T18:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MTQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MzMxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378743311", "bodyText": "Requires that the active user is set in the {@link org.elasticsearch.xpack.core.security.SecurityContext}.\n\nShould we also check here so that we don't throw an NPE on .principal() ?", "author": "jkakavas", "createdAt": "2020-02-13T09:31:31Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Determines what privileges a user has within a given {@link ServiceProviderPrivileges service}.\n+ */\n+public class UserPrivilegeResolver {\n+\n+    public class UserPrivileges {\n+        public final String principal;\n+        public final boolean hasAccess;\n+        public final Set<String> groups;\n+\n+        public UserPrivileges(String principal, boolean hasAccess, Set<String> groups) {\n+            this.principal = principal;\n+            this.hasAccess = hasAccess;\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"{\" + principal + \", \" + hasAccess + \", \" + groups + \"}\";\n+        }\n+    }\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final Client client;\n+    private final SecurityContext securityContext;\n+\n+    public UserPrivilegeResolver(Client client, SecurityContext securityContext) {\n+        this.client = client;\n+        this.securityContext = securityContext;\n+    }\n+\n+    /**\n+     * Resolves the user's privileges for the specified service.\n+     * Requires that the active user is set in the {@link org.elasticsearch.xpack.core.security.SecurityContext}.\n+     */\n+    public void resolve(ServiceProviderPrivileges service, ActionListener<UserPrivileges> listener) {\n+        HasPrivilegesRequest request = new HasPrivilegesRequest();\n+        final String username = securityContext.getUser().principal();", "originalCommit": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNTAzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r379225032", "bodyText": "If you prefer a ISE over an NPE, then yeah, we can do that.", "author": "tvernum", "createdAt": "2020-02-14T02:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MzMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMjMxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r380322315", "bodyText": "It's not that much / only a personal preference, but I think we try to avoid NPEs throughout the codebase and check and fail with ISE / IAE when applicable so it felt more consistent. Just a nit though eitherway", "author": "jkakavas", "createdAt": "2020-02-17T18:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MzMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ0OTQxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r380449412", "bodyText": "I think we try to avoid NPEs\n\nObjects.requireNonNull throws NPE, so I think we've accepted NPEs as long as the root cause is clear.", "author": "tvernum", "createdAt": "2020-02-18T04:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MzMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0ODY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378748670", "bodyText": "Duplicate of testResolveSsoWithNoGroups", "author": "jkakavas", "createdAt": "2020-02-13T09:41:24Z", "path": "x-pack/plugin/identity-provider/src/test/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolverTests.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.junit.Before;\n+import org.mockito.Mockito;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.emptyIterable;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.same;\n+\n+public class UserPrivilegeResolverTests extends ESTestCase {\n+\n+    private Client client;\n+    private SecurityContext securityContext;\n+    private UserPrivilegeResolver resolver;\n+\n+    @Before\n+    public void setupTest() {\n+        client = Mockito.mock(Client.class);\n+        securityContext = new SecurityContext(Settings.EMPTY, new ThreadContext(Settings.EMPTY));\n+        resolver = new UserPrivilegeResolver(client, securityContext);\n+    }\n+\n+    public void testResolveZeroAccess() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        setupUser(username);\n+        setupHasPrivileges(username, app);\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, \"cluster:\" + randomLong(), \"action:idp:sso\",\n+            Map.of(\"viewer\", \"role:cluster:view\", \"admin\", \"role:cluster:admin\")), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(false));\n+        assertThat(privileges.groups, emptyIterable());\n+    }\n+\n+    public void testResolveSsoWithNoGroupsDefined() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app, access(resource, loginAction, true));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of()), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, emptyIterable());\n+    }\n+\n+    public void testResolveSsoWithNoGroupAccess() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, true), access(resource, viewerAction, false), access(resource, adminAction, false));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of(\"viewer\", viewerAction, \"admin\", adminAction)), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, emptyIterable());\n+    }\n+\n+    public void testResolveSsoWithSingleGroup() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, true), access(resource, viewerAction, true), access(resource, adminAction, false));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of(\"viewer\", viewerAction, \"admin\", adminAction)), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, containsInAnyOrder(\"viewer\"));\n+    }\n+\n+    public void testResolveSsoWithMultipleGroup() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+        final String operatorAction = \"role:cluster:operator\";\n+        final String monitorAction = \"role:cluster:monitor\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, true),\n+            access(resource, viewerAction, false),\n+            access(resource, adminAction, false),\n+            access(resource, operatorAction, true),\n+            access(resource, monitorAction, true)\n+        );\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction,\n+            Map.of(\"viewer\", viewerAction, \"admin\", adminAction, \"operator\", operatorAction, \"monitor\", monitorAction)),\n+            future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, containsInAnyOrder(\"operator\", \"monitor\"));\n+    }\n+\n+    public void testResolveGroupAccessButNoSsoPrivilege() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, false), access(resource, viewerAction, true), access(resource, adminAction, false));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of(\"viewer\", viewerAction, \"admin\", adminAction)), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(false));\n+        assertThat(privileges.groups, containsInAnyOrder(\"viewer\"));\n+    }\n+\n+    public void testResolveSsoWithNoGroups() throws Exception {", "originalCommit": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNTcwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r379225702", "bodyText": "This is is testResolveSsoWithNoGroups. Do you mean duplicate of testResolveSsoWithNoGroupsDefined.\nIn which case the 2 tests do different things (but this one was supposed to get renamed, and I missed it).\ntestResolveSsoWithNoGroupsDefined tests when an SP does not declare any group assignment privileges.\ntestResolveSso**WhenUserHas**NoGroups (as it should be named) tests when an SP declares group privileges, but the user has none of them.", "author": "tvernum", "createdAt": "2020-02-14T02:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0ODY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNTk2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r379225961", "bodyText": "Oh, wait there is a duplicate.\nWe already have testResolveSsoWithNoGroupAccess and testResolveSsoWithNoGroupsDefined this was left over from when I split it out into those 2 separate cases.", "author": "tvernum", "createdAt": "2020-02-14T02:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0ODY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0OTkxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378749913", "bodyText": "Possibly add a test where the user is allowed an action in a resource and we check for the same action in another resource.", "author": "jkakavas", "createdAt": "2020-02-13T09:43:40Z", "path": "x-pack/plugin/identity-provider/src/test/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolverTests.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.junit.Before;\n+import org.mockito.Mockito;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.emptyIterable;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.same;\n+\n+public class UserPrivilegeResolverTests extends ESTestCase {", "originalCommit": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyODM4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r379228380", "bodyText": "It's not possible to actually test that here because hasPrivileges only returns information about the resources you ask for, and this test mocks hasPrivileges.\nWe'd need an integration test for that so we could define real privileges.", "author": "tvernum", "createdAt": "2020-02-14T02:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0OTkxMw=="}], "type": "inlineReview"}, {"oid": "8768552a7484b4cc5bc38b692b8f9181f527b74c", "url": "https://github.com/elastic/elasticsearch/commit/8768552a7484b4cc5bc38b692b8f9181f527b74c", "message": "Address feedback", "committedDate": "2020-02-14T03:42:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMzEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r380323120", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.groups = Set.copyOf(Objects.requireNonNull(groups, \"groups may not br null\"));\n          \n          \n            \n                        this.groups = Set.copyOf(Objects.requireNonNull(groups, \"groups may not be null\"));", "author": "jkakavas", "createdAt": "2020-02-17T18:30:51Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolver.java", "diffHunk": "@@ -28,20 +29,37 @@\n  */\n public class UserPrivilegeResolver {\n \n-    public class UserPrivileges {\n+    public static class UserPrivileges {\n         public final String principal;\n         public final boolean hasAccess;\n         public final Set<String> groups;\n \n         public UserPrivileges(String principal, boolean hasAccess, Set<String> groups) {\n-            this.principal = principal;\n+            this.principal = Objects.requireNonNull(principal, \"principal may not be null\");\n+            if (hasAccess == false && groups.isEmpty() == false) {\n+                throw new IllegalArgumentException(\"a user without access ([\" + hasAccess + \"]) may not have groups ([\" + groups + \"])\");\n+            }\n             this.hasAccess = hasAccess;\n-            this.groups = groups;\n+            this.groups = Set.copyOf(Objects.requireNonNull(groups, \"groups may not br null\"));", "originalCommit": "8768552a7484b4cc5bc38b692b8f9181f527b74c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "80ec25b97aeb4a77ff3f5c4a279f00c3fcadc90a", "url": "https://github.com/elastic/elasticsearch/commit/80ec25b97aeb4a77ff3f5c4a279f00c3fcadc90a", "message": "Fix typo in error message\n\nCo-Authored-By: Ioannis Kakavas <ikakavas@protonmail.com>", "committedDate": "2020-02-18T04:28:22Z", "type": "commit"}]}