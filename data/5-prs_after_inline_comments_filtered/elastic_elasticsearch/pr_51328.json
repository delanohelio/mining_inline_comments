{"pr_number": 51328, "pr_title": "QL: Refactor DataType for pluggability", "pr_createdAt": "2020-01-22T18:05:54Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51328", "timeline": [{"oid": "8bff48ba7a6c4747c4dd9adf6c0d81b8d3947f18", "url": "https://github.com/elastic/elasticsearch/commit/8bff48ba7a6c4747c4dd9adf6c0d81b8d3947f18", "message": "QL: Refactor DataType for pluggability\n\nChange DataType from enum to class\nBreak DataType enums into QL (default) and SQL types\nMake data type conversion pluggable so that new types can be introduced\n\nAs part of the process:\n- static type conversion in QL package (such as Literal) has been\nremoved\n- several utility classes have been broken into base (QL) and extended\n(SQL) parts based on type awareness\n- operators (+,-,/,*) are\n- due to extensibility, serialization of arithmetic operation has been\nslightly changed and pushed down to the operator executor itself", "committedDate": "2020-01-22T18:16:52Z", "type": "commit"}, {"oid": "8bff48ba7a6c4747c4dd9adf6c0d81b8d3947f18", "url": "https://github.com/elastic/elasticsearch/commit/8bff48ba7a6c4747c4dd9adf6c0d81b8d3947f18", "message": "QL: Refactor DataType for pluggability\n\nChange DataType from enum to class\nBreak DataType enums into QL (default) and SQL types\nMake data type conversion pluggable so that new types can be introduced\n\nAs part of the process:\n- static type conversion in QL package (such as Literal) has been\nremoved\n- several utility classes have been broken into base (QL) and extended\n(SQL) parts based on type awareness\n- operators (+,-,/,*) are\n- due to extensibility, serialization of arithmetic operation has been\nslightly changed and pushed down to the operator executor itself", "committedDate": "2020-01-22T18:16:52Z", "type": "forcePushed"}, {"oid": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "url": "https://github.com/elastic/elasticsearch/commit/153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "message": "Fix uncaught test failure", "committedDate": "2020-01-22T20:06:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2MTY1MA==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370661650", "bodyText": "Why this mix of styles? isSomething(DataType) vs. dataType.isSomething()\nIs it possible to use only one?\nAlso, is not obvious to me why isNumeric() remains on the DataType while isString() is moved to DataTypes.", "author": "astefan", "createdAt": "2020-01-24T14:29:40Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/DataTypes.java", "diffHunk": "@@ -60,160 +117,49 @@ public static DataType fromJava(Object value) {\n         if (value instanceof Short) {\n             return SHORT;\n         }\n-        if (value instanceof OffsetTime) {\n-            return TIME;\n-        }\n         if (value instanceof ZonedDateTime) {\n             return DATETIME;\n         }\n         if (value instanceof String || value instanceof Character) {\n             return KEYWORD;\n         }\n-        if (value instanceof Interval) {\n-            return ((Interval<?>) value).dataType();\n-        }\n-        if (value instanceof GeoShape) {\n-            return DataType.GEO_SHAPE;\n-        }\n-\n-        throw new QlIllegalArgumentException(\"No idea what's the DataType for {}\", value.getClass());\n-    }\n \n-    // return the compatible interval between the two - it is assumed the types are intervals\n-    // YEAR and MONTH -> YEAR_TO_MONTH\n-    // DAY... SECOND -> DAY_TIME\n-    // YEAR_MONTH and DAY_SECOND are NOT compatible\n-    public static DataType compatibleInterval(DataType left, DataType right) {\n-        if (left == right) {\n-            return left;\n-        }\n-        if (left.isYearMonthInterval() && right.isYearMonthInterval()) {\n-            // no need to look at YEAR/YEAR or MONTH/MONTH as these are equal and already handled\n-            return INTERVAL_YEAR_TO_MONTH;\n-        }\n-        if (left.isDayTimeInterval() && right.isDayTimeInterval()) {\n-            // to avoid specifying the combinations, extract the leading and trailing unit from the name\n-            // D > H > S > M which is also the alphabetical order\n-            String lName = left.name().substring(9);\n-            String rName = right.name().substring(9);\n-\n-            char leading = lName.charAt(0);\n-            if (rName.charAt(0) < leading) {\n-                leading = rName.charAt(0);\n-            }\n-            // look at the trailing unit\n-            if (lName.length() > 6) {\n-                int indexOf = lName.indexOf(\"_TO_\");\n-                lName = lName.substring(indexOf + 4);\n-            }\n-            if (rName.length() > 6) {\n-                int indexOf = rName.indexOf(\"_TO_\");\n-                rName = rName.substring(indexOf + 4);\n-            }\n-            char trailing = lName.charAt(0);\n-            if (rName.charAt(0) > trailing) {\n-                trailing = rName.charAt(0);\n-            }\n-\n-            return fromTypeName(\"INTERVAL_\" + intervalUnit(leading) + \"_TO_\" + intervalUnit(trailing));\n-        }\n         return null;\n     }\n \n-    private static String intervalUnit(char unitChar) {\n-        switch (unitChar) {\n-            case 'D':\n-                return \"DAY\";\n-            case 'H':\n-                return \"HOUR\";\n-            case 'M':\n-                return \"MINUTE\";\n-            case 'S':\n-                return \"SECOND\";\n-            default:\n-                throw new QlIllegalArgumentException(\"Unknown unit {}\", unitChar);\n-        }\n-    }\n-\n-    //\n-    // Metadata methods, mainly for ODBC.\n-    // As these are fairly obscure and limited in use, there is no point to promote them as a full type methods\n-    // hence why they appear here as utility methods.\n-    //\n-\n-    // https://docs.microsoft.com/en-us/sql/relational-databases/native-client-odbc-date-time/metadata-catalog\n-    // https://github.com/elastic/elasticsearch/issues/30386\n-    public static Integer metaSqlDataType(DataType t) {\n-        if (t == DATETIME) {\n-            // ODBC SQL_DATETME\n-            return Integer.valueOf(9);\n-        }\n-        // this is safe since the vendor SQL types are short despite the return value\n-        return t.sqlType().getVendorTypeNumber();\n-    }\n-\n-    // https://github.com/elastic/elasticsearch/issues/30386\n-    // https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlgettypeinfo-function\n-    public static Integer metaSqlDateTimeSub(DataType t) {\n-        if (t == DATETIME) {\n-            // ODBC SQL_CODE_TIMESTAMP\n-            return Integer.valueOf(3);\n-        }\n-        // ODBC null\n-        return 0;\n+    public static boolean isUnsupported(DataType from) {\n+        return from == UNSUPPORTED;\n     }\n \n-    public static Short metaSqlMinimumScale(DataType t) {\n-        return metaSqlSameScale(t);\n+    public static boolean isString(DataType t) {\n+        return t == KEYWORD || t == TEXT;\n     }\n \n-    public static Short metaSqlMaximumScale(DataType t) {\n-        return metaSqlSameScale(t);\n+    public static boolean isPrimitive(DataType t) {\n+        return t != OBJECT && t != NESTED && t != UNSUPPORTED;\n     }\n \n-    // https://docs.microsoft.com/en-us/sql/odbc/reference/appendixes/decimal-digits\n-    // https://github.com/elastic/elasticsearch/issues/40357\n-    // since the scale is fixed, minimum and maximum should return the same value\n-    // hence why this method exists\n-    private static Short metaSqlSameScale(DataType t) {\n-        // TODO: return info for SCALED_FLOATS (should be based on field not type)\n-        if (t.isInteger()) {\n-            return Short.valueOf((short) 0);\n-        }\n-        if (t.isDateBased() || t.isRational()) {\n-            return Short.valueOf((short) t.defaultPrecision);\n-        }\n-        return null;\n+    public static boolean isNull(DataType t) {\n+        return t == NULL;\n     }\n \n-    // https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlgettypeinfo-function\n-    public static Integer metaSqlRadix(DataType t) {\n-        // RADIX  - Determines how numbers returned by COLUMN_SIZE and DECIMAL_DIGITS should be interpreted.\n-        // 10 means they represent the number of decimal digits allowed for the column.\n-        // 2 means they represent the number of bits allowed for the column.\n-        // null means radix is not applicable for the given type.\n-        return t.isInteger() ? Integer.valueOf(10) : (t.isRational() ? Integer.valueOf(2) : null);\n+    public static boolean isNullOrNumeric(DataType t) {\n+        return t.isNumeric() || isNull(t);\n     }\n \n-    //https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlgettypeinfo-function#comments\n-    //https://docs.microsoft.com/en-us/sql/odbc/reference/appendixes/column-size\n-    public static Integer precision(DataType t) {\n-        if (t.isNumeric()) {\n-            return t.defaultPrecision;\n-        }\n-        return t.displaySize;\n+    public static boolean isSigned(DataType t) {\n+        return t.isNumeric();\n     }\n \n-    public static boolean areTypesCompatible(DataType left, DataType right) {\n+    public static boolean areCompatible(DataType left, DataType right) {\n         if (left == right) {\n             return true;\n         } else {\n             return\n-                (left == DataType.NULL || right == DataType.NULL)\n-                    || (left.isString() && right.isString())\n+                (left == NULL || right == NULL)\n+                    || (isString(left) && isString(right))", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3NjU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370776591", "bodyText": "DataType contains only methods that can work on its properties (such as whether it's numeric or not) while everything else is on DataTypes.\nFrom the usage point of view it would be cleaner to have all methods inside one place, namely DataTypes (as new types can have new properties such as interval) but in case of numeric properties these are parts of the DataType itself.\nThis can be revisited in the future so that these properties are fully externalized (and essentially hard-coded just like isString).", "author": "costin", "createdAt": "2020-01-24T18:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY2MTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4MDgwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370680809", "bodyText": "== false instead of ! ?", "author": "astefan", "createdAt": "2020-01-24T15:06:03Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Arithmetics.java", "diffHunk": "@@ -5,27 +5,33 @@\n  */\n package org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic;\n \n-import java.time.Duration;\n-import java.time.OffsetTime;\n-import java.time.Period;\n-import java.time.temporal.Temporal;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+\n+import java.util.function.BiFunction;\n \n /**\n  * Arithmetic operation using the type widening rules of the JLS 5.6.2 namely\n  * widen to double or float or long or int in this order.\n  */\n public final class Arithmetics {\n \n-    public static final long DAY_IN_MILLIS = 60 * 60 * 24 * 1000L;\n-\n     private Arithmetics() {}\n \n-    private enum IntervalOperation {\n-        ADD,\n-        SUB\n+    public interface NumericArithmetic extends BiFunction<Number, Number, Number> {\n+        default Object wrap(Object l, Object r) {\n+            if (!(l instanceof Number)) {", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3NzExNA==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370777114", "bodyText": "I've moved the code as it was without doing any style touches. I'd rather do that separately (similar to organize imports) to avoid the extra noise.\nI'm sure there are multiple places where the != style is being used.", "author": "costin", "createdAt": "2020-01-24T18:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4MDgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MDgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370690808", "bodyText": "Indentation issue.", "author": "astefan", "createdAt": "2020-01-24T15:25:06Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -410,25 +419,27 @@ private static EsField createField(String fieldName, Map<String, Map<String, Fie\n         return esField;\n     }\n \n-    private static EsField createField(String fieldName, String typeName, Map<String, EsField> props,\n+    private static EsField createField(DataTypeRegistry typeRegistry, String fieldName, String typeName, Map<String, EsField> props,\n             boolean isAggregateable, boolean isAlias) {\n-        DataType esType = DataType.fromTypeName(typeName);\n-        switch (esType) {\n-            case TEXT:\n+        DataType esType = typeRegistry.fromEs(typeName);\n+\n+        if (esType == TEXT) {\n                 return new TextEsField(fieldName, props, false, isAlias);", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MTA3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370691073", "bodyText": "Indentation issue.", "author": "astefan", "createdAt": "2020-01-24T15:25:37Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -410,25 +419,27 @@ private static EsField createField(String fieldName, Map<String, Map<String, Fie\n         return esField;\n     }\n \n-    private static EsField createField(String fieldName, String typeName, Map<String, EsField> props,\n+    private static EsField createField(DataTypeRegistry typeRegistry, String fieldName, String typeName, Map<String, EsField> props,\n             boolean isAggregateable, boolean isAlias) {\n-        DataType esType = DataType.fromTypeName(typeName);\n-        switch (esType) {\n-            case TEXT:\n+        DataType esType = typeRegistry.fromEs(typeName);\n+\n+        if (esType == TEXT) {\n                 return new TextEsField(fieldName, props, false, isAlias);\n-            case KEYWORD:\n-                int length = DataType.KEYWORD.defaultPrecision;\n+        }\n+        if (esType == KEYWORD) {\n+            int length = Short.MAX_VALUE;\n                 // TODO: to check whether isSearchable/isAggregateable takes into account the presence of the normalizer\n                 boolean normalized = false;\n                 return new KeywordEsField(fieldName, props, isAggregateable, length, normalized, isAlias);\n-            case DATETIME:\n+        }\n+        if (esType == DATETIME) {\n                 return new DateEsField(fieldName, props, isAggregateable);\n-            case UNSUPPORTED:\n+        }\n+        if (esType == UNSUPPORTED) {\n                 return new UnsupportedEsField(fieldName, typeName, null, props);\n-            default:\n+        }\n                 return new EsField(fieldName, esType, props, isAggregateable, isAlias);\n         }", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwMzYwNA==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371203604", "bodyText": "Still an indentation issue.", "author": "astefan", "createdAt": "2020-01-27T12:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MTA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370694591", "bodyText": "SqlDataTypeRegistry has DataTypes.isUnsupported(type); for this method implementation, DefaultDataTypeRegistry has  return type == UNSUPPORTED;.  Can this interface provide a default implementation and remove the specific ones (that seem to be the same) from the implementing classes?", "author": "astefan", "createdAt": "2020-01-24T15:32:18Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/DataTypeRegistry.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ql.type;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Central class for {@link DataType} creation and conversion.\n+ */\n+public interface DataTypeRegistry {\n+\n+    //\n+    // Discovery\n+    //\n+    Collection<DataType> dataTypes();\n+\n+    DataType fromEs(String typeName);\n+\n+    DataType fromJava(Object value);\n+\n+    boolean isUnsupported(DataType type);", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODg1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370778859", "bodyText": "A default implementation would tie the contract (the interface) to an DataType instance (UNSUPPORTED).\nDelegating to *DataTypes is cleaner and makes each interface implementation clearer in design - it also makes them fully independent (if needed).\nI replaced the == check with a call to DataTypes.isUnsupported to maintain the delegation pattern.", "author": "costin", "createdAt": "2020-01-24T18:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxMDEyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370710125", "bodyText": "Why is this method now available only for Keywords?", "author": "astefan", "createdAt": "2020-01-24T16:01:20Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/EsField.java", "diffHunk": "@@ -80,16 +80,9 @@ public EsField getExactField() {\n         return this;\n     }\n \n-    /**\n-     * Returns the precision of the field\n-     * <p>\n-     * Precision is the specified column size. For numeric data, this is the maximum precision. For character\n-     * data, this is the length in characters. For datetime datatypes, this is the length in characters of the\n-     * String representation (assuming the maximum allowed defaultPrecision of the fractional seconds component).\n-     */\n-    public int getPrecision() {\n-        return esDataType.defaultPrecision;\n-    }\n+    //    public int getPrecision() {", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3OTY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370779679", "bodyText": "Because it's used only there. Having it all over does not provide any value.\nSame as DateEsField which initially was suppose to maintain the date format however that's not the case so essentially it's just another EsField.\nThese APIs can be cleaned as not all properties are needed (including precision) and can be gathered into the module that needs them.", "author": "costin", "createdAt": "2020-01-24T18:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxMDEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxMDY2NA==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370710664", "bodyText": "What does the precision mean in the context of a generic QL keyword field?", "author": "astefan", "createdAt": "2020-01-24T16:02:25Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/KeywordEsField.java", "diffHunk": "@@ -27,12 +29,11 @@ public KeywordEsField(String name, Map<String, EsField> properties, boolean hasD\n     \n     public KeywordEsField(String name, Map<String, EsField> properties, boolean hasDocValues, int precision,\n             boolean normalized, boolean isAlias) {\n-        super(name, DataType.KEYWORD, properties, hasDocValues, isAlias);\n+        super(name, KEYWORD, properties, hasDocValues, isAlias);\n         this.precision = precision;\n         this.normalized = normalized;\n     }\n \n-    @Override\n     public int getPrecision() {", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc4MDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370780013", "bodyText": "Being a string, it represents the number of characters - namely ignore_above.", "author": "costin", "createdAt": "2020-01-24T18:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxMDY2NA=="}], "type": "inlineReview"}, {"oid": "457e91d99c2cdd1ee4557906c0869cadadae0659", "url": "https://github.com/elastic/elasticsearch/commit/457e91d99c2cdd1ee4557906c0869cadadae0659", "message": "Polish", "committedDate": "2020-01-24T18:34:59Z", "type": "commit"}, {"oid": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "url": "https://github.com/elastic/elasticsearch/commit/dc2f108146e016d6627d5a0e1703d30ceaea49ed", "message": "Merge branch 'master' into ql/datatype-refactor", "committedDate": "2020-01-27T10:50:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkzOTM5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370939391", "bodyText": "Leftover comment.", "author": "astefan", "createdAt": "2020-01-25T15:33:00Z", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/type/TypesTests.java", "diffHunk": "@@ -81,7 +79,7 @@ public void testDateField() {\n         EsField field = mapping.get(\"date\");\n         assertThat(field.getDataType(), is(DATETIME));\n         assertThat(field.isAggregatable(), is(true));\n-        assertThat(field.getPrecision(), is(3));\n+        //assertThat(field.getPrecision(), is(3));", "originalCommit": "457e91d99c2cdd1ee4557906c0869cadadae0659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwNDE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371204167", "bodyText": "I think you can remove length and use its value directly in the KeywordEsField consructor.\nI would say that normalized can also be removed, and still keep the TODO in there?", "author": "astefan", "createdAt": "2020-01-27T12:07:20Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -410,25 +419,27 @@ private static EsField createField(String fieldName, Map<String, Map<String, Fie\n         return esField;\n     }\n \n-    private static EsField createField(String fieldName, String typeName, Map<String, EsField> props,\n+    private static EsField createField(DataTypeRegistry typeRegistry, String fieldName, String typeName, Map<String, EsField> props,\n             boolean isAggregateable, boolean isAlias) {\n-        DataType esType = DataType.fromTypeName(typeName);\n-        switch (esType) {\n-            case TEXT:\n-                return new TextEsField(fieldName, props, false, isAlias);\n-            case KEYWORD:\n-                int length = DataType.KEYWORD.defaultPrecision;\n-                // TODO: to check whether isSearchable/isAggregateable takes into account the presence of the normalizer\n-                boolean normalized = false;\n-                return new KeywordEsField(fieldName, props, isAggregateable, length, normalized, isAlias);\n-            case DATETIME:\n-                return new DateEsField(fieldName, props, isAggregateable);\n-            case UNSUPPORTED:\n-                return new UnsupportedEsField(fieldName, typeName, null, props);\n-            default:\n-                return new EsField(fieldName, esType, props, isAggregateable, isAlias);\n+        DataType esType = typeRegistry.fromEs(typeName);\n+\n+        if (esType == TEXT) {\n+            return new TextEsField(fieldName, props, false, isAlias);\n+        }\n+        if (esType == KEYWORD) {\n+            int length = Short.MAX_VALUE;", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwNjEwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371206105", "bodyText": "Remove this line?", "author": "astefan", "createdAt": "2020-01-27T12:11:46Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/DateUtils.java", "diffHunk": "@@ -10,66 +10,25 @@\n import org.elasticsearch.common.time.DateFormatters;\n \n import java.time.Instant;\n-import java.time.LocalDate;\n-import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n \n-import static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE;\n-import static java.time.format.DateTimeFormatter.ISO_TIME;\n-\n-//FIXME: Taken from sql-proto.\n-//Ideally it should be shared but the dependencies across projects and and SQL-client make it tricky.\n-//Maybe a gradle task would fix that...\n+//NB: Taken from sql-proto.", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MTEzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371261139", "bodyText": "I think it's good to have it as information on where the code comes from (though it's not big enough to require some sort of automatic copying over).", "author": "costin", "createdAt": "2020-01-27T14:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwNjEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwNzI1NA==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371207254", "bodyText": "Indentation issues.", "author": "astefan", "createdAt": "2020-01-27T12:14:52Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "diffHunk": "@@ -14,87 +14,88 @@\n import java.util.Map.Entry;\n \n import static java.util.Collections.emptyMap;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.DATETIME;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.KEYWORD;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.NESTED;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.OBJECT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.TEXT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.UNSUPPORTED;\n \n public abstract class Types {\n \n     @SuppressWarnings(\"unchecked\")\n-    public static Map<String, EsField> fromEs(Map<String, Object> asMap) {\n+    public static Map<String, EsField> fromEs(DataTypeRegistry typeRegistry, Map<String, Object> asMap) {\n         Map<String, Object> props = null;\n         if (asMap != null && !asMap.isEmpty()) {\n             props = (Map<String, Object>) asMap.get(\"properties\");\n         }\n-        return props == null || props.isEmpty() ? emptyMap() : startWalking(props);\n+        return props == null || props.isEmpty() ? emptyMap() : startWalking(typeRegistry, props);\n     }\n \n-    private static Map<String, EsField> startWalking(Map<String, Object> mapping) {\n+    private static Map<String, EsField> startWalking(DataTypeRegistry typeRegistry, Map<String, Object> mapping) {\n         Map<String, EsField> types = new LinkedHashMap<>();\n \n         if (mapping == null) {\n             return emptyMap();\n         }\n         for (Entry<String, Object> entry : mapping.entrySet()) {\n-            walkMapping(entry.getKey(), entry.getValue(), types);\n+            walkMapping(typeRegistry, entry.getKey(), entry.getValue(), types);\n         }\n \n         return types;\n     }\n \n-    private static DataType getType(Map<String, Object> content) {\n+    private static DataType getType(DataTypeRegistry typeRegistry, Map<String, Object> content) {\n         if (content.containsKey(\"type\")) {\n             try {\n-                return DataType.fromTypeName(content.get(\"type\").toString());\n+                return typeRegistry.fromEs(content.get(\"type\").toString());\n             } catch (IllegalArgumentException ex) {\n-                return DataType.UNSUPPORTED;\n+                return UNSUPPORTED;\n             }\n         } else if (content.containsKey(\"properties\")) {\n-            return DataType.OBJECT;\n+            return OBJECT;\n         } else {\n-            return DataType.UNSUPPORTED;\n+            return UNSUPPORTED;\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private static void walkMapping(String name, Object value, Map<String, EsField> mapping) {\n+    private static void walkMapping(DataTypeRegistry typeRegistry, String name, Object value, Map<String, EsField> mapping) {\n         // object type - only root or nested docs supported\n         if (value instanceof Map) {\n             Map<String, Object> content = (Map<String, Object>) value;\n \n             // extract field type\n-            DataType esDataType = getType(content);\n+            DataType esDataType = getType(typeRegistry, content);\n             final Map<String, EsField> properties;\n-            if (esDataType == DataType.OBJECT || esDataType == DataType.NESTED) {\n-                properties = fromEs(content);\n+            if (esDataType == OBJECT || esDataType == NESTED) {\n+                properties = fromEs(typeRegistry, content);\n             } else if (content.containsKey(\"fields\")) {\n                 // Check for multifields\n                 Object fields = content.get(\"fields\");\n                 if (fields instanceof Map) {\n-                    properties = startWalking((Map<String, Object>) fields);\n+                    properties = startWalking(typeRegistry, (Map<String, Object>) fields);\n                 } else {\n                     properties = Collections.emptyMap();\n                 }\n             } else {\n-                properties = fromEs(content);\n+                properties = fromEs(typeRegistry, content);\n             }\n-            boolean docValues = boolSetting(content.get(\"doc_values\"), esDataType.defaultDocValues);\n+            boolean docValues = boolSetting(content.get(\"doc_values\"), esDataType.hasDocValues());\n             final EsField field;\n-            switch (esDataType) {\n-                case TEXT:\n+            if (esDataType == TEXT) {\n                     field = new TextEsField(name, properties, docValues);\n-                    break;\n-                case KEYWORD:\n-                    int length = intSetting(content.get(\"ignore_above\"), esDataType.defaultPrecision);\n+            } else if (esDataType == KEYWORD) {\n+                    int length = intSetting(content.get(\"ignore_above\"), Short.MAX_VALUE);", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwOTU2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371209561", "bodyText": "Why the use of mapSize() method? For situations where a new type is added and the Map initialization is forgotten?", "author": "astefan", "createdAt": "2020-01-27T12:20:18Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/type/SqlDataTypes.java", "diffHunk": "@@ -0,0 +1,726 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.type;\n+\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.expression.literal.geo.GeoShape;\n+import org.elasticsearch.xpack.sql.expression.literal.interval.Interval;\n+import org.elasticsearch.xpack.sql.expression.literal.interval.Intervals;\n+\n+import java.sql.JDBCType;\n+import java.sql.SQLType;\n+import java.time.OffsetTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.BINARY;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.BOOLEAN;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.BYTE;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.DATETIME;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.DOUBLE;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.FLOAT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.HALF_FLOAT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.INTEGER;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.IP;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.KEYWORD;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.LONG;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.NESTED;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.NULL;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.OBJECT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.SCALED_FLOAT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.SHORT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.TEXT;\n+import static org.elasticsearch.xpack.ql.type.DataTypes.UNSUPPORTED;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.mapSize;\n+\n+public class SqlDataTypes {\n+\n+    // @formatter:off\n+    // date-only, time-only\n+    public static final DataType DATE = new DataType(\"DATE\", null, Long.BYTES, false, false, true);\n+    public static final DataType TIME = new DataType(\"TIME\", null, Long.BYTES, false, false, true);\n+    // interval\n+    public static final DataType INTERVAL_YEAR =\n+                   new DataType(\"INTERVAL_YEAR\",             null, Integer.BYTES, false, false, false);\n+    public static final DataType INTERVAL_MONTH =\n+                   new DataType(\"INTERVAL_MONTH\",            null, Integer.BYTES, false, false, false);\n+    public static final DataType INTERVAL_DAY =\n+                   new DataType(\"INTERVAL_DAY\",              null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_HOUR =\n+                   new DataType(\"INTERVAL_HOUR\",             null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_MINUTE =\n+                   new DataType(\"INTERVAL_MINUTE\",           null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_SECOND =\n+                   new DataType(\"INTERVAL_SECOND\",           null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_YEAR_TO_MONTH =\n+                   new DataType(\"INTERVAL_YEAR_TO_MONTH\",    null, Integer.BYTES, false, false, false);\n+    public static final DataType INTERVAL_DAY_TO_HOUR =\n+                   new DataType(\"INTERVAL_DAY_TO_HOUR\",      null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_DAY_TO_MINUTE =\n+                   new DataType(\"INTERVAL_DAY_TO_MINUTE\",    null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_DAY_TO_SECOND =\n+                   new DataType(\"INTERVAL_DAY_TO_SECOND\",    null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_HOUR_TO_MINUTE =\n+                   new DataType(\"INTERVAL_HOUR_TO_MINUTE\",   null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_HOUR_TO_SECOND =\n+                   new DataType(\"INTERVAL_HOUR_TO_SECOND\",   null, Long.BYTES,    false, false, false);\n+    public static final DataType INTERVAL_MINUTE_TO_SECOND =\n+                   new DataType(\"INTERVAL_MINUTE_TO_SECOND\", null, Long.BYTES,    false, false, false);\n+    // geo\n+    public static final DataType GEO_SHAPE = new DataType(\"geo_shape\", Integer.MAX_VALUE, false, false, false);\n+    public static final DataType GEO_POINT = new DataType(\"geo_point\", Double.BYTES * 2,  false, false, false);\n+    public static final DataType SHAPE =     new DataType(\"shape\",     Integer.MAX_VALUE, false, false, false);\n+    // @formatter:on\n+\n+    private static final Map<String, DataType> ODBC_TO_ES = new HashMap<>(mapSize(38));\n+\n+    static {\n+        // Numeric\n+        ODBC_TO_ES.put(\"SQL_BIT\", BOOLEAN);\n+        ODBC_TO_ES.put(\"SQL_TINYINT\", BYTE);\n+        ODBC_TO_ES.put(\"SQL_SMALLINT\", SHORT);\n+        ODBC_TO_ES.put(\"SQL_INTEGER\", INTEGER);\n+        ODBC_TO_ES.put(\"SQL_BIGINT\", LONG);\n+        ODBC_TO_ES.put(\"SQL_REAL\", FLOAT);\n+        ODBC_TO_ES.put(\"SQL_FLOAT\", DOUBLE);\n+        ODBC_TO_ES.put(\"SQL_DOUBLE\", DOUBLE);\n+        ODBC_TO_ES.put(\"SQL_DECIMAL\", DOUBLE);\n+        ODBC_TO_ES.put(\"SQL_NUMERIC\", DOUBLE);\n+\n+        // String\n+        ODBC_TO_ES.put(\"SQL_GUID\", KEYWORD);\n+        ODBC_TO_ES.put(\"SQL_CHAR\", KEYWORD);\n+        ODBC_TO_ES.put(\"SQL_WCHAR\", KEYWORD);\n+        ODBC_TO_ES.put(\"SQL_VARCHAR\", TEXT);\n+        ODBC_TO_ES.put(\"SQL_WVARCHAR\", TEXT);\n+        ODBC_TO_ES.put(\"SQL_LONGVARCHAR\", TEXT);\n+        ODBC_TO_ES.put(\"SQL_WLONGVARCHAR\", TEXT);\n+\n+        // Binary\n+        ODBC_TO_ES.put(\"SQL_BINARY\", BINARY);\n+        ODBC_TO_ES.put(\"SQL_VARBINARY\", BINARY);\n+        ODBC_TO_ES.put(\"SQL_LONGVARBINARY\", BINARY);\n+\n+        // Date\n+        ODBC_TO_ES.put(\"SQL_DATE\", DATE);\n+        ODBC_TO_ES.put(\"SQL_TIME\", TIME);\n+        ODBC_TO_ES.put(\"SQL_TIMESTAMP\", DATETIME);\n+\n+        // Intervals\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_YEAR\", INTERVAL_YEAR);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_MONTH\", INTERVAL_MONTH);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_DAY\", INTERVAL_DAY);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_HOUR\", INTERVAL_HOUR);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_MINUTE\", INTERVAL_MINUTE);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_SECOND\", INTERVAL_SECOND);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_YEAR_TO_MONTH\", INTERVAL_YEAR_TO_MONTH);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_DAY_TO_HOUR\", INTERVAL_DAY_TO_HOUR);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_DAY_TO_MINUTE\", INTERVAL_DAY_TO_MINUTE);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_DAY_TO_SECOND\", INTERVAL_DAY_TO_SECOND);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_HOUR_TO_MINUTE\", INTERVAL_HOUR_TO_MINUTE);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_HOUR_TO_SECOND\", INTERVAL_HOUR_TO_SECOND);\n+        ODBC_TO_ES.put(\"SQL_INTERVAL_MINUTE_TO_SECOND\", INTERVAL_MINUTE_TO_SECOND);\n+    }\n+\n+    private static final Collection<DataType> TYPES = Stream.concat(DataTypes.types().stream(), Arrays.asList(\n+            DATE,\n+            TIME,\n+            INTERVAL_YEAR,\n+            INTERVAL_MONTH,\n+            INTERVAL_DAY,\n+            INTERVAL_HOUR,\n+            INTERVAL_MINUTE,\n+            INTERVAL_SECOND,\n+            INTERVAL_YEAR_TO_MONTH,\n+            INTERVAL_DAY_TO_HOUR,\n+            INTERVAL_DAY_TO_MINUTE,\n+            INTERVAL_DAY_TO_SECOND,\n+            INTERVAL_HOUR_TO_MINUTE,\n+            INTERVAL_HOUR_TO_SECOND,\n+            INTERVAL_MINUTE_TO_SECOND,\n+            GEO_SHAPE,\n+            GEO_POINT,\n+            SHAPE)\n+            .stream())\n+            .sorted(Comparator.comparing(DataType::typeName))\n+            .collect(toUnmodifiableList());\n+\n+    private static final Map<String, DataType> NAME_TO_TYPE = TYPES.stream()\n+            .collect(toUnmodifiableMap(DataType::typeName, t -> t));\n+\n+    private static final Map<String, DataType> ES_TO_TYPE = TYPES.stream()\n+            .filter(e -> e.esType() != null)\n+            .collect(toUnmodifiableMap(DataType::esType, t -> t));\n+\n+    private static final Map<String, DataType> SQL_TO_ES;\n+\n+    static {\n+        Map<String, DataType> sqlToEs = new HashMap<>(mapSize(45));", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MzUxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371263513", "bodyText": "To allocate a map high enough so that, while adding items, it doesn't require reallocation.\nIn this case the map is a constant and we know before hand its size hence the 'optimization' to use from the start a size high enough that everything fits yet small enough to not waste space.", "author": "costin", "createdAt": "2020-01-27T14:17:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwOTU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjA1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371236056", "bodyText": "Indentation issue. Also, check lines L1030-L1039, L1091, L1006, and L1111.", "author": "astefan", "createdAt": "2020-01-27T13:23:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1010,7 +1010,7 @@ private Expression propagate(And and) {\n                                     if (comp != null) {\n                                         // var cannot be equal to two different values at the same time\n                                         if (comp != 0) {\n-                                            return new Literal(and.source(), Boolean.FALSE, DataType.BOOLEAN);\n+                                        return new Literal(and.source(), Boolean.FALSE, DataTypes.BOOLEAN);", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6d6a8d10df3252e9b383e4f1bd66c8f6dc345cb4", "url": "https://github.com/elastic/elasticsearch/commit/6d6a8d10df3252e9b383e4f1bd66c8f6dc345cb4", "message": "Polish", "committedDate": "2020-01-27T14:33:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTYyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370409627", "bodyText": "minor: I would leave one arg per line as it was.", "author": "matriv", "createdAt": "2020-01-23T23:31:27Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysTypes.java", "diffHunk": "@@ -72,39 +81,37 @@ public SysTypes(Source source, int type) {\n \n     @Override\n     public final void execute(SqlSession session, ActionListener<Page> listener) {\n-        Stream<DataType> values = Stream.of(DataType.values());\n+        Stream<DataType> values = SqlDataTypes.types().stream();\n         if (type.intValue() != 0) {\n-            values = values.filter(t -> type.equals(t.sqlType().getVendorTypeNumber()));\n+            values = values.filter(t -> type.equals(sqlType(t).getVendorTypeNumber()));\n         }\n         List<List<?>> rows = values\n                 // sort by SQL int type (that's what the JDBC/ODBC specs want) followed by name\n-                .sorted(Comparator.comparing((DataType t) -> t.sqlType().getVendorTypeNumber()).thenComparing(DataType::sqlName))\n+                .sorted(Comparator.comparing((DataType t) -> sqlType(t).getVendorTypeNumber())\n+                        .thenComparing((DataType t) -> sqlType(t).getName()))\n                 .map(t -> asList(t.toString(),\n-                        t.sqlType().getVendorTypeNumber(),\n-                        DataTypes.precision(t),\n+                        sqlType(t).getVendorTypeNumber(), precision(t),", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTY4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370409685", "bodyText": "same here", "author": "matriv", "createdAt": "2020-01-23T23:31:35Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysTypes.java", "diffHunk": "@@ -72,39 +81,37 @@ public SysTypes(Source source, int type) {\n \n     @Override\n     public final void execute(SqlSession session, ActionListener<Page> listener) {\n-        Stream<DataType> values = Stream.of(DataType.values());\n+        Stream<DataType> values = SqlDataTypes.types().stream();\n         if (type.intValue() != 0) {\n-            values = values.filter(t -> type.equals(t.sqlType().getVendorTypeNumber()));\n+            values = values.filter(t -> type.equals(sqlType(t).getVendorTypeNumber()));\n         }\n         List<List<?>> rows = values\n                 // sort by SQL int type (that's what the JDBC/ODBC specs want) followed by name\n-                .sorted(Comparator.comparing((DataType t) -> t.sqlType().getVendorTypeNumber()).thenComparing(DataType::sqlName))\n+                .sorted(Comparator.comparing((DataType t) -> sqlType(t).getVendorTypeNumber())\n+                        .thenComparing((DataType t) -> sqlType(t).getName()))\n                 .map(t -> asList(t.toString(),\n-                        t.sqlType().getVendorTypeNumber(),\n-                        DataTypes.precision(t),\n+                        sqlType(t).getVendorTypeNumber(), precision(t),\n                         \"'\",\n                         \"'\",\n                         null,\n                         // don't be specific on nullable\n                         DatabaseMetaData.typeNullableUnknown,\n                         // all strings are case-sensitive\n-                        t.isString(),\n+                        isString(t),\n                         // everything is searchable,\n                         DatabaseMetaData.typeSearchable,\n                         // only numerics are signed\n-                        !t.isSigned(),\n+                        isSigned(t) == false,\n                         //no fixed precision scale SQL_FALSE\n                         Boolean.FALSE,\n                         // not auto-incremented\n                         Boolean.FALSE,\n                         null,\n-                        DataTypes.metaSqlMinimumScale(t),\n-                        DataTypes.metaSqlMaximumScale(t),\n+                        metaSqlMinimumScale(t), metaSqlMaximumScale(t),", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTcxMg==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r370409712", "bodyText": "and here", "author": "matriv", "createdAt": "2020-01-23T23:31:43Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysTypes.java", "diffHunk": "@@ -72,39 +81,37 @@ public SysTypes(Source source, int type) {\n \n     @Override\n     public final void execute(SqlSession session, ActionListener<Page> listener) {\n-        Stream<DataType> values = Stream.of(DataType.values());\n+        Stream<DataType> values = SqlDataTypes.types().stream();\n         if (type.intValue() != 0) {\n-            values = values.filter(t -> type.equals(t.sqlType().getVendorTypeNumber()));\n+            values = values.filter(t -> type.equals(sqlType(t).getVendorTypeNumber()));\n         }\n         List<List<?>> rows = values\n                 // sort by SQL int type (that's what the JDBC/ODBC specs want) followed by name\n-                .sorted(Comparator.comparing((DataType t) -> t.sqlType().getVendorTypeNumber()).thenComparing(DataType::sqlName))\n+                .sorted(Comparator.comparing((DataType t) -> sqlType(t).getVendorTypeNumber())\n+                        .thenComparing((DataType t) -> sqlType(t).getName()))\n                 .map(t -> asList(t.toString(),\n-                        t.sqlType().getVendorTypeNumber(),\n-                        DataTypes.precision(t),\n+                        sqlType(t).getVendorTypeNumber(), precision(t),\n                         \"'\",\n                         \"'\",\n                         null,\n                         // don't be specific on nullable\n                         DatabaseMetaData.typeNullableUnknown,\n                         // all strings are case-sensitive\n-                        t.isString(),\n+                        isString(t),\n                         // everything is searchable,\n                         DatabaseMetaData.typeSearchable,\n                         // only numerics are signed\n-                        !t.isSigned(),\n+                        isSigned(t) == false,\n                         //no fixed precision scale SQL_FALSE\n                         Boolean.FALSE,\n                         // not auto-incremented\n                         Boolean.FALSE,\n                         null,\n-                        DataTypes.metaSqlMinimumScale(t),\n-                        DataTypes.metaSqlMaximumScale(t),\n+                        metaSqlMinimumScale(t), metaSqlMaximumScale(t),\n                         // SQL_DATA_TYPE - ODBC wants this to be not null\n-                        DataTypes.metaSqlDataType(t),\n-                        DataTypes.metaSqlDateTimeSub(t),\n+                        metaSqlDataType(t), metaSqlDateTimeSub(t),", "originalCommit": "153e6b9cdcf2b4c3f404cb7498cc048eae27d949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1Nzg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371257879", "bodyText": "minor: extra empty line", "author": "matriv", "createdAt": "2020-01-27T14:06:57Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/scalar/ScalarFunction.java", "diffHunk": "@@ -35,4 +44,104 @@ protected ScalarFunction(Source source, List<Expression> fields) {\n     public Expression orderBy() {\n         return null;\n     }\n+\n+\n+    //\n+    // Script generation\n+    //\n+", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NzkzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371257931", "bodyText": "minor: extra empty line", "author": "matriv", "createdAt": "2020-01-27T14:07:04Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/scalar/ScalarFunction.java", "diffHunk": "@@ -35,4 +44,104 @@ protected ScalarFunction(Source source, List<Expression> fields) {\n     public Expression orderBy() {\n         return null;\n     }\n+\n+\n+    //\n+    // Script generation\n+    //\n+\n+    public ScriptTemplate asScript(Expression exp) {\n+        if (exp.foldable()) {\n+            return scriptWithFoldable(exp);\n+        }\n+\n+        if (exp instanceof FieldAttribute) {\n+            return scriptWithField((FieldAttribute) exp);\n+        }\n+\n+        if (exp instanceof ScalarFunction) {\n+            return scriptWithScalar((ScalarFunction) exp);\n+        }\n+\n+        if (exp instanceof AggregateFunction) {\n+            return scriptWithAggregate((AggregateFunction) exp);\n+        }\n+\n+        if (exp instanceof GroupingFunction) {\n+            return scriptWithGrouping((GroupingFunction) exp);\n+        }\n+        throw new QlIllegalArgumentException(\"Cannot evaluate script for expression {}\", exp);\n+    }\n+\n+", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1ODMxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371258315", "bodyText": "minor: extra empty line", "author": "matriv", "createdAt": "2020-01-27T14:07:45Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/types/SqlTypesTests.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.types;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.type.EsField;\n+import org.elasticsearch.xpack.ql.type.KeywordEsField;\n+import org.elasticsearch.xpack.ql.type.TextEsField;\n+import org.elasticsearch.xpack.ql.type.TypesTests;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeRegistry;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.ql.type.DataTypes.DATETIME;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SqlTypesTests extends ESTestCase {\n+\n+", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1ODM2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371258365", "bodyText": "minor: extra empty line", "author": "matriv", "createdAt": "2020-01-27T14:07:51Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/types/SqlTypesTests.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.types;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.type.EsField;\n+import org.elasticsearch.xpack.ql.type.KeywordEsField;\n+import org.elasticsearch.xpack.ql.type.TextEsField;\n+import org.elasticsearch.xpack.ql.type.TypesTests;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeRegistry;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.ql.type.DataTypes.DATETIME;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SqlTypesTests extends ESTestCase {\n+\n+\n+    public void testGeoField() {\n+        Map<String, EsField> mapping = loadMapping(\"mapping-geo.json\");\n+        assertThat(mapping.size(), is(2));\n+        EsField gp = mapping.get(\"location\");\n+        assertThat(gp.getDataType().typeName(), is(\"geo_point\"));\n+        EsField gs = mapping.get(\"site\");\n+        assertThat(gs.getDataType().typeName(), is(\"geo_shape\"));\n+    }\n+", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MDI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371260266", "bodyText": "Could you please share the logic in this re-arrangement?", "author": "matriv", "createdAt": "2020-01-27T14:11:30Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plan/logical/command/sys/SysTypesTests.java", "diffHunk": "@@ -32,30 +33,30 @@\n     private final SqlParser parser = new SqlParser();\n \n     private Tuple<Command, SqlSession> sql(String sql) {\n-        EsIndex test = new EsIndex(\"test\", TypesTests.loadMapping(\"mapping-multi-field-with-nested.json\", true));\n-        Analyzer analyzer = new Analyzer(TestUtils.TEST_CFG, new FunctionRegistry(), IndexResolution.valid(test), null);\n+        EsIndex test = new EsIndex(\"test\", SqlTypesTests.loadMapping(\"mapping-multi-field-with-nested.json\", true));\n+        Analyzer analyzer = new Analyzer(SqlTestUtils.TEST_CFG, new FunctionRegistry(), IndexResolution.valid(test), null);\n         Command cmd = (Command) analyzer.analyze(parser.createStatement(sql), false);\n \n         IndexResolver resolver = mock(IndexResolver.class);\n-        SqlSession session = new SqlSession(TestUtils.TEST_CFG, null, null, resolver, null, null, null, null, null);\n+        SqlSession session = new SqlSession(SqlTestUtils.TEST_CFG, null, null, resolver, null, null, null, null, null);\n         return new Tuple<>(cmd, session);\n     }\n \n     public void testSysTypes() {\n         Command cmd = sql(\"SYS TYPES\").v1();\n \n         List<String> names = asList(\"BYTE\", \"LONG\", \"BINARY\", \"NULL\", \"INTEGER\", \"SHORT\", \"HALF_FLOAT\", \"FLOAT\", \"DOUBLE\", \"SCALED_FLOAT\",\n-                \"KEYWORD\", \"TEXT\", \"IP\", \"BOOLEAN\", \"DATE\", \"TIME\", \"DATETIME\",\n+                \"IP\", \"KEYWORD\", \"TEXT\", \"BOOLEAN\", \"DATE\", \"TIME\", \"DATETIME\",", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NTkxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371285919", "bodyText": "Added a comment - reproducing here for the record:\n\nordered per SQL type id (numeric) and then (for the same id) alphabetically", "author": "costin", "createdAt": "2020-01-27T14:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MDI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMwMDc2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371300769", "bodyText": "Thank you, I reviewed the PR over a couple of days and I forgot some stuff.", "author": "matriv", "createdAt": "2020-01-27T15:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MDI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MDY2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371270663", "bodyText": "same here", "author": "matriv", "createdAt": "2020-01-27T14:29:16Z", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/type/TypesTests.java", "diffHunk": "@@ -110,7 +108,7 @@ public void testDocValueField() {\n         assertThat(mapping.size(), is(1));\n         EsField field = mapping.get(\"session_id\");\n         assertThat(field, instanceOf(KeywordEsField.class));\n-        assertThat(field.getPrecision(), is(15));\n+        //assertThat(field.getPrecision(), is(15));", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3Mjk5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371272999", "bodyText": "Personal preference: I kinda liked more the method asOptionaScript", "author": "matriv", "createdAt": "2020-01-27T14:33:05Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/math/BinaryOptionalNumericFunction.java", "diffHunk": "@@ -88,7 +89,7 @@ public Expression replaceChildren(List<Expression> newChildren) {\n     @Override\n     public ScriptTemplate asScript() {\n         ScriptTemplate leftScript = asScript(left);\n-        ScriptTemplate rightScript = asOptionalScript(right);\n+        ScriptTemplate rightScript = asScript(right == null ? Literal.NULL : right);", "originalCommit": "dc2f108146e016d6627d5a0e1703d30ceaea49ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4Njg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51328#discussion_r371286841", "bodyText": "I removed it since it was not used anywhere outside the base class.\nThe script generation needs improvement anyway as it has evolved beyond the initial requirements.", "author": "costin", "createdAt": "2020-01-27T14:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3Mjk5OQ=="}], "type": "inlineReview"}]}