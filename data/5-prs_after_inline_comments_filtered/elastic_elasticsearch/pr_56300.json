{"pr_number": 56300, "pr_title": "EQL: Introduce support for sequences", "pr_createdAt": "2020-05-06T19:17:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56300", "timeline": [{"oid": "70d7ce8f41e2b022b72f8cffd5cedf47ba76890b", "url": "https://github.com/elastic/elasticsearch/commit/70d7ce8f41e2b022b72f8cffd5cedf47ba76890b", "message": "EQL: Introduce support for sequences\n\nInitial support for EQL sequences\nThe current algorithm is focused on correctness and does not contain\nany optimization which is left for the future.\n\nThe current implementation uses a state machine approach which moves\nascending and runs each query one after the other working on computing\nsequences as the data comes in.\nFor each result, the key and its timestamp are being extracted which are\nthen used for matching/building a sequence.", "committedDate": "2020-05-06T19:16:13Z", "type": "commit"}, {"oid": "70d7ce8f41e2b022b72f8cffd5cedf47ba76890b", "url": "https://github.com/elastic/elasticsearch/commit/70d7ce8f41e2b022b72f8cffd5cedf47ba76890b", "message": "EQL: Introduce support for sequences\n\nInitial support for EQL sequences\nThe current algorithm is focused on correctness and does not contain\nany optimization which is left for the future.\n\nThe current implementation uses a state machine approach which moves\nascending and runs each query one after the other working on computing\nsequences as the data comes in.\nFor each result, the key and its timestamp are being extracted which are\nthen used for matching/building a sequence.", "committedDate": "2020-05-06T19:16:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzOTQ3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421039475", "bodyText": "Since this doesn't precisely mirror the grammar, what errors will it cause if you do this?\nby substring(field)\nI completely agree with this restriction for Elasticsearch, even though Endpoint isn't bound by it. Will this raise a good error message or does it get buried in an uncaught exception?", "author": "rw-access", "createdAt": "2020-05-06T19:29:59Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/ExpressionBuilder.java", "diffHunk": "@@ -73,8 +74,8 @@ public Expression visitSingleExpression(EqlBaseParser.SingleExpressionContext ct\n     }\n \n     @Override\n-    public List<Expression> visitJoinKeys(JoinKeysContext ctx) {\n-        return ctx != null ? expressions(ctx.expression()) : emptyList();\n+    public List<Attribute> visitJoinKeys(JoinKeysContext ctx) {", "originalCommit": "70d7ce8f41e2b022b72f8cffd5cedf47ba76890b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5MDQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421390478", "bodyText": "Right now it will throw an exception since it expects a materialized expression which will fail for a function.\nThis needs improving but I'd rather handle that in a follow-up PR.", "author": "costin", "createdAt": "2020-05-07T10:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzOTQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3NjE1OA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421076158", "bodyText": "Thanks for this fix! Looks like this resolves\n#53237", "author": "rw-access", "createdAt": "2020-05-06T20:36:49Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1030,9 +1029,7 @@ protected LogicalPlan rule(Filter filter) {\n                     return filter.child();\n                 }\n                 if (FALSE.equals(condition) || Expressions.isNull(condition)) {\n-                    //TODO: re-visit this branch when it's decided if EQL needs a LocalRelation-like class\n-                    //return new LocalRelation(filter.source(), new EmptyExecutable(filter.output()));\n-                    throw new RuleExecutionException(\"Does not know how to handle a local relation\");\n+                    return nonMatchingFilter(filter);", "originalCommit": "70d7ce8f41e2b022b72f8cffd5cedf47ba76890b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDYyMA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421380620", "bodyText": "Not entirely - there is still some work to be done there mainly on returning the results from the empty executable however I didn't want to add that into this PR.", "author": "costin", "createdAt": "2020-05-07T09:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3NjE1OA=="}], "type": "inlineReview"}, {"oid": "9d1ead0fda5d291b07964be5180d0b0a19c7dd7d", "url": "https://github.com/elastic/elasticsearch/commit/9d1ead0fda5d291b07964be5180d0b0a19c7dd7d", "message": "Break eventQuery into two bits\n\nAdd Projection to restrict the field extraction only to higher-level\nconstructs like join/sequence", "committedDate": "2020-05-07T12:48:48Z", "type": "commit"}, {"oid": "efb8239c7ff27f768c88cf322b7b8426afc6fb3d", "url": "https://github.com/elastic/elasticsearch/commit/efb8239c7ff27f768c88cf322b7b8426afc6fb3d", "message": "Merge remote-tracking branch 'remotes/upstream/master' into eql/seqence-pr", "committedDate": "2020-05-07T13:13:59Z", "type": "commit"}, {"oid": "3515f88388cf337e90245f2a907025bb6191f835", "url": "https://github.com/elastic/elasticsearch/commit/3515f88388cf337e90245f2a907025bb6191f835", "message": "Fix checkstyle", "committedDate": "2020-05-07T13:31:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxMzA4OA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421513088", "bodyText": "why AtomicInteger where int will do just fine?", "author": "aleksmaus", "createdAt": "2020-05-07T13:42:12Z", "path": "x-pack/plugin/eql/qa/common/src/main/java/org/elasticsearch/test/eql/CommonEqlActionTestCase.java", "diffHunk": "@@ -140,18 +145,25 @@ public void cleanup() throws Exception {\n             }\n \n             if (supported) {\n-                String name = spec.description();\n-                if (Strings.isNullOrEmpty(name)) {\n-                    name = spec.note();\n-                }\n-                if (Strings.isNullOrEmpty(name)) {\n-                    name = spec.query();\n-                }\n-\n-                testSpecs.add(new Object[]{++counter, name, spec});\n+                filteredSpecs.add(spec);\n             }\n         }\n-        return testSpecs;\n+        counter = specs.size();\n+        return asArray(filteredSpecs);\n+    }\n+\n+    public static List<Object[]> asArray(List<EqlSpec> specs) {\n+        AtomicInteger counter = new AtomicInteger();", "originalCommit": "3515f88388cf337e90245f2a907025bb6191f835", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNDgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421534808", "bodyText": "int doesn't work since the stream pipeline requires a final/non-enclosed object. The AtomicLong is essentially a hack to increment the counter while keeping the same reference.", "author": "costin", "createdAt": "2020-05-07T14:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxMzA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2OTA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423669085", "bodyText": "It's a bit of misuse for AtomicInteger only for a Holder functionality but since it's a test it's not important.", "author": "matriv", "createdAt": "2020-05-12T11:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxMzA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxODU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421518581", "bodyText": "did you mean ExecutionManager.class here?", "author": "aleksmaus", "createdAt": "2020-05-07T13:49:22Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.assembler;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.tasks.TaskCancelledException;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.execution.listener.RuntimeUtils;\n+import org.elasticsearch.xpack.eql.execution.payload.Payload;\n+import org.elasticsearch.xpack.eql.execution.payload.SearchResponsePayload;\n+import org.elasticsearch.xpack.eql.execution.search.Querier;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.FieldHitExtractor;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.TimestampFieldHitExtractor;\n+import org.elasticsearch.xpack.eql.plan.physical.EsQueryExec;\n+import org.elasticsearch.xpack.eql.plan.physical.PhysicalPlan;\n+import org.elasticsearch.xpack.eql.plan.physical.SequenceExec;\n+import org.elasticsearch.xpack.eql.querydsl.container.FieldExtractorRegistry;\n+import org.elasticsearch.xpack.eql.querydsl.container.QueryContainer;\n+import org.elasticsearch.xpack.eql.session.Configuration;\n+import org.elasticsearch.xpack.eql.session.EqlSession;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.HitExtractor;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.util.Check;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.action.ActionListener.wrap;\n+import static org.elasticsearch.xpack.eql.execution.listener.RuntimeUtils.prepareRequest;\n+\n+public class ExecutionManager implements QueryClient {\n+\n+    private static final Logger log = LogManager.getLogger(Querier.class);", "originalCommit": "3515f88388cf337e90245f2a907025bb6191f835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyMzI1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421523257", "bodyText": "do we need to assert the assumption on sizes of the plans and listOfKeys here? not obvious in the scope of this function", "author": "aleksmaus", "createdAt": "2020-05-07T13:55:13Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.assembler;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.tasks.TaskCancelledException;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.execution.listener.RuntimeUtils;\n+import org.elasticsearch.xpack.eql.execution.payload.Payload;\n+import org.elasticsearch.xpack.eql.execution.payload.SearchResponsePayload;\n+import org.elasticsearch.xpack.eql.execution.search.Querier;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.FieldHitExtractor;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.TimestampFieldHitExtractor;\n+import org.elasticsearch.xpack.eql.plan.physical.EsQueryExec;\n+import org.elasticsearch.xpack.eql.plan.physical.PhysicalPlan;\n+import org.elasticsearch.xpack.eql.plan.physical.SequenceExec;\n+import org.elasticsearch.xpack.eql.querydsl.container.FieldExtractorRegistry;\n+import org.elasticsearch.xpack.eql.querydsl.container.QueryContainer;\n+import org.elasticsearch.xpack.eql.session.Configuration;\n+import org.elasticsearch.xpack.eql.session.EqlSession;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.HitExtractor;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.util.Check;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.action.ActionListener.wrap;\n+import static org.elasticsearch.xpack.eql.execution.listener.RuntimeUtils.prepareRequest;\n+\n+public class ExecutionManager implements QueryClient {\n+\n+    private static final Logger log = LogManager.getLogger(Querier.class);\n+\n+    private final Configuration cfg;\n+    private final Client client;\n+    private final TimeValue keepAlive;\n+    private final String indices;\n+\n+    public ExecutionManager(EqlSession eqlSession) {\n+        this.cfg = eqlSession.configuration();\n+        this.client = eqlSession.client();\n+        this.keepAlive = cfg.requestTimeout();\n+        this.indices = cfg.indexAsWildcard();\n+    }\n+\n+    public Executable from(SequenceExec seqExec) {\n+        FieldExtractorRegistry extractorRegistry = new FieldExtractorRegistry();\n+        \n+        List<List<Attribute>> listOfKeys = seqExec.keys();\n+        List<PhysicalPlan> plans = seqExec.children();\n+        List<Criterion> criteria = new ArrayList<>(plans.size() - 1);\n+        \n+        // build a criterion for each query\n+        for (int i = 0; i < plans.size() - 1; i++) {\n+            List<Attribute> keys = listOfKeys.get(i);", "originalCommit": "3515f88388cf337e90245f2a907025bb6191f835", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0OTg2MA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r421549860", "bodyText": "This is handled inside LogicalPlan.visitJoin/visitSequence when the keys between the top-level and potentially individual queries are merged in a unified way.", "author": "costin", "createdAt": "2020-05-07T14:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyMzI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0NDk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423344944", "bodyText": "Can you add clarity to what \"Instance  of a sequence\" means, and how it relates to other classes like SequenceRuntime?\n\nResult of a sequence\nA pending sequence that contains its current state as it progresses from pos 0 to pos N-1\nNode for the AST\nSequence physical plan\nQuery within a sequence\netc", "author": "rw-access", "createdAt": "2020-05-11T22:00:39Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/Sequence.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.sequence;\n+\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.util.Check;\n+\n+import java.text.NumberFormat;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+\n+/**\n+ * Instance of a sequence. Defined by its key and stage.", "originalCommit": "3515f88388cf337e90245f2a907025bb6191f835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM3NDA5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423374099", "bodyText": "Inverting this might simplify the frame() function: List<Map<SequenceKey, SequenceFrame>>", "author": "rw-access", "createdAt": "2020-05-11T23:20:55Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/KeyToSequences.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.sequence;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Dedicated collection for mapping a key to a list of sequences */\n+/** The list represents the sequence for each stage (based on its index) and is fixed in size */\n+\n+class KeyToSequences {\n+\n+    private final int listSize;\n+    private final Map<SequenceKey, List<SequenceFrame>> keyToSequences;", "originalCommit": "3515f88388cf337e90245f2a907025bb6191f835", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MzUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423593509", "bodyText": "Indeed - my concern iswhich layout is more memory efficient. Maps are heavier than lists and for a large number of keys that would be required in the first stages in a sequences, that would result in a number of maps with a large number of keys.\nThe access time would be faster as the number of keys gets smaller in each stage but (without benchmarking) I considered that to be less of an issue.\nFurther experimentation will tell which one would work better.\nHaving a list for every single key (even if transitory) might prove problematic as well.", "author": "costin", "createdAt": "2020-05-12T09:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM3NDA5OQ=="}], "type": "inlineReview"}, {"oid": "2b608e484722493866802c68d417dcec9f8ec2e1", "url": "https://github.com/elastic/elasticsearch/commit/2b608e484722493866802c68d417dcec9f8ec2e1", "message": "Address feedback\n\nAdd documentation and hook up integration tests again", "committedDate": "2020-05-12T10:48:38Z", "type": "commit"}, {"oid": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "url": "https://github.com/elastic/elasticsearch/commit/e6386bf32c49c1b2a68b81672b6250abe8fc7807", "message": "Merge branch 'master' into eql/seqence-pr", "committedDate": "2020-05-12T11:29:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4NjE0NA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423686144", "bodyText": "The projection was introduced since:\n\nthe results only care about the hits, not individual fields.\nhaving each field extracted, due to the number of exact types, causes the doc values limit to be reached.\n\nBefore this PR the event filters did not return any attributes but now, as inputs to sequences they have to otherwise the key or timestamp field resolution for them fails.\nHence why the visitEventQuery now wraps the visitEventFilter - the latter creates the proper plan for internal use while the former wraps it up for external consumption. Note that sequence and join use the same idea - they don't output any attribute since their entire content is needed.", "author": "costin", "createdAt": "2020-05-12T12:17:05Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,8 +52,17 @@ public LogicalPlanBuilder(ParserParams params) {\n         super(params);\n     }\n \n+    private Attribute fieldTimestamp() {\n+        return new UnresolvedAttribute(Source.EMPTY, params.fieldTimestamp());\n+    }\n+\n     @Override\n     public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n+        return new Project(source(ctx), visitEventFilter(ctx.eventFilter()), emptyList());", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NTA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423695096", "bodyText": "@costin thx for explaining!", "author": "matriv", "createdAt": "2020-05-12T12:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4NjE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423013972", "bodyText": "minor: can be final", "author": "matriv", "createdAt": "2020-05-11T12:47:56Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueriesUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.planner;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+class QueriesUtils {", "originalCommit": "3515f88388cf337e90245f2a907025bb6191f835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNzgxOA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423017818", "bodyText": "Why not create an ArrayList and if necessary make it immutable before returning?", "author": "matriv", "createdAt": "2020-05-11T12:54:59Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/SequenceKey.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.sequence;\n+\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class SequenceKey {\n+\n+    public static final SequenceKey NONE = new SequenceKey();\n+\n+    private final Object[] keys;\n+\n+    public SequenceKey(Object... keys) {\n+        this.keys = keys;\n+    }\n+\n+    public List<String> asStringList() {\n+        String[] s = new String[keys.length];", "originalCommit": "3515f88388cf337e90245f2a907025bb6191f835", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcyMDc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423720763", "bodyText": "Because this achieves the same thing but faster. By using asList the backing array is returned with a fixed size (no extra allocation) and wrapped as a semi-immutable list, meaning it won't grow but you can replace it.\nWhich I think it's fine considering the internal usage.", "author": "costin", "createdAt": "2020-05-12T13:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNzgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423670692", "bodyText": "Is it ok to use only the 1st one?", "author": "matriv", "createdAt": "2020-05-12T11:48:42Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/listener/BasicListener.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.listener;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.session.Results;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.eql.execution.listener.RuntimeUtils.logSearchResponse;\n+\n+public class BasicListener implements ActionListener<SearchResponse> {\n+\n+    private static final Logger log = LogManager.getLogger(BasicListener.class);\n+\n+    private final ActionListener<Results> listener;\n+    private final SearchRequest request;\n+\n+    public BasicListener(ActionListener<Results> listener,\n+                               SearchRequest request) {\n+\n+        this.listener = listener;\n+        this.request = request;\n+    }\n+\n+    @Override\n+    public void onResponse(SearchResponse response) {\n+        try {\n+            ShardSearchFailure[] failures = response.getShardFailures();\n+            if (CollectionUtils.isEmpty(failures) == false) {\n+                listener.onFailure(new EqlIllegalArgumentException(failures[0].reason(), failures[0].getCause()));", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4ODc5MA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423788790", "bodyText": "That's what we currently use in SQL/QL as well. We could revisit this for a better error message, however it's a separate issue.", "author": "costin", "createdAt": "2020-05-12T14:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NjI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423996253", "bodyText": "Re: AtomicInteger, Holder is inside ql package, a dependency qa does not currently use.", "author": "costin", "createdAt": "2020-05-12T19:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MzE4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423673181", "bodyText": "Maybe extract this to a static method so that the string is also more \"static\".", "author": "matriv", "createdAt": "2020-05-12T11:53:34Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -62,27 +79,31 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n \n         Filter filter = new Filter(source, RELATION, condition);\n         // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n-        Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n-                Order.NullsPosition.FIRST);\n+        Order order = new Order(source, fieldTimestamp(), Order.OrderDirection.ASC, Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n \n     @Override\n     public Join visitJoin(JoinContext ctx) {\n-        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+        List<Attribute> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        Source source = source(ctx);\n+\n+        KeyedFilter until;\n \n-        LogicalPlan until;\n-        \n         if (ctx.until != null) {\n             until = visitJoinTerm(ctx.until, parentJoinKeys);\n         } else {\n-            // no until declared means the condition never gets executed and thus folds to false\n-            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+            // no until declared means no results\n+            // create a dummy keyed filter\n+            String notUsed = \"<not-used>\";\n+            Attribute tsField = new FieldAttribute(source, notUsed, new UnsupportedEsField(notUsed, notUsed));", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NzgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423997808", "bodyText": "If there's no reuse, no much point in making the string static since the compiler does that automatically through the constant pool.", "author": "costin", "createdAt": "2020-05-12T19:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MzE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MzY4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423673689", "bodyText": "minor: empty line.", "author": "matriv", "createdAt": "2020-05-12T11:54:34Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plan/physical/SequenceExec.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.plan.physical;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.execution.assembler.ExecutionManager;\n+import org.elasticsearch.xpack.eql.session.EqlSession;\n+import org.elasticsearch.xpack.eql.session.Results;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.NamedExpression;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.singletonList;\n+\n+public class SequenceExec extends PhysicalPlan {\n+\n+    private final List<List<Attribute>> keys;\n+    private final Attribute timestamp;\n+\n+    public SequenceExec(Source source,\n+                        List<List<Attribute>> keys,\n+                        List<PhysicalPlan> matches,\n+                        List<Attribute> untilKeys,\n+                        PhysicalPlan until,\n+                        Attribute timestampField) {\n+        this(source, CollectionUtils.combine(matches, until), CollectionUtils.combine(keys, singletonList(untilKeys)), timestampField);\n+    }\n+\n+    private SequenceExec(Source source, List<PhysicalPlan> children, List<List<Attribute>> keys, Attribute timestampField) {\n+        super(source, children);\n+        this.keys = keys;\n+        this.timestamp = timestampField;\n+    }\n+\n+    @Override\n+    protected NodeInfo<SequenceExec> info() {\n+        return NodeInfo.create(this, SequenceExec::new, children(), keys, timestamp);\n+    }\n+\n+    @Override\n+    public PhysicalPlan replaceChildren(List<PhysicalPlan> newChildren) {\n+        if (newChildren.size() != children().size()) {\n+            throw new EqlIllegalArgumentException(\"Expected the same number of children [{}] but got [{}]\", children().size(), newChildren\n+                    .size());\n+        }\n+        return new SequenceExec(source(), newChildren, keys, timestamp);\n+    }\n+\n+    @Override\n+    public List<Attribute> output() {\n+        List<Attribute> attrs = new ArrayList<>();\n+        attrs.add(timestamp);\n+        for (List<? extends NamedExpression> ne : keys) {\n+            attrs.addAll(Expressions.asAttributes(ne));\n+        }\n+        return attrs;\n+    }\n+\n+    public List<List<Attribute>> keys() {\n+        return keys;\n+    }\n+\n+    public Attribute timestamp() {\n+        return timestamp;\n+    }\n+\n+    @Override\n+    public void execute(EqlSession session, ActionListener<Results> listener) {\n+        new ExecutionManager(session).from(this).execute(listener);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(timestamp, keys, children());\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        SequenceExec other = (SequenceExec) obj;\n+        return Objects.equals(timestamp, other.timestamp)\n+                && Objects.equals(children(), other.children())\n+                && Objects.equals(keys, other.keys);\n+                ", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NTkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423675902", "bodyText": "I don't get this, sorry.", "author": "matriv", "createdAt": "2020-05-12T11:58:33Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/Sequence.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.sequence;\n+\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.util.Check;\n+\n+import java.text.NumberFormat;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+\n+/**\n+ * Holder class representing the instance of a sequence. Used at runtime by the engine to track sequences.\n+ * Defined by its key and stage.\n+ * This class is NOT immutable (to optimize memory) which means its associations need to be managed.\n+ */\n+public class Sequence {\n+\n+    private final SequenceKey key;\n+    private final int stages;\n+    private final Match[] matches;\n+\n+    private int currentStage = 0;\n+\n+    public Sequence(SequenceKey key, int stages, long timestamp, SearchHit firstHit) {\n+        Check.isTrue(stages >= 2, \"A sequence requires at least 2 criteria, given [{}]\", stages);\n+        this.key = key;\n+        this.stages = stages;\n+        this.matches = new Match[stages];\n+        this.matches[0] = new Match(timestamp, firstHit);\n+    }\n+\n+    public int putMatch(int stage, SearchHit hit, long timestamp) {\n+        if (stage == currentStage + 1) {\n+            int previousStage = currentStage;\n+            currentStage = stage;\n+            matches[currentStage] = new Match(timestamp, hit);\n+            return previousStage;\n+        }\n+        throw new EqlIllegalArgumentException(\"Incorrect stage [{}] specified for Sequence[key={}, stage=]\", stage, key, currentStage);\n+    }\n+\n+    public SequenceKey key() {\n+        return key;\n+    }\n+\n+    public int currentStage() {\n+        return currentStage;\n+    }\n+\n+    public long currentTimestamp() {\n+        return matches[currentStage].timestamp();\n+    }\n+\n+    public long timestamp(int stage) {\n+        if (stage > currentStage) {\n+            return Long.MAX_VALUE;", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5MDQxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423790419", "bodyText": "This piece of code is not fully fleshed out - essentially for a frame of events, we can tell what's the minimum and maximum timestamp (when it started and where it stopped). The above case is for the corner case - when a stage that did not match is asked for, return an out of band value (MAX) so there's no match.", "author": "costin", "createdAt": "2020-05-12T14:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NTkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgyMzc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423823787", "bodyText": "Would be nice to have a comment for that.", "author": "matriv", "createdAt": "2020-05-12T15:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NjY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423676644", "bodyText": "You could use String.valueOf(stages).length().", "author": "matriv", "createdAt": "2020-05-12T11:59:58Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/Sequence.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.sequence;\n+\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.util.Check;\n+\n+import java.text.NumberFormat;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+\n+/**\n+ * Holder class representing the instance of a sequence. Used at runtime by the engine to track sequences.\n+ * Defined by its key and stage.\n+ * This class is NOT immutable (to optimize memory) which means its associations need to be managed.\n+ */\n+public class Sequence {\n+\n+    private final SequenceKey key;\n+    private final int stages;\n+    private final Match[] matches;\n+\n+    private int currentStage = 0;\n+\n+    public Sequence(SequenceKey key, int stages, long timestamp, SearchHit firstHit) {\n+        Check.isTrue(stages >= 2, \"A sequence requires at least 2 criteria, given [{}]\", stages);\n+        this.key = key;\n+        this.stages = stages;\n+        this.matches = new Match[stages];\n+        this.matches[0] = new Match(timestamp, firstHit);\n+    }\n+\n+    public int putMatch(int stage, SearchHit hit, long timestamp) {\n+        if (stage == currentStage + 1) {\n+            int previousStage = currentStage;\n+            currentStage = stage;\n+            matches[currentStage] = new Match(timestamp, hit);\n+            return previousStage;\n+        }\n+        throw new EqlIllegalArgumentException(\"Incorrect stage [{}] specified for Sequence[key={}, stage=]\", stage, key, currentStage);\n+    }\n+\n+    public SequenceKey key() {\n+        return key;\n+    }\n+\n+    public int currentStage() {\n+        return currentStage;\n+    }\n+\n+    public long currentTimestamp() {\n+        return matches[currentStage].timestamp();\n+    }\n+\n+    public long timestamp(int stage) {\n+        if (stage > currentStage) {\n+            return Long.MAX_VALUE;\n+        }\n+        return matches[stage].timestamp();\n+    }\n+\n+    public List<SearchHit> hits() {\n+        List<SearchHit> hits = new ArrayList<>(matches.length);\n+        for (Match m : matches) {\n+            hits.add(m.hit());\n+        }\n+        return hits;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(currentStage, key);\n+    }\n+    \n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        \n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        \n+        Sequence other = (Sequence) obj;\n+        return Objects.equals(currentStage, other.currentStage)\n+                && Objects.equals(key, other.key);\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        int numberOfDigits = stages > 100 ? 3 : stages > 10 ? 2 : 1;", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5MTQ5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423791496", "bodyText": "True but it felt a waste to allocate a string only to discard it instead of doing 3 comparisons :).", "author": "costin", "createdAt": "2020-05-12T14:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NjY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4ODQ4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423688489", "bodyText": "could be also final", "author": "matriv", "createdAt": "2020-05-12T12:21:17Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/listener/RuntimeUtils.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.listener;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.search.aggregations.Aggregation;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.FieldHitExtractor;\n+import org.elasticsearch.xpack.eql.querydsl.container.ComputedRef;\n+import org.elasticsearch.xpack.eql.querydsl.container.SearchHitFieldRef;\n+import org.elasticsearch.xpack.eql.session.Configuration;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.ComputingExtractor;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.HitExtractor;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.HitExtractorInput;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.ReferenceInput;\n+import org.elasticsearch.xpack.ql.index.IndexResolver;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class RuntimeUtils {", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d3e2671d9f17d9fd393e22e56c3a98883b091ffc", "url": "https://github.com/elastic/elasticsearch/commit/d3e2671d9f17d9fd393e22e56c3a98883b091ffc", "message": "Merge remote-tracking branch 'remotes/upstream/master' into eql/seqence-pr", "committedDate": "2020-05-12T12:50:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NjUxNA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423696514", "bodyText": "This method exists in the same form in SQL's Querier. Can you extract it from both places in a common location in QL?", "author": "astefan", "createdAt": "2020-05-12T12:34:41Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/listener/RuntimeUtils.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.listener;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.search.aggregations.Aggregation;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.FieldHitExtractor;\n+import org.elasticsearch.xpack.eql.querydsl.container.ComputedRef;\n+import org.elasticsearch.xpack.eql.querydsl.container.SearchHitFieldRef;\n+import org.elasticsearch.xpack.eql.session.Configuration;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.ComputingExtractor;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.HitExtractor;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.HitExtractorInput;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.ReferenceInput;\n+import org.elasticsearch.xpack.ql.index.IndexResolver;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class RuntimeUtils {\n+\n+    private RuntimeUtils() {}\n+\n+    static void logSearchResponse(SearchResponse response, Logger logger) {", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwMjY3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r424002675", "bodyText": "Most of the methods inside RuntimeUtils are similar between the two, including the request preparation.\nI think parts of the EQL execution could be ported to SQL (through QL) once things finalized but since we're not yet there, I opted not to chase that in this PR.\nThe aim here is to get the basic sequence work in place and then iterate over that.\nI've raised #56641 to make sure we're not losing track of that.", "author": "costin", "createdAt": "2020-05-12T20:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NjUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODM2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423698362", "bodyText": "You don't seem to do anything with keepAlive. I assume it will be added later?", "author": "astefan", "createdAt": "2020-05-12T12:37:42Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.assembler;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.tasks.TaskCancelledException;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.execution.listener.RuntimeUtils;\n+import org.elasticsearch.xpack.eql.execution.payload.Payload;\n+import org.elasticsearch.xpack.eql.execution.payload.SearchResponsePayload;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.FieldHitExtractor;\n+import org.elasticsearch.xpack.eql.execution.search.extractor.TimestampFieldHitExtractor;\n+import org.elasticsearch.xpack.eql.plan.physical.EsQueryExec;\n+import org.elasticsearch.xpack.eql.plan.physical.PhysicalPlan;\n+import org.elasticsearch.xpack.eql.plan.physical.SequenceExec;\n+import org.elasticsearch.xpack.eql.querydsl.container.FieldExtractorRegistry;\n+import org.elasticsearch.xpack.eql.querydsl.container.QueryContainer;\n+import org.elasticsearch.xpack.eql.session.Configuration;\n+import org.elasticsearch.xpack.eql.session.EqlSession;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.HitExtractor;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.util.Check;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.action.ActionListener.wrap;\n+import static org.elasticsearch.xpack.eql.execution.listener.RuntimeUtils.prepareRequest;\n+\n+public class ExecutionManager implements QueryClient {\n+\n+    private static final Logger log = LogManager.getLogger(ExecutionManager.class);\n+\n+    private final Configuration cfg;\n+    private final Client client;\n+    private final TimeValue keepAlive;", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwMjg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r424002868", "bodyText": "Yes", "author": "costin", "createdAt": "2020-05-12T20:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcwMTI2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423701265", "bodyText": "Newline?", "author": "astefan", "createdAt": "2020-05-12T12:42:25Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/SequenceStateMachine.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.sequence;\n+\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.search.SearchHit;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * State machine that holds and manages all in-flight sequences.\n+ */\n+public class SequenceStateMachine {\n+\n+    /** Current sequences for each key */\n+    /** Note will be multiple sequences for the same key and the same stage with different timestamps */\n+    private final KeyToSequences keyToSequences;\n+    /** Current keys on each stage */\n+    private final StageToKeys stageToKeys;\n+\n+    /** minimum timestamp per stage */\n+    /** this ignores the key */\n+    private final long[] timestampMarkers;\n+\n+    private final int completionStage;\n+\n+    /** list of completed sequences - separate to avoid polluting the other stages */\n+    private final List<Sequence> completed;\n+\n+    public SequenceStateMachine(int stages) {\n+        this.completionStage = stages - 1;\n+        this.stageToKeys = new StageToKeys(completionStage);\n+        this.keyToSequences = new KeyToSequences(completionStage);\n+        this.timestampMarkers = new long[completionStage];\n+        this.completed = new LinkedList<>();\n+    }\n+\n+    public List<Sequence> completeSequences() {\n+        return completed;\n+    }\n+\n+    public long getTimestampMarker(int stage) {\n+        return timestampMarkers[stage];\n+    }\n+\n+    public void setTimestampMarker(int stage, long timestamp) {\n+        timestampMarkers[stage] = timestamp;\n+    }\n+\n+    public void trackSequence(Sequence sequence, long tMin, long tMax) {\n+        SequenceKey key = sequence.key();\n+\n+        stageToKeys.keys(0).add(key);\n+        SequenceFrame frame = keyToSequences.frame(0, key);\n+        frame.setTimeFrame(tMin, tMax);\n+        frame.add(sequence);\n+    }\n+\n+    /** Match the given hit (based on key and timestamp) with any potential sequence from the previous", "originalCommit": "e6386bf32c49c1b2a68b81672b6250abe8fc7807", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcyMTg0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r423721847", "bodyText": "This sounds like an incomplete sentence.", "author": "astefan", "createdAt": "2020-05-12T13:13:46Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/sequence/SequenceFrame.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.sequence;\n+\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+\n+/** List of sequences (typically in a stage) used for finding continuous events within a time-frame */\n+public class SequenceFrame {\n+\n+    // NB: since the size varies significantly, use a LinkedList\n+    // Considering the order it might make sense to use a B-Tree+ for faster lookups which should work well with\n+    // timestamp compression (which is known for the group", "originalCommit": "d3e2671d9f17d9fd393e22e56c3a98883b091ffc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "45250f8cdaa0d7341f0b1ef2dc5f6301940244a3", "url": "https://github.com/elastic/elasticsearch/commit/45250f8cdaa0d7341f0b1ef2dc5f6301940244a3", "message": "Addressing the next round of feedback", "committedDate": "2020-05-12T20:10:24Z", "type": "commit"}, {"oid": "f58a5a84e395ea4f96c9767aa0f0230f7b6b4c71", "url": "https://github.com/elastic/elasticsearch/commit/f58a5a84e395ea4f96c9767aa0f0230f7b6b4c71", "message": "Merge remote-tracking branch 'remotes/upstream/master' into eql/seqence-pr", "committedDate": "2020-05-12T20:11:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEyMTcxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r424121719", "bodyText": "this is an odd formatting for if else if .... seems like the same line is more common in the current code", "author": "aleksmaus", "createdAt": "2020-05-13T01:24:13Z", "path": "x-pack/plugin/eql/qa/common/src/main/java/org/elasticsearch/test/eql/CommonEqlActionTestCase.java", "diffHunk": "@@ -165,9 +179,29 @@ public CommonEqlActionTestCase(int num, String name, EqlSpec spec) {\n     }\n \n     public void test() throws Exception {\n-        EqlSearchRequest request = new EqlSearchRequest(testIndexName, spec.query());\n-        EqlSearchResponse response = highLevelClient().eql().search(request, RequestOptions.DEFAULT);\n-        assertSpec(response.hits().events());\n+        assertResponse(runQuery(testIndexName, spec.query()));\n+    }\n+\n+    protected void assertResponse(EqlSearchResponse response) {\n+        Hits hits = response.hits();\n+        if (hits.events() != null) {\n+            assertSearchHits(hits.events());\n+        }\n+        else if (hits.sequences() != null) {\n+            assertSequences(hits.sequences());\n+        }\n+        else {\n+            fail(\"No events or sequences found\");\n+        }", "originalCommit": "f58a5a84e395ea4f96c9767aa0f0230f7b6b4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEyNTI2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/56300#discussion_r424125261", "bodyText": "nit: slightly shorter\n        SequenceKey key = SequenceKey.NONE;\n        if (!criterion.keyExtractors().isEmpty()) {\n            Object[] docKeys = new Object[keyExtractors.size()];\n            for (int i = 0; i < docKeys.length; i++) {\n                docKeys[i] = keyExtractors.get(i).extract(hit);\n            }\n            key = new SequenceKey(docKeys);\n        }", "author": "aleksmaus", "createdAt": "2020-05-13T01:38:36Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/SequenceRuntime.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.assembler;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.eql.execution.payload.Payload;\n+import org.elasticsearch.xpack.eql.execution.sequence.Sequence;\n+import org.elasticsearch.xpack.eql.execution.sequence.SequenceKey;\n+import org.elasticsearch.xpack.eql.execution.sequence.SequenceStateMachine;\n+import org.elasticsearch.xpack.eql.session.Results;\n+import org.elasticsearch.xpack.ql.execution.search.extractor.HitExtractor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.action.ActionListener.wrap;\n+\n+/**\n+ * Executable tracking sequences at runtime.\n+ */\n+class SequenceRuntime implements Executable {\n+\n+    private final List<Criterion> criteria;\n+    // NB: just like in a list, this represents the total number of stages yet counting starts at 0\n+    private final int numberOfStages;\n+    private final SequenceStateMachine stateMachine;\n+    private final QueryClient queryClient;\n+    private long startTime;\n+\n+    SequenceRuntime(List<Criterion> criteria, QueryClient queryClient) {\n+        this.criteria = criteria;\n+        this.numberOfStages = criteria.size();\n+        this.stateMachine = new SequenceStateMachine(numberOfStages);\n+        this.queryClient = queryClient;\n+    }\n+\n+    @Override\n+    public void execute(ActionListener<Results> resultsListener) {\n+        startTime = System.currentTimeMillis();\n+        startSequencing(resultsListener);\n+    }\n+\n+    private void startSequencing(ActionListener<Results> resultsListener) {\n+        Criterion firstStage = criteria.get(0);\n+        queryClient.query(firstStage.searchSource(), wrap(payload -> {\n+\n+            // 1. execute last stage (find keys)\n+            startTracking(payload);\n+\n+            // 2. go descending through the rest of the stages, while adjusting the query\n+            inspectStage(1, resultsListener);\n+\n+        }, resultsListener::onFailure));\n+    }\n+\n+    private void startTracking(Payload<SearchHit> payload) {\n+        Criterion lastCriterion = criteria.get(0);\n+        List<SearchHit> hits = payload.values();\n+\n+        long tMin = Long.MAX_VALUE;\n+        long tMax = Long.MIN_VALUE;\n+        // we could have extracted that in the hit loop but that if would have been evaluated\n+        // for every document\n+        if (hits.isEmpty() == false) {\n+            tMin = (Long) lastCriterion.timestampExtractor().extract(hits.get(0));\n+            tMax = (Long) lastCriterion.timestampExtractor().extract(hits.get(hits.size() - 1));\n+        }\n+\n+        for (SearchHit hit : hits) {\n+            KeyWithTime keyAndTime = findKey(hit, lastCriterion);\n+            Sequence seq = new Sequence(keyAndTime.key, numberOfStages, keyAndTime.timestamp, hit);\n+            stateMachine.trackSequence(seq, tMin, tMax);\n+        }\n+        // TB: change\n+        stateMachine.setTimestampMarker(0, tMin);\n+    }\n+\n+    private void inspectStage(int stage, ActionListener<Results> resultsListener) {\n+        // sequencing is done, return results\n+        if (stage == numberOfStages) {\n+            resultsListener.onResponse(assembleResults());\n+            return;\n+        }\n+        // else continue finding matches\n+        Criterion currentCriterion = criteria.get(stage);\n+        // narrow by the previous stage timestamp marker\n+        currentCriterion.fromTimestamp(stateMachine.getTimestampMarker(stage - 1));\n+        \n+        queryClient.query(currentCriterion.searchSource(), wrap(payload -> {\n+            findMatches(stage, payload);\n+            inspectStage(stage + 1, resultsListener);\n+        }, resultsListener::onFailure));\n+    }\n+\n+    private void findMatches(int currentStage, Payload<SearchHit> payload) {\n+        Criterion currentCriterion = criteria.get(currentStage);\n+        List<SearchHit> hits = payload.values();\n+        \n+        // break the results per key\n+        for (SearchHit hit : hits) {\n+            KeyWithTime kt = findKey(hit, currentCriterion);\n+            stateMachine.match(currentStage, kt.key, kt.timestamp, hit);\n+        }\n+    }\n+\n+    private KeyWithTime findKey(SearchHit hit, Criterion criterion) {\n+        List<HitExtractor> keyExtractors = criterion.keyExtractors();\n+\n+        SequenceKey key;\n+        if (criterion.keyExtractors().isEmpty()) {\n+            key = SequenceKey.NONE;\n+        } else {\n+            Object[] docKeys = new Object[keyExtractors.size()];\n+            for (int i = 0; i < docKeys.length; i++) {\n+                docKeys[i] = keyExtractors.get(i).extract(hit);\n+            }\n+            key = new SequenceKey(docKeys);\n+        }", "originalCommit": "f58a5a84e395ea4f96c9767aa0f0230f7b6b4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}