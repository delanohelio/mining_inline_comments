{"pr_number": 55834, "pr_title": "Split java plugin elements out of BuildPlugin", "pr_createdAt": "2020-04-27T23:26:14Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55834", "timeline": [{"oid": "d18dcb2165c1ccf864bdc719c692e709886445e4", "url": "https://github.com/elastic/elasticsearch/commit/d18dcb2165c1ccf864bdc719c692e709886445e4", "message": "Split java plugin elements out of BuildPlugin\n\nBuildPlugin is a catch all for any elasticsearch common build\ninfrastructure. Unfortunately that makes reusing parts of it difficult.\nThis commit splits the parts specific to all java based projects out to\nour own elasticsearch.java plugin.", "committedDate": "2020-04-27T23:24:00Z", "type": "commit"}, {"oid": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "url": "https://github.com/elastic/elasticsearch/commit/02807869f9a5d418a6d66993d98bc31b57e61aa4", "message": "formatting", "committedDate": "2020-04-28T00:01:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1Njc1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416756755", "bodyText": "We should probably name this variable testCompileConfig.", "author": "mark-vieira", "createdAt": "2020-04-28T16:32:26Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);", "originalCommit": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NzkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416757925", "bodyText": "FWIW, I recently found out you can just do project.getExtensions().getExtraProperties() as a convenience for getting the ExtraPropertiesExtension.", "author": "mark-vieira", "createdAt": "2020-04-28T16:34:13Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);", "originalCommit": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjcwMw==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416772703", "bodyText": "Nice! very useful", "author": "rjernst", "createdAt": "2020-04-28T16:55:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NzkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1ODM1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416758353", "bodyText": "This seems like something we'd want to throw in one of our util classes.", "author": "mark-vieira", "createdAt": "2020-04-28T16:34:54Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {", "originalCommit": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MzQ2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416773469", "bodyText": "Possibly, but I'd rather add it there once we have more uses.", "author": "rjernst", "createdAt": "2020-04-28T16:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1ODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MDE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416760191", "bodyText": "I'm wondering why we need afterEvaluate here. Is it strictly necessary? If anything, shouldn't any config in the build script take precedence over these conventions?", "author": "mark-vieira", "createdAt": "2020-04-28T16:37:36Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {", "originalCommit": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3NDA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416774079", "bodyText": "I'm not sure how necessary it is, but I'd like to defer this until after this PR, so that any behavior changes can be isolated.", "author": "rjernst", "createdAt": "2020-04-28T16:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MDE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MTg5NA==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416761894", "bodyText": "Let's ditch this and just use BuildParams.inFipsJvm(). No need to have this implemented twice.", "author": "mark-vieira", "createdAt": "2020-04-28T16:40:15Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {\n+            project.getTasks().withType(JavaCompile.class).configureEach(compileTask -> {\n+                CompileOptions compileOptions = compileTask.getOptions();\n+\n+                configureFork.accept(compileOptions);\n+                /*\n+                 * -path because gradle will send in paths that don't always exist.\n+                 * -missing because we have tons of missing @returns and @param.\n+                 * -serial because we don't use java serialization.\n+                 */\n+                // don't even think about passing args with -J-xxx, oracle will ask you to submit a bug report :)\n+                // fail on all javac warnings\n+                List<String> compilerArgs = compileOptions.getCompilerArgs();\n+                compilerArgs.add(\"-Werror\");\n+                compilerArgs.add(\"-Xlint:all,-path,-serial,-options,-deprecation,-try\");\n+                compilerArgs.add(\"-Xdoclint:all\");\n+                compilerArgs.add(\"-Xdoclint:-missing\");\n+\n+                // either disable annotation processor completely (default) or allow to enable them if an annotation processor is explicitly\n+                // defined\n+                if (compilerArgs.contains(\"-processor\") == false) {\n+                    compilerArgs.add(\"-proc:none\");\n+                }\n+\n+                compileOptions.setEncoding(\"UTF-8\");\n+                compileOptions.setIncremental(true);\n+\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+\n+            });\n+            // also apply release flag to groovy, which is used in build-tools\n+            project.getTasks().withType(GroovyCompile.class).configureEach(compileTask -> {\n+                configureFork.accept(compileTask.getOptions());\n+\n+                // TODO: this probably shouldn't apply to groovy at all?\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                final List<String> compilerArgs = compileTask.getOptions().getCompilerArgs();\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+            });\n+        });\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            // Ensure that when we are compiling against the \"original\" JAR that we also include any \"shadow\" dependencies on the compile\n+            // classpath\n+            Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+            Configuration apiConfig = project.getConfigurations().getByName(JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME);\n+            shadowConfig.getDependencies().all(dependency -> apiConfig.getDependencies().add(dependency));\n+        });\n+    }\n+\n+    /**\n+     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n+     */\n+    public static void configureInputNormalization(Project project) {\n+        project.getNormalization().getRuntimeClasspath().ignore(\"META-INF/MANIFEST.MF\");\n+    }\n+\n+    public static void configureTestTasks(Project project) {\n+        // Default test task should run only unit tests\n+        maybeConfigure(project.getTasks(), \"test\", Test.class, task -> task.include(\"**/*Tests.class\"));\n+\n+        // none of this stuff is applicable to the `:buildSrc` project tests\n+        if (project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+\n+        File heapdumpDir = new File(project.getBuildDir(), \"heapdump\");\n+\n+        project.getTasks().withType(Test.class).configureEach(test -> {\n+            File testOutputDir = new File(test.getReports().getJunitXml().getDestination(), \"output\");\n+\n+            ErrorReportingTestListener listener = new ErrorReportingTestListener(test.getTestLogging(), testOutputDir);\n+            test.getExtensions().add(\"errorReportingTestListener\", listener);\n+            test.addTestOutputListener(listener);\n+            test.addTestListener(listener);\n+\n+            /*\n+             * We use lazy-evaluated strings in order to configure system properties whose value will not be known until\n+             * execution time (e.g. cluster port numbers). Adding these via the normal DSL doesn't work as these get treated\n+             * as task inputs and therefore Gradle attempts to snapshot them before/after task execution. This fails due\n+             * to the GStrings containing references to non-serializable objects.\n+             *\n+             * We bypass this by instead passing this system properties vi a CommandLineArgumentProvider. This has the added\n+             * side-effect that these properties are NOT treated as inputs, therefore they don't influence things like the\n+             * build cache key or up to date checking.\n+             */\n+            SystemPropertyCommandLineArgumentProvider nonInputProperties = new SystemPropertyCommandLineArgumentProvider();\n+\n+            test.doFirst(t -> {\n+                project.mkdir(testOutputDir);\n+                project.mkdir(heapdumpDir);\n+                project.mkdir(test.getWorkingDir());\n+                project.mkdir(test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+                // TODO remove once jvm.options are added to test system properties\n+                test.systemProperty(\"java.locale.providers\", \"SPI,COMPAT\");\n+            });\n+            if (inFipsJvm()) {\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bc-fips:1.0.1\");\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bctls-fips:1.0.9\");\n+            }\n+            test.getJvmArgumentProviders().add(nonInputProperties);\n+            test.getExtensions().add(\"nonInputProperties\", nonInputProperties);\n+\n+            test.setWorkingDir(project.file(project.getBuildDir() + \"/testrun/\" + test.getName()));\n+            test.setMaxParallelForks(Integer.parseInt(System.getProperty(\"tests.jvms\", BuildParams.getDefaultParallel().toString())));\n+\n+            test.exclude(\"**/*$*.class\");\n+\n+            test.jvmArgs(\n+                \"-Xmx\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"-Xms\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"--illegal-access=warn\",\n+                \"-XX:+HeapDumpOnOutOfMemoryError\"\n+            );\n+\n+            test.getJvmArgumentProviders().add(() -> List.of(\"-XX:HeapDumpPath=$heapdumpDir\"));\n+\n+            String argline = System.getProperty(\"tests.jvm.argline\");\n+            if (argline != null) {\n+                test.jvmArgs((Object[]) argline.split(\" \"));\n+            }\n+\n+            if (Boolean.parseBoolean(System.getProperty(\"tests.asserts\", \"true\"))) {\n+                test.jvmArgs(\"-ea\", \"-esa\");\n+            }\n+\n+            Map<String, String> sysprops = Map.of(\n+                \"java.awt.headless\",\n+                \"true\",\n+                \"tests.gradle\",\n+                \"true\",\n+                \"tests.artifact\",\n+                project.getName(),\n+                \"tests.task\",\n+                test.getPath(),\n+                \"tests.security.manager\",\n+                \"true\",\n+                \"jna.nosys\",\n+                \"true\"\n+            );\n+            test.systemProperties(sysprops);\n+\n+            // ignore changing test seed when build is passed -Dignore.tests.seed for cacheability experimentation\n+            if (System.getProperty(\"ignore.tests.seed\") != null) {\n+                nonInputProperties.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            } else {\n+                test.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            }\n+\n+            // don't track these as inputs since they contain absolute paths and break cache relocatability\n+            File gradleHome = project.getGradle().getGradleUserHomeDir();\n+            String gradleVersion = project.getGradle().getGradleVersion();\n+            nonInputProperties.systemProperty(\"gradle.dist.lib\", new File(project.getGradle().getGradleHomeDir(), \"lib\"));\n+            nonInputProperties.systemProperty(\n+                \"gradle.worker.jar\",\n+                gradleHome + \"/caches/\" + gradleVersion + \"/workerMain/gradle-worker.jar\"\n+            );\n+            nonInputProperties.systemProperty(\"gradle.user.home\", gradleHome);\n+            // we use 'temp' relative to CWD since this is per JVM and tests are forbidden from writing to CWD\n+            nonInputProperties.systemProperty(\"java.io.tmpdir\", test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+            nonInputProperties.systemProperty(\"compiler.java\", BuildParams.getCompilerJavaVersion().getMajorVersion());\n+            nonInputProperties.systemProperty(\"runtime.java\", BuildParams.getRuntimeJavaVersion().getMajorVersion());\n+\n+            // TODO: remove setting logging level via system property\n+            test.systemProperty(\"tests.logger.level\", \"WARN\");\n+            System.getProperties().entrySet().forEach(entry -> {\n+                if ((entry.getKey().toString().startsWith(\"tests.\") || entry.getKey().toString().startsWith(\"es.\"))) {\n+                    test.systemProperty(entry.getKey().toString(), entry.getValue());\n+                }\n+            });\n+\n+            // TODO: remove this once ctx isn't added to update script params in 7.0\n+            test.systemProperty(\"es.scripting.update.ctx_in_params\", \"false\");\n+\n+            // TODO: remove this property in 8.0\n+            test.systemProperty(\"es.search.rewrite_sort\", \"true\");\n+\n+            // TODO: remove this once cname is prepended to transport.publish_address by default in 8.0\n+            test.systemProperty(\"es.transport.cname_in_publish_address\", \"true\");\n+\n+            // Set netty system properties to the properties we configure in jvm.options\n+            test.systemProperty(\"io.netty.noUnsafe\", \"true\");\n+            test.systemProperty(\"io.netty.noKeySetOptimization\", \"true\");\n+            test.systemProperty(\"io.netty.recycler.maxCapacityPerThread\", \"0\");\n+\n+            test.testLogging(logging -> {\n+                logging.setShowExceptions(true);\n+                logging.setShowCauses(true);\n+                logging.setExceptionFormat(\"full\");\n+            });\n+\n+            if (OS.current().equals(OS.WINDOWS) && System.getProperty(\"tests.timeoutSuite\") == null) {\n+                // override the suite timeout to 30 mins for windows, because it has the most inefficient filesystem known to man\n+                test.systemProperty(\"tests.timeoutSuite\", \"1800000!\");\n+            }\n+\n+            /*\n+             *  If this project builds a shadow JAR than any unit tests should test against that artifact instead of\n+             *  compiled class output and dependency jars. This better emulates the runtime environment of consumers.\n+             */\n+            project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", p -> {\n+                // Remove output class files and any other dependencies from the test classpath, since the shadow JAR includes these\n+                FileCollection mainRuntime = project.getExtensions()\n+                    .getByType(SourceSetContainer.class)\n+                    .getByName(SourceSet.MAIN_SOURCE_SET_NAME)\n+                    .getRuntimeClasspath();\n+                // Add any \"shadow\" dependencies. These are dependencies that are *not* bundled into the shadow JAR\n+                Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+                // Add the shadow JAR artifact itself\n+                FileCollection shadowJar = project.files(project.getTasks().named(\"shadowJar\"));\n+\n+                test.setClasspath(test.getClasspath().minus(mainRuntime).plus(shadowConfig).plus(shadowJar));\n+            });\n+        });\n+    }\n+\n+    private static boolean inFipsJvm() {", "originalCommit": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzE5OA==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416763198", "bodyText": "We should probably start replacing these with Util.getBooleanProperty for consistent bahavior.", "author": "mark-vieira", "createdAt": "2020-04-28T16:42:02Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {\n+            project.getTasks().withType(JavaCompile.class).configureEach(compileTask -> {\n+                CompileOptions compileOptions = compileTask.getOptions();\n+\n+                configureFork.accept(compileOptions);\n+                /*\n+                 * -path because gradle will send in paths that don't always exist.\n+                 * -missing because we have tons of missing @returns and @param.\n+                 * -serial because we don't use java serialization.\n+                 */\n+                // don't even think about passing args with -J-xxx, oracle will ask you to submit a bug report :)\n+                // fail on all javac warnings\n+                List<String> compilerArgs = compileOptions.getCompilerArgs();\n+                compilerArgs.add(\"-Werror\");\n+                compilerArgs.add(\"-Xlint:all,-path,-serial,-options,-deprecation,-try\");\n+                compilerArgs.add(\"-Xdoclint:all\");\n+                compilerArgs.add(\"-Xdoclint:-missing\");\n+\n+                // either disable annotation processor completely (default) or allow to enable them if an annotation processor is explicitly\n+                // defined\n+                if (compilerArgs.contains(\"-processor\") == false) {\n+                    compilerArgs.add(\"-proc:none\");\n+                }\n+\n+                compileOptions.setEncoding(\"UTF-8\");\n+                compileOptions.setIncremental(true);\n+\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+\n+            });\n+            // also apply release flag to groovy, which is used in build-tools\n+            project.getTasks().withType(GroovyCompile.class).configureEach(compileTask -> {\n+                configureFork.accept(compileTask.getOptions());\n+\n+                // TODO: this probably shouldn't apply to groovy at all?\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                final List<String> compilerArgs = compileTask.getOptions().getCompilerArgs();\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+            });\n+        });\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            // Ensure that when we are compiling against the \"original\" JAR that we also include any \"shadow\" dependencies on the compile\n+            // classpath\n+            Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+            Configuration apiConfig = project.getConfigurations().getByName(JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME);\n+            shadowConfig.getDependencies().all(dependency -> apiConfig.getDependencies().add(dependency));\n+        });\n+    }\n+\n+    /**\n+     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n+     */\n+    public static void configureInputNormalization(Project project) {\n+        project.getNormalization().getRuntimeClasspath().ignore(\"META-INF/MANIFEST.MF\");\n+    }\n+\n+    public static void configureTestTasks(Project project) {\n+        // Default test task should run only unit tests\n+        maybeConfigure(project.getTasks(), \"test\", Test.class, task -> task.include(\"**/*Tests.class\"));\n+\n+        // none of this stuff is applicable to the `:buildSrc` project tests\n+        if (project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+\n+        File heapdumpDir = new File(project.getBuildDir(), \"heapdump\");\n+\n+        project.getTasks().withType(Test.class).configureEach(test -> {\n+            File testOutputDir = new File(test.getReports().getJunitXml().getDestination(), \"output\");\n+\n+            ErrorReportingTestListener listener = new ErrorReportingTestListener(test.getTestLogging(), testOutputDir);\n+            test.getExtensions().add(\"errorReportingTestListener\", listener);\n+            test.addTestOutputListener(listener);\n+            test.addTestListener(listener);\n+\n+            /*\n+             * We use lazy-evaluated strings in order to configure system properties whose value will not be known until\n+             * execution time (e.g. cluster port numbers). Adding these via the normal DSL doesn't work as these get treated\n+             * as task inputs and therefore Gradle attempts to snapshot them before/after task execution. This fails due\n+             * to the GStrings containing references to non-serializable objects.\n+             *\n+             * We bypass this by instead passing this system properties vi a CommandLineArgumentProvider. This has the added\n+             * side-effect that these properties are NOT treated as inputs, therefore they don't influence things like the\n+             * build cache key or up to date checking.\n+             */\n+            SystemPropertyCommandLineArgumentProvider nonInputProperties = new SystemPropertyCommandLineArgumentProvider();\n+\n+            test.doFirst(t -> {\n+                project.mkdir(testOutputDir);\n+                project.mkdir(heapdumpDir);\n+                project.mkdir(test.getWorkingDir());\n+                project.mkdir(test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+                // TODO remove once jvm.options are added to test system properties\n+                test.systemProperty(\"java.locale.providers\", \"SPI,COMPAT\");\n+            });\n+            if (inFipsJvm()) {\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bc-fips:1.0.1\");\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bctls-fips:1.0.9\");\n+            }\n+            test.getJvmArgumentProviders().add(nonInputProperties);\n+            test.getExtensions().add(\"nonInputProperties\", nonInputProperties);\n+\n+            test.setWorkingDir(project.file(project.getBuildDir() + \"/testrun/\" + test.getName()));\n+            test.setMaxParallelForks(Integer.parseInt(System.getProperty(\"tests.jvms\", BuildParams.getDefaultParallel().toString())));\n+\n+            test.exclude(\"**/*$*.class\");\n+\n+            test.jvmArgs(\n+                \"-Xmx\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"-Xms\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"--illegal-access=warn\",\n+                \"-XX:+HeapDumpOnOutOfMemoryError\"\n+            );\n+\n+            test.getJvmArgumentProviders().add(() -> List.of(\"-XX:HeapDumpPath=$heapdumpDir\"));\n+\n+            String argline = System.getProperty(\"tests.jvm.argline\");\n+            if (argline != null) {\n+                test.jvmArgs((Object[]) argline.split(\" \"));\n+            }\n+\n+            if (Boolean.parseBoolean(System.getProperty(\"tests.asserts\", \"true\"))) {", "originalCommit": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2NDMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416764327", "bodyText": "This seems to be in the old impl too, but what's with the ! suffix?", "author": "mark-vieira", "createdAt": "2020-04-28T16:43:41Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchJavaPlugin.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle;\n+\n+import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.elasticsearch.gradle.test.ErrorReportingTestListener;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleDependency;\n+import org.gradle.api.artifacts.ProjectDependency;\n+import org.gradle.api.artifacts.ResolutionStrategy;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.plugins.JavaPluginExtension;\n+import org.gradle.api.tasks.SourceSet;\n+import org.gradle.api.tasks.SourceSetContainer;\n+import org.gradle.api.tasks.compile.CompileOptions;\n+import org.gradle.api.tasks.compile.GroovyCompile;\n+import org.gradle.api.tasks.compile.JavaCompile;\n+import org.gradle.api.tasks.testing.Test;\n+import org.gradle.internal.jvm.Jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.gradle.util.GradleUtils.maybeConfigure;\n+\n+/**\n+ * A wrapper around Gradle's Java plugin that applies our common configuration.\n+ */\n+public class ElasticsearchJavaPlugin implements Plugin<Project> {\n+    @Override\n+    public void apply(Project project) {\n+        // make sure the global build info plugin is applied to the root project\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        project.getPluginManager().apply(JavaPlugin.class);\n+        configureConfigurations(project);\n+        configureCompile(project);\n+        configureInputNormalization(project);\n+        configureTestTasks(project);\n+    }\n+\n+    /**\n+     * Makes dependencies non-transitive.\n+     *\n+     * Gradle allows setting all dependencies as non-transitive very easily.\n+     * Sadly this mechanism does not translate into maven pom generation. In order\n+     * to effectively make the pom act as if it has no transitive dependencies,\n+     * we must exclude each transitive dependency of each direct dependency.\n+     *\n+     * Determining the transitive deps of a dependency which has been resolved as\n+     * non-transitive is difficult because the process of resolving removes the\n+     * transitive deps. To sidestep this issue, we create a configuration per\n+     * direct dependency version. This specially named and unique configuration\n+     * will contain all of the transitive dependencies of this particular\n+     * dependency. We can then use this configuration during pom generation\n+     * to iterate the transitive dependencies and add excludes.\n+     */\n+    public static void configureConfigurations(Project project) {\n+        // we want to test compileOnly deps!\n+        Configuration compileOnlyConfig = project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        Configuration compileConfig = project.getConfigurations().getByName(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        compileConfig.extendsFrom(compileOnlyConfig);\n+\n+        // we are not shipping these jars, we act like dumb consumers of these things\n+        if (project.getPath().startsWith(\":test:fixtures\") || project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+        // fail on any conflicting dependency versions\n+        project.getConfigurations().all(configuration -> {\n+            if (configuration.getName().endsWith(\"Fixture\")) {\n+                // just a self contained test-fixture configuration, likely transitive and hellacious\n+                return;\n+            }\n+            configuration.resolutionStrategy(ResolutionStrategy::failOnVersionConflict);\n+        });\n+\n+        // force all dependencies added directly to compile/testCompile to be non-transitive, except for ES itself\n+        Consumer<String> disableTransitiveDeps = configName -> {\n+            Configuration config = project.getConfigurations().getByName(configName);\n+            config.getDependencies().all(dep -> {\n+                if (dep instanceof ModuleDependency\n+                    && dep instanceof ProjectDependency == false\n+                    && dep.getGroup().startsWith(\"org.elasticsearch\") == false) {\n+                    ((ModuleDependency) dep).setTransitive(false);\n+                }\n+            });\n+        };\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.TEST_COMPILE_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n+        disableTransitiveDeps.accept(JavaPlugin.RUNTIME_ONLY_CONFIGURATION_NAME);\n+    }\n+\n+    /** Adds compiler settings to the project */\n+    public static void configureCompile(Project project) {\n+        ExtraPropertiesExtension ext = project.getExtensions().getByType(ExtraPropertiesExtension.class);\n+        ext.set(\"compactProfile\", \"full\");\n+\n+        JavaPluginExtension java = project.getExtensions().getByType(JavaPluginExtension.class);\n+        java.setSourceCompatibility(BuildParams.getMinimumRuntimeVersion());\n+        java.setTargetCompatibility(BuildParams.getMinimumRuntimeVersion());\n+\n+        Function<File, String> canonicalPath = file -> {\n+            try {\n+                return file.getCanonicalPath();\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to get canonical path for \" + file, e);\n+            }\n+        };\n+        // common options to both java and groovy\n+        Consumer<CompileOptions> configureFork = compileOptions -> {\n+            // we only fork if the Gradle JDK is not the same as the compiler JDK\n+            String compilerJavaHome = canonicalPath.apply(BuildParams.getCompilerJavaHome());\n+            String currentJavaHome = canonicalPath.apply(Jvm.current().getJavaHome());\n+            if (compilerJavaHome.equals(currentJavaHome)) {\n+                compileOptions.setFork(false);\n+            } else {\n+                compileOptions.setFork(true);\n+                compileOptions.getForkOptions().setJavaHome(BuildParams.getCompilerJavaHome());\n+            }\n+        };\n+\n+        project.afterEvaluate(p -> {\n+            project.getTasks().withType(JavaCompile.class).configureEach(compileTask -> {\n+                CompileOptions compileOptions = compileTask.getOptions();\n+\n+                configureFork.accept(compileOptions);\n+                /*\n+                 * -path because gradle will send in paths that don't always exist.\n+                 * -missing because we have tons of missing @returns and @param.\n+                 * -serial because we don't use java serialization.\n+                 */\n+                // don't even think about passing args with -J-xxx, oracle will ask you to submit a bug report :)\n+                // fail on all javac warnings\n+                List<String> compilerArgs = compileOptions.getCompilerArgs();\n+                compilerArgs.add(\"-Werror\");\n+                compilerArgs.add(\"-Xlint:all,-path,-serial,-options,-deprecation,-try\");\n+                compilerArgs.add(\"-Xdoclint:all\");\n+                compilerArgs.add(\"-Xdoclint:-missing\");\n+\n+                // either disable annotation processor completely (default) or allow to enable them if an annotation processor is explicitly\n+                // defined\n+                if (compilerArgs.contains(\"-processor\") == false) {\n+                    compilerArgs.add(\"-proc:none\");\n+                }\n+\n+                compileOptions.setEncoding(\"UTF-8\");\n+                compileOptions.setIncremental(true);\n+\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+\n+            });\n+            // also apply release flag to groovy, which is used in build-tools\n+            project.getTasks().withType(GroovyCompile.class).configureEach(compileTask -> {\n+                configureFork.accept(compileTask.getOptions());\n+\n+                // TODO: this probably shouldn't apply to groovy at all?\n+                // TODO: use native Gradle support for --release when available (cf. https://github.com/gradle/gradle/issues/2510)\n+                final JavaVersion targetCompatibilityVersion = JavaVersion.toVersion(compileTask.getTargetCompatibility());\n+                final List<String> compilerArgs = compileTask.getOptions().getCompilerArgs();\n+                compilerArgs.add(\"--release\");\n+                compilerArgs.add(targetCompatibilityVersion.getMajorVersion());\n+            });\n+        });\n+\n+        project.getPluginManager().withPlugin(\"com.github.johnrengelman.shadow\", plugin -> {\n+            // Ensure that when we are compiling against the \"original\" JAR that we also include any \"shadow\" dependencies on the compile\n+            // classpath\n+            Configuration shadowConfig = project.getConfigurations().getByName(ShadowBasePlugin.getCONFIGURATION_NAME());\n+            Configuration apiConfig = project.getConfigurations().getByName(JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME);\n+            shadowConfig.getDependencies().all(dependency -> apiConfig.getDependencies().add(dependency));\n+        });\n+    }\n+\n+    /**\n+     * Apply runtime classpath input normalization so that changes in JAR manifests don't break build cacheability\n+     */\n+    public static void configureInputNormalization(Project project) {\n+        project.getNormalization().getRuntimeClasspath().ignore(\"META-INF/MANIFEST.MF\");\n+    }\n+\n+    public static void configureTestTasks(Project project) {\n+        // Default test task should run only unit tests\n+        maybeConfigure(project.getTasks(), \"test\", Test.class, task -> task.include(\"**/*Tests.class\"));\n+\n+        // none of this stuff is applicable to the `:buildSrc` project tests\n+        if (project.getPath().equals(\":build-tools\")) {\n+            return;\n+        }\n+\n+        File heapdumpDir = new File(project.getBuildDir(), \"heapdump\");\n+\n+        project.getTasks().withType(Test.class).configureEach(test -> {\n+            File testOutputDir = new File(test.getReports().getJunitXml().getDestination(), \"output\");\n+\n+            ErrorReportingTestListener listener = new ErrorReportingTestListener(test.getTestLogging(), testOutputDir);\n+            test.getExtensions().add(\"errorReportingTestListener\", listener);\n+            test.addTestOutputListener(listener);\n+            test.addTestListener(listener);\n+\n+            /*\n+             * We use lazy-evaluated strings in order to configure system properties whose value will not be known until\n+             * execution time (e.g. cluster port numbers). Adding these via the normal DSL doesn't work as these get treated\n+             * as task inputs and therefore Gradle attempts to snapshot them before/after task execution. This fails due\n+             * to the GStrings containing references to non-serializable objects.\n+             *\n+             * We bypass this by instead passing this system properties vi a CommandLineArgumentProvider. This has the added\n+             * side-effect that these properties are NOT treated as inputs, therefore they don't influence things like the\n+             * build cache key or up to date checking.\n+             */\n+            SystemPropertyCommandLineArgumentProvider nonInputProperties = new SystemPropertyCommandLineArgumentProvider();\n+\n+            test.doFirst(t -> {\n+                project.mkdir(testOutputDir);\n+                project.mkdir(heapdumpDir);\n+                project.mkdir(test.getWorkingDir());\n+                project.mkdir(test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+                // TODO remove once jvm.options are added to test system properties\n+                test.systemProperty(\"java.locale.providers\", \"SPI,COMPAT\");\n+            });\n+            if (inFipsJvm()) {\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bc-fips:1.0.1\");\n+                project.getDependencies().add(\"testRuntimeOnly\", \"org.bouncycastle:bctls-fips:1.0.9\");\n+            }\n+            test.getJvmArgumentProviders().add(nonInputProperties);\n+            test.getExtensions().add(\"nonInputProperties\", nonInputProperties);\n+\n+            test.setWorkingDir(project.file(project.getBuildDir() + \"/testrun/\" + test.getName()));\n+            test.setMaxParallelForks(Integer.parseInt(System.getProperty(\"tests.jvms\", BuildParams.getDefaultParallel().toString())));\n+\n+            test.exclude(\"**/*$*.class\");\n+\n+            test.jvmArgs(\n+                \"-Xmx\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"-Xms\" + System.getProperty(\"tests.heap.size\", \"512m\"),\n+                \"--illegal-access=warn\",\n+                \"-XX:+HeapDumpOnOutOfMemoryError\"\n+            );\n+\n+            test.getJvmArgumentProviders().add(() -> List.of(\"-XX:HeapDumpPath=$heapdumpDir\"));\n+\n+            String argline = System.getProperty(\"tests.jvm.argline\");\n+            if (argline != null) {\n+                test.jvmArgs((Object[]) argline.split(\" \"));\n+            }\n+\n+            if (Boolean.parseBoolean(System.getProperty(\"tests.asserts\", \"true\"))) {\n+                test.jvmArgs(\"-ea\", \"-esa\");\n+            }\n+\n+            Map<String, String> sysprops = Map.of(\n+                \"java.awt.headless\",\n+                \"true\",\n+                \"tests.gradle\",\n+                \"true\",\n+                \"tests.artifact\",\n+                project.getName(),\n+                \"tests.task\",\n+                test.getPath(),\n+                \"tests.security.manager\",\n+                \"true\",\n+                \"jna.nosys\",\n+                \"true\"\n+            );\n+            test.systemProperties(sysprops);\n+\n+            // ignore changing test seed when build is passed -Dignore.tests.seed for cacheability experimentation\n+            if (System.getProperty(\"ignore.tests.seed\") != null) {\n+                nonInputProperties.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            } else {\n+                test.systemProperty(\"tests.seed\", BuildParams.getTestSeed());\n+            }\n+\n+            // don't track these as inputs since they contain absolute paths and break cache relocatability\n+            File gradleHome = project.getGradle().getGradleUserHomeDir();\n+            String gradleVersion = project.getGradle().getGradleVersion();\n+            nonInputProperties.systemProperty(\"gradle.dist.lib\", new File(project.getGradle().getGradleHomeDir(), \"lib\"));\n+            nonInputProperties.systemProperty(\n+                \"gradle.worker.jar\",\n+                gradleHome + \"/caches/\" + gradleVersion + \"/workerMain/gradle-worker.jar\"\n+            );\n+            nonInputProperties.systemProperty(\"gradle.user.home\", gradleHome);\n+            // we use 'temp' relative to CWD since this is per JVM and tests are forbidden from writing to CWD\n+            nonInputProperties.systemProperty(\"java.io.tmpdir\", test.getWorkingDir().toPath().resolve(\"temp\"));\n+\n+            nonInputProperties.systemProperty(\"compiler.java\", BuildParams.getCompilerJavaVersion().getMajorVersion());\n+            nonInputProperties.systemProperty(\"runtime.java\", BuildParams.getRuntimeJavaVersion().getMajorVersion());\n+\n+            // TODO: remove setting logging level via system property\n+            test.systemProperty(\"tests.logger.level\", \"WARN\");\n+            System.getProperties().entrySet().forEach(entry -> {\n+                if ((entry.getKey().toString().startsWith(\"tests.\") || entry.getKey().toString().startsWith(\"es.\"))) {\n+                    test.systemProperty(entry.getKey().toString(), entry.getValue());\n+                }\n+            });\n+\n+            // TODO: remove this once ctx isn't added to update script params in 7.0\n+            test.systemProperty(\"es.scripting.update.ctx_in_params\", \"false\");\n+\n+            // TODO: remove this property in 8.0\n+            test.systemProperty(\"es.search.rewrite_sort\", \"true\");\n+\n+            // TODO: remove this once cname is prepended to transport.publish_address by default in 8.0\n+            test.systemProperty(\"es.transport.cname_in_publish_address\", \"true\");\n+\n+            // Set netty system properties to the properties we configure in jvm.options\n+            test.systemProperty(\"io.netty.noUnsafe\", \"true\");\n+            test.systemProperty(\"io.netty.noKeySetOptimization\", \"true\");\n+            test.systemProperty(\"io.netty.recycler.maxCapacityPerThread\", \"0\");\n+\n+            test.testLogging(logging -> {\n+                logging.setShowExceptions(true);\n+                logging.setShowCauses(true);\n+                logging.setExceptionFormat(\"full\");\n+            });\n+\n+            if (OS.current().equals(OS.WINDOWS) && System.getProperty(\"tests.timeoutSuite\") == null) {\n+                // override the suite timeout to 30 mins for windows, because it has the most inefficient filesystem known to man\n+                test.systemProperty(\"tests.timeoutSuite\", \"1800000!\");", "originalCommit": "02807869f9a5d418a6d66993d98bc31b57e61aa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3Njk1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55834#discussion_r416776953", "bodyText": "From our own contributing docs, it seems the exclamation is important, although I have not found documentation on how it works. I'd like to leave this as a followup.", "author": "rjernst", "createdAt": "2020-04-28T17:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2NDMyNw=="}], "type": "inlineReview"}, {"oid": "94250957e468948cf618cccda0d5bff6eda67ed6", "url": "https://github.com/elastic/elasticsearch/commit/94250957e468948cf618cccda0d5bff6eda67ed6", "message": "address feedback", "committedDate": "2020-04-28T17:02:14Z", "type": "commit"}, {"oid": "6a0f136303e053f26a2d8aa47400b445ab106e50", "url": "https://github.com/elastic/elasticsearch/commit/6a0f136303e053f26a2d8aa47400b445ab106e50", "message": "checkstyle", "committedDate": "2020-04-28T17:11:17Z", "type": "commit"}, {"oid": "3059ab06da3b65740cac7eb044e2ac606881b2ab", "url": "https://github.com/elastic/elasticsearch/commit/3059ab06da3b65740cac7eb044e2ac606881b2ab", "message": "Merge branch 'master' into buildsplit2", "committedDate": "2020-04-28T17:12:06Z", "type": "commit"}]}