{"pr_number": 52003, "pr_title": "[Transform] improve irrecoverable error detection - part 2", "pr_createdAt": "2020-02-06T15:45:03Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52003", "timeline": [{"oid": "f8a1d01d05e7bbb0355d53d638566464ad29211d", "url": "https://github.com/elastic/elasticsearch/commit/f8a1d01d05e7bbb0355d53d638566464ad29211d", "message": "base error handling on rest status instead of listing individual exception\ntypes", "committedDate": "2020-02-07T09:32:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA3MzcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/52003#discussion_r378073706", "bodyText": "AFAIU this one could be \"final\".", "author": "przemekwitek", "createdAt": "2020-02-12T07:15:59Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/utils/ExceptionRootCauseFinder.java", "diffHunk": "@@ -7,19 +7,37 @@\n package org.elasticsearch.xpack.transform.utils;\n \n import org.elasticsearch.ElasticsearchException;\n-import org.elasticsearch.ResourceNotFoundException;\n import org.elasticsearch.action.bulk.BulkItemResponse;\n import org.elasticsearch.action.search.SearchPhaseExecutionException;\n import org.elasticsearch.action.search.ShardSearchFailure;\n-import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.rest.RestStatus;\n \n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n \n /**\n  * Set of static utils to find the cause of a search exception.\n  */\n public final class ExceptionRootCauseFinder {\n \n+    /**\n+     * List of rest statuses that we consider irrecoverable\n+     */\n+    public static Set<RestStatus> IRRECOVERABLE_REST_STATUSES = new HashSet<>(", "originalCommit": "f8a1d01d05e7bbb0355d53d638566464ad29211d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA3NDU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52003#discussion_r378074596", "bodyText": "You may find it out of scope of this PR, but this class is lacking unit tests.", "author": "przemekwitek", "createdAt": "2020-02-12T07:18:46Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/utils/ExceptionRootCauseFinder.java", "diffHunk": "@@ -7,19 +7,37 @@\n package org.elasticsearch.xpack.transform.utils;\n \n import org.elasticsearch.ElasticsearchException;\n-import org.elasticsearch.ResourceNotFoundException;\n import org.elasticsearch.action.bulk.BulkItemResponse;\n import org.elasticsearch.action.search.SearchPhaseExecutionException;\n import org.elasticsearch.action.search.ShardSearchFailure;\n-import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.rest.RestStatus;\n \n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n \n /**\n  * Set of static utils to find the cause of a search exception.\n  */\n public final class ExceptionRootCauseFinder {", "originalCommit": "f8a1d01d05e7bbb0355d53d638566464ad29211d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA3NDc1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52003#discussion_r378074751", "bodyText": "ExceptionRootCauseFinder. prefix should not be needed here.", "author": "przemekwitek", "createdAt": "2020-02-12T07:19:17Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/utils/ExceptionRootCauseFinder.java", "diffHunk": "@@ -67,11 +85,16 @@ public static String getDetailedMessage(Throwable t) {\n     public static Throwable getFirstIrrecoverableExceptionFromBulkResponses(Collection<BulkItemResponse> failures) {\n         for (BulkItemResponse failure : failures) {\n             Throwable unwrappedThrowable = org.elasticsearch.ExceptionsHelper.unwrapCause(failure.getFailure().getCause());\n-            if (unwrappedThrowable instanceof MapperParsingException\n-                || unwrappedThrowable instanceof IllegalArgumentException\n-                || unwrappedThrowable instanceof ResourceNotFoundException) {\n+            if (unwrappedThrowable instanceof IllegalArgumentException) {\n                 return unwrappedThrowable;\n             }\n+\n+            if (unwrappedThrowable instanceof ElasticsearchException) {\n+                ElasticsearchException elasticsearchException = (ElasticsearchException) unwrappedThrowable;\n+                if (ExceptionRootCauseFinder.IRRECOVERABLE_REST_STATUSES.contains(elasticsearchException.status())) {", "originalCommit": "f8a1d01d05e7bbb0355d53d638566464ad29211d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA3NTgwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52003#discussion_r378075801", "bodyText": "You could return; in line 511 and get rid of else clauses, just like you did above.", "author": "przemekwitek", "createdAt": "2020-02-12T07:22:42Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -477,37 +475,53 @@ synchronized void handleFailure(Exception e) {\n \n         if (unwrappedException instanceof CircuitBreakingException) {\n             handleCircuitBreakingException((CircuitBreakingException) unwrappedException);\n-        } else if (unwrappedException instanceof ScriptException) {\n+            return;\n+        }\n+\n+        if (unwrappedException instanceof ScriptException) {\n             handleScriptException((ScriptException) unwrappedException);\n-            // irrecoverable error without special handling\n-        } else if (unwrappedException instanceof BulkIndexingException && ((BulkIndexingException) unwrappedException).isIrrecoverable()) {\n+            return;\n+        }\n+\n+        if (unwrappedException instanceof BulkIndexingException && ((BulkIndexingException) unwrappedException).isIrrecoverable()) {\n             handleIrrecoverableBulkIndexingException((BulkIndexingException) unwrappedException);\n-        } else if (unwrappedException instanceof IndexNotFoundException\n-            || unwrappedException instanceof AggregationResultUtils.AggregationExtractionException\n-            || unwrappedException instanceof TransformConfigReloadingException\n-            || unwrappedException instanceof ResourceNotFoundException\n-            || unwrappedException instanceof IllegalArgumentException) {\n-                failIndexer(\"task encountered irrecoverable failure: \" + e.getMessage());\n-            } else if (context.getAndIncrementFailureCount() > context.getNumFailureRetries()) {\n-                failIndexer(\n-                    \"task encountered more than \"\n-                        + context.getNumFailureRetries()\n-                        + \" failures; latest failure: \"\n-                        + ExceptionRootCauseFinder.getDetailedMessage(unwrappedException)\n-                );\n-            } else {\n-                // Since our schedule fires again very quickly after failures it is possible to run into the same failure numerous\n-                // times in a row, very quickly. We do not want to spam the audit log with repeated failures, so only record the first one\n-                if (e.getMessage().equals(lastAuditedExceptionMessage) == false) {\n-                    String message = ExceptionRootCauseFinder.getDetailedMessage(unwrappedException);\n+            return;\n+        }\n \n-                    auditor.warning(\n-                        getJobId(),\n-                        \"Transform encountered an exception: \" + message + \" Will attempt again at next scheduled trigger.\"\n-                    );\n-                    lastAuditedExceptionMessage = message;\n-                }\n+        // irrecoverable error without special handling\n+        if (unwrappedException instanceof ElasticsearchException) {\n+            ElasticsearchException elasticsearchException = (ElasticsearchException) unwrappedException;\n+            if (ExceptionRootCauseFinder.IRRECOVERABLE_REST_STATUSES.contains(elasticsearchException.status())) {\n+                failIndexer(\"task encountered irrecoverable failure: \" + elasticsearchException.getDetailedMessage());\n+                return;\n             }\n+        }\n+\n+        if (unwrappedException instanceof IllegalArgumentException) {\n+            failIndexer(\"task encountered irrecoverable failure: \" + e.getMessage());\n+            return;\n+        }\n+\n+        if (context.getAndIncrementFailureCount() > context.getNumFailureRetries()) {\n+            failIndexer(\n+                \"task encountered more than \"\n+                    + context.getNumFailureRetries()\n+                    + \" failures; latest failure: \"\n+                    + ExceptionRootCauseFinder.getDetailedMessage(unwrappedException)\n+            );\n+        } else {", "originalCommit": "f8a1d01d05e7bbb0355d53d638566464ad29211d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6df1d702d2e1a97753d1711134241903f9ce727b", "url": "https://github.com/elastic/elasticsearch/commit/6df1d702d2e1a97753d1711134241903f9ce727b", "message": "base error handling on rest status instead of listing individual exception\ntypes", "committedDate": "2020-02-12T08:45:02Z", "type": "commit"}, {"oid": "1b1505b2eca644e7c6e7e5b9fc80feb025ae837f", "url": "https://github.com/elastic/elasticsearch/commit/1b1505b2eca644e7c6e7e5b9fc80feb025ae837f", "message": "apply review suggestions", "committedDate": "2020-02-12T10:02:57Z", "type": "commit"}, {"oid": "1b1505b2eca644e7c6e7e5b9fc80feb025ae837f", "url": "https://github.com/elastic/elasticsearch/commit/1b1505b2eca644e7c6e7e5b9fc80feb025ae837f", "message": "apply review suggestions", "committedDate": "2020-02-12T10:02:57Z", "type": "forcePushed"}, {"oid": "e570ca8cf1a2663d1c60dba451bac995d5219552", "url": "https://github.com/elastic/elasticsearch/commit/e570ca8cf1a2663d1c60dba451bac995d5219552", "message": "improve unit test", "committedDate": "2020-02-12T10:07:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MzM1OA==", "url": "https://github.com/elastic/elasticsearch/pull/52003#discussion_r378163358", "bodyText": "assertThat(..., equalTo(...))\n?", "author": "przemekwitek", "createdAt": "2020-02-12T10:28:41Z", "path": "x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/utils/ExceptionRootCauseFinderTests.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.transform.utils;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.DocWriteRequest.OpType;\n+import org.elasticsearch.action.bulk.BulkItemResponse;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.translog.TranslogException;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ExceptionRootCauseFinderTests extends ESTestCase {\n+    public void testFetFirstIrrecoverableExceptionFromBulkResponses() {\n+        Map<Integer, BulkItemResponse> bulkItemResponses = new HashMap<>();\n+\n+        int id = 1;\n+        // 1\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\"the_index\", \"id\", new MapperParsingException(\"mapper parsing error\"))\n+            )\n+        );\n+        // 2\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\"the_index\", \"id\", new ResourceNotFoundException(\"resource not found error\"))\n+            )\n+        );\n+        // 3\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\"the_index\", \"id\", new IllegalArgumentException(\"illegal argument error\"))\n+            )\n+        );\n+        // 4 not irrecoverable\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\"the_index\", \"id\", new EsRejectedExecutionException(\"es rejected execution\"))\n+            )\n+        );\n+        // 5 not irrecoverable\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\"the_index\", \"id\", new TranslogException(new ShardId(\"the_index\", \"uid\", 0), \"translog error\"))\n+            )\n+        );\n+        // 6\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\n+                    \"the_index\",\n+                    \"id\",\n+                    new ElasticsearchSecurityException(\"Authentication required\", RestStatus.UNAUTHORIZED)\n+                )\n+            )\n+        );\n+        // 7\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\n+                    \"the_index\",\n+                    \"id\",\n+                    new ElasticsearchSecurityException(\"current license is non-compliant for [transform]\", RestStatus.FORBIDDEN)\n+                )\n+            )\n+        );\n+        // 8 not irrecoverable\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\n+                    \"the_index\",\n+                    \"id\",\n+                    new ElasticsearchSecurityException(\"overloaded, to many requests\", RestStatus.TOO_MANY_REQUESTS)\n+                )\n+            )\n+        );\n+        // 9 not irrecoverable\n+        bulkItemResponses.put(\n+            id,\n+            new BulkItemResponse(\n+                id++,\n+                OpType.INDEX,\n+                new BulkItemResponse.Failure(\n+                    \"the_index\",\n+                    \"id\",\n+                    new ElasticsearchSecurityException(\"internal error\", RestStatus.INTERNAL_SERVER_ERROR)\n+                )\n+            )\n+        );\n+\n+        assertFirstException(bulkItemResponses.values(), MapperParsingException.class, \"mapper parsing error\");\n+        bulkItemResponses.remove(1);\n+        assertFirstException(bulkItemResponses.values(), ResourceNotFoundException.class, \"resource not found error\");\n+        bulkItemResponses.remove(2);\n+        assertFirstException(bulkItemResponses.values(), IllegalArgumentException.class, \"illegal argument error\");\n+        bulkItemResponses.remove(3);\n+        assertFirstException(bulkItemResponses.values(), ElasticsearchSecurityException.class, \"Authentication required\");\n+        bulkItemResponses.remove(6);\n+        assertFirstException(\n+            bulkItemResponses.values(),\n+            ElasticsearchSecurityException.class,\n+            \"current license is non-compliant for [transform]\"\n+        );\n+        bulkItemResponses.remove(7);\n+\n+        assertNull(ExceptionRootCauseFinder.getFirstIrrecoverableExceptionFromBulkResponses(bulkItemResponses.values()));\n+    }\n+\n+    private static void assertFirstException(Collection<BulkItemResponse> bulkItemResponses, Class<?> expectedClass, String message) {\n+        Throwable t = ExceptionRootCauseFinder.getFirstIrrecoverableExceptionFromBulkResponses(bulkItemResponses);\n+        assertNotNull(t);\n+        assertEquals(t.getClass(), expectedClass);", "originalCommit": "e570ca8cf1a2663d1c60dba451bac995d5219552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}