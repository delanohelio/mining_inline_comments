{"pr_number": 60851, "pr_title": "Implement distance_feature for runtime dates", "pr_createdAt": "2020-08-06T21:23:02Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60851", "timeline": [{"oid": "2a1c4b1ff45a871ca5b4e6504b00f93a364585b6", "url": "https://github.com/elastic/elasticsearch/commit/2a1c4b1ff45a871ca5b4e6504b00f93a364585b6", "message": "WIP", "committedDate": "2020-08-06T21:13:48Z", "type": "commit"}, {"oid": "05d5c5a147ec7501d6ff524d88fdf00ef403d85c", "url": "https://github.com/elastic/elasticsearch/commit/05d5c5a147ec7501d6ff524d88fdf00ef403d85c", "message": "Merge branch 'feature/runtime_fields' into runtime_fields_distance_feature", "committedDate": "2020-08-06T21:17:07Z", "type": "commit"}, {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9", "url": "https://github.com/elastic/elasticsearch/commit/f788941140488bb51c7950ac11797ab8a606b6b9", "message": "Finish test", "committedDate": "2020-08-06T21:34:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2OTY1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470069659", "bodyText": "Should a potential max score be:  weight instead of boost?\nThis method and several other methods  don't seem to throw IOException", "author": "mayya-sharipova", "createdAt": "2020-08-13T16:18:02Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {\n+                @Override\n+                public boolean matches() throws IOException {\n+                    script.runForDoc(approximation().docID());\n+                    return script.count() > 0;\n+                }\n+\n+                @Override\n+                public float matchCost() {\n+                    return MATCH_COST;\n+                }\n+            };\n+            disi = TwoPhaseIterator.asDocIdSetIterator(twoPhase);\n+            this.weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+        }\n+\n+        @Override\n+        public int docID() {\n+            return disi.docID();\n+        }\n+\n+        @Override\n+        public DocIdSetIterator iterator() {\n+            return disi;\n+        }\n+\n+        @Override\n+        public TwoPhaseIterator twoPhaseIterator() {\n+            return twoPhase;\n+        }\n+\n+        @Override\n+        public float getMaxScore(int upTo) throws IOException {\n+            return boost;", "originalCommit": "f788941140488bb51c7950ac11797ab8a606b6b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MDUwMg==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470160502", "bodyText": "Yes! good catch.", "author": "nik9000", "createdAt": "2020-08-13T18:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2OTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3OTU2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470079569", "bodyText": "should we incorporate the initial boost to hashCode, equals, toString ?", "author": "mayya-sharipova", "createdAt": "2020-08-13T16:34:04Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {\n+                @Override\n+                public boolean matches() throws IOException {\n+                    script.runForDoc(approximation().docID());\n+                    return script.count() > 0;\n+                }\n+\n+                @Override\n+                public float matchCost() {\n+                    return MATCH_COST;\n+                }\n+            };\n+            disi = TwoPhaseIterator.asDocIdSetIterator(twoPhase);\n+            this.weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+        }\n+\n+        @Override\n+        public int docID() {\n+            return disi.docID();\n+        }\n+\n+        @Override\n+        public DocIdSetIterator iterator() {\n+            return disi;\n+        }\n+\n+        @Override\n+        public TwoPhaseIterator twoPhaseIterator() {\n+            return twoPhase;\n+        }\n+\n+        @Override\n+        public float getMaxScore(int upTo) throws IOException {\n+            return boost;\n+        }\n+\n+        @Override\n+        public float score() throws IOException {\n+            if (script.count() == 0) {\n+                return 0;\n+            }\n+            return LongScriptFieldDistanceFeatureQuery.this.score(weight, (double) minAbsoluteDistance(script));\n+        }\n+    }\n+\n+    long minAbsoluteDistance(AbstractLongScriptFieldScript script) {\n+        long minDistance = Long.MAX_VALUE;\n+        for (int i = 0; i < script.count(); i++) {\n+            minDistance = Math.min(minDistance, distanceFor(script.values()[i]));\n+        }\n+        return minDistance;\n+    }\n+\n+    long valueWithMinAbsoluteDistance(AbstractLongScriptFieldScript script) {\n+        long minDistance = Long.MAX_VALUE;\n+        long minDistanceValue = Long.MAX_VALUE;\n+        for (int i = 0; i < script.count(); i++) {\n+            long distance = distanceFor(script.values()[i]);\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                minDistanceValue = script.values()[i];\n+            }\n+        }\n+        return minDistanceValue;\n+    }\n+\n+    long distanceFor(long value) {\n+        long distance = Math.max(value, origin) - Math.min(value, origin);\n+        if (distance < 0) {\n+            // The distance doesn't fit into signed long so clamp it to MAX_VALUE\n+            return Long.MAX_VALUE;\n+        }\n+        return distance;\n+    }\n+\n+    float score(float weight, double distance) {\n+        return (float) (weight * (pivot / (pivot + distance)));\n+    }\n+\n+    @Override\n+    public String toString(String field) {\n+        StringBuilder b = new StringBuilder();\n+        if (false == fieldName().equals(field)) {\n+            b.append(fieldName()).append(\":\");\n+        }\n+        b.append(getClass().getSimpleName()).append(\"(origin=\").append(origin).append(\",pivot=\").append(pivot).append(\")\");\n+        return b.toString();\n+\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), origin, pivot);", "originalCommit": "f788941140488bb51c7950ac11797ab8a606b6b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MDYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470160635", "bodyText": "Yes.", "author": "nik9000", "createdAt": "2020-08-13T18:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3OTU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5Mzc2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470093766", "bodyText": "I am not familiar with runtime fields, but I am wondering if we intend always to create an iterator across all documents? Do we plan to add support to limit number of docs (e.g. only docs returned by a top filter)?", "author": "mayya-sharipova", "createdAt": "2020-08-13T16:57:55Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {", "originalCommit": "f788941140488bb51c7950ac11797ab8a606b6b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MjUxMA==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470162510", "bodyText": "I believe we're hoping for bool queries to AND together a \"normal\" query and a runtime field query. I've experimented with this for our term and match style queries and it seems to work pretty well. If the \"normal\" query is selective then the runtime query won't be asked if it matches most documents. On the flip side, if the runtime field query non-selective then we'll quickly fill up the 10,000 hits and terminate early.", "author": "nik9000", "createdAt": "2020-08-13T18:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5Mzc2Ng=="}], "type": "inlineReview"}, {"oid": "dfd27ff5640fc29eca1673d076c6ffbfc82506c9", "url": "https://github.com/elastic/elasticsearch/commit/dfd27ff5640fc29eca1673d076c6ffbfc82506c9", "message": "Merge branch 'feature/runtime_fields' into runtime_fields_distance_feature", "committedDate": "2020-08-13T19:10:10Z", "type": "commit"}, {"oid": "9739a0c95eae2c0cd98c46d71dd93133026df4ac", "url": "https://github.com/elastic/elasticsearch/commit/9739a0c95eae2c0cd98c46d71dd93133026df4ac", "message": "Update tests", "committedDate": "2020-08-13T19:43:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwODc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470508788", "bodyText": "I wonder what the plan is for the instanceof checks in DistanceFeatureQueryBuilder#doToQuery . Are we ok with keeping those?", "author": "javanna", "createdAt": "2020-08-14T09:14:57Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptDateMappedFieldType.java", "diffHunk": "@@ -86,6 +88,30 @@ public DocValueFormat docValueFormat(@Nullable String format, ZoneId timeZone) {\n         return scriptFactory.newFactory(script.getParams(), lookup);\n     }\n \n+    @Override\n+    public Query distanceFeatureQuery(Object origin, String pivot, float boost, QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);\n+        return DateFieldType.handleNow(context, now -> {\n+            long originLong = DateFieldType.parseToLong(\n+                origin,\n+                true,\n+                null,\n+                dateTimeFormatter.toDateMathParser(),\n+                now,\n+                DateFieldMapper.Resolution.MILLISECONDS\n+            );\n+            TimeValue pivotTime = TimeValue.parseTimeValue(pivot, \"distance_feature.pivot\");\n+            return new LongScriptFieldDistanceFeatureQuery(\n+                script,\n+                leafFactory(context.lookup())::newInstance,\n+                name(),\n+                originLong,\n+                pivotTime.getMillis(),\n+                boost\n+            );\n+        });\n+    }", "originalCommit": "9739a0c95eae2c0cd98c46d71dd93133026df4ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUxMzI5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470513291", "bodyText": "oh actually those are gone upstream, great! sorry for the noise then, you already did what I would asked you to do", "author": "javanna", "createdAt": "2020-08-14T09:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwODc4OA=="}], "type": "inlineReview"}]}