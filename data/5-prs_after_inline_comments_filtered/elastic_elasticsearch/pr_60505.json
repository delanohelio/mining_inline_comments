{"pr_number": 60505, "pr_title": " Add recovery state tracking for Searchable Snapshots", "pr_createdAt": "2020-07-31T10:31:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60505", "timeline": [{"oid": "352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "url": "https://github.com/elastic/elasticsearch/commit/352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "message": "Keep track of recovery stats during searchable snapshots cache pre-warm", "committedDate": "2020-07-31T11:05:03Z", "type": "commit"}, {"oid": "352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "url": "https://github.com/elastic/elasticsearch/commit/352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "message": "Keep track of recovery stats during searchable snapshots cache pre-warm", "committedDate": "2020-07-31T11:05:03Z", "type": "forcePushed"}, {"oid": "b301b6fe8b4ff444950a47ef2d949752f6b9081a", "url": "https://github.com/elastic/elasticsearch/commit/b301b6fe8b4ff444950a47ef2d949752f6b9081a", "message": "Fix visibility issue", "committedDate": "2020-07-31T12:03:51Z", "type": "commit"}, {"oid": "614c4754ab9a29ad8056c7bf23c71c64d0a6b705", "url": "https://github.com/elastic/elasticsearch/commit/614c4754ab9a29ad8056c7bf23c71c64d0a6b705", "message": "Do not output file details by default", "committedDate": "2020-07-31T12:49:07Z", "type": "commit"}, {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "url": "https://github.com/elastic/elasticsearch/commit/1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "message": "Merge branch 'master' into searchable-snapshots-recovery-state", "committedDate": "2020-08-02T11:32:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1MzE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464253167", "bodyText": "what's the point of this private method? It's just delegating a single call, yet introducing an unnecessary abstraction", "author": "ywelsch", "createdAt": "2020-08-03T07:59:18Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -387,58 +395,73 @@ private void cleanExistingRegularShardFiles() {\n         }\n     }\n \n+    private void onPreWarmFinished() {", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1NjU4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464256586", "bodyText": "Inline this into prewarmCache? Especially as it's duplicating the iteration logic down below.", "author": "ywelsch", "createdAt": "2020-08-03T08:06:41Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -455,6 +478,19 @@ private void prewarmNext(final Executor executor, final BlockingQueue<Tuple<Acti\n         }\n     }\n \n+    private void addRecoveryFileDetails() {", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2MTQ1NA==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464261454", "bodyText": "KeptOpen?", "author": "ywelsch", "createdAt": "2020-08-03T08:17:09Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -736,6 +765,74 @@ public void testRequiresAdditionalSettings() {\n         }\n     }\n \n+    public void testRecoveryStateIsKeepOpenAfterPreWarmFailures() throws Exception {", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NTEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464265101", "bodyText": "With the change in behavior of this PR, rename this perhaps to \"snapshot_prewarm\".", "author": "ywelsch", "createdAt": "2020-08-03T08:24:29Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsConstants.java", "diffHunk": "@@ -30,6 +30,8 @@\n \n     public static final String SNAPSHOT_DIRECTORY_FACTORY_KEY = \"snapshot\";\n \n+    public static final String SNAPSHOT_RECOVERY_STATE_FACTORY_KEY = \"on_demand\";", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MDY1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464270659", "bodyText": "This assumes that noone is touching the index setting index.recovery.type. Perhaps we should also throw an explicit exception here when assertions are not enabled?", "author": "ywelsch", "createdAt": "2020-08-03T08:35:14Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -176,7 +180,9 @@ protected final boolean assertCurrentThreadMayLoadSnapshot() {\n      *\n      * @return true if the snapshot was loaded by executing this method, false otherwise\n      */\n-    public boolean loadSnapshot() {\n+    public boolean loadSnapshot(RecoveryState recoveryState) {\n+        assert recoveryState != null;\n+        assert recoveryState instanceof SearchableSnapshotRecoveryState;", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NDQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464274409", "bodyText": "maybe just choose a random subset of  these, and then check later that fileDetails does  not contain any of the subset  chosen? THis test  here would currently be trivially satisfied if the code was to just ignore all files whenever excluded files existed.", "author": "ywelsch", "createdAt": "2020-08-03T08:42:46Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -736,6 +765,74 @@ public void testRequiresAdditionalSettings() {\n         }\n     }\n \n+    public void testRecoveryStateIsKeepOpenAfterPreWarmFailures() throws Exception {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FaultyReadsFileSystem disruptFileSystemProvider = new FaultyReadsFileSystem(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+\n+        try {\n+            SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+            testDirectories(true, true, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+                ThreadPoolExecutor executor = (ThreadPoolExecutor) snapshotDirectory.cacheFetchAsyncExecutor();\n+                assertBusy(() -> {\n+                    assertThat(executor.getActiveCount(), equalTo(0));\n+                    assertThat(executor.getQueue().size(), equalTo(0));\n+                });\n+\n+                assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.FINALIZE));\n+                // All pre-warm tasks failed\n+                assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            });\n+        } finally {\n+            PathUtilsForTesting.teardown();\n+        }\n+    }\n+\n+    public void testRecoveryStateIsEmptyWhenTheCacheIsNotPreWarmed() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+        testDirectories(true, false, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+            assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.DONE));\n+            assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            assertThat(recoveryState.getIndex().totalRecoverFiles(), equalTo(0));\n+        });\n+    }\n+\n+    public void testNonCachedFilesAreExcludedFromRecoveryState() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+\n+        List<String> allFileExtensions = List.of(\n+            \"fdt\",\n+            \"fdx\",\n+            \"nvd\",\n+            \"dvd\",\n+            \"tip\",\n+            \"cfs\",\n+            \"dim\",\n+            \"fnm\",\n+            \"dvm\",\n+            \"tmd\",\n+            \"doc\",\n+            \"tim\",\n+            \"pos\",\n+            \"cfe\",\n+            \"fdm\",\n+            \"nvm\"\n+        );\n+        Settings settings = Settings.builder().putList(SNAPSHOT_CACHE_EXCLUDED_FILE_TYPES_SETTING.getKey(), allFileExtensions).build();", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NzIwMA==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464277200", "bodyText": "is this info-level logging still needed?", "author": "ywelsch", "createdAt": "2020-08-03T08:48:03Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -703,6 +700,29 @@ private void assertRecovered(String indexName, TotalHits originalAllHits, TotalH\n         }\n     }\n \n+    private void assertRecoveryStats(String indexName, boolean preWarmEnabled) {\n+        int shardCount = getNumShards(indexName).totalNumShards;\n+        final RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries(indexName).get();\n+        assertThat(recoveryResponse.shardRecoveryStates().get(indexName).size(), equalTo(shardCount));\n+\n+        for (List<RecoveryState> recoveryStates : recoveryResponse.shardRecoveryStates().values()) {\n+            for (RecoveryState recoveryState : recoveryStates) {\n+                logger.info(\"Checking {}[{}]\", recoveryState.getShardId(), recoveryState.getPrimary() ? \"p\" : \"r\");", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3Nzk3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464277975", "bodyText": "That's not true anymore with the latest approach? Shouldn't it always be DONE?", "author": "ywelsch", "createdAt": "2020-08-03T08:49:32Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -703,6 +700,29 @@ private void assertRecovered(String indexName, TotalHits originalAllHits, TotalH\n         }\n     }\n \n+    private void assertRecoveryStats(String indexName, boolean preWarmEnabled) {\n+        int shardCount = getNumShards(indexName).totalNumShards;\n+        final RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries(indexName).get();\n+        assertThat(recoveryResponse.shardRecoveryStates().get(indexName).size(), equalTo(shardCount));\n+\n+        for (List<RecoveryState> recoveryStates : recoveryResponse.shardRecoveryStates().values()) {\n+            for (RecoveryState recoveryState : recoveryStates) {\n+                logger.info(\"Checking {}[{}]\", recoveryState.getShardId(), recoveryState.getPrimary() ? \"p\" : \"r\");\n+                ByteSizeValue cacheSize = getCacheSizeForShard(recoveryState.getShardId());\n+                boolean largeCache = cacheSize.compareTo(new ByteSizeValue(1, ByteSizeUnit.MB)) >= 0;\n+                assertThat(\n+                    Strings.toString(recoveryState),\n+                    recoveryState.getIndex().recoveredFileCount(),\n+                    preWarmEnabled && largeCache ? greaterThan(0) : greaterThanOrEqualTo(0)\n+                );\n+\n+                // Since the cache size is variable, the pre-warm phase might fail as some of the files can be evicted\n+                // while a part is pre-fetched, in that case the recovery state is left as FINALIZE.\n+                assertThat(recoveryState.getStage(), anyOf(equalTo(RecoveryState.Stage.DONE), equalTo(RecoveryState.Stage.FINALIZE)));", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4NDg1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464284851", "bodyText": "In those tests the cache size is set randomly, meaning that's possible that in some test instances the cache won't have room for all the files in the index therefore some of the pre-warming tasks would fail.", "author": "fcofdez", "createdAt": "2020-08-03T09:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3Nzk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4NjQxNA==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464286414", "bodyText": "Can we make a stronger assertion here then in case where the cache is set to unbounded?", "author": "ywelsch", "createdAt": "2020-08-03T09:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3Nzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3ODE2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464278169", "bodyText": "Is still relevant with the latest approach?", "author": "ywelsch", "createdAt": "2020-08-03T08:49:53Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -703,6 +700,29 @@ private void assertRecovered(String indexName, TotalHits originalAllHits, TotalH\n         }\n     }\n \n+    private void assertRecoveryStats(String indexName, boolean preWarmEnabled) {\n+        int shardCount = getNumShards(indexName).totalNumShards;\n+        final RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries(indexName).get();\n+        assertThat(recoveryResponse.shardRecoveryStates().get(indexName).size(), equalTo(shardCount));\n+\n+        for (List<RecoveryState> recoveryStates : recoveryResponse.shardRecoveryStates().values()) {\n+            for (RecoveryState recoveryState : recoveryStates) {\n+                logger.info(\"Checking {}[{}]\", recoveryState.getShardId(), recoveryState.getPrimary() ? \"p\" : \"r\");\n+                ByteSizeValue cacheSize = getCacheSizeForShard(recoveryState.getShardId());\n+                boolean largeCache = cacheSize.compareTo(new ByteSizeValue(1, ByteSizeUnit.MB)) >= 0;", "originalCommit": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "46b07633c84432eb970fc8b04a401c4ae5f736f6", "url": "https://github.com/elastic/elasticsearch/commit/46b07633c84432eb970fc8b04a401c4ae5f736f6", "message": "Address review comments", "committedDate": "2020-08-03T13:36:34Z", "type": "commit"}, {"oid": "467693798cdbec046126e58bf0aadc4fb05f9e78", "url": "https://github.com/elastic/elasticsearch/commit/467693798cdbec046126e58bf0aadc4fb05f9e78", "message": "Merge remote-tracking branch 'origin/master' into searchable-snapshots-recovery-state", "committedDate": "2020-08-03T13:37:05Z", "type": "commit"}, {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38", "url": "https://github.com/elastic/elasticsearch/commit/b2989f667ca763500b9c6311ec03af81aeb2ef38", "message": "Fix stlye errors", "committedDate": "2020-08-03T13:57:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464916131", "bodyText": "In case where file.metadata().hashEqualsContents(), I wonder if we should just mark those files as recovered (reused = true) (as they are subsequently available), i.e. recoveryState.getIndex().addFileDetail(file.physicalName(), file.length(), true);.", "author": "ywelsch", "createdAt": "2020-08-04T09:18:12Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -388,57 +398,70 @@ private void cleanExistingRegularShardFiles() {\n     }\n \n     private void prewarmCache() {\n-        if (prewarmCache) {\n-            final BlockingQueue<Tuple<ActionListener<Void>, CheckedRunnable<Exception>>> queue = new LinkedBlockingQueue<>();\n-            final Executor executor = prewarmExecutor();\n+        if (prewarmCache == false) {\n+            recoveryState.preWarmFinished();\n+            return;\n+        }\n \n-            for (BlobStoreIndexShardSnapshot.FileInfo file : snapshot().indexFiles()) {\n-                if (file.metadata().hashEqualsContents() || isExcludedFromCache(file.physicalName())) {\n-                    continue;\n-                }\n-                try {\n-                    final IndexInput input = openInput(file.physicalName(), CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n-                    assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n-\n-                    final int numberOfParts = Math.toIntExact(file.numberOfParts());\n-                    final GroupedActionListener<Void> listener = new GroupedActionListener<>(\n-                        ActionListener.wrap(voids -> input.close(), e -> IOUtils.closeWhileHandlingException(input)),\n-                        numberOfParts\n-                    );\n-\n-                    for (int p = 0; p < numberOfParts; p++) {\n-                        final int part = p;\n-                        queue.add(Tuple.tuple(listener, () -> {\n-                            ensureOpen();\n-\n-                            logger.trace(\"{} warming cache for [{}] part [{}/{}]\", shardId, file.physicalName(), part + 1, numberOfParts);\n-                            final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-                            ((CachedBlobContainerIndexInput) input).prefetchPart(part);\n-\n-                            logger.trace(\n-                                () -> new ParameterizedMessage(\n-                                    \"{} part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                    shardId,\n-                                    part + 1,\n-                                    numberOfParts,\n-                                    file.physicalName(),\n-                                    TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                )\n-                            );\n-                        }));\n-                    }\n-                } catch (IOException e) {\n-                    logger.warn(() -> new ParameterizedMessage(\"{} unable to prewarm file [{}]\", shardId, file.physicalName()), e);\n+        final BlockingQueue<Tuple<ActionListener<Void>, CheckedRunnable<Exception>>> queue = new LinkedBlockingQueue<>();\n+        final Executor executor = prewarmExecutor();\n+\n+        final GroupedActionListener<Void> completionListener = new GroupedActionListener<>(\n+            ActionListener.wrap(voids -> recoveryState.preWarmFinished(), e -> {}), // Ignore pre-warm errors\n+            snapshot().totalFileCount()\n+        );\n+\n+        for (BlobStoreIndexShardSnapshot.FileInfo file : snapshot().indexFiles()) {\n+            if (file.metadata().hashEqualsContents() || isExcludedFromCache(file.physicalName())) {\n+                recoveryState.ignoreFile(file.physicalName());", "originalCommit": "b2989f667ca763500b9c6311ec03af81aeb2ef38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMTg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464931841", "bodyText": "I think that's a good idea.", "author": "fcofdez", "createdAt": "2020-08-04T09:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NzkyNA==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465547924", "bodyText": "Is this behavior tested anywhere?", "author": "ywelsch", "createdAt": "2020-08-05T08:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1ODc0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465558741", "bodyText": "No, I'll add a test that covers files with file.metadata().hashEqualsContents() property, thanks!", "author": "fcofdez", "createdAt": "2020-08-05T08:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxODAzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464918039", "bodyText": "should we throw an exception here if the stage is currently not FINALIZE, i.e. validateCurrentStage(FINALIZE)?", "author": "ywelsch", "createdAt": "2020-08-04T09:21:33Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/indices/recovery/SearchableSnapshotRecoveryState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.Nullable;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public final class SearchableSnapshotRecoveryState extends RecoveryState {\n+    private boolean preWarmFinished;\n+\n+    public SearchableSnapshotRecoveryState(ShardRouting shardRouting, DiscoveryNode targetNode, @Nullable DiscoveryNode sourceNode) {\n+        super(shardRouting, targetNode, sourceNode, new Index());\n+    }\n+\n+    @Override\n+    public synchronized RecoveryState setStage(Stage stage) {\n+        // The transition to the final state was done by #prewarmCompleted, just ignore the transition\n+        if (getStage() == Stage.DONE) {\n+            return this;\n+        }\n+\n+        // Pre-warm is still running, hold the state transition\n+        // until the pre-warm process finishes\n+        if (preWarmFinished == false && stage == Stage.DONE) {\n+            return this;", "originalCommit": "b2989f667ca763500b9c6311ec03af81aeb2ef38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyOTYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464929635", "bodyText": "+1", "author": "fcofdez", "createdAt": "2020-08-04T09:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxODAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxOTI0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464919242", "bodyText": "do we not need to implement this method, which  gets called when a peer recovery retries?", "author": "ywelsch", "createdAt": "2020-08-04T09:23:41Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/indices/recovery/SearchableSnapshotRecoveryState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.Nullable;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public final class SearchableSnapshotRecoveryState extends RecoveryState {\n+    private boolean preWarmFinished;\n+\n+    public SearchableSnapshotRecoveryState(ShardRouting shardRouting, DiscoveryNode targetNode, @Nullable DiscoveryNode sourceNode) {\n+        super(shardRouting, targetNode, sourceNode, new Index());\n+    }\n+\n+    @Override\n+    public synchronized RecoveryState setStage(Stage stage) {\n+        // The transition to the final state was done by #prewarmCompleted, just ignore the transition\n+        if (getStage() == Stage.DONE) {\n+            return this;\n+        }\n+\n+        // Pre-warm is still running, hold the state transition\n+        // until the pre-warm process finishes\n+        if (preWarmFinished == false && stage == Stage.DONE) {\n+            return this;\n+        }\n+\n+        return super.setStage(stage);\n+    }\n+\n+    public synchronized void preWarmFinished() {\n+        // For small shards it's possible that the\n+        // cache is pre-warmed before the stage has transitioned\n+        // to FINALIZE, so the transition to the final state is delayed until\n+        // the recovery process catches up.\n+        if (getStage() == Stage.FINALIZE) {\n+            super.setStage(Stage.DONE);\n+        }\n+\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.stopTimer();\n+        preWarmFinished = true;\n+    }\n+\n+    public synchronized void ignoreFile(String name) {\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.addFileToIgnore(name);\n+    }\n+\n+    private static final class Index extends RecoveryState.Index {\n+        // We ignore the files that won't be part of the pre-warming\n+        // phase since the information for those files won't be\n+        // updated and marking them as reused might be confusing,\n+        // as they are fetched on-demand from the underlying repository.\n+        private final Set<String> filesToIgnore = new HashSet<>();\n+\n+        private Index() {\n+            super(new SearchableSnapshotRecoveryFilesDetails());\n+            // We start loading data just at the beginning\n+            super.start();\n+        }\n+\n+        private synchronized void addFileToIgnore(String name) {\n+            filesToIgnore.add(name);\n+        }\n+\n+        @Override\n+        public synchronized void addFileDetail(String name, long length, boolean reused) {\n+            if (filesToIgnore.contains(name)) {\n+                return;\n+            }\n+\n+            super.addFileDetail(name, length, reused);\n+        }\n+\n+        // We have to bypass all the calls to the timer\n+        @Override\n+        public synchronized void start() {}\n+\n+        @Override\n+        public synchronized void stop() {}\n+\n+        @Override\n+        public synchronized void reset() {}", "originalCommit": "b2989f667ca763500b9c6311ec03af81aeb2ef38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMTAxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464931011", "bodyText": "The behavior don't change during peer recovery, the cache starts pre-warming as soon as the directory is created if I'm not mistaken.", "author": "fcofdez", "createdAt": "2020-08-04T09:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxOTI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464920660", "bodyText": "This means that the reused flag is not overridden, but based on what it was initially set?", "author": "ywelsch", "createdAt": "2020-08-04T09:26:03Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/indices/recovery/SearchableSnapshotRecoveryState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.Nullable;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public final class SearchableSnapshotRecoveryState extends RecoveryState {\n+    private boolean preWarmFinished;\n+\n+    public SearchableSnapshotRecoveryState(ShardRouting shardRouting, DiscoveryNode targetNode, @Nullable DiscoveryNode sourceNode) {\n+        super(shardRouting, targetNode, sourceNode, new Index());\n+    }\n+\n+    @Override\n+    public synchronized RecoveryState setStage(Stage stage) {\n+        // The transition to the final state was done by #prewarmCompleted, just ignore the transition\n+        if (getStage() == Stage.DONE) {\n+            return this;\n+        }\n+\n+        // Pre-warm is still running, hold the state transition\n+        // until the pre-warm process finishes\n+        if (preWarmFinished == false && stage == Stage.DONE) {\n+            return this;\n+        }\n+\n+        return super.setStage(stage);\n+    }\n+\n+    public synchronized void preWarmFinished() {\n+        // For small shards it's possible that the\n+        // cache is pre-warmed before the stage has transitioned\n+        // to FINALIZE, so the transition to the final state is delayed until\n+        // the recovery process catches up.\n+        if (getStage() == Stage.FINALIZE) {\n+            super.setStage(Stage.DONE);\n+        }\n+\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.stopTimer();\n+        preWarmFinished = true;\n+    }\n+\n+    public synchronized void ignoreFile(String name) {\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.addFileToIgnore(name);\n+    }\n+\n+    private static final class Index extends RecoveryState.Index {\n+        // We ignore the files that won't be part of the pre-warming\n+        // phase since the information for those files won't be\n+        // updated and marking them as reused might be confusing,\n+        // as they are fetched on-demand from the underlying repository.\n+        private final Set<String> filesToIgnore = new HashSet<>();\n+\n+        private Index() {\n+            super(new SearchableSnapshotRecoveryFilesDetails());\n+            // We start loading data just at the beginning\n+            super.start();\n+        }\n+\n+        private synchronized void addFileToIgnore(String name) {\n+            filesToIgnore.add(name);\n+        }\n+\n+        @Override\n+        public synchronized void addFileDetail(String name, long length, boolean reused) {\n+            if (filesToIgnore.contains(name)) {\n+                return;\n+            }\n+\n+            super.addFileDetail(name, length, reused);\n+        }\n+\n+        // We have to bypass all the calls to the timer\n+        @Override\n+        public synchronized void start() {}\n+\n+        @Override\n+        public synchronized void stop() {}\n+\n+        @Override\n+        public synchronized void reset() {}\n+\n+        private synchronized void stopTimer() {\n+            super.stop();\n+        }\n+    }\n+\n+    private static class SearchableSnapshotRecoveryFilesDetails extends RecoveryFilesDetails {\n+        @Override\n+        public void addFileDetails(String name, long length, boolean reused) {\n+            // We allow reporting the same file details multiple times as we populate the file\n+            // details before the recovery is executed and therefore we ignore the rest\n+            // of the calls for the same files.\n+            fileDetails.computeIfAbsent(name, n -> new FileDetail(name, length, reused));", "originalCommit": "b2989f667ca763500b9c6311ec03af81aeb2ef38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMDMwNg==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464930306", "bodyText": "That's correct.", "author": "fcofdez", "createdAt": "2020-08-04T09:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0OTM0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465549341", "bodyText": "This sounds wrong then, as we would have reused == true for all files (as we initially fake that all files are present), which is wrong as we can only reuse what we actually locally have.", "author": "ywelsch", "createdAt": "2020-08-05T08:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1Mjc0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465552741", "bodyText": "Those file details are populated first on SearchableSnapshotDirectory#prewarmCache, and that process is triggered before the recovery process starts. Meaning that they should contain the correct information.", "author": "fcofdez", "createdAt": "2020-08-05T08:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NjgxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465556819", "bodyText": "Can we assert something to that effect?", "author": "ywelsch", "createdAt": "2020-08-05T08:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1OTk0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465559942", "bodyText": "I'm thinking that maybe the intent will be clearer if we set a flag after the information is populated in SearchableSnapshotDirectory#prewarmCache and we bypass the calls to this method once that flag is true, wdyt?", "author": "fcofdez", "createdAt": "2020-08-05T08:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU2NTc1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465565752", "bodyText": "yes", "author": "ywelsch", "createdAt": "2020-08-05T08:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzNzU5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r465637595", "bodyText": "Finally I've kept the same approach as it's possible that during peer recoveries an additional segments_n file is sent over as after restore the index is marked with a new history uuid generating a new segments_ file that's unknown to the target peer. So I've added a stronger assertion to ensure that if the file was already added it has the same length.", "author": "fcofdez", "createdAt": "2020-08-05T10:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMTc1MA==", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464921750", "bodyText": "simpler to just assertFalse(fileHasExcludedType)", "author": "ywelsch", "createdAt": "2020-08-04T09:27:58Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -736,6 +765,79 @@ public void testRequiresAdditionalSettings() {\n         }\n     }\n \n+    public void testRecoveryStateIsKeptOpenAfterPreWarmFailures() throws Exception {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FaultyReadsFileSystem disruptFileSystemProvider = new FaultyReadsFileSystem(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+\n+        try {\n+            SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+            testDirectories(true, true, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+                ThreadPoolExecutor executor = (ThreadPoolExecutor) snapshotDirectory.cacheFetchAsyncExecutor();\n+                assertBusy(() -> {\n+                    assertThat(executor.getActiveCount(), equalTo(0));\n+                    assertThat(executor.getQueue().size(), equalTo(0));\n+                });\n+\n+                assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.FINALIZE));\n+                // All pre-warm tasks failed\n+                assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            });\n+        } finally {\n+            PathUtilsForTesting.teardown();\n+        }\n+    }\n+\n+    public void testRecoveryStateIsEmptyWhenTheCacheIsNotPreWarmed() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+        testDirectories(true, false, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+            assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.DONE));\n+            assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            assertThat(recoveryState.getIndex().totalRecoverFiles(), equalTo(0));\n+        });\n+    }\n+\n+    public void testNonCachedFilesAreExcludedFromRecoveryState() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+\n+        List<String> allFileExtensions = List.of(\n+            \"fdt\",\n+            \"fdx\",\n+            \"nvd\",\n+            \"dvd\",\n+            \"tip\",\n+            \"cfs\",\n+            \"dim\",\n+            \"fnm\",\n+            \"dvm\",\n+            \"tmd\",\n+            \"doc\",\n+            \"tim\",\n+            \"pos\",\n+            \"cfe\",\n+            \"fdm\",\n+            \"nvm\"\n+        );\n+        List<String> fileTypesExcludedFromCaching = randomSubsetOf(allFileExtensions);\n+        Settings settings = Settings.builder()\n+            .putList(SNAPSHOT_CACHE_EXCLUDED_FILE_TYPES_SETTING.getKey(), fileTypesExcludedFromCaching)\n+            .build();\n+        testDirectories(true, true, recoveryState, settings, (directory, snapshotDirectory) -> {\n+            ThreadPoolExecutor executor = (ThreadPoolExecutor) snapshotDirectory.prewarmExecutor();\n+            assertBusy(() -> {\n+                assertThat(executor.getActiveCount(), equalTo(0));\n+                assertThat(executor.getQueue().size(), equalTo(0));\n+            });\n+\n+            assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.DONE));\n+            for (RecoveryState.FileDetail fileDetail : recoveryState.getIndex().fileDetails()) {\n+                boolean fileHasExcludedType = fileTypesExcludedFromCaching.stream().anyMatch(type -> fileDetail.name().endsWith(type));\n+                assertThat(fileHasExcludedType, equalTo(false));", "originalCommit": "b2989f667ca763500b9c6311ec03af81aeb2ef38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "becd151ef0bf8b3be05a7829dd151026af4ca251", "url": "https://github.com/elastic/elasticsearch/commit/becd151ef0bf8b3be05a7829dd151026af4ca251", "message": "Address review comments", "committedDate": "2020-08-04T12:24:49Z", "type": "commit"}, {"oid": "4985df57111f66815afa5ad17dc67eafa02af33d", "url": "https://github.com/elastic/elasticsearch/commit/4985df57111f66815afa5ad17dc67eafa02af33d", "message": "Merge remote-tracking branch 'origin/master' into searchable-snapshots-recovery-state", "committedDate": "2020-08-04T12:24:59Z", "type": "commit"}, {"oid": "eda436e0981d3a4ab31aa0684ff1830f4f49d820", "url": "https://github.com/elastic/elasticsearch/commit/eda436e0981d3a4ab31aa0684ff1830f4f49d820", "message": "Add test for reused files and add stronger assertions for", "committedDate": "2020-08-05T10:43:17Z", "type": "commit"}, {"oid": "50ab07bf5e2fc1c511adb249fc571aa5f77f3f6d", "url": "https://github.com/elastic/elasticsearch/commit/50ab07bf5e2fc1c511adb249fc571aa5f77f3f6d", "message": "Merge remote-tracking branch 'origin/master' into searchable-snapshots-recovery-state", "committedDate": "2020-08-05T10:43:50Z", "type": "commit"}]}