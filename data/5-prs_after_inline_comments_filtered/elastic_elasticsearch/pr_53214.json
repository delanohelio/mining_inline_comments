{"pr_number": 53214, "pr_title": "add tests for missing aggregation", "pr_createdAt": "2020-03-06T06:58:28Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53214", "timeline": [{"oid": "474f4e58e7b73773790509a1c797d2c290a08445", "url": "https://github.com/elastic/elasticsearch/commit/474f4e58e7b73773790509a1c797d2c290a08445", "message": "add tests for missing aggregation\n\nTest with unmapped fields and using the missing parameter, which isn't\nvery useful with this aggregation but does work as expected. Also\nincludes yaml tests\n\nFor #42949", "committedDate": "2020-03-06T06:50:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MjQ3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53214#discussion_r388742476", "bodyText": "Note: in some of the aggregator tests similar to this one (where there's a second field we expect to be absent sometimes), we don't pass a field type for the second field like above. If the test is missing the second field type, that field can't be read even if an aggregator was erroneously trying to collect it", "author": "andyb-elastic", "createdAt": "2020-03-06T07:08:18Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java", "diffHunk": "@@ -28,81 +28,115 @@\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.common.lucene.search.Queries;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n import org.elasticsearch.index.mapper.RangeFieldMapper;\n import org.elasticsearch.index.mapper.RangeType;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n \n import java.io.IOException;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n import java.util.function.Consumer;\n \n+import static java.util.Collections.singleton;\n+\n \n public class MissingAggregatorTests extends AggregatorTestCase {\n     public void testMatchNoDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), 0);\n                 assertFalse(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            singleton(fieldType));\n     }\n \n     public void testMatchAllDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), numDocs);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));\n     }\n \n     public void testMatchSparse() throws IOException {\n         int numDocs = randomIntBetween(100, 200);\n         final AtomicInteger count = new AtomicInteger();\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> {\n+            builder -> {},\n+            (index, doc) -> {\n                 if (randomBoolean()) {\n-                    doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong()));\n                     count.incrementAndGet();\n                 } else {\n-                    doc.add(new SortedNumericDocValuesField(\"field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong()));\n                 }\n             },\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), count.get());\n                 count.set(0);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));", "originalCommit": "474f4e58e7b73773790509a1c797d2c290a08445", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2OTkwNw==", "url": "https://github.com/elastic/elasticsearch/pull/53214#discussion_r389169907", "bodyText": "We should fix that, could you open a ticket so we don't forget please?", "author": "not-napoleon", "createdAt": "2020-03-06T22:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MjQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4ODc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53214#discussion_r389188793", "bodyText": "I opened #53250", "author": "andyb-elastic", "createdAt": "2020-03-06T23:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MjQ3Ng=="}], "type": "inlineReview"}, {"oid": "a964952b9097a678c20d3e83db66092541c5b495", "url": "https://github.com/elastic/elasticsearch/commit/a964952b9097a678c20d3e83db66092541c5b495", "message": "add supported valuessourcetype tests", "committedDate": "2020-03-06T23:52:43Z", "type": "commit"}, {"oid": "8e222d93dc11675533050abafa1829a22651b6dd", "url": "https://github.com/elastic/elasticsearch/commit/8e222d93dc11675533050abafa1829a22651b6dd", "message": "add script tests\n\nAlso change the test case pattern to be more flexible and more similar\nto how the other agg tests are written", "committedDate": "2020-03-11T01:28:41Z", "type": "commit"}, {"oid": "37dd0410786076372e4afbc298fb252af9f5eab9", "url": "https://github.com/elastic/elasticsearch/commit/37dd0410786076372e4afbc298fb252af9f5eab9", "message": "Merge branch 'master' into feature-missing-agg-tests", "committedDate": "2020-03-11T01:31:29Z", "type": "commit"}]}