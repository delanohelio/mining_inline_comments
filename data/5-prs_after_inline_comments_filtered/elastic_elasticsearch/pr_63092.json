{"pr_number": 63092, "pr_title": "[ML] adding for_export flag for ml plugin GET resource APIs", "pr_createdAt": "2020-09-30T17:29:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63092", "timeline": [{"oid": "baf04b72176018f812a2ec3a2e37f170532a6c58", "url": "https://github.com/elastic/elasticsearch/commit/baf04b72176018f812a2ec3a2e37f170532a6c58", "message": "[ML] adding for_export flag for APIs", "committedDate": "2020-09-30T17:28:05Z", "type": "commit"}, {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "url": "https://github.com/elastic/elasticsearch/commit/fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "message": "fixing test", "committedDate": "2020-09-30T18:11:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MDAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497990034", "bodyText": "BTW, is there any reason for ALLOW_NO_MATCH to be ParseField rather than String?", "author": "przemekwitek", "createdAt": "2020-10-01T05:23:05Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/GetDataFrameAnalyticsRequest.java", "diffHunk": "@@ -33,10 +33,12 @@\n public class GetDataFrameAnalyticsRequest implements Validatable {\n \n     public static final ParseField ALLOW_NO_MATCH = new ParseField(\"allow_no_match\");", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MTgwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498181805", "bodyText": "probably not, but just didn't touch the existing field :)", "author": "benwtrent", "createdAt": "2020-10-01T11:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MDAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MjMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497992322", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else { // Don't include random defaults or unnecessary defauls in export\n          \n          \n            \n                    } else { // Don't include random defaults or unnecessary defaults in export", "author": "przemekwitek", "createdAt": "2020-10-01T05:31:46Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497993914", "bodyText": "So this else block is not for making the retrieved config \"puttable\" but it does something more (clears defaults).\nI'm wondering what happens when we ever change the code for generating the default. Then the config is indexed with default D1, then in the subsequent version we change the default to be D2 and then we retrieve the config for export and the default is not cleared (as it was the default in the past but no longer is). Is that a good behavior?", "author": "przemekwitek", "createdAt": "2020-10-01T05:37:30Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4Mjk0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498182943", "bodyText": "@przemekwitek a related question.\nWhat if the user didn't set their own chunking_config but when they cloned the datafeed, they DID change the aggregation information (maybe the date_histogram bucket size). Then when they try to PUT, the chunking config is now illegal.\nShould we allow this behavior?", "author": "benwtrent", "createdAt": "2020-10-01T11:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxNzEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498217126", "bodyText": "Tough question. I guess it's better to stick to the promise that we are able to PUT the config obtained via GET with for_export...", "author": "przemekwitek", "createdAt": "2020-10-01T12:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNDY0MA==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498034640", "bodyText": "We should have a single method that calculates the default query delay between this one and Builder.setDefaultQueryDelay", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T07:23:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -473,26 +505,36 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n         builder.field(SCROLL_SIZE.getPreferredName(), scrollSize);\n-        if (chunkingConfig != null) {\n-            builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n-        }\n-        if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(HEADERS.getPreferredName(), headers);\n-        }\n         if (delayedDataCheckConfig != null) {\n             builder.field(DELAYED_DATA_CHECK_CONFIG.getPreferredName(), delayedDataCheckConfig);\n         }\n         if (maxEmptySearches != null) {\n             builder.field(MAX_EMPTY_SEARCHES.getPreferredName(), maxEmptySearches);\n         }\n-        builder.startObject(INDICES_OPTIONS.getPreferredName());\n-        indicesOptions.toXContent(builder, params);\n-        builder.endObject();\n-\n         builder.endObject();\n         return builder;\n     }\n \n+    private TimeValue defaultRandomQueryDelay() {\n+        Random random = new Random(jobId.hashCode());", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498036877", "bodyText": "Is there a benefit to not always return the query? The query is integral to the behaviour of the datafeed. Even in the improbable scenario where we change the default query in a future release, it'd be a weird surprise to get a datafeed for_export from a previous version cluster and put it in a newer version to find out different docs are picked because the default query changed.", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T07:27:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export\n+            if (queryDelay.equals(defaultRandomQueryDelay()) == false) {\n+                builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            }\n+            // This is always \"match_all\"\n+            if (queryProvider.equals(QueryProvider.defaultQuery()) == false) {", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MzkxNw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498183917", "bodyText": "put it in a newer version to find out different docs are picked because the default query changed.\n\nIf we change the default query to EXCLUDE docs, I think that is a huge thing and should probably never be done.\nI can happily include the query here, but it did seem unnecessary to me.", "author": "benwtrent", "createdAt": "2020-10-01T11:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwMTA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498301085", "bodyText": "Agreed that changing the default query sounds hard to justify :-)\nBut I do think we should include the query. We return it in get, so we might as well also return it for_export.", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T14:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzODc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498038753", "bodyText": "Same here, let's avoid duplication on the default calculation. We can reuse this in the Builder.setDefaultChunkingConfig.", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T07:31:00Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -473,26 +505,36 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n         builder.field(SCROLL_SIZE.getPreferredName(), scrollSize);\n-        if (chunkingConfig != null) {\n-            builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n-        }\n-        if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(HEADERS.getPreferredName(), headers);\n-        }\n         if (delayedDataCheckConfig != null) {\n             builder.field(DELAYED_DATA_CHECK_CONFIG.getPreferredName(), delayedDataCheckConfig);\n         }\n         if (maxEmptySearches != null) {\n             builder.field(MAX_EMPTY_SEARCHES.getPreferredName(), maxEmptySearches);\n         }\n-        builder.startObject(INDICES_OPTIONS.getPreferredName());\n-        indicesOptions.toXContent(builder, params);\n-        builder.endObject();\n-\n         builder.endObject();\n         return builder;\n     }\n \n+    private TimeValue defaultRandomQueryDelay() {\n+        Random random = new Random(jobId.hashCode());\n+        long delayMillis = random.longs(Builder.MIN_DEFAULT_QUERY_DELAY.millis(), Builder.MAX_DEFAULT_QUERY_DELAY.millis())\n+            .findFirst().getAsLong();\n+        return TimeValue.timeValueMillis(delayMillis);\n+    }\n+\n+    private ChunkingConfig defaultChunkingConfig() {\n+        if (aggProvider == null || aggProvider.getParsedAggs() == null) {", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa4ed0bcf916fb3598b6e24aab33bb14f2f488a9", "url": "https://github.com/elastic/elasticsearch/commit/fa4ed0bcf916fb3598b6e24aab33bb14f2f488a9", "message": "addressing pr comments", "committedDate": "2020-10-01T12:32:36Z", "type": "commit"}, {"oid": "90d7c0ac5ae9536cc5aa33f3025683886d72d5b5", "url": "https://github.com/elastic/elasticsearch/commit/90d7c0ac5ae9536cc5aa33f3025683886d72d5b5", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-add-for-export-flag", "committedDate": "2020-10-01T12:50:48Z", "type": "commit"}, {"oid": "03edfd4fec42419d1c495cba55e3bce7d29e9cc9", "url": "https://github.com/elastic/elasticsearch/commit/03edfd4fec42419d1c495cba55e3bce7d29e9cc9", "message": "fixing style", "committedDate": "2020-10-01T12:59:49Z", "type": "commit"}, {"oid": "2a639213f77b08f2eda92b6c3fed8b101f509940", "url": "https://github.com/elastic/elasticsearch/commit/2a639213f77b08f2eda92b6c3fed8b101f509940", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-add-for-export-flag", "committedDate": "2020-10-02T11:14:34Z", "type": "commit"}]}