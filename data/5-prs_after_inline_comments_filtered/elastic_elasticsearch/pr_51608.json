{"pr_number": 51608, "pr_title": "Allow Parallel Snapshot Restore And Delete", "pr_createdAt": "2020-01-29T13:01:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51608", "timeline": [{"oid": "68299a42f9b937484550b0ad4e237fa438958cec", "url": "https://github.com/elastic/elasticsearch/commit/68299a42f9b937484550b0ad4e237fa438958cec", "message": "Allow Parallel Snapshot Restore And Delete\n\nThere is no reason not to allow deletes in parallel to restores\nif they're dealing with different snapshots.\nA delete will not remove any files related to the snapshot that\nis being restored if it is different from the deleted snapshot\nbecause those files will still be referenced by the restoring\nsnapshot.\nLoading RepositoryData concurrently to modifying it is concurrency\nsafe nowadays as well since the repo generation is tracked in the\ncluster state.\n\nCloses #41463", "committedDate": "2020-01-29T12:54:05Z", "type": "commit"}, {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406", "url": "https://github.com/elastic/elasticsearch/commit/52bbaf4308e07725e36da688edcc0c4ecd875406", "message": "this test still makes sense ...", "committedDate": "2020-01-29T13:46:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MTUxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372391511", "bodyText": "Removing this one instead of adjusting it, it's totally redundant to the new resiliency test I added, that proves we don't get a dead-lock in this code either and it's much more useful for debugging.", "author": "original-brownbear", "createdAt": "2020-01-29T13:49:31Z", "path": "server/src/test/java/org/elasticsearch/snapshots/MinThreadsSnapshotRestoreIT.java", "diffHunk": "@@ -152,58 +152,4 @@ public void testSnapshottingWithInProgressDeletionNotAllowed() throws Exception\n         client().admin().cluster().prepareCreateSnapshot(repo, snapshot2).setWaitForCompletion(true).get();\n         assertEquals(1, client().admin().cluster().prepareGetSnapshots(repo).setSnapshots(\"_all\").get().getSnapshots(repo).size());\n     }\n-\n-    public void testRestoreWithInProgressDeletionsNotAllowed() throws Exception {", "originalCommit": "52bbaf4308e07725e36da688edcc0c4ecd875406", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzOTIyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372839221", "bodyText": "Just to be sure, the execution order will be randomized by the deterministicTaskQueue?", "author": "tlrx", "createdAt": "2020-01-30T09:28:31Z", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(", "originalCommit": "52bbaf4308e07725e36da688edcc0c4ecd875406", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NjI1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372846251", "bodyText": "Yes exactly, sometimes the restore will run first, sometimes the delete will run first :)", "author": "original-brownbear", "createdAt": "2020-01-30T09:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzOTIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MDMzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372850339", "bodyText": "Thanks!", "author": "tlrx", "createdAt": "2020-01-30T09:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzOTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0MjMzMA==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372842330", "bodyText": "Is there a specific reason to add this check?", "author": "tlrx", "createdAt": "2020-01-30T09:34:57Z", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));", "originalCommit": "52bbaf4308e07725e36da688edcc0c4ecd875406", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NjQwOA==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372846408", "bodyText": "Nah, that was just stupid c&p :) dropped it, sorry for the noise.", "author": "original-brownbear", "createdAt": "2020-01-30T09:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0MjMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0Mjg2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372842861", "bodyText": "Maybe also check that the expected snapshot is here?", "author": "tlrx", "createdAt": "2020-01-30T09:36:05Z", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));\n+        final Repository repository = masterNode.repositoriesService.repository(repoName);\n+        Collection<SnapshotId> snapshotIds = getRepositoryData(repository).getSnapshotIds();\n+        assertThat(snapshotIds, hasSize(1));\n+\n+        for (SnapshotId snapshotId : snapshotIds) {\n+            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId);\n+            assertEquals(SnapshotState.SUCCESS, snapshotInfo.state());", "originalCommit": "52bbaf4308e07725e36da688edcc0c4ecd875406", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NjUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372846516", "bodyText": "Sure I made the check more exact in ece5a80", "author": "original-brownbear", "createdAt": "2020-01-30T09:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0Mjg2MQ=="}], "type": "inlineReview"}, {"oid": "b2a8b2b1198aca2bbf6e0b8cb5d6de973e6b7933", "url": "https://github.com/elastic/elasticsearch/commit/b2a8b2b1198aca2bbf6e0b8cb5d6de973e6b7933", "message": "Merge remote-tracking branch 'elastic/master' into 41463", "committedDate": "2020-01-30T09:37:21Z", "type": "commit"}, {"oid": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb", "url": "https://github.com/elastic/elasticsearch/commit/ece5a807f3ec17b1667ce8fad0a5bceb95e858fb", "message": "more accurate test", "committedDate": "2020-01-30T09:42:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MTE5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372851196", "bodyText": "Should we also index some docs (mostly to generate more snapshot files) before and in-between snapshots, and then run a query?", "author": "tlrx", "createdAt": "2020-01-30T09:52:39Z", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +518,61 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)", "originalCommit": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg2ODY1OA==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372868658", "bodyText": "Good idea, right now I don't expect it to make a difference but good to have some checks on this :) I pushed e8fe17e", "author": "original-brownbear", "createdAt": "2020-01-30T10:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MTE5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDQ3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372870475", "bodyText": "I don't expect it either but I prefer to have some shard files around :) Thanks", "author": "tlrx", "createdAt": "2020-01-30T10:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MTE5Ng=="}], "type": "inlineReview"}, {"oid": "e8fe17ecd035527bc1863f6d7f32e6c78e4999d5", "url": "https://github.com/elastic/elasticsearch/commit/e8fe17ecd035527bc1863f6d7f32e6c78e4999d5", "message": "index some docs", "committedDate": "2020-01-30T10:25:57Z", "type": "commit"}]}