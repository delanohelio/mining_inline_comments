{"pr_number": 51991, "pr_title": "Cache completion stats between refreshes", "pr_createdAt": "2020-02-06T10:43:40Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51991", "timeline": [{"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b", "url": "https://github.com/elastic/elasticsearch/commit/5be0d83709ec31e3f6d6438a84110b59ea7ea81b", "message": "Cache completion stats between refreshes\n\nComputing the stats for completion fields may involve a significant amount of\nwork since it walks every field of every segment looking for completion fields.\nInnocuous-looking APIs like `GET _stats` or `GET _cluster/stats` do this for\nevery shard in the cluster. This repeated work is unnecessary since these stats\ndo not change between refreshes; in many indices they remain constant for a\nlong time.\n\nThis commit introduces a cache for these stats which is invalidated on a\nrefresh, allowing most stats calls to bypass the work needed to compute them on\nmost shards.\n\nCloses #51915", "committedDate": "2020-02-06T10:35:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375763398", "bodyText": "I don't like this. These stats live at the Engine level, but the reference managers live down here, and we need to register the cache as a refresh listener; if there were any other implementations of Engine then they would also need to do the same (except ReadOnlyEngines of course, they don't refresh so don't need to update these stats).\nWe can't do this in the Engine constructor since these reference managers haven't been created when that runs, but I can't see another obvious place in the Engine lifecycle to do this. Suggestions welcome.", "author": "DaveCTurner", "createdAt": "2020-02-06T10:47:39Z", "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -247,6 +247,7 @@ public InternalEngine(EngineConfig engineConfig) {\n             }\n             this.lastRefreshedCheckpointListener = new LastRefreshedCheckpointListener(localCheckpointTracker.getProcessedCheckpoint());\n             this.internalReaderManager.addListener(lastRefreshedCheckpointListener);\n+            this.externalReaderManager.addListener(completionStatsCache);", "originalCommit": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg1NTA3OA==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375855078", "bodyText": "I think I would prefer to move the completionStatsCache field down to this level instead (and repeat it in ReadOnlyEngine for now). That would make the completionStats method abstract in Engine.\nI see no need to specialize the caching in ReadOnlyEngine, but in theory, we could pick a different strategy there...", "author": "henningandersen", "createdAt": "2020-02-06T14:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NTg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377195885", "bodyText": "Sure, thanks for the suggestion. Done in c3ae272.", "author": "DaveCTurner", "createdAt": "2020-02-10T17:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375764081", "bodyText": "NB this moves the stats back to the EXTERNAL searcher scope. Prior to #33847 they used the EXTERNAL searcher as here but since then they have been using the INTERNAL one. I think EXTERNAL is more appropriate.", "author": "DaveCTurner", "createdAt": "2020-02-06T10:48:55Z", "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "diffHunk": "@@ -177,32 +170,14 @@ public MergeStats getMergeStats() {\n     /** Returns how many bytes we are currently moving from heap to disk */\n     public abstract long getWritingBytes();\n \n+\n+    final CompletionStatsCache completionStatsCache = new CompletionStatsCache(() -> acquireSearcher(\"completion_stats\"));", "originalCommit": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg0MDA5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375840097", "bodyText": "Thanks for highlighting this. My hunch is that internal is more appropriate due to refreshIfNeeded, which can in some cases refresh the internal scope. This is out of a preference for returning as recent stats information as we can. Can you elaborate on why you find EXTERNAL more appropriate?", "author": "henningandersen", "createdAt": "2020-02-06T13:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5ODM3MA==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377198370", "bodyText": "I don't think we ever use the segments that are only referenced by the INTERNAL searcher for completion suggestions, but AIUI the previous implementation would load up their suggesters anyway. By moving this back to EXTERNAL we avoid even loading these unnecessary suggesters until they're externally exposed, so there's no need to account for their memory usage.\nI've not confirmed 100% that we never use internal-only segments for completion suggestions, so maybe that assumption is flawed.", "author": "DaveCTurner", "createdAt": "2020-02-10T17:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0OTk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r383949951", "bodyText": "++, thanks for elaborating, this makes perfect sense.", "author": "henningandersen", "createdAt": "2020-02-25T15:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ=="}], "type": "inlineReview"}, {"oid": "a590d74e14df890e0d7e12da73e68f28363b2e7d", "url": "https://github.com/elastic/elasticsearch/commit/a590d74e14df890e0d7e12da73e68f28363b2e7d", "message": "Merge branch 'master' into 2020-02-05-CompletionStatsCache", "committedDate": "2020-02-06T10:51:11Z", "type": "commit"}, {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9", "url": "https://github.com/elastic/elasticsearch/commit/db5be3a794c5560a8fd534bfb7fc5fc28472aac9", "message": "Imports", "committedDate": "2020-02-06T11:01:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkwNjMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375906335", "bodyText": "Instead of invalidating the entire current cache, we can mark the current cache as outdated (i.e., need to refresh), then we can reuse the stats of some LeafReader that haven't changed between refreshes.", "author": "dnhatn", "createdAt": "2020-02-06T15:34:56Z", "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {\n+            long sizeInBytes = 0;\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>();\n+\n+            try (Engine.Searcher currentSearcher = searcherSupplier.get()) {\n+                for (LeafReaderContext atomicReaderContext : currentSearcher.getIndexReader().leaves()) {\n+                    LeafReader atomicReader = atomicReaderContext.reader();\n+                    for (FieldInfo info : atomicReader.getFieldInfos()) {\n+                        Terms terms = atomicReader.terms(info.name);\n+                        if (terms instanceof CompletionTerms) {\n+                            // TODO: currently we load up the suggester for reporting its size\n+                            final long fstSize = ((CompletionTerms) terms).suggester().ramBytesUsed();\n+                            completionFields.addTo(info.name, fstSize);\n+                            sizeInBytes += fstSize;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return new CompletionStats(sizeInBytes, new FieldMemoryStats(completionFields));\n+        });\n+\n+        return filterCompletionStatsByFieldName(fieldNamePatterns, newFuture.actionGet());\n+    }\n+\n+    private static CompletionStats filterCompletionStatsByFieldName(String[] fieldNamePatterns, CompletionStats fullCompletionStats) {\n+        final FieldMemoryStats fieldMemoryStats;\n+        if (fieldNamePatterns != null && fieldNamePatterns.length > 0) {\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>(fieldNamePatterns.length);\n+            for (ObjectLongCursor<String> fieldCursor : fullCompletionStats.getFields()) {\n+                if (Regex.simpleMatch(fieldNamePatterns, fieldCursor.key)) {\n+                    completionFields.addTo(fieldCursor.key, fieldCursor.value);\n+                }\n+            }\n+            fieldMemoryStats = new FieldMemoryStats(completionFields);\n+        } else {\n+            fieldMemoryStats = null;\n+        }\n+        return new CompletionStats(fullCompletionStats.getSizeInBytes(), fieldMemoryStats);\n+    }\n+\n+    @Override\n+    public void beforeRefresh() {\n+    }\n+\n+    @Override\n+    public void afterRefresh(boolean didRefresh) {\n+        if (didRefresh) {\n+            completionStatsFutureRef.set(null);", "originalCommit": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIwMTgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377201835", "bodyText": "If we re-use a LeafReader across a refresh, does it keep its suggester loaded? If so, do we not already avoid most of the work of recomputing stats?\nNote that we need to break the stats down by field, because the user can select the fields in the API. If I understand correctly I think re-using stats on a per-segment basis too would require tracking everything on a per-segment-per-field basis which seems unnecessary.", "author": "DaveCTurner", "createdAt": "2020-02-10T17:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkwNjMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzODI2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375838265", "bodyText": "I think I would prefer to not cache an exception result (or at least clear the ref further down if newFuture.actionGet() throws an exception) in order to not stick to a bad result forever.", "author": "henningandersen", "createdAt": "2020-02-06T13:40:34Z", "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {", "originalCommit": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NTM4OA==", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377195388", "bodyText": "Sure, makes sense, I made it immediately invalidate the cache on an exception (the exception is still shared amongst concurrent callers) in 5e9a3ab.", "author": "DaveCTurner", "createdAt": "2020-02-10T17:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzODI2NQ=="}], "type": "inlineReview"}, {"oid": "2adb2b9fbaca83f7ad435085167697c38367c8d3", "url": "https://github.com/elastic/elasticsearch/commit/2adb2b9fbaca83f7ad435085167697c38367c8d3", "message": "Merge branch 'master' into 2020-02-05-CompletionStatsCache", "committedDate": "2020-02-10T16:33:41Z", "type": "commit"}, {"oid": "c3ae2725aa2a470fccf6b222eae6afbdc557d5c4", "url": "https://github.com/elastic/elasticsearch/commit/c3ae2725aa2a470fccf6b222eae6afbdc557d5c4", "message": "Push down", "committedDate": "2020-02-10T16:41:24Z", "type": "commit"}, {"oid": "5e9a3ab3cbc6ffd28939ef3435912cab62acb963", "url": "https://github.com/elastic/elasticsearch/commit/5e9a3ab3cbc6ffd28939ef3435912cab62acb963", "message": "Don't cache exceptional results", "committedDate": "2020-02-10T16:53:23Z", "type": "commit"}, {"oid": "e3262eb8ae5d6e1dd59fcc84cfabafea3be58d06", "url": "https://github.com/elastic/elasticsearch/commit/e3262eb8ae5d6e1dd59fcc84cfabafea3be58d06", "message": "wait_for_events", "committedDate": "2020-02-10T16:55:57Z", "type": "commit"}, {"oid": "a5d200e310b4d31ca6572759834ebe6e1c1b1656", "url": "https://github.com/elastic/elasticsearch/commit/a5d200e310b4d31ca6572759834ebe6e1c1b1656", "message": "Impors", "committedDate": "2020-02-10T17:23:27Z", "type": "commit"}, {"oid": "f19cd763dcec085b4625ffb0d17eb914e27226e3", "url": "https://github.com/elastic/elasticsearch/commit/f19cd763dcec085b4625ffb0d17eb914e27226e3", "message": "Merge branch 'master' into 2020-02-05-CompletionStatsCache", "committedDate": "2020-02-21T16:29:56Z", "type": "commit"}]}