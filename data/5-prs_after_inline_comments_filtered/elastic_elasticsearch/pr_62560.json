{"pr_number": 62560, "pr_title": "Use Globals Ords in Cardinality aggregation when it makes sense", "pr_createdAt": "2020-09-17T16:02:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62560", "timeline": [{"oid": "731befd08d2b6e90a3ed7138b42ac06d9be7105d", "url": "https://github.com/elastic/elasticsearch/commit/731befd08d2b6e90a3ed7138b42ac06d9be7105d", "message": "Use Globals Ords in Cardinality aggregation when it makes sense", "committedDate": "2020-09-17T15:58:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjMzOA==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490416338", "bodyText": "I know that building global ords is expensive. You pay the cost each time you need them and the index has been modified. Beyond that, I dunno if this is expensive.", "author": "nik9000", "createdAt": "2020-09-17T16:57:21Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/CardinalityAggregatorFactory.java", "diffHunk": "@@ -48,7 +49,28 @@\n     }\n \n     public static void registerAggregators(ValuesSourceRegistry.Builder builder) {\n-        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY, CoreValuesSourceType.ALL_CORE, CardinalityAggregator::new, true);\n+        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY,\n+            CoreValuesSourceType.ALL_CORE,\n+            (name, valuesSourceConfig, precision, context, parent, metadata) -> {\n+                // super hacky but it shows the point of the approach\n+                if (valuesSourceConfig.hasValues()) {\n+                    ValuesSource valuesSource = valuesSourceConfig.getValuesSource();\n+                    if (valuesSource instanceof ValuesSource.Bytes.WithOrdinals) {\n+                        ValuesSource.Bytes.WithOrdinals source = (ValuesSource.Bytes.WithOrdinals) valuesSource;\n+                        // is this call expensive? I hope not\n+                        final long maxOrd = source.globalMaxOrd(context.searcher());", "originalCommit": "731befd08d2b6e90a3ed7138b42ac06d9be7105d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUwMjgxMA==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490502810", "bodyText": "My understanding is that this call is generally cheap if the global ords are built (e.g. getting the max ord is a cheap operation).  But this will trigger rebuilding ords if the segments have changed and can then be very expensive :)\nDoes Lucene have a cheap way to get the total number of terms for a field?  Even though that doesn't factor in deleted docs or any filtering, perhaps that'd be sufficient heuristic?", "author": "polyfractal", "createdAt": "2020-09-17T19:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxODQyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490818421", "bodyText": "I don't think we want to trigger rebuilding ords if we are not going to use them", "author": "iverase", "createdAt": "2020-09-18T09:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgzMDE5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490830197", "bodyText": "Yes we had the same problem in the terms aggregation but users can set the mode to map to avoid loading the global ordinals.\n\nDoes Lucene have a cheap way to get the total number of terms for a field? Even though that doesn't factor in deleted docs or any filtering, perhaps that'd be sufficient heuristic?\n\nLucene provides the number of different terms in SortedSetDocValues but that's a per-segment view. The global view is provided by global ordinals but they can be costly to compute. The cardinality in each segment could be enough for the heuristic though, you can take the max or the sum and avoid loading the global ordinal until you have some hints that it might save some significant memory ?", "author": "jimczi", "createdAt": "2020-09-18T09:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgzNzAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490837012", "bodyText": "Yes, probably we need some heuristics considering as well the ratio of number of docs / number of different terms as it will give us an idea if there is many repeated values?", "author": "iverase", "createdAt": "2020-09-18T09:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490417191", "bodyText": "I think a more \"normal\" way to do this is to pull all of these into the aggregator itself and return a \"small\" Collector.", "author": "nik9000", "createdAt": "2020-09-17T16:58:44Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.FixedBitSet;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private final OrdinalsCollector collector;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = new HyperLogLogPlusPlusSparse(precision, context.bigArrays(), maxOrd, 1);\n+        this.collector = new OrdinalsCollector(counts, context.bigArrays(), maxOrd);\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        collector.postCollect();\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);\n+    }\n+\n+    private static class OrdinalsCollector extends LeafBucketCollector implements Releasable {\n+\n+        private final BigArrays bigArrays;\n+        private SortedSetDocValues values;\n+        private final int maxOrd;\n+        private final HyperLogLogPlusPlusSparse counts;\n+        private ObjectArray<FixedBitSet> visitedOrds;  // Danger! This is not tracked by BigArrays!", "originalCommit": "731befd08d2b6e90a3ed7138b42ac06d9be7105d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MjI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490482281", "bodyText": "Can you use a BitArray instead ?  I am afraid that this strategy might be counter productive if the parent aggregation creates lots of buckets ? It's no different than the normal execution but if we don't track the memory we'd only  rely on  the real-memory circuit breaker. Maybe the strategy could be adapted depending on the parent ?", "author": "jimczi", "createdAt": "2020-09-17T18:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc3MzI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490773298", "bodyText": "@jimczi I open #62600 to address it", "author": "iverase", "createdAt": "2020-09-18T08:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxOTg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490419841", "bodyText": "It can be quite large if the incoming cardinality is high and the cardinality of the field we're measuring is low. We have that problem in the implementation we have today though. I mean, like, say you have date_hist(hours) -> terms(high_cardinality) -> cardinality(average value around 2 or something). In that case we'll allocate the whole bit map for every incoming ord, only to set one or two bits.", "author": "nik9000", "createdAt": "2020-09-17T17:03:01Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/CardinalityAggregatorFactory.java", "diffHunk": "@@ -48,7 +49,28 @@\n     }\n \n     public static void registerAggregators(ValuesSourceRegistry.Builder builder) {\n-        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY, CoreValuesSourceType.ALL_CORE, CardinalityAggregator::new, true);\n+        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY,\n+            CoreValuesSourceType.ALL_CORE,\n+            (name, valuesSourceConfig, precision, context, parent, metadata) -> {\n+                // super hacky but it shows the point of the approach\n+                if (valuesSourceConfig.hasValues()) {\n+                    ValuesSource valuesSource = valuesSourceConfig.getValuesSource();\n+                    if (valuesSource instanceof ValuesSource.Bytes.WithOrdinals) {\n+                        ValuesSource.Bytes.WithOrdinals source = (ValuesSource.Bytes.WithOrdinals) valuesSource;\n+                        // is this call expensive? I hope not\n+                        final long maxOrd = source.globalMaxOrd(context.searcher());\n+                        final long countsMemoryUsage = HyperLogLogPlusPlus.memoryUsage(precision);\n+                        final long ordinalsMemoryUsage = maxOrd * 4;\n+                        // better heuristic? Currently we pay the price of the bitSet but it should be small\n+                        if (ordinalsMemoryUsage < countsMemoryUsage) {", "originalCommit": "731befd08d2b6e90a3ed7138b42ac06d9be7105d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fde41b13e0d72d221a8a36b589341704acf4ac82", "url": "https://github.com/elastic/elasticsearch/commit/fde41b13e0d72d221a8a36b589341704acf4ac82", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator", "committedDate": "2020-09-18T11:31:38Z", "type": "commit"}, {"oid": "9221d5bc5976b5e5cf109dc8022405044497fe82", "url": "https://github.com/elastic/elasticsearch/commit/9221d5bc5976b5e5cf109dc8022405044497fe82", "message": "address review comments", "committedDate": "2020-09-18T11:56:03Z", "type": "commit"}, {"oid": "d06005f056dc3f45224e69447788e02c845b9864", "url": "https://github.com/elastic/elasticsearch/commit/d06005f056dc3f45224e69447788e02c845b9864", "message": "Change the way we storage hashes in HyperLogLogPlusPlusSparse so we can have variable length arrays!", "committedDate": "2020-09-18T14:12:00Z", "type": "commit"}, {"oid": "6191f818d842b7c32e923ddb748c76f5fa2307fb", "url": "https://github.com/elastic/elasticsearch/commit/6191f818d842b7c32e923ddb748c76f5fa2307fb", "message": "iter", "committedDate": "2020-09-18T16:35:31Z", "type": "commit"}, {"oid": "32c9ce30bd728b6f2e9d938e39262731ab253d64", "url": "https://github.com/elastic/elasticsearch/commit/32c9ce30bd728b6f2e9d938e39262731ab253d64", "message": "iter", "committedDate": "2020-09-19T10:21:23Z", "type": "commit"}, {"oid": "b26d9637e6c71483386b19bfa8137d0e7977d338", "url": "https://github.com/elastic/elasticsearch/commit/b26d9637e6c71483386b19bfa8137d0e7977d338", "message": "iter", "committedDate": "2020-09-20T06:34:02Z", "type": "commit"}, {"oid": "70f2f44cf2b6bddc40d5db2046cc168102b4b904", "url": "https://github.com/elastic/elasticsearch/commit/70f2f44cf2b6bddc40d5db2046cc168102b4b904", "message": "use final", "committedDate": "2020-09-20T06:48:11Z", "type": "commit"}, {"oid": "e9a0b2696aa4db26837225747da77dbf816f5a53", "url": "https://github.com/elastic/elasticsearch/commit/e9a0b2696aa4db26837225747da77dbf816f5a53", "message": "make sure we release counts", "committedDate": "2020-09-20T07:12:01Z", "type": "commit"}, {"oid": "b70c625996e59e23ad3335744f5d44094ffc90fd", "url": "https://github.com/elastic/elasticsearch/commit/b70c625996e59e23ad3335744f5d44094ffc90fd", "message": "release collector early", "committedDate": "2020-09-20T07:19:13Z", "type": "commit"}, {"oid": "76db2514ba01c648aa7e916ceaa50a356a70acc2", "url": "https://github.com/elastic/elasticsearch/commit/76db2514ba01c648aa7e916ceaa50a356a70acc2", "message": "fix npe", "committedDate": "2020-09-20T08:06:29Z", "type": "commit"}, {"oid": "b59d13a5ba11d320d5bb2774b3b3639c07089091", "url": "https://github.com/elastic/elasticsearch/commit/b59d13a5ba11d320d5bb2774b3b3639c07089091", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator", "committedDate": "2020-09-20T09:02:51Z", "type": "commit"}, {"oid": "595afd6500f7d911e09c93e689d722f156e7f6ff", "url": "https://github.com/elastic/elasticsearch/commit/595afd6500f7d911e09c93e689d722f156e7f6ff", "message": "Don't leak CircuitBreaker on construction", "committedDate": "2020-09-21T09:13:50Z", "type": "commit"}, {"oid": "3389f230b5682019309ed7bb64a9d0465e58dc44", "url": "https://github.com/elastic/elasticsearch/commit/3389f230b5682019309ed7bb64a9d0465e58dc44", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator", "committedDate": "2020-09-21T13:45:03Z", "type": "commit"}, {"oid": "6125508d92bf4b9754f5cd22c1fb291b7f86662b", "url": "https://github.com/elastic/elasticsearch/commit/6125508d92bf4b9754f5cd22c1fb291b7f86662b", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator", "committedDate": "2020-09-22T10:34:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3NTYwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493575605", "bodyText": "We don't need these at all. We'll get the information that this is the global ords-based aggregator by default in the debug info. If we want anything here is might be debug insight into the sparse hll++ data structure.", "author": "nik9000", "createdAt": "2020-09-23T13:16:21Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private OrdinalsCollector collector;\n+\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = null;\n+        this.collector = new OrdinalsCollector(context.bigArrays(), maxOrd);\n+        this.precision = precision;\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, collector.bigArrays, collector.visitedOrds.size());\n+        collector.postCollect(counts);\n+        collector.close();\n+        collector = null;\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts == null ? 0 : counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (counts == null || owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 1);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);", "originalCommit": "6125508d92bf4b9754f5cd22c1fb291b7f86662b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU5MzQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493593459", "bodyText": "I think I saw some errors if I don't do this. I will double check.", "author": "iverase", "createdAt": "2020-09-23T13:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3NTYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU5Njg2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493596863", "bodyText": "That probably comes from a test I just added. We can totally change it.", "author": "nik9000", "createdAt": "2020-09-23T13:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3NTYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2OTE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r495769149", "bodyText": "I changed the test and remove it.", "author": "iverase", "createdAt": "2020-09-28T08:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3NTYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3OTU3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493579572", "bodyText": "I'm not generally a fan of ObjectArray just because it means we're allocating something per bucket. It makes sense here though. Probably worth talking about.\nI wonder if it'd be worth having two storage mechanisms here - a list of longs and transitioning into a BitArray. BitArray would take up a bunch of space if all you are doing is recording a hand full of big longs. But maybe this isn't really worth our time. This is already fairly complex to have these two collection mechanisms.", "author": "nik9000", "createdAt": "2020-09-23T13:20:30Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private OrdinalsCollector collector;\n+\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = null;\n+        this.collector = new OrdinalsCollector(context.bigArrays(), maxOrd);\n+        this.precision = precision;\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, collector.bigArrays, collector.visitedOrds.size());\n+        collector.postCollect(counts);\n+        collector.close();\n+        collector = null;\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts == null ? 0 : counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (counts == null || owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 1);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);\n+    }\n+\n+    private static class OrdinalsCollector extends LeafBucketCollector implements Releasable {\n+\n+        private final BigArrays bigArrays;\n+        private SortedSetDocValues values;\n+        private final int maxOrd;\n+        private ObjectArray<BitArray> visitedOrds;", "originalCommit": "6125508d92bf4b9754f5cd22c1fb291b7f86662b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3MTkwMw==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r495771903", "bodyText": "I don't think they would be tremendously big. In theory the biggest array would be at precisions 18, where BitArray can be up to ~11KB. In most cases it BitArray will be much smaller so not sure if it is worthy.", "author": "iverase", "createdAt": "2020-09-28T08:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3OTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA5MTI5NA==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r496091294", "bodyText": "Yeah. Almost certainly not worth it now.", "author": "nik9000", "createdAt": "2020-09-28T16:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3OTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493581359", "bodyText": "I wonder if we need a second class here - maybe all of these members should just go into the top level class?", "author": "nik9000", "createdAt": "2020-09-23T13:22:13Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private OrdinalsCollector collector;\n+\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = null;\n+        this.collector = new OrdinalsCollector(context.bigArrays(), maxOrd);\n+        this.precision = precision;\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, collector.bigArrays, collector.visitedOrds.size());\n+        collector.postCollect(counts);\n+        collector.close();\n+        collector = null;\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts == null ? 0 : counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (counts == null || owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 1);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);\n+    }\n+\n+    private static class OrdinalsCollector extends LeafBucketCollector implements Releasable {", "originalCommit": "6125508d92bf4b9754f5cd22c1fb291b7f86662b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU5NTU4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493595583", "bodyText": "+1", "author": "iverase", "createdAt": "2020-09-23T13:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3MjM0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r495772349", "bodyText": "I have tried and I am not convince we should create that layer.", "author": "iverase", "createdAt": "2020-09-28T08:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxNjMzMg==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r499616332", "bodyText": "I was suggesting we remove this layer. Is that what you tried and found wasn't worth it?", "author": "nik9000", "createdAt": "2020-10-05T13:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3ODQxMw==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r499678413", "bodyText": "I tried to create a base class for the cardinality aggregators and move collectors to that layer, but because the flow on the ordinals collector is different to the standard collector, it gives more issues than solve them.", "author": "iverase", "createdAt": "2020-10-05T15:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3ODU0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r499778547", "bodyText": "Oh! I was just thinking that the members on this class could just be moved to the outer class and that we could return a super simple collector like we do for most aggs. Is that worth it, do you think?", "author": "nik9000", "createdAt": "2020-10-05T18:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2ODY0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r500768648", "bodyText": "Ooops, I understand, I did the change, it makes sense.", "author": "iverase", "createdAt": "2020-10-07T06:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ=="}], "type": "inlineReview"}, {"oid": "f6fa137074f1e5b3df15e389cc6480ae711d2718", "url": "https://github.com/elastic/elasticsearch/commit/f6fa137074f1e5b3df15e389cc6480ae711d2718", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator", "committedDate": "2020-09-25T13:22:52Z", "type": "commit"}, {"oid": "e4dba1b3311677ee605dd6bf08635703293b2165", "url": "https://github.com/elastic/elasticsearch/commit/e4dba1b3311677ee605dd6bf08635703293b2165", "message": "Change yml test so it does not fail", "committedDate": "2020-09-25T13:40:54Z", "type": "commit"}, {"oid": "183b2378df06879467bae6c56c88b415a897f11f", "url": "https://github.com/elastic/elasticsearch/commit/183b2378df06879467bae6c56c88b415a897f11f", "message": "remove unused import", "committedDate": "2020-09-25T13:51:30Z", "type": "commit"}, {"oid": "e57075183339b5dc5d8709035f800b75218a597c", "url": "https://github.com/elastic/elasticsearch/commit/e57075183339b5dc5d8709035f800b75218a597c", "message": "Move collector to the class", "committedDate": "2020-10-07T05:51:03Z", "type": "commit"}, {"oid": "87630396be05709bb05321cdb6505dc42079d8bc", "url": "https://github.com/elastic/elasticsearch/commit/87630396be05709bb05321cdb6505dc42079d8bc", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator", "committedDate": "2020-10-07T05:52:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1NDYyNg==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r501154626", "bodyText": "Could you move the final stuff above the non-final stuff? It makes it just a little easier for me to read.", "author": "nik9000", "createdAt": "2020-10-07T16:37:00Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private final BigArrays bigArrays;", "originalCommit": "87630396be05709bb05321cdb6505dc42079d8bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1NjE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r501156157", "bodyText": "I think we cold free allVisitedOrds here. Do you think it'd be worth shifting the method around so LongArray hashes is the outer most try?", "author": "nik9000", "createdAt": "2020-10-07T16:39:26Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private final BigArrays bigArrays;\n+    private SortedSetDocValues values;\n+    private final int maxOrd;\n+    private ObjectArray<BitArray> visitedOrds;\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.precision = precision;\n+        this.maxOrd = maxOrd;\n+        this.bigArrays = context.bigArrays();\n+        this.visitedOrds = bigArrays.newObjectArray(1);\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        values = valuesSource.globalOrdinalsValues(ctx);\n+        return new LeafBucketCollector() {\n+            @Override\n+            public void collect(int doc, long bucketOrd) throws IOException {\n+                visitedOrds = bigArrays.grow(visitedOrds, bucketOrd + 1);\n+                BitArray bits = visitedOrds.get(bucketOrd);\n+                if (bits == null) {\n+                    bits = new BitArray(maxOrd, bigArrays);\n+                    visitedOrds.set(bucketOrd, bits);\n+                }\n+                if (values.advanceExact(doc)) {\n+                    for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n+                        bits.set((int) ord);\n+                    }\n+                }\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, bigArrays, visitedOrds.size());\n+        try (BitArray allVisitedOrds = new BitArray(maxOrd, bigArrays)) {\n+            for (long bucket = visitedOrds.size() - 1; bucket >= 0; --bucket) {\n+                final BitArray bits = visitedOrds.get(bucket);\n+                if (bits != null) {\n+                    allVisitedOrds.or(bits);\n+                }\n+            }\n+\n+            try (LongArray hashes = bigArrays.newLongArray(maxOrd, false)) {\n+                final MurmurHash3.Hash128 hash = new MurmurHash3.Hash128();\n+                for (long ord = allVisitedOrds.nextSetBit(0); ord < Long.MAX_VALUE;\n+                     ord = ord + 1 < maxOrd ? allVisitedOrds.nextSetBit(ord + 1) : Long.MAX_VALUE) {\n+                    final BytesRef value = values.lookupOrd(ord);\n+                    MurmurHash3.hash128(value.bytes, value.offset, value.length, 0, hash);\n+                    hashes.set(ord, hash.h1);\n+                }\n+                for (long bucket = visitedOrds.size() - 1; bucket >= 0; --bucket) {", "originalCommit": "87630396be05709bb05321cdb6505dc42079d8bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb3598f1f7db45cf9301e2d85d0bfdca30048b05", "url": "https://github.com/elastic/elasticsearch/commit/eb3598f1f7db45cf9301e2d85d0bfdca30048b05", "message": "address review comments", "committedDate": "2020-10-08T12:26:06Z", "type": "commit"}, {"oid": "38f85a50ebe0d79b636efd0c9866dfe154d34644", "url": "https://github.com/elastic/elasticsearch/commit/38f85a50ebe0d79b636efd0c9866dfe154d34644", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator", "committedDate": "2020-10-08T13:46:23Z", "type": "commit"}, {"oid": "39157c288be5d44b7ced84f059aaf1fc78f5da08", "url": "https://github.com/elastic/elasticsearch/commit/39157c288be5d44b7ced84f059aaf1fc78f5da08", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator\n\n# Conflicts:\n#\tserver/src/main/java/org/elasticsearch/search/aggregations/metrics/CardinalityAggregatorFactory.java", "committedDate": "2020-10-13T06:16:10Z", "type": "commit"}]}