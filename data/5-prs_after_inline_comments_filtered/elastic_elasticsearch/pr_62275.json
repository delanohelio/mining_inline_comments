{"pr_number": 62275, "pr_title": "Make some Allocation Decider Code a Little More JIT Aware", "pr_createdAt": "2020-09-11T20:56:34Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62275", "timeline": [{"oid": "e53fbf0afadf1c28d3c0839e6eff7b58585bc4b1", "url": "https://github.com/elastic/elasticsearch/commit/e53fbf0afadf1c28d3c0839e6eff7b58585bc4b1", "message": "much nicer", "committedDate": "2020-09-11T20:18:05Z", "type": "commit"}, {"oid": "ad98bd5c5d4c7d16de416fa4b79a0a6cb6b24421", "url": "https://github.com/elastic/elasticsearch/commit/ad98bd5c5d4c7d16de416fa4b79a0a6cb6b24421", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff", "committedDate": "2020-09-13T19:47:01Z", "type": "commit"}, {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "url": "https://github.com/elastic/elasticsearch/commit/99019b353fa4bc462a92a5b1cdc1b834c469319b", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff", "committedDate": "2020-09-14T08:09:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNDE0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487824142", "bodyText": "Is there a reason we cannot just always return NO_UNASSIGNED_PRIMARIES? Looks like we can avoid the dependency on debug in this method.", "author": "henningandersen", "createdAt": "2020-09-14T10:55:38Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,53 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final boolean debug = allocation.debugDecision();\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return debug ? NO_UNASSIGNED_PRIMARIES : Decision.NO;", "originalCommit": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNDQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487904409", "bodyText": "++ that works as far as I can tell", "author": "original-brownbear", "createdAt": "2020-09-14T13:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNDE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNTM4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487825381", "bodyText": "Add\n// fall-through\nto signal that fall through is intended.", "author": "henningandersen", "createdAt": "2020-09-14T10:58:07Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,53 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final boolean debug = allocation.debugDecision();\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return debug ? NO_UNASSIGNED_PRIMARIES : Decision.NO;\n+                }\n+                // check if there are initializing primaries that don't have a relocatingNodeId entry.\n+                if (routingNodes.hasInactivePrimaries()) {\n+                    return debug ? NO_INACTIVE_PRIMARIES : Decision.NO;\n+                }\n+                return debug ? YES_ALL_PRIMARIES_ACTIVE : Decision.YES;\n+            case INDICES_ALL_ACTIVE:\n+                // check if there are unassigned shards.\n+                if (routingNodes.hasUnassignedShards()) {\n+                    return debug ? NO_UNASSIGNED_SHARDS : Decision.NO;\n+                }\n+                // in case all indices are assigned, are there initializing shards which\n+                // are not relocating?\n+                if (routingNodes.hasInactiveShards()) {\n+                    return debug ? NO_INACTIVE_SHARDS : Decision.NO;\n+                }\n         }", "originalCommit": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNTcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487825727", "bodyText": "I wonder if this fits better into the switch now in a default block?", "author": "henningandersen", "createdAt": "2020-09-14T10:58:46Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,53 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final boolean debug = allocation.debugDecision();\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return debug ? NO_UNASSIGNED_PRIMARIES : Decision.NO;\n+                }\n+                // check if there are initializing primaries that don't have a relocatingNodeId entry.\n+                if (routingNodes.hasInactivePrimaries()) {\n+                    return debug ? NO_INACTIVE_PRIMARIES : Decision.NO;\n+                }\n+                return debug ? YES_ALL_PRIMARIES_ACTIVE : Decision.YES;\n+            case INDICES_ALL_ACTIVE:\n+                // check if there are unassigned shards.\n+                if (routingNodes.hasUnassignedShards()) {\n+                    return debug ? NO_UNASSIGNED_SHARDS : Decision.NO;\n+                }\n+                // in case all indices are assigned, are there initializing shards which\n+                // are not relocating?\n+                if (routingNodes.hasInactiveShards()) {\n+                    return debug ? NO_INACTIVE_SHARDS : Decision.NO;\n+                }\n         }\n-        // type == Type.ALWAYS\n-        return allocation.decision(Decision.YES, NAME, \"all shards are active\");\n+        // all shards active from above or type == Type.ALWAYS", "originalCommit": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwODIzMg==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487908232", "bodyText": "++", "author": "original-brownbear", "createdAt": "2020-09-14T13:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTI3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487851271", "bodyText": "Rather than inline the debug flag switch, would it be possible to use a supplier-style (perhaps a function, depending on input) just like is done for logging? So that it would be either:\nallocation.decision(Decision.NO, NAME, \"......[%d]...[%s]\", a -> a.args(maxRetry, unassignedInfo.toString()))\n\nor\nallocation.decision(Decision.NO, NAME, res -> debugDecision(res, unassignedInfo, numFailedAllcations, maxRetry))", "author": "henningandersen", "createdAt": "2020-09-14T11:49:52Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/MaxRetryAllocationDecider.java", "diffHunk": "@@ -41,27 +41,36 @@\n \n     public static final String NAME = \"max_retry\";\n \n+    private static final Decision YES_NO_FAILURES = Decision.single(Decision.Type.YES, NAME, \"shard has no previous failures\");\n+\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n         final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();\n         final Decision decision;\n-        if (unassignedInfo != null && unassignedInfo.getNumFailedAllocations() > 0) {\n+        final boolean debug = allocation.debugDecision();\n+        final int numFailedAllocations = unassignedInfo == null ? 0 : unassignedInfo.getNumFailedAllocations();\n+        if (numFailedAllocations > 0) {\n             final IndexMetadata indexMetadata = allocation.metadata().getIndexSafe(shardRouting.index());\n             final int maxRetry = SETTING_ALLOCATION_MAX_RETRY.get(indexMetadata.getSettings());\n-            if (unassignedInfo.getNumFailedAllocations() >= maxRetry) {\n-                decision = allocation.decision(Decision.NO, NAME, \"shard has exceeded the maximum number of retries [%d] on \" +\n-                    \"failed allocation attempts - manually call [/_cluster/reroute?retry_failed=true] to retry, [%s]\",\n-                    maxRetry, unassignedInfo.toString());\n-            } else {\n-                decision = allocation.decision(Decision.YES, NAME, \"shard has failed allocating [%d] times but [%d] retries are allowed\",\n-                    unassignedInfo.getNumFailedAllocations(), maxRetry);\n-            }\n+            final Decision res = numFailedAllocations >= maxRetry ? Decision.NO : Decision.YES;\n+            decision = debug ? debugDecision(res, unassignedInfo, numFailedAllocations, maxRetry) : res;", "originalCommit": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzk1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487907959", "bodyText": "I guess technically yes, but it looks a lot more complicated and won't inline as well. I mean even for logging we often use\ne.g. if (logger.isTraceEnabled()) {because the suppliers aren't free as well (especially when they capture a bunch of vars?).", "author": "original-brownbear", "createdAt": "2020-09-14T13:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTc0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487851742", "bodyText": "I wonder if it was just as good (or better) to just extract the non-happy path here out into a method of its own?", "author": "henningandersen", "createdAt": "2020-09-14T11:50:44Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/MaxRetryAllocationDecider.java", "diffHunk": "@@ -41,27 +41,36 @@\n \n     public static final String NAME = \"max_retry\";\n \n+    private static final Decision YES_NO_FAILURES = Decision.single(Decision.Type.YES, NAME, \"shard has no previous failures\");\n+\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n         final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();\n         final Decision decision;\n-        if (unassignedInfo != null && unassignedInfo.getNumFailedAllocations() > 0) {\n+        final boolean debug = allocation.debugDecision();\n+        final int numFailedAllocations = unassignedInfo == null ? 0 : unassignedInfo.getNumFailedAllocations();\n+        if (numFailedAllocations > 0) {\n             final IndexMetadata indexMetadata = allocation.metadata().getIndexSafe(shardRouting.index());", "originalCommit": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMzkzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487903931", "bodyText": "Sure why not, certainly fits in with the theme of this PR :)", "author": "original-brownbear", "createdAt": "2020-09-14T13:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MjA3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487852075", "bodyText": "I am not sure we need to switch on debug for purely constant decisions?", "author": "henningandersen", "createdAt": "2020-09-14T11:51:24Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/MaxRetryAllocationDecider.java", "diffHunk": "@@ -41,27 +41,36 @@\n \n     public static final String NAME = \"max_retry\";\n \n+    private static final Decision YES_NO_FAILURES = Decision.single(Decision.Type.YES, NAME, \"shard has no previous failures\");\n+\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n         final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();\n         final Decision decision;\n-        if (unassignedInfo != null && unassignedInfo.getNumFailedAllocations() > 0) {\n+        final boolean debug = allocation.debugDecision();\n+        final int numFailedAllocations = unassignedInfo == null ? 0 : unassignedInfo.getNumFailedAllocations();\n+        if (numFailedAllocations > 0) {\n             final IndexMetadata indexMetadata = allocation.metadata().getIndexSafe(shardRouting.index());\n             final int maxRetry = SETTING_ALLOCATION_MAX_RETRY.get(indexMetadata.getSettings());\n-            if (unassignedInfo.getNumFailedAllocations() >= maxRetry) {\n-                decision = allocation.decision(Decision.NO, NAME, \"shard has exceeded the maximum number of retries [%d] on \" +\n-                    \"failed allocation attempts - manually call [/_cluster/reroute?retry_failed=true] to retry, [%s]\",\n-                    maxRetry, unassignedInfo.toString());\n-            } else {\n-                decision = allocation.decision(Decision.YES, NAME, \"shard has failed allocating [%d] times but [%d] retries are allowed\",\n-                    unassignedInfo.getNumFailedAllocations(), maxRetry);\n-            }\n+            final Decision res = numFailedAllocations >= maxRetry ? Decision.NO : Decision.YES;\n+            decision = debug ? debugDecision(res, unassignedInfo, numFailedAllocations, maxRetry) : res;\n         } else {\n-            decision = allocation.decision(Decision.YES, NAME, \"shard has no previous failures\");\n+            decision = debug ? YES_NO_FAILURES : Decision.YES;", "originalCommit": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTQ2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487901466", "bodyText": "I looked into this and I think no we don't, we seem to only be using the full explanation in the explain allocation request -> will adjust accordingly", "author": "original-brownbear", "createdAt": "2020-09-14T13:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MjA3NQ=="}], "type": "inlineReview"}, {"oid": "6e772a0327072fff62e7fb11b212d18b86b0b7db", "url": "https://github.com/elastic/elasticsearch/commit/6e772a0327072fff62e7fb11b212d18b86b0b7db", "message": "CR comments", "committedDate": "2020-09-14T13:25:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1Nzk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r490957989", "bodyText": "I think it would be nice to add Decision.constant that still uses Decision.Single but avoids the trap of being able to specify parameters (or eagerly resolves the string if anyone do specify them).", "author": "henningandersen", "createdAt": "2020-09-18T13:42:47Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,55 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");", "originalCommit": "6e772a0327072fff62e7fb11b212d18b86b0b7db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNDM4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r491014386", "bodyText": "Actually, I'm starting to wonder how much point there even is in making the String creation in the existing Decision.single lazy? The memory savings probably aren't that massive they only affect debug anyway?", "author": "original-brownbear", "createdAt": "2020-09-18T15:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1Nzk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMjAyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r491032025", "bodyText": "++, seems just resolving this early is not a big deal. It will resolve it anyway in both equals, hashCode and streaming write.", "author": "henningandersen", "createdAt": "2020-09-18T15:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1Nzk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA0NzE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r491047152", "bodyText": "Perfect :) Made it eager serialize now, also makes the Decision object immutable in general :)", "author": "original-brownbear", "createdAt": "2020-09-18T16:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1Nzk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1OTU1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r490959557", "bodyText": "Maybe remove this variable that it is only used once?", "author": "henningandersen", "createdAt": "2020-09-18T13:45:07Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/SameShardAllocationDecider.java", "diffHunk": "@@ -75,6 +78,7 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n             return decision;\n         }\n         if (node.node() != null) {\n+            final boolean debug = allocation.debugDecision();", "originalCommit": "6e772a0327072fff62e7fb11b212d18b86b0b7db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNDQ2NA==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r491014464", "bodyText": "++", "author": "original-brownbear", "createdAt": "2020-09-18T15:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1OTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjIwNA==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r490972204", "bodyText": "In AllocationDeciders we choose to early terminate no decisions, but only if the object is Decision.NO. I think we need to change that to check the underlying type if we return constants here.", "author": "henningandersen", "createdAt": "2020-09-18T14:04:04Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,55 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    @SuppressWarnings(\"fallthrough\")\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return NO_UNASSIGNED_PRIMARIES;", "originalCommit": "6e772a0327072fff62e7fb11b212d18b86b0b7db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA0NzU0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r491047549", "bodyText": "Fixed by checking decision type :) thanks for spotting this!", "author": "original-brownbear", "createdAt": "2020-09-18T16:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzODU0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515038542", "bodyText": "I wonder if we can add a test that the early termination works in AllocationDeciders? At least one specific test with one specific example if making something that randomly exercises all decider NO decisions is too complicated.", "author": "henningandersen", "createdAt": "2020-10-30T11:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjIwNA=="}], "type": "inlineReview"}, {"oid": "7ef2fc712f9e7328df723d766aba14a5a8db5179", "url": "https://github.com/elastic/elasticsearch/commit/7ef2fc712f9e7328df723d766aba14a5a8db5179", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff", "committedDate": "2020-09-18T15:03:03Z", "type": "commit"}, {"oid": "1f811c81d764fb9f916ae48dd144367cf6c1de75", "url": "https://github.com/elastic/elasticsearch/commit/1f811c81d764fb9f916ae48dd144367cf6c1de75", "message": "remove redundant var + improve no check", "committedDate": "2020-09-18T15:39:02Z", "type": "commit"}, {"oid": "6bd66082f5121ca32025b2fd465b8064a0daa804", "url": "https://github.com/elastic/elasticsearch/commit/6bd66082f5121ca32025b2fd465b8064a0daa804", "message": "no more layy explain string", "committedDate": "2020-09-18T16:01:10Z", "type": "commit"}, {"oid": "8a59791711df64248ce2d2dc153fc5ab2d98479a", "url": "https://github.com/elastic/elasticsearch/commit/8a59791711df64248ce2d2dc153fc5ab2d98479a", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff", "committedDate": "2020-10-29T08:57:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzNTY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515035661", "bodyText": "Is there a reason for not using [%s] for the settings key?", "author": "henningandersen", "createdAt": "2020-10-30T11:35:58Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AwarenessAllocationDecider.java", "diffHunk": "@@ -185,18 +188,31 @@ private Decision underCapacity(ShardRouting shardRouting, RoutingNode node, Rout\n             final int currentNodeCount = shardPerAttribute.get(node.node().getAttributes().get(awarenessAttribute));\n             final int maximumNodeCount = (shardCount + numberOfAttributes - 1) / numberOfAttributes; // ceil(shardCount/numberOfAttributes)\n             if (currentNodeCount > maximumNodeCount) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"there are too many copies of the shard allocated to nodes with attribute [%s], there are [%d] total configured \" +\n-                        \"shard copies for this shard id and [%d] total attribute values, expected the allocated shard count per \" +\n-                        \"attribute [%d] to be less than or equal to the upper bound of the required number of shards per attribute [%d]\",\n-                        awarenessAttribute,\n-                        shardCount,\n-                        numberOfAttributes,\n-                        currentNodeCount,\n-                        maximumNodeCount);\n+                return debug ? debugNoTooManyCopies(shardCount, awarenessAttribute, numberOfAttributes, currentNodeCount, maximumNodeCount)\n+                        : Decision.NO;\n             }\n         }\n \n-        return allocation.decision(Decision.YES, NAME, \"node meets all awareness attribute requirements\");\n+        return YES_ALL_MET;\n+    }\n+\n+    private static Decision debugNoTooManyCopies(int shardCount, String awarenessAttribute, int numberOfAttributes, int currentNodeCount,\n+                                                 int maximumNodeCount) {\n+        return Decision.single(Decision.Type.NO, NAME,\n+                \"there are too many copies of the shard allocated to nodes with attribute [%s], there are [%d] total configured \" +\n+                        \"shard copies for this shard id and [%d] total attribute values, expected the allocated shard count per \" +\n+                        \"attribute [%d] to be less than or equal to the upper bound of the required number of shards per attribute [%d]\",\n+                awarenessAttribute,\n+                shardCount,\n+                numberOfAttributes,\n+                currentNodeCount,\n+                maximumNodeCount);\n+    }\n+\n+    private static Decision debugNoMissingAttribute(String awarenessAttribute, List<String> awarenessAttributes) {\n+        return Decision.single(Decision.Type.NO, NAME,\n+                \"node does not contain the awareness attribute [%s]; required attributes cluster setting [\"\n+                        + CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING.getKey() + \"=%s]\", awarenessAttribute,", "originalCommit": "8a59791711df64248ce2d2dc153fc5ab2d98479a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4NDc1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515084752", "bodyText": "I figured if we're already optimizing, why not just make this compile to one string constant instead of a constant format replacement", "author": "original-brownbear", "createdAt": "2020-10-30T13:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzNTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEzOTkyOA==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515139928", "bodyText": "Sure, it just seems odd to have both forms (string concatenation and replacement) in the very same line?", "author": "henningandersen", "createdAt": "2020-10-30T14:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzNTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0NDg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515144844", "bodyText": "Hmm replacement with a constant seems odd as well to me as well :) But I just realized that this is the debug path anyway, so I'm happy to change this back if you want.\nThat said, for better or for worse, we do have that pattern of mixing concatenation + replacement in a bunch of places for logging or for file name formatting in BlobstoreRepository for example?", "author": "original-brownbear", "createdAt": "2020-10-30T14:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzNTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1ODYxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515158611", "bodyText": "OK, leave it as is, I can certainly gladly accept it as is, was a small nit only.\n\ncompile to one string constant\n\nI think the getKey call prevents that? Though maybe the jit does something smart about this?", "author": "henningandersen", "createdAt": "2020-10-30T14:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzNTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NTc0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515195745", "bodyText": "I think the getKey call prevents that? Though maybe the jit does something smart about this?\n\nI would have thought the JIT can figure this out, but it took only a few minutes with JitWatch to learn that this is not the case. This initially compiles to:\n  private static org.elasticsearch.cluster.routing.allocation.decider.Decision debugNoMissingAttribute(java.lang.String, java.util.List<java.lang.String>);\n    Code:\n       0: getstatic     #236                // Field org/elasticsearch/cluster/routing/allocation/decider/Decision$Type.NO:Lorg/elasticsearch/cluster/routing/allocation/decider/Decision$Type;\n       3: ldc           #241                // String awareness\n       5: getstatic     #7                  // Field CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING:Lorg/elasticsearch/common/settings/Setting;\n       8: invokevirtual #257                // Method org/elasticsearch/common/settings/Setting.getKey:()Ljava/lang/String;\n      11: invokedynamic #259,  0            // InvokeDynamic #2:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;\n      16: iconst_2\n      17: anewarray     #245                // class java/lang/Object\n      20: dup\n      21: iconst_0\n      22: aload_0\n      23: aastore\n      24: dup\n      25: iconst_1\n      26: aload_1\n\nand all that happens is that the getKey call is eventually inlined but the string concatenation still happens every time.\n-> I'll revert this before merging in a bit :)", "author": "original-brownbear", "createdAt": "2020-10-30T15:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzNTY2MQ=="}], "type": "inlineReview"}, {"oid": "89bc2c68713dc0e91e4f253e36a58d60bd29c672", "url": "https://github.com/elastic/elasticsearch/commit/89bc2c68713dc0e91e4f253e36a58d60bd29c672", "message": "Merge branch 'master' of github.com:elastic/elasticsearch into fix-some-expensive-stuff", "committedDate": "2020-10-30T13:17:50Z", "type": "commit"}, {"oid": "7813daf82880f4b1964fa3093a1976d5348fddb9", "url": "https://github.com/elastic/elasticsearch/commit/7813daf82880f4b1964fa3093a1976d5348fddb9", "message": "CR: add test for short-circuit", "committedDate": "2020-10-30T14:30:00Z", "type": "commit"}, {"oid": "765850c3bed6fbdb7e8848de96f6046570b9d126", "url": "https://github.com/elastic/elasticsearch/commit/765850c3bed6fbdb7e8848de96f6046570b9d126", "message": "replace all the way", "committedDate": "2020-10-30T16:10:08Z", "type": "commit"}]}