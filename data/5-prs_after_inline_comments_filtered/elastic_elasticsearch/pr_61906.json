{"pr_number": 61906, "pr_title": "Determine shard size before allocating shards recovering from snapshots", "pr_createdAt": "2020-09-03T12:45:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61906", "timeline": [{"oid": "1268d7aaa5d28a182afb552613f688a23b079985", "url": "https://github.com/elastic/elasticsearch/commit/1268d7aaa5d28a182afb552613f688a23b079985", "message": "Determine shard size before searchable snapshot shard allocation", "committedDate": "2020-09-07T10:17:35Z", "type": "forcePushed"}, {"oid": "99d2a2806285e590af136f7d8937d1afc93a27b5", "url": "https://github.com/elastic/elasticsearch/commit/99d2a2806285e590af136f7d8937d1afc93a27b5", "message": "Determine shard size before searchable snapshot shard allocation", "committedDate": "2020-09-07T12:41:37Z", "type": "forcePushed"}, {"oid": "4a999820dc192645bc8c024648343bcddc48fca6", "url": "https://github.com/elastic/elasticsearch/commit/4a999820dc192645bc8c024648343bcddc48fca6", "message": "Determine shard size before searchable snapshot shard allocation", "committedDate": "2020-09-07T15:27:58Z", "type": "commit"}, {"oid": "311d08f2b348911002873c328c9901cadc298aa5", "url": "https://github.com/elastic/elasticsearch/commit/311d08f2b348911002873c328c9901cadc298aa5", "message": "Add test for restore case", "committedDate": "2020-09-07T15:27:58Z", "type": "commit"}, {"oid": "311d08f2b348911002873c328c9901cadc298aa5", "url": "https://github.com/elastic/elasticsearch/commit/311d08f2b348911002873c328c9901cadc298aa5", "message": "Add test for restore case", "committedDate": "2020-09-07T15:27:58Z", "type": "forcePushed"}, {"oid": "232cc2e3764b5b13f15320e2441da78094c4ba82", "url": "https://github.com/elastic/elasticsearch/commit/232cc2e3764b5b13f15320e2441da78094c4ba82", "message": "more  test fixes  + CCR integration", "committedDate": "2020-09-08T09:32:30Z", "type": "commit"}, {"oid": "e6a9a4717961129f8c5676727a87187552e312d7", "url": "https://github.com/elastic/elasticsearch/commit/e6a9a4717961129f8c5676727a87187552e312d7", "message": "checkstyle", "committedDate": "2020-09-08T11:18:18Z", "type": "commit"}, {"oid": "f0c48e691cc50566a8267fe0fc13f2404d8d4d92", "url": "https://github.com/elastic/elasticsearch/commit/f0c48e691cc50566a8267fe0fc13f2404d8d4d92", "message": "Merge remote-tracking branch 'elastic/master' into snapshot-size-based-allocation", "committedDate": "2020-09-08T11:19:02Z", "type": "commit"}, {"oid": "c596dac2b8e18068772118b07e6fe8b5da91a8ff", "url": "https://github.com/elastic/elasticsearch/commit/c596dac2b8e18068772118b07e6fe8b5da91a8ff", "message": "checkstyle", "committedDate": "2020-09-08T19:16:51Z", "type": "commit"}, {"oid": "7fc0052540cb493e6921ec6dfd20cab7d0e04f00", "url": "https://github.com/elastic/elasticsearch/commit/7fc0052540cb493e6921ec6dfd20cab7d0e04f00", "message": "chasdada", "committedDate": "2020-09-09T07:40:14Z", "type": "commit"}, {"oid": "5e64f308895ac9bfb2f33e5d30701b59cf3eb3cb", "url": "https://github.com/elastic/elasticsearch/commit/5e64f308895ac9bfb2f33e5d30701b59cf3eb3cb", "message": "Merge remote-tracking branch 'elastic/master' into snapshot-size-based-allocation", "committedDate": "2020-09-09T08:50:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MDg0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r485450843", "bodyText": "I'm not sure which thread-pool to use here. SNAPSHOT wasn't great because I feared allocation could be delayed by long-running backups. ASYNC_FETCH thread pool could turn out to be problematic as it might interfere with recoveries of local primaries (although that threadpool is generously sized).", "author": "ywelsch", "createdAt": "2020-09-09T08:56:25Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesServiceSupplier;\n+    private final Supplier<RerouteService> rerouteServiceSupplier;\n+\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> snapshotShardSizes;\n+\n+    private final Set<SnapshotShard> fetchingShards = Sets.newConcurrentHashSet();\n+\n+    public InternalSnapshotsInfoService(ThreadPool threadPool, Supplier<RepositoriesService> repositoriesServiceSupplier,\n+                                        Supplier<RerouteService> rerouteServiceSupplier) {\n+        this.threadPool = threadPool;\n+        this.repositoriesServiceSupplier = repositoriesServiceSupplier;\n+        this.rerouteServiceSupplier = rerouteServiceSupplier;\n+        snapshotShardSizes = ImmutableOpenMap.of();\n+    }\n+\n+    public static class SnapshotShard {\n+\n+        private final Snapshot snapshot;\n+        private final IndexId index;\n+        private final int shardId;\n+\n+        public SnapshotShard(Snapshot snapshot, IndexId index, int shardId) {\n+            this.snapshot = snapshot;\n+            this.index = index;\n+            this.shardId = shardId;\n+        }\n+\n+        public Snapshot getSnapshot() {\n+            return snapshot;\n+        }\n+\n+        public IndexId getIndex() {\n+            return index;\n+        }\n+\n+        public int getShardId() {\n+            return shardId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SnapshotShard that = (SnapshotShard) o;\n+            return shardId == that.shardId &&\n+                snapshot.equals(that.snapshot) &&\n+                index.equals(that.index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(snapshot, index, shardId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SnapshotShard{\" +\n+                \"snapshot=\" + snapshot +\n+                \", index=\" + index +\n+                \", shardId=\" + shardId +\n+                '}';\n+        }\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(snapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> requiredSnapshotShards = new HashSet<>();\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.id());\n+                    requiredSnapshotShards.add(snapshotShard);\n+                    // check if already populated entry\n+                    if (snapshotShardSizes.get(snapshotShard) == null) {\n+                        // check if already fetching snapshot info in progress\n+                        if (fetchingShards.add(snapshotShard)) {\n+                            // TODO: Use a dedicated threadpool here? Use FETCH thread pool?\n+                            threadPool.generic().execute(new AbstractRunnable() {", "originalCommit": "5e64f308895ac9bfb2f33e5d30701b59cf3eb3cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzMDQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r495930498", "bodyText": "I agree with not using the SNAPSHOT thread pool here. I think we should reuse FETCH_SHARD_STORE or add a new one.", "author": "tlrx", "createdAt": "2020-09-28T13:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MDg0Mw=="}], "type": "inlineReview"}, {"oid": "7dda136a6f4c6aa3696be30be4d196d31fb5c352", "url": "https://github.com/elastic/elasticsearch/commit/7dda136a6f4c6aa3696be30be4d196d31fb5c352", "message": "Merge branch 'master' into snapshot-size-based-allocation", "committedDate": "2020-09-28T10:56:09Z", "type": "commit"}, {"oid": "ef544ce81231bb5d36ae883e8c2135fb99bd9f9b", "url": "https://github.com/elastic/elasticsearch/commit/ef544ce81231bb5d36ae883e8c2135fb99bd9f9b", "message": "Fix DataTierAllocationDeciderTests", "committedDate": "2020-09-28T11:07:38Z", "type": "commit"}, {"oid": "d1d805782b65f3d0e5376f0cb23ae3205a6b2bd9", "url": "https://github.com/elastic/elasticsearch/commit/d1d805782b65f3d0e5376f0cb23ae3205a6b2bd9", "message": "Apply some feedback and cosmetics", "committedDate": "2020-09-28T13:36:40Z", "type": "commit"}, {"oid": "cb6daa1f9262d2b11f68ee18775db67c074b7da7", "url": "https://github.com/elastic/elasticsearch/commit/cb6daa1f9262d2b11f68ee18775db67c074b7da7", "message": "Fix imports", "committedDate": "2020-09-28T14:50:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2MzUwMg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r496863502", "bodyText": "On failures, every reroute will trigger another round of fetch of shard size(s) and lead to more warning logs. And in the meantime, the cluster is yellow due to ClusterShardHealth.getInactivePrimaryHealth.\nIn particular if this happens together with the bursts described below, it could be a burdensome load on the master node?", "author": "henningandersen", "createdAt": "2020-09-29T16:14:37Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesServiceSupplier;\n+    private final Supplier<RerouteService> rerouteServiceSupplier;\n+\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> snapshotShardSizes;\n+\n+    private final Set<SnapshotShard> fetchingShards = Sets.newConcurrentHashSet();\n+\n+    public InternalSnapshotsInfoService(ThreadPool threadPool, Supplier<RepositoriesService> repositoriesServiceSupplier,\n+                                        Supplier<RerouteService> rerouteServiceSupplier) {\n+        this.threadPool = threadPool;\n+        this.repositoriesServiceSupplier = repositoriesServiceSupplier;\n+        this.rerouteServiceSupplier = rerouteServiceSupplier;\n+        snapshotShardSizes = ImmutableOpenMap.of();\n+    }\n+\n+    public static class SnapshotShard {\n+\n+        private final Snapshot snapshot;\n+        private final IndexId index;\n+        private final int shardId;\n+\n+        public SnapshotShard(Snapshot snapshot, IndexId index, int shardId) {\n+            this.snapshot = snapshot;\n+            this.index = index;\n+            this.shardId = shardId;\n+        }\n+\n+        public Snapshot getSnapshot() {\n+            return snapshot;\n+        }\n+\n+        public IndexId getIndex() {\n+            return index;\n+        }\n+\n+        public int getShardId() {\n+            return shardId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            final SnapshotShard that = (SnapshotShard) o;\n+            return shardId == that.shardId\n+                && snapshot.equals(that.snapshot)\n+                && index.equals(that.index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(snapshot, index, shardId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SnapshotShard{\" +\n+                \"snapshot=\" + snapshot +\n+                \", index=\" + index +\n+                \", shardId=\" + shardId +\n+                '}';\n+        }\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(snapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> requiredSnapshotShards = new HashSet<>();\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.id());\n+                    requiredSnapshotShards.add(snapshotShard);\n+                    // check if already populated entry\n+                    if (snapshotShardSizes.get(snapshotShard) == null) {\n+                        // check if already fetching snapshot info in progress\n+                        if (fetchingShards.add(snapshotShard)) {\n+                            // TODO: Use a dedicated threadpool here? Use FETCH thread pool?\n+                            threadPool.generic().execute(new AbstractRunnable() {\n+                                @Override\n+                                public void onFailure(Exception e) {\n+                                    logger.warn(new ParameterizedMessage(\"failed to retrieve shard size information for {}\",", "originalCommit": "cb6daa1f9262d2b11f68ee18775db67c074b7da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MDYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r496880617", "bodyText": "I think this will lead to a burst of many requests to the blob store to get the shard size whenever a node holding searchable snapshots fails or is restarted.\nThis could block the generic thread pool for a while, potentially causing other issues. Similarly if moving to the FETCH_SHARD_STORE pool it might interfere with recoveries of primaries.\nGeneric pool has minimum 128 threads, which does mean a decent amount of parallel fetching from blobstore, but going for other pools would likely lower this considerably.\nIt also feels like a bad spot in our allocation to have a dependency on an external blob store, in particular if it responds very slowly for odd reasons. Once persistent cache is in place, we should be able to recover on our own without accessing the blob store.", "author": "henningandersen", "createdAt": "2020-09-29T16:33:51Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesServiceSupplier;\n+    private final Supplier<RerouteService> rerouteServiceSupplier;\n+\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> snapshotShardSizes;\n+\n+    private final Set<SnapshotShard> fetchingShards = Sets.newConcurrentHashSet();\n+\n+    public InternalSnapshotsInfoService(ThreadPool threadPool, Supplier<RepositoriesService> repositoriesServiceSupplier,\n+                                        Supplier<RerouteService> rerouteServiceSupplier) {\n+        this.threadPool = threadPool;\n+        this.repositoriesServiceSupplier = repositoriesServiceSupplier;\n+        this.rerouteServiceSupplier = rerouteServiceSupplier;\n+        snapshotShardSizes = ImmutableOpenMap.of();\n+    }\n+\n+    public static class SnapshotShard {\n+\n+        private final Snapshot snapshot;\n+        private final IndexId index;\n+        private final int shardId;\n+\n+        public SnapshotShard(Snapshot snapshot, IndexId index, int shardId) {\n+            this.snapshot = snapshot;\n+            this.index = index;\n+            this.shardId = shardId;\n+        }\n+\n+        public Snapshot getSnapshot() {\n+            return snapshot;\n+        }\n+\n+        public IndexId getIndex() {\n+            return index;\n+        }\n+\n+        public int getShardId() {\n+            return shardId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            final SnapshotShard that = (SnapshotShard) o;\n+            return shardId == that.shardId\n+                && snapshot.equals(that.snapshot)\n+                && index.equals(that.index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(snapshot, index, shardId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SnapshotShard{\" +\n+                \"snapshot=\" + snapshot +\n+                \", index=\" + index +\n+                \", shardId=\" + shardId +\n+                '}';\n+        }\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(snapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> requiredSnapshotShards = new HashSet<>();\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.id());\n+                    requiredSnapshotShards.add(snapshotShard);\n+                    // check if already populated entry\n+                    if (snapshotShardSizes.get(snapshotShard) == null) {\n+                        // check if already fetching snapshot info in progress\n+                        if (fetchingShards.add(snapshotShard)) {\n+                            // TODO: Use a dedicated threadpool here? Use FETCH thread pool?\n+                            threadPool.generic().execute(new AbstractRunnable() {\n+                                @Override\n+                                public void onFailure(Exception e) {\n+                                    logger.warn(new ParameterizedMessage(\"failed to retrieve shard size information for {}\",\n+                                        shardRouting), e);\n+                                }\n+\n+                                @Override\n+                                protected void doRun() {\n+                                    final RepositoriesService repositories = repositoriesServiceSupplier.get();\n+                                    assert repositories != null;\n+                                    final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+                                    final IndexShardSnapshotStatus status =\n+                                        repository.getShardSnapshotStatus(snapshotRecoverySource.snapshot().getSnapshotId(),", "originalCommit": "cb6daa1f9262d2b11f68ee18775db67c074b7da7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4MjA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r497482098", "bodyText": "++ we must limit the concurrency here. This isn't just about threads (though that's reason enough) but also about memory to some degree.  org.elasticsearch.repositories.blobstore.BlobStoreRepository#getShardSnapshotStatus might use a few MB per shard in memory because the underlying metadata file that is loaded from the blobstore is non-trivial in size (we essentially have the same requests in the _status APIs for snapshot status and don't parallelize them there either at least for now because we have to be careful about the concurrency).", "author": "original-brownbear", "createdAt": "2020-09-30T12:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MDYxNw=="}], "type": "inlineReview"}, {"oid": "8f5c2abdb1454b863fab860274ef1c201f9274ca", "url": "https://github.com/elastic/elasticsearch/commit/8f5c2abdb1454b863fab860274ef1c201f9274ca", "message": "Bound concurrent snapshot shard size retrievals", "committedDate": "2020-10-05T07:57:01Z", "type": "commit"}, {"oid": "f5ea5a9d9059598248ed25e0e383d3d242794269", "url": "https://github.com/elastic/elasticsearch/commit/f5ea5a9d9059598248ed25e0e383d3d242794269", "message": "Merge branch 'master' into snapshot-size-based-allocation", "committedDate": "2020-10-05T07:57:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxOTIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499419217", "bodyText": "This only need to be added on master nodes right? (relates #63223)", "author": "original-brownbear", "createdAt": "2020-10-05T08:15:38Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.AdjustableSemaphore;\n+import org.elasticsearch.common.util.concurrent.RunOnce;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private final AdjustableSemaphore semaphore;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.semaphore = new AdjustableSemaphore(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings), false);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        clusterService.addListener(this);", "originalCommit": "f5ea5a9d9059598248ed25e0e383d3d242794269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NDk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499454991", "bodyText": "Good catch, I pushed 6c59655#diff-555b04095ef512902f5b90599d4a8da1R101-R103", "author": "tlrx", "createdAt": "2020-10-05T09:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxOTIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyODE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499428159", "bodyText": "Do we really need a Semaphore here? Can't we just have these tasks increment a counter with incrementAndGet whenever we try to start one and if it's below the current limit + 1 we start a task? Then we only need to decrement the counter when we poll a null from the queue and it's all a lot easier isn't it?", "author": "original-brownbear", "createdAt": "2020-10-05T08:31:40Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.AdjustableSemaphore;\n+import org.elasticsearch.common.util.concurrent.RunOnce;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private final AdjustableSemaphore semaphore;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.semaphore = new AdjustableSemaphore(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings), false);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        clusterService.addListener(this);\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        semaphore.setMaxPermits(maxConcurrentFetches);\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, semaphore.getMaxPermits());\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        if (semaphore.tryAcquire()) {", "originalCommit": "f5ea5a9d9059598248ed25e0e383d3d242794269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTMzMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499455330", "bodyText": "Something like 6c59655?", "author": "tlrx", "createdAt": "2020-10-05T09:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyODE1OQ=="}], "type": "inlineReview"}, {"oid": "9aea78a9c829d69f0d01829127e3c07b36d66687", "url": "https://github.com/elastic/elasticsearch/commit/9aea78a9c829d69f0d01829127e3c07b36d66687", "message": "Revert", "committedDate": "2020-10-05T09:08:54Z", "type": "commit"}, {"oid": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "url": "https://github.com/elastic/elasticsearch/commit/6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "message": "apply feedback", "committedDate": "2020-10-05T09:15:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNzk5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499507993", "bodyText": "NIT: we could make this ActionListener just a static constant?", "author": "original-brownbear", "createdAt": "2020-10-05T10:48:04Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718274", "bodyText": "Sure, I pushed bfd352c", "author": "tlrx", "createdAt": "2020-10-05T16:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMDczOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499510739", "bodyText": "This method can just be inlined, we never overwrite it?", "author": "original-brownbear", "createdAt": "2020-10-05T10:53:46Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718303", "bodyText": "This is a left-over, I removed it in f9ed974", "author": "tlrx", "createdAt": "2020-10-05T16:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMDczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMzU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499513566", "bodyText": "Maybe extract these two lines into a method releaseFetcher or so and with a one liner describing what this does since we use this in two spots?", "author": "original-brownbear", "createdAt": "2020-10-05T10:59:05Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(\n+                                    r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+                                    e -> logger.debug(\"reroute after snapshot shard size update failed\", e)));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+                    }\n+\n+                    @Override\n+                    public void onAfter() {\n+                        unknownSnapshotShards.remove(snapshotShard);\n+                        fetchNextSnapshotShard();\n+                    }\n+                });\n+                success = true;\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.warn(\"snapshot shard size fetcher has been interrupted\", e);\n+        } finally {\n+            if (success == false) {\n+                final int value = concurrentFetches.decrementAndGet();\n+                assert value >= 0 : \"Unexpected value: \" + value;", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxNjE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499516152", "bodyText": "Maybe just make this a one liner with the above since we never really use status otherwise:\n                        final long snapshotShardSize = repository.getShardSnapshotStatus(\n                                snapshotShard.snapshot().getSnapshotId(),\n                                snapshotShard.index(),\n                                snapshotShard.shardId()\n                        ).asCopy().getTotalSize();", "author": "original-brownbear", "createdAt": "2020-10-05T11:04:32Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718360", "bodyText": "Ok, I pushed 866ba36", "author": "tlrx", "createdAt": "2020-10-05T16:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxNjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxODEzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499518135", "bodyText": "NIT: Maybe just if (isMaster == false) ?", "author": "original-brownbear", "createdAt": "2020-10-05T11:08:36Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODQxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718410", "bodyText": "Done in 7343b63", "author": "tlrx", "createdAt": "2020-10-05T16:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxODEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMTc4MA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499521780", "bodyText": "Should we make sure to return the same size for the same shard consistently? (and maybe also assert that we are indeed dealing with a snapshot recovery routing here?)", "author": "original-brownbear", "createdAt": "2020-10-05T11:15:25Z", "path": "test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java", "diffHunk": "@@ -55,6 +58,14 @@\n     private static final ClusterSettings EMPTY_CLUSTER_SETTINGS =\n         new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n \n+    public static final SnapshotsInfoService SNAPSHOT_INFO_SERVICE_WITH_SHARD_SIZES = () ->\n+        new SnapshotShardSizeInfo(ImmutableOpenMap.of()) {\n+            @Override\n+            public Long getShardSize(ShardRouting shardRouting) {\n+                return randomNonNegativeLong();", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODQ0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718447", "bodyText": "I think that it is trappy to always return an random size here. Test that rely on snapshot shard information should use their own implementation. I pushed 28de2d6 to add an assertion as you suggested + throw an unsupported exception here.", "author": "tlrx", "createdAt": "2020-10-05T16:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMTc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNTE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499535167", "bodyText": "Isn't updated always true since we won't double schedule a job for a certain shard's size ever?", "author": "original-brownbear", "createdAt": "2020-10-05T11:41:08Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODQ4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718482", "bodyText": "Indeed - I added an assertion on this in 2faf525", "author": "tlrx", "createdAt": "2020-10-05T16:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNzE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499537167", "bodyText": "Should we assert that this returned true?", "author": "original-brownbear", "createdAt": "2020-10-05T11:44:53Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(\n+                                    r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+                                    e -> logger.debug(\"reroute after snapshot shard size update failed\", e)));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+                    }\n+\n+                    @Override\n+                    public void onAfter() {\n+                        unknownSnapshotShards.remove(snapshotShard);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718537", "bodyText": "I think we can -> a3dcb20", "author": "tlrx", "createdAt": "2020-10-05T16:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNzE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzOTY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499539673", "bodyText": "NIT: } else if (event.previousState().nodes().isLocalNodeElectedMaster()) { maybe so we don't execute this over and over?\nI also wonder if we even need to do this? Maybe we should instead just clean out unnecessary items in the map on event.routingTableChanged() if we're not master to not have to repopulate the map over and over in an unstable master situation where it might jump in and out of the cluster a few times (which would be really painful if we're dealing with a large number of shards)?", "author": "original-brownbear", "createdAt": "2020-10-05T11:49:26Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718571", "bodyText": "+1 on the previous state isLocalNodeElectedMaster() condition (ada6dd5).\nI added a //TODO for the other point you raise. I'm not sure we should do it but if we think we should I can do it in a follow up PR.", "author": "tlrx", "createdAt": "2020-10-05T16:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzOTY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540175", "bodyText": "NIT: space after null,", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:16Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -553,7 +551,7 @@ public void testClusterAndIndex() {\n                 .put(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE, \"data_warm,data_cold\")\n                 .build());\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540389", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:38Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -181,7 +183,7 @@ public void testIndexRequires() {\n                 .put(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE, \"data_hot\")\n                 .build());\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQyMg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540422", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:42Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -143,7 +145,7 @@ public void testClusterIncludes() {\n     public void testClusterExcludes() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQ0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540442", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:44Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -108,7 +110,7 @@ public void testClusterRequires() {\n     public void testClusterIncludes() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQ3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540471", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:48Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -74,7 +76,7 @@\n     public void testClusterRequires() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718651", "bodyText": "Spaces addressed in b942b2d (sorry)", "author": "tlrx", "createdAt": "2020-10-05T16:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499541123", "bodyText": "NIT: use org.elasticsearch.threadpool.ThreadPool#terminate(java.util.concurrent.ExecutorService, long, java.util.concurrent.TimeUnit) and assert it returns true?", "author": "original-brownbear", "createdAt": "2020-10-05T11:51:58Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        threadPool.shutdownNow();\n+        threadPool.awaitTermination(30L, TimeUnit.SECONDS);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718693", "bodyText": "Sure, see be18fad", "author": "tlrx", "createdAt": "2020-10-05T16:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0NDIzMg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499544232", "bodyText": "NIT: Could do this in one go with the utilities we have as (also avoid mixing our own concurrency primitives with the JDK's):\n        PlainActionFuture.get(future -> clusterService.getClusterApplierService().onNewClusterState(reason,\n                () -> applier.apply(clusterService.state()),\n                new ClusterApplier.ClusterApplyListener() {\n                    @Override\n                    public void onSuccess(String source) {\n                        future.onResponse(source);\n                    }\n\n                    @Override\n                    public void onFailure(String source, Exception e) {\n                        future.onFailure(e);\n                    }\n                }));", "author": "original-brownbear", "createdAt": "2020-10-05T11:57:40Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        threadPool.shutdownNow();\n+        threadPool.awaitTermination(30L, TimeUnit.SECONDS);\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+\n+        latch.countDown();\n+        waitForMaxActiveGenericThreads(0);\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+        verify(rerouteService, times(numberOfShards)).reroute(anyString(), any(Priority.class), any());\n+\n+        for (int i = 0; i < numberOfShards; i++) {\n+            final ShardRouting shardRouting = clusterService.state().routingTable().index(indexName).shard(i).primaryShard();\n+            assertThat(snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting), equalTo(expectedShardSizes[i]));\n+        }\n+    }\n+\n+    public void testErroneousSnapshotShardSizes() throws Exception {\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), randomIntBetween(1, 10))\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> succeed = Sets.newConcurrentHashSet();\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> failed = Sets.newConcurrentHashSet();\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    final InternalSnapshotsInfoService.SnapshotShard snapshotShard =\n+                        new InternalSnapshotsInfoService.SnapshotShard(new Snapshot(\"_repo\", snapshotId), indexId, shardId);\n+                    if (randomBoolean()) {\n+                        failed.add(snapshotShard);\n+                        throw new SnapshotException(snapshotShard.snapshot(), \"simulated\");\n+                    } else {\n+                        succeed.add(snapshotShard);\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                    }\n+                }\n+            });\n+\n+        final int maxShardsToCreate = scaledRandomIntBetween(10, 500);\n+        final Thread addSnapshotRestoreIndicesThread = new Thread(() -> {\n+            int remainingShards = maxShardsToCreate;\n+            while (remainingShards > 0) {\n+                final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+                final int numberOfShards = randomIntBetween(1, maxShardsToCreate);\n+                try {\n+                    applyClusterState(\"add-more-unassigned-shards-for-\" + indexName,\n+                        clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+                } catch (Exception e) {\n+                    throw new AssertionError(e);\n+                } finally {\n+                    remainingShards -= numberOfShards;\n+                }\n+            }\n+        });\n+        addSnapshotRestoreIndicesThread.start();\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(succeed.size()));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+\n+        addSnapshotRestoreIndicesThread.join();\n+    }\n+\n+    public void testNoLongerMaster() throws Exception {\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.EMPTY, clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                }\n+            });\n+\n+        for (int i = 0; i < randomIntBetween(1, 10); i++) {\n+            final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+            final int nbShards =  randomIntBetween(1, 5);\n+            applyClusterState(\"restore-indices-when-master-\" + indexName,\n+                clusterState -> addUnassignedShards(clusterState, indexName, nbShards));\n+        }\n+\n+        applyClusterState(\"demote-current-master\", this::demoteMasterNode);\n+\n+        for (int i = 0; i < randomIntBetween(1, 10); i++) {\n+            final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+            final int nbShards =  randomIntBetween(1, 5);\n+            applyClusterState(\"restore-indices-when-no-longer-master-\" + indexName,\n+                clusterState -> addUnassignedShards(clusterState, indexName, nbShards));\n+        }\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+    }\n+\n+    private void applyClusterState(final String reason, final Function<ClusterState, ClusterState> applier) throws Exception {\n+        final CompletableFuture<String> future = new CompletableFuture<>();\n+        clusterService.getClusterApplierService().onNewClusterState(reason,", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODc0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718746", "bodyText": "Indeed, thanks: 6dcff94", "author": "tlrx", "createdAt": "2020-10-05T16:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0NDIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MDY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499550651", "bodyText": "I think there is a race here, in that if all threads polled and found out that queue is empty but did not count down the counter yet, we could add to the queue here and risk that the increment results in a number higher than maxConcurrentFetches?", "author": "henningandersen", "createdAt": "2020-10-05T12:10:29Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3Mjc2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499572762", "bodyText": "Right sorry for missing that ... looking at this again, do we even have to be so tricky here? :) Maybe we should just sychronize fetchNextSnapshotShard and this block:\n            for (int i = 0; i < nbFetchers; i++) {\n                final int activeFetches = concurrentFetches.incrementAndGet();\n                if (activeFetches < maxConcurrentFetches + 1) {\n                    fetchNextSnapshotShard();\n                } else {\n                    final int value = concurrentFetches.decrementAndGet();\n                    assert value >= 0 : \"Unexpected value: \" + value;\n                }\n            }\non the same mutex (e.g.  on queue) and use a normal int for the in-progress count (no need to bother with the count-down here then as well, we can just call fetchNextSnapshotShard() however often we are allowed in a loop and just adjust the in-progress count once)?  That seems the simplest and least error prone since the performance of the locking is not relevant here anyway?", "author": "original-brownbear", "createdAt": "2020-10-05T12:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MDY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxOTcyMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499719720", "bodyText": "Following Armin's opinion for simplicity and usage of synchronized blocks I reworked the concurrency part in 674d6c9. I hope it makes things simpler but I must admit that I don't have clear ideas today so I'd appreciate more reviews there.", "author": "tlrx", "createdAt": "2020-10-05T16:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MDY1MQ=="}], "type": "inlineReview"}, {"oid": "bfd352c3757230037fee9344ff202f293ce648de", "url": "https://github.com/elastic/elasticsearch/commit/bfd352c3757230037fee9344ff202f293ce648de", "message": "listener as a constant", "committedDate": "2020-10-05T12:44:07Z", "type": "commit"}, {"oid": "f9ed97469d10f6d5473c56d351421ecdb54c5bbc", "url": "https://github.com/elastic/elasticsearch/commit/f9ed97469d10f6d5473c56d351421ecdb54c5bbc", "message": "remove left over", "committedDate": "2020-10-05T12:45:04Z", "type": "commit"}, {"oid": "866ba36c7ec8a02b7a2ca2e69b0f5c3826691541", "url": "https://github.com/elastic/elasticsearch/commit/866ba36c7ec8a02b7a2ca2e69b0f5c3826691541", "message": "inline snapshotShardSize", "committedDate": "2020-10-05T12:46:37Z", "type": "commit"}, {"oid": "7343b63aafb0b19510e0b4f7236628f4dd41aebf", "url": "https://github.com/elastic/elasticsearch/commit/7343b63aafb0b19510e0b4f7236628f4dd41aebf", "message": "isMaster == false", "committedDate": "2020-10-05T12:48:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499576714", "bodyText": "I think there is a race with unknownSnapshotShards. It does take something extreme but in this case I think we might not read one of the shard sizes:\n\nA cluster state change results in queuing a read for a shard.\nThe read happens and populates knownSnapshotShards, but the thread is halted before removing from unkonwnSnapshotShards.\nA cluster state change removes the need for the shard (deleted index?).\nA cluster state change reintroduces the need to read the shard sizes. This will not add to queue, since this line did not complete yet on the original read.\nThe fetch thread removes shard from unknownSnapshotShards", "author": "henningandersen", "createdAt": "2020-10-05T12:55:40Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(\n+                                    r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+                                    e -> logger.debug(\"reroute after snapshot shard size update failed\", e)));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+                    }\n+\n+                    @Override\n+                    public void onAfter() {\n+                        unknownSnapshotShards.remove(snapshotShard);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwOTY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499609674", "bodyText": "but the thread is halted before removing from\n\nThis is impossible for a running node isn't it? We don't ever kill/interrupt actively executing threads on the generic pool and then keep going with the node?\n(can you even halt a thread in such a way that this method which is called in a finally block isn't executed every time we run this Runnable?)", "author": "original-brownbear", "createdAt": "2020-10-05T13:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzOTk3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499639973", "bodyText": "I'm interested in Armin's questions answers, but besides this Henning raised a good point where the snapshot shard size should be removed from unknownSnapshotShards as soon as it is read, before it is added back to knownSnapshotShards", "author": "tlrx", "createdAt": "2020-10-05T14:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNzg1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499807859", "bodyText": "I should probably have used \"paused\" rather than \"halted\". The finally block does run, but steps 3 and 4 could go in before it runs. Thanks for addressing this.", "author": "henningandersen", "createdAt": "2020-10-05T19:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA=="}], "type": "inlineReview"}, {"oid": "28de2d67de1b28c7d3e29e46bda50e2bef38baa9", "url": "https://github.com/elastic/elasticsearch/commit/28de2d67de1b28c7d3e29e46bda50e2bef38baa9", "message": "add assert + throw UOE", "committedDate": "2020-10-05T13:40:29Z", "type": "commit"}, {"oid": "2faf52519a6d663559eacac5592a7cbe6a317f80", "url": "https://github.com/elastic/elasticsearch/commit/2faf52519a6d663559eacac5592a7cbe6a317f80", "message": "assert updated", "committedDate": "2020-10-05T13:45:24Z", "type": "commit"}, {"oid": "a3dcb20796c2dec4189289bd6a7e2fcc554bbf93", "url": "https://github.com/elastic/elasticsearch/commit/a3dcb20796c2dec4189289bd6a7e2fcc554bbf93", "message": "assert removed", "committedDate": "2020-10-05T13:47:12Z", "type": "commit"}, {"oid": "b942b2db21b646f910664c935f11e3919d329945", "url": "https://github.com/elastic/elasticsearch/commit/b942b2db21b646f910664c935f11e3919d329945", "message": "spaces", "committedDate": "2020-10-05T13:51:05Z", "type": "commit"}, {"oid": "be18fad0a34ae29242e2414d1f36f01d7d19c127", "url": "https://github.com/elastic/elasticsearch/commit/be18fad0a34ae29242e2414d1f36f01d7d19c127", "message": "terminate()", "committedDate": "2020-10-05T13:51:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU5MTU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499591541", "bodyText": "This is unused?", "author": "DaveCTurner", "createdAt": "2020-10-05T13:18:54Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "diffHunk": "@@ -150,6 +150,7 @@\n     private final SetOnce<BlobStoreCacheService> blobStoreCacheService = new SetOnce<>();\n     private final SetOnce<CacheService> cacheService = new SetOnce<>();\n     private final SetOnce<ThreadPool> threadPool = new SetOnce<>();\n+    private final SetOnce<ClusterService> clusterService = new SetOnce<>();", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718886", "bodyText": "It is, I removed it in ae5895c", "author": "tlrx", "createdAt": "2020-10-05T16:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU5MTU0MQ=="}], "type": "inlineReview"}, {"oid": "ada6dd50fd6c550822361263efe8e943bae6e13f", "url": "https://github.com/elastic/elasticsearch/commit/ada6dd50fd6c550822361263efe8e943bae6e13f", "message": "isLocalNodeElectedMaster + TODO", "committedDate": "2020-10-05T13:59:03Z", "type": "commit"}, {"oid": "ae5895ce811addbc5094133031dabec540882c02", "url": "https://github.com/elastic/elasticsearch/commit/ae5895ce811addbc5094133031dabec540882c02", "message": "Remove SetOnce<ClusterService>", "committedDate": "2020-10-05T14:03:01Z", "type": "commit"}, {"oid": "6dcff94a1e851651bf8c954f07276426cbedb970", "url": "https://github.com/elastic/elasticsearch/commit/6dcff94a1e851651bf8c954f07276426cbedb970", "message": "PlainActionFuture.get()", "committedDate": "2020-10-05T14:05:31Z", "type": "commit"}, {"oid": "674d6c9387d90f492eaf3d04bd573616b06d5327", "url": "https://github.com/elastic/elasticsearch/commit/674d6c9387d90f492eaf3d04bd573616b06d5327", "message": "another shot at concurrent fetches", "committedDate": "2020-10-05T16:13:57Z", "type": "commit"}, {"oid": "291831f02ced1131a8aecb2104f6ca89853ae69b", "url": "https://github.com/elastic/elasticsearch/commit/291831f02ced1131a8aecb2104f6ca89853ae69b", "message": "Merge branch 'master' into snapshot-size-based-allocation", "committedDate": "2020-10-05T18:51:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzQ2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499973462", "bodyText": "NIT: revert", "author": "original-brownbear", "createdAt": "2020-10-06T02:36:22Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterInfo.java", "diffHunk": "@@ -22,7 +22,6 @@\n import com.carrotsearch.hppc.ObjectHashSet;\n import com.carrotsearch.hppc.cursors.ObjectCursor;\n import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n-", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4NTg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500185889", "bodyText": "Done in 881f621", "author": "tlrx", "createdAt": "2020-10-06T11:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NTY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499975641", "bodyText": "We can save some code here now that we have the mutex and don't need a concurrent collection any longer?\ne.g.\ndiff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 43cd8cd11b1..a1917c3544b 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n@@ -46,13 +46,12 @@ import org.elasticsearch.repositories.Repository;\n import org.elasticsearch.threadpool.ThreadPool;\n \n import java.util.Collections;\n+import java.util.Deque;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.Objects;\n import java.util.Set;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n \n public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n@@ -81,7 +80,7 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n     private final Set<SnapshotShard> unknownSnapshotShards;\n \n     /** a blocking queue used for concurrent fetching **/\n-    private final BlockingQueue<SnapshotShard> queue;\n+    private final Deque<SnapshotShard> queue;\n \n     private volatile int maxConcurrentFetches;\n     private volatile int activeFetches;\n@@ -99,7 +98,7 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n         this.rerouteService = rerouteServiceSupplier;\n         this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n         this.unknownSnapshotShards  = new LinkedHashSet<>();\n-        this.queue = new LinkedBlockingQueue<>();\n+        this.queue = new LinkedList<>();\n         this.mutex = new Object();\n         this.activeFetches = 0;\n         this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n@@ -159,15 +158,10 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n     private void fetchNextSnapshotShard() {\n         synchronized (mutex) {\n             if (activeFetches < maxConcurrentFetches) {\n-                try {\n-                    final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n-                    if (snapshotShard != null) {\n-                        threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n-                        activeFetches += 1;\n-                    }\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    logger.warn(\"snapshot shard size fetcher has been interrupted\", e);\n+                final SnapshotShard snapshotShard = queue.pollFirst();\n+                if (snapshotShard != null) {\n+                    threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n+                    activeFetches += 1;\n                 }\n             }\n             assert assertNumberOfConcurrentFetches();", "author": "original-brownbear", "createdAt": "2020-10-06T02:45:24Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        synchronized (mutex) {\n+            if (activeFetches < maxConcurrentFetches) {\n+                try {\n+                    final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwOTk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500009972", "bodyText": "Can we just use poll() and make the queue declaration non blocking? That also removes the need for interrupt handling.", "author": "henningandersen", "createdAt": "2020-10-06T05:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4NTk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500185941", "bodyText": "Makes perfect sense, thanks for noticing this! I pushed 528a848", "author": "tlrx", "createdAt": "2020-10-06T11:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjEzOA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499976138", "bodyText": "This should now synchronise on the mutex as well shouldn't it?", "author": "original-brownbear", "createdAt": "2020-10-06T02:47:30Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        synchronized (mutex) {\n+            if (activeFetches < maxConcurrentFetches) {\n+                try {\n+                    final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+                    if (snapshotShard != null) {\n+                        threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n+                        activeFetches += 1;\n+                    }\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    logger.warn(\"snapshot shard size fetcher has been interrupted\", e);\n+                }\n+            }\n+            assert assertNumberOfConcurrentFetches();\n+        }\n+    }\n+\n+    private class FetchingSnapshotShardSizeRunnable extends AbstractRunnable {\n+\n+        private final SnapshotShard snapshotShard;\n+        private boolean removed;\n+\n+        FetchingSnapshotShardSizeRunnable(SnapshotShard snapshotShard) {\n+            super();\n+            this.snapshotShard = snapshotShard;\n+            this.removed = false;\n+        }\n+\n+        @Override\n+        protected void doRun() throws Exception {\n+            final RepositoriesService repositories = repositoriesService.get();\n+            assert repositories != null;\n+            final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+            logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+            final long snapshotShardSize = repository.getShardSnapshotStatus(\n+                snapshotShard.snapshot().getSnapshotId(),\n+                snapshotShard.index(),\n+                snapshotShard.shardId()\n+            ).asCopy().getTotalSize();\n+\n+            logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+            boolean updated = false;\n+            synchronized (mutex) {\n+                removed = unknownSnapshotShards.remove(snapshotShard);\n+                assert removed : \"snapshot shard to remove does not exist \" + snapshotShardSize;\n+                if (isMaster) {\n+                    final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                        ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                    updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                    assert updated : \"snapshot shard size already exists for \" + snapshotShard;\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+                activeFetches -= 1;\n+                assert assertNumberOfConcurrentFetches();\n+            }\n+            if (updated) {\n+                rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH, REROUTE_LISTENER);\n+            }\n+        }\n+\n+        @Override\n+        public void onFailure(Exception e) {\n+            logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+            synchronized (mutex) {\n+                if (removed == false) {\n+                    unknownSnapshotShards.remove(snapshotShard);\n+                }\n+                activeFetches -= 1;\n+                assert assertNumberOfConcurrentFetches();\n+            }\n+        }\n+\n+        @Override\n+        public void onAfter() {\n+            fetchNextSnapshotShard();\n+        }\n+    }\n+\n+    private void cleanUpKnownSnapshotShardSizes(Set<SnapshotShard> requiredSnapshotShards) {\n+        assert Thread.holdsLock(mutex);\n+        ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+        for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+            if (requiredSnapshotShards.contains(shard.value) == false) {\n+                if (newSnapshotShardSizes == null) {\n+                    newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                }\n+                newSnapshotShardSizes.remove(shard.value);\n+            }\n+        }\n+        if (newSnapshotShardSizes != null) {\n+            knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+        }\n+    }\n+\n+    private boolean assertNumberOfConcurrentFetches() {\n+        assert activeFetches >= 0 : \"active fetches should be greater than or equal to zero but got: \" + activeFetches;\n+        assert activeFetches <= maxConcurrentFetches : activeFetches + \" <= \" + maxConcurrentFetches;\n+        return true;\n+    }\n+\n+    // used in tests\n+    int numberOfUnknownSnapshotShardSizes() {\n+        return unknownSnapshotShards.size();", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4NTk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500185969", "bodyText": "Yes -> a777c12", "author": "tlrx", "createdAt": "2020-10-06T11:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499976816", "bodyText": "Should we also clear queue here?", "author": "original-brownbear", "createdAt": "2020-10-06T02:50:15Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODExNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188116", "bodyText": "Yes we should -> 4a716b0", "author": "tlrx", "createdAt": "2020-10-06T11:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAxMDUwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500010506", "bodyText": "AFAICS, this is now fully protected by mutex.", "author": "henningandersen", "createdAt": "2020-10-06T05:16:21Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODE5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188193", "bodyText": "Good catch: a8e7475", "author": "tlrx", "createdAt": "2020-10-06T11:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAxMDUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNzcwNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500027707", "bodyText": "This seems to assume that we only get here for unassigned shards, never for initializing shards. I have not found a smoking gun where we could get here in that case, but I would prefer to be more specific in the condition above to only go here for unassigned shards.", "author": "henningandersen", "createdAt": "2020-10-06T06:13:58Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java", "diffHunk": "@@ -482,6 +484,12 @@ public static long getExpectedShardSize(ShardRouting shard, long defaultValue, C\n             }\n             return targetShardSize == 0 ? defaultValue : targetShardSize;\n         } else {\n+            if (shard.active() == false\n+                && shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                final Long shardSize = snapshotShardSizeInfo.getShardSize(shard);\n+                assert shardSize != null : \"no shard size provided for \" + shard;", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODI4NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188284", "bodyText": "It seems reasonable indeed (0aaf829)", "author": "tlrx", "createdAt": "2020-10-06T11:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNzcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5Nzc2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500197762", "bodyText": "FWIW I think we don't get here for shards that are initialising from a snapshot today: the callers are canAllocate(), sizeOfRelocatingShards() and BalancedShardsAllocator#allocateUnassigned:\n\nBalancedShardsAllocator#allocateUnassigned only works with unassigned shards\nsizeOfRelocatingShards() only works with relocating shards (either source or target) which necessarily don't have recovery source SNAPSHOT,\ncanAllocate() only tries to allocate unassigned shards and shards that are fully started.\n\nI'm still +1 on this change.", "author": "DaveCTurner", "createdAt": "2020-10-06T11:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNzcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDAwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:30:47Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -104,7 +106,7 @@ private ClusterState createInitialClusterState(boolean startShards) {\n     public void testNonResizeRouting() {\n         ClusterState clusterState = createInitialClusterState(true);\n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:31:01Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -128,7 +130,7 @@ public void testShrink() { // we don't handle shrink yet\n         Index idx = clusterState.metadata().index(\"target\").getIndex();\n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDE4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:31:14Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -156,7 +158,7 @@ public void testSourceNotActive() {\n \n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDI3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034279", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:31:29Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -196,7 +198,7 @@ public void testSourcePrimaryActive() {\n \n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzODk4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500038983", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        null, null,0);\n          \n          \n            \n                        null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:43:03Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java", "diffHunk": "@@ -73,7 +75,7 @@ public void testFilterInitialRecovery() {\n \n         // after failing the shard we are unassigned since the node is blacklisted and we can't initialize on the other node\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTE0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        null, null,0);\n          \n          \n            \n                        null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:43:28Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java", "diffHunk": "@@ -124,7 +126,7 @@ public void testFilterInitialRecovery() {\n         assertEquals(routingTable.index(\"idx\").shard(0).primaryShard().currentNodeId(), \"node1\");\n \n         allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTI0MA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039240", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        clusterState.getRoutingNodes(), clusterState, null, null,0L);\n          \n          \n            \n                        clusterState.getRoutingNodes(), clusterState, null, null, 0L);", "author": "henningandersen", "createdAt": "2020-10-06T06:43:44Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java", "diffHunk": "@@ -193,7 +193,7 @@ private ClusterState createInitialClusterState() {\n     private Decision executeAllocation(final ClusterState clusterState, final ShardRouting shardRouting) {\n         final AllocationDecider decider = new RestoreInProgressAllocationDecider();\n         final RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n-            clusterState.getRoutingNodes(), clusterState, null, 0L);\n+            clusterState.getRoutingNodes(), clusterState, null, null,0L);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTQwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(),\"allocId\");\n          \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(), \"allocId\");", "author": "henningandersen", "createdAt": "2020-10-06T06:44:09Z", "path": "server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java", "diffHunk": "@@ -341,7 +343,7 @@ public void testFoundAllocationButNoDecider() {\n      * deciders say yes, we allocate to that node.\n      */\n     public void testRestore() {\n-        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), \"allocId\");\n+        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(),\"allocId\");", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTQ5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039495", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(),\"allocId\");\n          \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(), \"allocId\");", "author": "henningandersen", "createdAt": "2020-10-06T06:44:18Z", "path": "server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java", "diffHunk": "@@ -355,7 +357,7 @@ public void testRestore() {\n      * deciders say throttle, we add it to ignored shards.\n      */\n     public void testRestoreThrottle() {\n-        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), \"allocId\");\n+        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(),\"allocId\");", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODM4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188385", "bodyText": "Sorry for the noise, the reported spaces issues are addressed in 42ba44f", "author": "tlrx", "createdAt": "2020-10-06T11:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0MTM1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500041353", "bodyText": "I find this name confusing, since this service has no shard sizes? Should it be ...WITH_NO_SHARD_SIZES?", "author": "henningandersen", "createdAt": "2020-10-06T06:48:34Z", "path": "test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java", "diffHunk": "@@ -55,6 +59,16 @@\n     private static final ClusterSettings EMPTY_CLUSTER_SETTINGS =\n         new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n \n+    public static final SnapshotsInfoService SNAPSHOT_INFO_SERVICE_WITH_SHARD_SIZES = () ->", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188453", "bodyText": "Indeed -> 212c8e3", "author": "tlrx", "createdAt": "2020-10-06T11:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0MTM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0Njc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500046798", "bodyText": "I think we are missing a test for this.", "author": "henningandersen", "createdAt": "2020-10-06T06:59:58Z", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/repository/CcrRepository.java", "diffHunk": "@@ -429,8 +433,23 @@ void acquireRetentionLeaseOnLeader(\n     }\n \n     @Override\n-    public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId leaderShardId) {\n-        throw new UnsupportedOperationException(\"Unsupported for repository of type: \" + TYPE);\n+    public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId index, ShardId shardId) {", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzczMTc2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r503731764", "bodyText": "I opened #63590 for this.", "author": "tlrx", "createdAt": "2020-10-13T07:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0Njc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0ODc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500048775", "bodyText": "This change seems odd to me. I suppose the allocationDeciders are effectively unused, but in that case I would still prefer to pass down allocationDeciders.", "author": "henningandersen", "createdAt": "2020-10-06T07:04:18Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java", "diffHunk": "@@ -70,8 +70,8 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n     static int getPendingAllocations(Index index, AllocationDeciders allocationDeciders, ClusterState clusterState) {\n         // All the allocation attributes are already set so just need to check\n         // if the allocation has happened\n-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, clusterState.getRoutingNodes(), clusterState, null,\n-            System.nanoTime());\n+        RoutingAllocation allocation = new RoutingAllocation(ALLOCATION_DECIDERS, clusterState.getRoutingNodes(), clusterState, null,", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODY3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188672", "bodyText": "Thanks for catching this! It seems that git's merge algorithm did not report a conflict when I merged master back to this branch :(\nIt is fixed in 3dd593d", "author": "tlrx", "createdAt": "2020-10-06T11:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0ODc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA1OTg5NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500059894", "bodyText": "I would think that assertBusy is unnecessary here, given that we wait for generic thread pool to be unused?", "author": "henningandersen", "createdAt": "2020-10-06T07:26:41Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+\n+        latch.countDown();\n+        waitForMaxActiveGenericThreads(0);\n+\n+        assertBusy(() -> {", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTEzOA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189138", "bodyText": "I'd expect something like this too but ThreadPoolExecutor#getActiveCount() returns an approximate numbers of active threads. It works well when active threads are blocked but waiting for 0 does not make much sense here. I removed waitForMaxActiveGenericThreads(0) to only rely on the assertBusy() (39da087)", "author": "tlrx", "createdAt": "2020-10-06T11:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA1OTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NTc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500065782", "bodyText": "I think we risk these two assertions being OK if they run before any of the threads start adding anything? If that happens on most runs, the test does not verify anything.\nI wonder if it was good enough to just do this after the join below? Or keep it here but add it below the join too.", "author": "henningandersen", "createdAt": "2020-10-06T07:37:09Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+\n+        latch.countDown();\n+        waitForMaxActiveGenericThreads(0);\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+        verify(rerouteService, times(numberOfShards)).reroute(anyString(), any(Priority.class), any());\n+\n+        for (int i = 0; i < numberOfShards; i++) {\n+            final ShardRouting shardRouting = clusterService.state().routingTable().index(indexName).shard(i).primaryShard();\n+            assertThat(snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting), equalTo(expectedShardSizes[i]));\n+        }\n+    }\n+\n+    public void testErroneousSnapshotShardSizes() throws Exception {\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), randomIntBetween(1, 10))\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> succeed = Sets.newConcurrentHashSet();\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> failed = Sets.newConcurrentHashSet();\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    final InternalSnapshotsInfoService.SnapshotShard snapshotShard =\n+                        new InternalSnapshotsInfoService.SnapshotShard(new Snapshot(\"_repo\", snapshotId), indexId, shardId);\n+                    if (randomBoolean()) {\n+                        failed.add(snapshotShard);\n+                        throw new SnapshotException(snapshotShard.snapshot(), \"simulated\");\n+                    } else {\n+                        succeed.add(snapshotShard);\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                    }\n+                }\n+            });\n+\n+        final int maxShardsToCreate = scaledRandomIntBetween(10, 500);\n+        final Thread addSnapshotRestoreIndicesThread = new Thread(() -> {\n+            int remainingShards = maxShardsToCreate;\n+            while (remainingShards > 0) {\n+                final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+                final int numberOfShards = randomIntBetween(1, maxShardsToCreate);\n+                try {\n+                    applyClusterState(\"add-more-unassigned-shards-for-\" + indexName,\n+                        clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+                } catch (Exception e) {\n+                    throw new AssertionError(e);\n+                } finally {\n+                    remainingShards -= numberOfShards;\n+                }\n+            }\n+        });\n+        addSnapshotRestoreIndicesThread.start();\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(succeed.size()));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTIwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189201", "bodyText": "You're right, not sure why I moved this before the join.\n\nI wonder if it was good enough to just do this after the join below?\n\nDone in 3732dd2.", "author": "tlrx", "createdAt": "2020-10-06T11:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MDAwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500070006", "bodyText": "I suppose this is somewhat verified by the reroute count check below, but I would like to add a counter for how many times getShardSnapshotStatus was called too and verify that it is correct.", "author": "henningandersen", "createdAt": "2020-10-06T07:44:29Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTMxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189310", "bodyText": "Makes sense, added in ac45f17", "author": "tlrx", "createdAt": "2020-10-06T11:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MDAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MjU1OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500072558", "bodyText": "Can we add more shards (or just one) here to verify that the deduplication works? We can verify that there is nothing on the queue and at the end that we get the right amount of repo calls.", "author": "henningandersen", "createdAt": "2020-10-06T07:48:59Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTUyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189529", "bodyText": "I added 465c8fb that reapplies the last cluster state which should be enough I think\n(as the test verifies that there are no more unknown shard sizes and that the snapshot shard size have been fetched the right number of time).", "author": "tlrx", "createdAt": "2020-10-06T11:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MjU1OA=="}], "type": "inlineReview"}, {"oid": "881f6210a9e1dccba37497555a1a7fbb68f8b410", "url": "https://github.com/elastic/elasticsearch/commit/881f6210a9e1dccba37497555a1a7fbb68f8b410", "message": "revert extra line", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "url": "https://github.com/elastic/elasticsearch/commit/a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "message": "mutex for unknowns", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "528a8485fbf3501f0770c702c7693538e359115e", "url": "https://github.com/elastic/elasticsearch/commit/528a8485fbf3501f0770c702c7693538e359115e", "message": "non blocking queue", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "4a716b02cce940402831cb20fdd6155d5badbd18", "url": "https://github.com/elastic/elasticsearch/commit/4a716b02cce940402831cb20fdd6155d5badbd18", "message": "clear queue", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "a8e7475afc25dc2877012ae195f30418e5437f61", "url": "https://github.com/elastic/elasticsearch/commit/a8e7475afc25dc2877012ae195f30418e5437f61", "message": "activeFetches", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "0aaf829e30b0c3a0c869843650f866357731d6d7", "url": "https://github.com/elastic/elasticsearch/commit/0aaf829e30b0c3a0c869843650f866357731d6d7", "message": "check unassigned", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "42ba44f71085aed68965e1f74a26ab30f2f10723", "url": "https://github.com/elastic/elasticsearch/commit/42ba44f71085aed68965e1f74a26ab30f2f10723", "message": "spaces", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "212c8e397dd9fac63587f6c39e12317c624c6667", "url": "https://github.com/elastic/elasticsearch/commit/212c8e397dd9fac63587f6c39e12317c624c6667", "message": "SNAPSHOT_INFO_SERVICE_WITH_NO_SHARD_SIZES", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "3dd593d203c328882683e2febcd7dbd37cc0f62b", "url": "https://github.com/elastic/elasticsearch/commit/3dd593d203c328882683e2febcd7dbd37cc0f62b", "message": "allocationDeciders", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "39da08724cd8cecdb4338a6daccce374971a6e16", "url": "https://github.com/elastic/elasticsearch/commit/39da08724cd8cecdb4338a6daccce374971a6e16", "message": "remove wait for zero active threads", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "3732dd28962b074c1c0ec9ac48e7534e5d4d3b08", "url": "https://github.com/elastic/elasticsearch/commit/3732dd28962b074c1c0ec9ac48e7534e5d4d3b08", "message": "move assertBusy()", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "ac45f178bbd0b3907c6e2dc2d9feac1de90cfd61", "url": "https://github.com/elastic/elasticsearch/commit/ac45f178bbd0b3907c6e2dc2d9feac1de90cfd61", "message": "getShardSnapshotStatusCount", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "465c8fb893c6af46757c40c17354cd8f50bb12dd", "url": "https://github.com/elastic/elasticsearch/commit/465c8fb893c6af46757c40c17354cd8f50bb12dd", "message": "check deduplication", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "59ab20c3c3a450f4233753c131d62938bc602daa", "url": "https://github.com/elastic/elasticsearch/commit/59ab20c3c3a450f4233753c131d62938bc602daa", "message": "SnapshotResiliencyTests", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIzMTQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500231461", "bodyText": "I think this needs to be done before spawning the task: we assert that this is \u22650 elsewhere but that assertion will fail if it's decremented by the completion of the runnable before it's incremented here.", "author": "DaveCTurner", "createdAt": "2020-10-06T12:23:26Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final Queue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedList<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+                final Iterator<SnapshotShard> iterator = queue.iterator();\n+                while (iterator.hasNext()) {\n+                    final SnapshotShard snapshotShard = iterator.next();\n+                    final boolean removed = unknownSnapshotShards.remove(snapshotShard);\n+                    assert removed : \"snapshot shard to remove does not exist \" + snapshotShard;\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        synchronized (mutex) {\n+            if (activeFetches < maxConcurrentFetches) {\n+                final SnapshotShard snapshotShard = queue.poll();\n+                if (snapshotShard != null) {\n+                    threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n+                    activeFetches += 1;", "originalCommit": "59ab20c3c3a450f4233753c131d62938bc602daa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIzNTk2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500235967", "bodyText": "Why not drain the queue using .poll() until it's empty?", "author": "DaveCTurner", "createdAt": "2020-10-06T12:30:32Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final Queue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedList<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+                final Iterator<SnapshotShard> iterator = queue.iterator();", "originalCommit": "59ab20c3c3a450f4233753c131d62938bc602daa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIzODkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500238901", "bodyText": "can we assert something about the state if neither of the previous if blocks matched (so this node isn't/wasn't just the master): isMaster == false, queue and unknownSnapshotShards and knownSnapshotShardSizes are all empty, ...", "author": "DaveCTurner", "createdAt": "2020-10-06T12:35:17Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final Queue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedList<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+                final Iterator<SnapshotShard> iterator = queue.iterator();\n+                while (iterator.hasNext()) {\n+                    final SnapshotShard snapshotShard = iterator.next();\n+                    final boolean removed = unknownSnapshotShards.remove(snapshotShard);\n+                    assert removed : \"snapshot shard to remove does not exist \" + snapshotShard;\n+                    iterator.remove();\n+                }\n+            }\n+        }", "originalCommit": "59ab20c3c3a450f4233753c131d62938bc602daa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0d9917489f22a731cd69ba33311dca9e9134aee1", "url": "https://github.com/elastic/elasticsearch/commit/0d9917489f22a731cd69ba33311dca9e9134aee1", "message": "handle snapshot shard size failures", "committedDate": "2020-10-06T13:53:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM4MDE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500380141", "bodyText": "I think we should also remove this in cleanUpKnownSnapshotShardSizes to avoid this eventually potentially leading to a memory issue. We can do this in a follow-up too, no need to hold merging this PR.", "author": "henningandersen", "createdAt": "2020-10-06T15:17:43Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -132,6 +142,7 @@ public void clusterChanged(ClusterChangedEvent event) {\n                     if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n                         // check if already fetching snapshot info in progress\n                         if (unknownSnapshotShards.add(snapshotShard)) {\n+                            failedSnapshotShards.remove(snapshotShard); // retry the failed shard", "originalCommit": "0d9917489f22a731cd69ba33311dca9e9134aee1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzYxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r501763610", "bodyText": "I opened #63492 to address this", "author": "tlrx", "createdAt": "2020-10-08T14:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM4MDE0MQ=="}], "type": "inlineReview"}]}