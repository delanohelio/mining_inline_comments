{"pr_number": 52822, "pr_title": "Implement Cancellable DirectoryReader", "pr_createdAt": "2020-02-26T15:01:43Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52822", "timeline": [{"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "url": "https://github.com/elastic/elasticsearch/commit/e2ebfb48fab5d86de9137dfe624967c078cd88bf", "message": "Implement Cancellable DirectoryReader\n\nImplement a Cancellable DirectoryReader that wraps the original\nDirectoryReader so that when a search task is cancelled the\nDirectoryReaders also stop their work fast. This is usuful for\nexpensive operations like wilcard/prefix queries where the\nDirectoryReaders can spend lots of time and consume resources,\nas previously their work wouldn't stop even though the original\nsearch task was cancelled (e.g. because of timeout or dropped client\nconnection).", "committedDate": "2020-02-26T14:55:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NDA5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384554097", "bodyText": "this leniency looks dangerous?", "author": "jpountz", "createdAt": "2020-02-26T15:10:02Z", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -708,6 +708,8 @@ private DefaultSearchContext createSearchContext(SearchRewriteContext rewriteCon\n                 searcher, clusterService, indexService, indexShard, bigArrays, threadPool::relativeTimeInMillis, timeout, fetchPhase);\n             success = true;\n             return searchContext;\n+        } catch (IOException e) {\n+            return null;", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwNDI4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384604284", "bodyText": "Should I simply propagate the exception? or any other suggestion?", "author": "matriv", "createdAt": "2020-02-26T16:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NDA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384556337", "bodyText": "This implementation feels a bit awkward, I'd rather like to fork ExitableDirectoryReader entirely to not inherit from its QueryTimeout abstraction.", "author": "jpountz", "createdAt": "2020-02-26T15:13:21Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +340,99 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n+     */\n+    private static class CancellableIndexReader extends FilterDirectoryReader {\n+\n+        private final Cancellable checkCancelled;\n+\n+        private CancellableIndexReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, checkCancelled);\n+                }\n+            });\n+            this.checkCancelled = checkCancelled;\n+        }\n+\n+        private void setCheckCancelled(Supplier<Runnable> checkCancelled) {\n+            this.checkCancelled.setCancellable(checkCancelled);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a leaf reader with a cancellable task\n+     */\n+    private static class CancellableLeafReader extends ExitableDirectoryReader.ExitableFilterAtomicReader {\n+\n+        private CancellableLeafReader(LeafReader leafReader, Cancellable checkCancelled)  {\n+            super(leafReader, checkCancelled);\n+        }\n+\n+        @Override\n+        public NumericDocValues getNumericDocValues(String field) throws IOException {\n+            return in.getNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n+            return in.getBinaryDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedDocValues getSortedDocValues(String field) throws IOException {\n+            return in.getSortedDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n+            return in.getSortedNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n+            return in.getSortedSetDocValues(field);\n+        }\n+    }\n+\n+    /**\n+     * Implementation of {@link QueryTimeout} with a Runnable task.\n+     */\n+    private static class Cancellable implements QueryTimeout {\n+\n+        private Supplier<Runnable> cancellable;\n+\n+        public void setCancellable(Supplier<Runnable> cancellable) {\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public boolean shouldExit() {\n+            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n+            if (cancellable.get() == null) {\n+                return false;\n+            }\n+            cancellable.get().run();\n+            return false;\n+        }", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5ODk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384598966", "bodyText": "I tried that in the 1st approach but this means we have to copy the whole ExitablePointValues to wrap the point values and therefore the ExitableIntersectVisitor.", "author": "matriv", "createdAt": "2020-02-26T16:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1OTgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385159816", "bodyText": "I don't mind copying it.", "author": "jpountz", "createdAt": "2020-02-27T14:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjcxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385756710", "bodyText": "+1 to copy", "author": "jimczi", "createdAt": "2020-02-28T15:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NzgzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384557839", "bodyText": "use try-with-resources?", "author": "jpountz", "createdAt": "2020-02-26T15:15:24Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java", "diffHunk": "@@ -62,13 +61,19 @@ public void testEmpty() throws IOException {\n                 .method(PercentilesMethod.TDIGEST);\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);\n         fieldType.setName(\"field\");\n-        try (IndexReader reader = new MultiReader()) {\n+\n+        Directory directory = newDirectory();\n+        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), directory);\n+        try (IndexReader reader = unmappedIndexWriter.getReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n             PercentileRanks ranks = search(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n             assertFalse(AggregationInspectionHelper.hasValue(((InternalTDigestPercentileRanks)ranks)));\n+        } finally {\n+            unmappedIndexWriter.close();\n+            directory.close();", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1OTU0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384559546", "bodyText": "CancellableIndexReader shouldn't have any overhead, so it might be simpler to wrap all the time here.", "author": "jpountz", "createdAt": "2020-02-26T15:17:49Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -79,8 +89,18 @@\n     private QueryProfiler profiler;\n     private Runnable checkCancelled;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, true);\n+    }\n+\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                boolean shouldWrap) throws IOException {\n+        super(shouldWrap? new CancellableIndexReader((DirectoryReader) reader, new Cancellable()) : reader);", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwMjUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384602509", "bodyText": "This boolean was added together with a second constructor because of the AggregatorTestCase and hundreds of tests that derive from that. If we wrap the IndexReader we get:\njava.lang.AssertionError: The top-reader used to create Weight is not the same as the current reader's top-reader (org.apache.lucene.index.CompositeReaderContext@382edaaa\n\nwhich I tried to fix by changing the AggregatorTestCase to receive IndexReader and not IndexSearcher as an argument. and all the tests to use the derived IndexSearcher from the context created. But even with this there were a few more tests failing that didn't manage to fix, so after discussion with @jimczi we decided to make this workaround for the moment and address the issue in a separate PR afterwards.\nI can add a TODO though to not miss it.", "author": "matriv", "createdAt": "2020-02-26T16:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1OTU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MDAyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384560025", "bodyText": "Let's call it CancellableDirectoryReader if it extends DirectoryReader.", "author": "jpountz", "createdAt": "2020-02-26T15:18:26Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +340,99 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n+     */\n+    private static class CancellableIndexReader extends FilterDirectoryReader {", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c8901426c48505594b333392bc7d41008644f11e", "url": "https://github.com/elastic/elasticsearch/commit/c8901426c48505594b333392bc7d41008644f11e", "message": "fix compilation", "committedDate": "2020-02-26T15:49:41Z", "type": "commit"}, {"oid": "e38cfa0b5dc885e6540d0433138fa0a8cc796bfe", "url": "https://github.com/elastic/elasticsearch/commit/e38cfa0b5dc885e6540d0433138fa0a8cc796bfe", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-02-26T16:10:27Z", "type": "commit"}, {"oid": "73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "url": "https://github.com/elastic/elasticsearch/commit/73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "message": "Address comments", "committedDate": "2020-02-26T16:20:54Z", "type": "commit"}, {"oid": "ffdf6d2008be37ffd588df5f5648d0794ae9b5a8", "url": "https://github.com/elastic/elasticsearch/commit/ffdf6d2008be37ffd588df5f5648d0794ae9b5a8", "message": "Fix behaviour by properly handling cancellable.run()", "committedDate": "2020-02-26T16:44:09Z", "type": "commit"}, {"oid": "add7dd448fb6c219ab3788c338ab169b7716d2a4", "url": "https://github.com/elastic/elasticsearch/commit/add7dd448fb6c219ab3788c338ab169b7716d2a4", "message": "split query timeout and cancellation to be able to unset query timeout", "committedDate": "2020-02-27T17:07:22Z", "type": "commit"}, {"oid": "d74edb27f06729b1f299c20b6b5d19284c012578", "url": "https://github.com/elastic/elasticsearch/commit/d74edb27f06729b1f299c20b6b5d19284c012578", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-02-27T17:07:34Z", "type": "commit"}, {"oid": "331411be33e0e2b1bbfad1c6aad03d5af5548b8a", "url": "https://github.com/elastic/elasticsearch/commit/331411be33e0e2b1bbfad1c6aad03d5af5548b8a", "message": "Custom implementation of ExitableDirReader to overcome casting", "committedDate": "2020-02-27T21:45:40Z", "type": "commit"}, {"oid": "d10c51a9ea4ca8d2e2813b0c854f679ad8cc3dc8", "url": "https://github.com/elastic/elasticsearch/commit/d10c51a9ea4ca8d2e2813b0c854f679ad8cc3dc8", "message": "revert changes", "committedDate": "2020-02-27T22:18:03Z", "type": "commit"}, {"oid": "e5fdf477933856da0877b81737c1d77640d01d54", "url": "https://github.com/elastic/elasticsearch/commit/e5fdf477933856da0877b81737c1d77640d01d54", "message": "revert", "committedDate": "2020-02-27T22:20:34Z", "type": "commit"}, {"oid": "248ee5159f39ad7e00dde8490407c6ce858e12d2", "url": "https://github.com/elastic/elasticsearch/commit/248ee5159f39ad7e00dde8490407c6ce858e12d2", "message": "revert unrelated changes", "committedDate": "2020-02-27T22:35:58Z", "type": "commit"}, {"oid": "bc8519367323b9a0ce4c2bf98c6df17bd0aee0cb", "url": "https://github.com/elastic/elasticsearch/commit/bc8519367323b9a0ce4c2bf98c6df17bd0aee0cb", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-02-27T22:36:10Z", "type": "commit"}, {"oid": "ce2d557d56d860402220bb64cfbca16c100eef25", "url": "https://github.com/elastic/elasticsearch/commit/ce2d557d56d860402220bb64cfbca16c100eef25", "message": "Fix issues after splitting to cancelation and timeout", "committedDate": "2020-02-28T02:08:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385577015", "bodyText": "Why do we need to do this?", "author": "jpountz", "createdAt": "2020-02-28T09:00:20Z", "path": "server/src/main/java/org/elasticsearch/search/query/QueryPhase.java", "diffHunk": "@@ -310,6 +297,8 @@ static boolean executeInternal(SearchContext searchContext) throws QueryPhaseExe\n                 queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n                 queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n             }\n+            // Search phase has finished, no longer need to check for timeout\n+            searcher.unsetCheckTimeout();", "originalCommit": "ce2d557d56d860402220bb64cfbca16c100eef25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4NjQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385686480", "bodyText": "So that we don't experience a timeout during the aggregation phase. (there were integ tests that were failing because of this). I changed the comment to mention it.", "author": "matriv", "createdAt": "2020-02-28T13:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NzIwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385757209", "bodyText": "We should do this on the cancellable object directly. The searcher shouldn't be able to unset this way. See my comment on the context searcher.", "author": "jimczi", "createdAt": "2020-02-28T15:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ=="}], "type": "inlineReview"}, {"oid": "0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "url": "https://github.com/elastic/elasticsearch/commit/0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "message": "Add unit test", "committedDate": "2020-02-28T13:09:14Z", "type": "commit"}, {"oid": "4c3183f14eefbec43885c33b4b47839c6ed1bf95", "url": "https://github.com/elastic/elasticsearch/commit/4c3183f14eefbec43885c33b4b47839c6ed1bf95", "message": "re-enable MultiReader Tests, fix cancellation tests", "committedDate": "2020-02-28T13:59:30Z", "type": "commit"}, {"oid": "8b38977ffd8682adad31a1063049c42f436b2cce", "url": "https://github.com/elastic/elasticsearch/commit/8b38977ffd8682adad31a1063049c42f436b2cce", "message": "fix checkstyle - enhance comments", "committedDate": "2020-02-28T14:24:26Z", "type": "commit"}, {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "url": "https://github.com/elastic/elasticsearch/commit/9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "message": "Fix NPE", "committedDate": "2020-02-28T14:53:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MzY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385753641", "bodyText": "The implementation should live on the QueryPhase imo. This way you don't need to expose the checkDirReaderCancelled and checkDirReaderCancelled  in the searcher.", "author": "jimczi", "createdAt": "2020-02-28T15:20:00Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Mzk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385753969", "bodyText": "These two functions should not be part of the interface, checkCancelled should be enough", "author": "jimczi", "createdAt": "2020-02-28T15:20:38Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyMjI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386022266", "bodyText": "I don't like that much either, I exposed the checkDirReaderCancelled() so that I we can have tests that differentiate between exit in the searcher and exit from the dirReader: https://github.com/elastic/elasticsearch/pull/52822/files#diff-2abce48f3a52657ce3740afade6d5f8fR132\nBut as discussed I could just unit test the Cancellable reader instead.", "author": "matriv", "createdAt": "2020-02-29T11:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Mzk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDE5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385754196", "bodyText": "Can you call QueryCancellable ?", "author": "jimczi", "createdAt": "2020-02-28T15:20:58Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385756200", "bodyText": "why do you need to use a custom Holder ? Now that cancellable directory reader is forked, you should be able to set the cancellable lazily ? So instead of passing the Cancellable here you'd set it in ContextIndexSearcher#setCancellable ?", "author": "jimczi", "createdAt": "2020-02-28T15:24:34Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,10 +89,27 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private Holder<Cancellable> cancellable;", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MjU4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385792582", "bodyText": "The issue is that we need a reference to the cancellable (the holder actually) during construction of the Reader: https://github.com/elastic/elasticsearch/pull/52822/files#diff-913ad694a7d744ee93ae1dac48d67b0eR403\nSo that later on with the setCancellable we can set it to the holder.", "author": "matriv", "createdAt": "2020-02-28T16:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEwMjgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386102831", "bodyText": "Alreanatively I changed so that the ContextIndexSearcher doesn't know of the holder, but then a cast to CancellableDirectoryReader is required to call the setCancellable.", "author": "matriv", "createdAt": "2020-03-01T12:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Nzg2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385757862", "bodyText": "Can you revert this change ? It should work without this modification so I'd like to keep this for a different pr since the issue is not related to the exitable directory reader.", "author": "jimczi", "createdAt": "2020-02-28T15:27:11Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java", "diffHunk": "@@ -611,14 +611,8 @@ public void testCacheAggregation() throws IOException {\n         }", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MjgzMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385792830", "bodyText": "Sure, will do.", "author": "matriv", "createdAt": "2020-02-28T16:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Nzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1ODE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385758145", "bodyText": "Same here, this shouldn't be needed with the extra constructor.", "author": "jimczi", "createdAt": "2020-02-28T15:27:37Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java", "diffHunk": "@@ -920,14 +920,8 @@ public void testCacheAggregation() throws IOException {\n         }", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1ODI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385758263", "bodyText": "Here too ;)", "author": "jimczi", "createdAt": "2020-02-28T15:27:48Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java", "diffHunk": "@@ -22,7 +22,6 @@\n import org.apache.lucene.document.Document;", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNzg1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385807859", "bodyText": "can you check that the argument is not null since we seem to assume it's never null in some places?", "author": "jpountz", "createdAt": "2020-02-28T16:54:41Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -92,10 +121,14 @@ public void setProfiler(QueryProfiler profiler) {\n \n     /**\n      * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * collecting documents and check for query cancellation or timeout\n      */\n-    public void setCheckCancelled(Runnable checkCancelled) {\n-        this.checkCancelled = checkCancelled;\n+    public void setCancellable(Cancellable cancellable) {\n+        this.cancellable.set(cancellable);", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODYwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385808605", "bodyText": "Let's do the get() call once for all instead of forcing the bulk scorer to do it every time it wants to check whether the request has been cancelled?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());\n          \n          \n            \n                                    Runnable checkCancelled = cancellable.get();\n          \n          \n            \n                                    return new CancellableBulkScorer(in, checkCancelled);", "author": "jpountz", "createdAt": "2020-02-28T16:56:12Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -244,7 +270,7 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, checkCancelled);\n+                        return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385810022", "bodyText": "let's throw an UnsupportedOperationException? (this is only used when asking a DirectoryReader to take into account some new changes in a directory, which should never happen with this impl)", "author": "jpountz", "createdAt": "2020-02-28T16:58:48Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {\n+\n+        private Runnable checkCancelled;\n+        private Runnable checkTimeout;\n+\n+        private CancellableImpl() {\n+        }\n+\n+        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n+            this.checkCancelled = checkCancelled;\n+            this.checkTimeout = checkTimeout;\n+        }\n+\n+        @Override\n+        public boolean isEnabled() {\n+            return checkCancelled != null || checkTimeout != null;\n+        }\n+\n+        @Override\n+        public void checkCancelled() {\n+            if (checkTimeout != null) {\n+                checkTimeout.run();\n+            }\n+            if (checkCancelled != null) {\n+                checkCancelled.run();\n+            }\n+        }\n+\n+        @Override\n+        public void unsetCheckTimeout() {\n+            this.checkTimeout = null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellable);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385811360", "bodyText": "If we want to reduce the overhead to a minimum, we could make MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK a power of two minus 1 (e.g. (1 << 4) - 1, ie. 15, and use a mask instead of a remainder: (calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0.", "author": "jpountz", "createdAt": "2020-02-28T17:01:20Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {\n+\n+        private Runnable checkCancelled;\n+        private Runnable checkTimeout;\n+\n+        private CancellableImpl() {\n+        }\n+\n+        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n+            this.checkCancelled = checkCancelled;\n+            this.checkTimeout = checkTimeout;\n+        }\n+\n+        @Override\n+        public boolean isEnabled() {\n+            return checkCancelled != null || checkTimeout != null;\n+        }\n+\n+        @Override\n+        public void checkCancelled() {\n+            if (checkTimeout != null) {\n+                checkTimeout.run();\n+            }\n+            if (checkCancelled != null) {\n+                checkCancelled.run();\n+            }\n+        }\n+\n+        @Override\n+        public void unsetCheckTimeout() {\n+            this.checkTimeout = null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellable);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<Cancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n+                    new ExitableTerms(terms, cancellable.get()) : terms;\n+        }\n+\n+        @Override\n+        public CacheHelper getCoreCacheHelper() {\n+            return in.getCoreCacheHelper();\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Helper class to be used as an immutable reference so that the underlying\n+     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n+     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n+     */\n+    private static class Holder<T> {\n+\n+        private T in;\n+\n+        private Holder(T in) {\n+            this.in = in;\n+        }\n+\n+        private void set(T in) {\n+            this.in = in;\n+        }\n+\n+        private T get() {\n+            return in;\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n+     */\n+    private static class ExitableTerms extends FilterTerms {\n+\n+        private final Cancellable cancellable;\n+\n+        private ExitableTerms(Terms terms, Cancellable cancellable) {\n+            super(terms);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n+            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n+        }\n+\n+        @Override\n+        public TermsEnum iterator() throws IOException {\n+            return new ExitableTermsEnum(in.iterator(), cancellable);\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n+     * implementing an exitable enumeration of terms.\n+     */\n+    private static class ExitableTermsEnum extends FilterTermsEnum {\n+\n+        private final Cancellable cancellable;\n+\n+        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n+            super(termsEnum);\n+            this.cancellable = cancellable;\n+            this.cancellable.checkDirReaderCancelled();\n+        }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            // Before every iteration, check if the iteration should exit\n+            this.cancellable.checkDirReaderCancelled();\n+            return in.next();\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n+     */\n+    private static class ExitablePointValues extends PointValues {\n+\n+        private final PointValues in;\n+        private final Cancellable cancellable;\n+\n+        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+            this.cancellable.checkDirReaderCancelled();\n+        }\n+\n+        @Override\n+        public void intersect(IntersectVisitor visitor) throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n+        }\n+\n+        @Override\n+        public long estimatePointCount(IntersectVisitor visitor) {\n+            cancellable.checkDirReaderCancelled();\n+            return in.estimatePointCount(visitor);\n+        }\n+\n+        @Override\n+        public byte[] getMinPackedValue() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getMinPackedValue();\n+        }\n+\n+        @Override\n+        public byte[] getMaxPackedValue() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getMaxPackedValue();\n+        }\n+\n+        @Override\n+        public int getNumDimensions() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getNumDimensions();\n+        }\n+\n+        @Override\n+        public int getNumIndexDimensions() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getNumIndexDimensions();\n+        }\n+\n+        @Override\n+        public int getBytesPerDimension() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getBytesPerDimension();\n+        }\n+\n+        @Override\n+        public long size() {\n+            cancellable.checkDirReaderCancelled();\n+            return in.size();\n+        }\n+\n+        @Override\n+        public int getDocCount() {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getDocCount();\n+        }\n+    }\n+\n+    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n+\n+        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n+\n+        private final PointValues.IntersectVisitor in;\n+        private final Cancellable cancellable;\n+        private int calls;\n+\n+        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+        }\n+\n+        private void checkAndThrowWithSampling() {\n+            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyMTkyNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386021926", "bodyText": "Could you please explain why power of two - 1 is better?", "author": "matriv", "createdAt": "2020-02-29T11:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMwODQ0MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386308440", "bodyText": "Masks are typically cheaper than remainders. And a%b is the same as a & (b-1) when a is positive and b is a power of two.", "author": "jpountz", "createdAt": "2020-03-02T10:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MDEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386370101", "bodyText": "Thank you!", "author": "matriv", "createdAt": "2020-03-02T12:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA=="}], "type": "inlineReview"}, {"oid": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "url": "https://github.com/elastic/elasticsearch/commit/0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "message": "address comments", "committedDate": "2020-02-29T11:42:57Z", "type": "commit"}, {"oid": "3936a05c6adb5c38bb33d370d6e05db93dd3d872", "url": "https://github.com/elastic/elasticsearch/commit/3936a05c6adb5c38bb33d370d6e05db93dd3d872", "message": "fix revert", "committedDate": "2020-02-29T16:00:24Z", "type": "commit"}, {"oid": "9bf0fe3d64f140fc2e534257a6eae073ea1b5c95", "url": "https://github.com/elastic/elasticsearch/commit/9bf0fe3d64f140fc2e534257a6eae073ea1b5c95", "message": "fix revert", "committedDate": "2020-02-29T16:01:31Z", "type": "commit"}, {"oid": "ce51935a96c3d59af66205144924f3ff1b32d17e", "url": "https://github.com/elastic/elasticsearch/commit/ce51935a96c3d59af66205144924f3ff1b32d17e", "message": "move impl to QueryPhase", "committedDate": "2020-02-29T17:26:42Z", "type": "commit"}, {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "url": "https://github.com/elastic/elasticsearch/commit/9695114f3028f98ae59dc5ff7481aab3251bce9f", "message": "unit test wrapping and exit", "committedDate": "2020-03-01T12:10:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1ODMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386958322", "bodyText": "Let's use a method ref instead in order to avoid creating an anonymous class\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return new CancellableBulkScorer(in, () -> checkCancelled());\n          \n          \n            \n                                    return new CancellableBulkScorer(in, cancellable::checkCancelled);", "author": "jpountz", "createdAt": "2020-03-03T11:28:04Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -244,7 +269,7 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, checkCancelled);\n+                        return new CancellableBulkScorer(in, () -> checkCancelled());", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1ODU4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386958588", "bodyText": "can you avoid doing a null check every time we check whether the request should be cancelled, like the code did before?", "author": "jpountz", "createdAt": "2020-03-03T11:28:40Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -207,8 +233,7 @@ private void searchLeaf(LeafReaderContext ctx, Weight weight, Collector collecto\n             Scorer scorer = weight.scorer(ctx);\n             if (scorer != null) {\n                 try {\n-                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                        checkCancelled == null ? () -> { } : checkCancelled);\n+                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector, () -> checkCancelled());", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386959490", "bodyText": "this constructor seems to always be called with a Holder around a null, so let's remove it from the ctor arguments and just set cancellableHolder = new Holder<>(null);?", "author": "jpountz", "createdAt": "2020-03-03T11:30:32Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk3OTE4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386979181", "bodyText": "The issue is that we need to pass it in the ctor because we need to use it in the constructor: https://github.com/elastic/elasticsearch/pull/52822/files/9695114f3028f98ae59dc5ff7481aab3251bce9f#diff-913ad694a7d744ee93ae1dac48d67b0eR368\nso that it's passed down the object tree properly.", "author": "matriv", "createdAt": "2020-03-03T12:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk5MDQ3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386990474", "bodyText": "Ah, I see. Nevermind then.", "author": "jpountz", "createdAt": "2020-03-03T12:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNzA0OA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387327048", "bodyText": "I also wonder if we can replace the Holder with a mutable QueryTimeout implementation:\nSomething like:\n   private static class MutableQueryTimeout implements QueryTimeout {\n        private final Set<Runnable> runnables = new HashSet<>();\n\n        Object add(Runnable action) {\n            if (runnables.add(action) == false) {\n                throw new IllegalArgumentException(\"already added\");\n            }\n            return action;\n        }\n\n        boolean remove(Runnable action) {\n            return runnables.remove(action);\n        }\n\n        @Override\n        public boolean shouldExit() {\n            for (Runnable timeout : runnables) {\n                timeout.run();\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isTimeoutEnabled() {\n            return runnables.size() > 0;\n        }\n    }\n\nThis way you can expose a simple QueryTimeout in the wrapped reader and keep the logic simple there ?\nThe ContextIndexSearcher could then expose the addQueryTimeout, removeQueryTimeout directly for the QueryPhase modification.", "author": "jimczi", "createdAt": "2020-03-03T22:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MDY4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386960687", "bodyText": "can you add a comment about why we're not wrapping CompletionTerms? I also wonder that this instanceof logic might be fragile as terms may be wrapped e.g. if document-level security is used?", "author": "jpountz", "createdAt": "2020-03-03T11:32:44Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n+                }\n+            });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<QueryCancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk5MDkwNA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386990904", "bodyText": "Added a comment.\n\nWhat other wrapping classes could we encouter?\nShould we have another ExitableTerms class that extends CompletionTerms and also wrap those with cancellation?", "author": "matriv", "createdAt": "2020-03-03T12:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MDY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MTM4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386961380", "bodyText": "Can we do it on a regular interval (like in ExitableIntersectVisitor) instead of for every term, I worry that this might add noticeable overhead.", "author": "jpountz", "createdAt": "2020-03-03T11:33:56Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n+                }\n+            });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<QueryCancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n+                    new ExitableTerms(terms, cancellable.get()) : terms;\n+        }\n+\n+        @Override\n+        public CacheHelper getCoreCacheHelper() {\n+            return in.getCoreCacheHelper();\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Helper class to be used as an immutable reference so that the underlying\n+     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n+     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n+     */\n+    private static class Holder<T> {\n+\n+        private T in;\n+\n+        private Holder(T in) {\n+            this.in = in;\n+        }\n+\n+        private void set(T in) {\n+            this.in = in;\n+        }\n+\n+        private T get() {\n+            return in;\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n+     */\n+    static class ExitableTerms extends FilterTerms {\n+\n+        private final QueryCancellable cancellable;\n+\n+        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n+            super(terms);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n+            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n+        }\n+\n+        @Override\n+        public TermsEnum iterator() throws IOException {\n+            return new ExitableTermsEnum(in.iterator(), cancellable);\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n+     * implementing an exitable enumeration of terms.\n+     */\n+    private static class ExitableTermsEnum extends FilterTermsEnum {\n+\n+        private final QueryCancellable cancellable;\n+\n+        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n+            super(termsEnum);\n+            this.cancellable = cancellable;\n+            this.cancellable.checkCancelled();\n+        }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            // Before every iteration, check if the iteration should exit\n+            this.cancellable.checkCancelled();", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d562cf1d4a23d023685095dfa18a1448574dd475", "url": "https://github.com/elastic/elasticsearch/commit/d562cf1d4a23d023685095dfa18a1448574dd475", "message": "address comments", "committedDate": "2020-03-03T12:32:42Z", "type": "commit"}, {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "url": "https://github.com/elastic/elasticsearch/commit/6243ceddaf39089ce8fef6c14da6d22608099f3f", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-03-03T12:52:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3MjE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387172149", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        this.cancellable == null ? () -> {} : this::checkCancelled);\n          \n          \n            \n                                        this.cancellable == null ? () -> {} : cancellable::checkCancelled);", "author": "jpountz", "createdAt": "2020-03-03T17:17:44Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -208,7 +235,7 @@ private void searchLeaf(LeafReaderContext ctx, Weight weight, Collector collecto\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                        checkCancelled == null ? () -> { } : checkCancelled);\n+                            this.cancellable == null ? () -> {} : this::checkCancelled);", "originalCommit": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3NzAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387177013", "bodyText": "I tend to prefer fully-qualified calls to TestUtil#nextInt instead of adding a static import, given that this method name is quite generic.", "author": "jpountz", "createdAt": "2020-03-03T17:26:14Z", "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java", "diffHunk": "@@ -53,17 +57,19 @@ public static void setup() throws IOException {\n         // we need at least 2 segments - so no merges should be allowed\n         w.w.getConfig().setMergePolicy(NoMergePolicy.INSTANCE);\n         w.setDoRandomForceMerge(false);\n-        indexRandomDocuments(w, TestUtil.nextInt(random(), 2, 20));\n+        int numDocs = nextInt(random(), 2, 20);\n+        indexRandomDocuments(w, numDocs, 0);\n         w.flush();\n-        indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20));\n+        indexRandomDocuments(w, nextInt(random(), 1, 20), numDocs);", "originalCommit": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3ODMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387178313", "bodyText": "let's also test that it can interrupt iteration over the terms/points?", "author": "jpountz", "createdAt": "2020-03-03T17:28:33Z", "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java", "diffHunk": "@@ -92,4 +98,22 @@ public void testCancellableCollector() throws IOException {\n             () -> searcher.search(new MatchAllDocsQuery(), collector));\n     }\n \n+    public void testCancellableDirectoryReader() throws IOException {\n+        AtomicBoolean cancelled = new AtomicBoolean();\n+        ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n+                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n+        searcher.setCancellable(() -> {\n+            if (cancelled.get()) {\n+                throw new TaskCancelledException(\"cancelled\");\n+            }\n+        });\n+        searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator();\n+        searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount();\n+\n+        cancelled.set(true);\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator());\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount());\n+    }", "originalCommit": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyMTA2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387721067", "bodyText": "Can you also test the removal of the runnable ?", "author": "jimczi", "createdAt": "2020-03-04T14:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3ODMxMw=="}], "type": "inlineReview"}, {"oid": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "url": "https://github.com/elastic/elasticsearch/commit/19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "message": "improve tests", "committedDate": "2020-03-03T19:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387323729", "bodyText": "nit: This class deserves its own file. Is there a specific reason to rename from ExitableDirectoryReader ?", "author": "jimczi", "createdAt": "2020-03-03T22:07:40Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +347,278 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {", "originalCommit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzNzczNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387337736", "bodyText": "Initially I didn't want to mix it up with Lucene's ExitableDirectoryReader, but I can rename. Only this class or also include the underlying wrapper classes?", "author": "matriv", "createdAt": "2020-03-03T22:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODU2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387338560", "bodyText": "Also if we move it to its own file then it needs to know of the MutableQueryTimeout.", "author": "matriv", "createdAt": "2020-03-03T22:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2Njk1OA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387366958", "bodyText": "Only this class or also include the underlying wrapper classes?\n\nAll of it, yes.\n\nAlso if we move it to its own file then it needs to know of the MutableQueryTimeout.\n\nWhy that ? The idea is to have a simple interface in the reader and to use the mutable impl only for the searcher. You can create one in the ctr like this:\n public ContextIndexSearcher(IndexReader reader,\n                                Similarity similarity,\n                                QueryCache queryCache,\n                                QueryCachingPolicy queryCachingPolicy) throws IOException {\n        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n    }\n\n    private ContextIndexSearcher(IndexReader reader,\n                                Similarity similarity,\n                                QueryCache queryCache,\n                                QueryCachingPolicy queryCachingPolicy,\n                                MutableQueryTimeout timeout) throws IOException {\n        super(ExitableDirectoryReader.wrap((DirectoryReader) reader, timeout));\n        this.queryTimeout = timeout;\n        setSimilarity(similarity);\n        setQueryCache(queryCache);\n        setQueryCachingPolicy(queryCachingPolicy);\n    }\n\n?", "author": "jimczi", "createdAt": "2020-03-04T00:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyOTM4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387329382", "bodyText": "See my comment below, I think this could be simplified into:\n            boolean timeoutSet = scrollContext == null && searchContext.timeout() != null &&\n                searchContext.timeout().equals(SearchService.NO_TIMEOUT) == false;\n            final Runnable timeoutRunnable;\n            if (timeoutSet) {\n                final long startTime = searchContext.getRelativeTimeInMillis();\n                final long timeout = searchContext.timeout().millis();\n                final long maxTime = startTime + timeout;\n                timeoutRunnable = searcher.addQueryTimeout(() -> {\n                    final long time = searchContext.getRelativeTimeInMillis();\n                    if (time > maxTime) {\n                        throw new TimeExceededException();\n                    }\n                });\n            } else {\n                timeoutRunnable = null;\n            }\n\n            if (searchContext.lowLevelCancellation()) {\n                SearchShardTask task = searchContext.getTask();\n                searcher.addQueryTimeout(() -> {\n                    if (task.isCancelled()) {\n                        throw new TaskCancelledException(\"cancelled\");\n                    }\n                });\n            }\n            try {\n                ...\n            } finally {\n              if (timeoutRunnable != null) {\n                 searcher.removeQueryTimeout(timeoutRunnable);\n              }\n           }", "author": "jimczi", "createdAt": "2020-03-03T22:19:46Z", "path": "server/src/main/java/org/elasticsearch/search/query/QueryPhase.java", "diffHunk": "@@ -272,20 +273,8 @@ static boolean executeInternal(SearchContext searchContext) throws QueryPhaseExe\n                 cancellationRunnable = null;\n             }\n \n-            final Runnable checkCancelled;\n-            if (timeoutRunnable != null && cancellationRunnable != null) {\n-                checkCancelled = () -> {\n-                    timeoutRunnable.run();\n-                    cancellationRunnable.run();\n-                };\n-            } else if (timeoutRunnable != null) {\n-                checkCancelled = timeoutRunnable;\n-            } else if (cancellationRunnable != null) {\n-                checkCancelled = cancellationRunnable;\n-            } else {\n-                checkCancelled = null;\n-            }\n-            searcher.setCheckCancelled(checkCancelled);\n+            QueryCancellableImpl cancellable = new QueryCancellableImpl(timeoutRunnable, cancellationRunnable);", "originalCommit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "url": "https://github.com/elastic/elasticsearch/commit/b446dfd16c6de533f1ccc2a552407e6df03f3376", "message": "extract wrapper classes to another file, use more elegant approach for cancellable", "committedDate": "2020-03-04T11:36:21Z", "type": "commit"}, {"oid": "183da1740e1380abba936dd676eba04694717bb5", "url": "https://github.com/elastic/elasticsearch/commit/183da1740e1380abba936dd676eba04694717bb5", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-03-04T13:07:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387719706", "bodyText": "nit: the naming of the add is inconsistent with the remove. I wonder how to expose the name here, [add/remove]CheckExitReader ?\nIn any case the javadocs should be adapted to mention the fact that these checks run when we access the reader so not only when collecting document. This makes me think that we may want to wrap the task cancellation check before we rewrite the Lucene query for instance. I am fine if we do this in a follow up since it should be fairly easy to add.", "author": "jimczi", "createdAt": "2020-03-04T14:57:05Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,25 +80,42 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+    }\n+\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n         this.profiler = profiler;\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * Add a {@link Runnable} that will be run on a regular basis while\n+     * collecting documents and check for query cancellation or timeout.\n      */\n-    public void setCheckCancelled(Runnable checkCancelled) {\n-        this.checkCancelled = checkCancelled;\n+    public Runnable addQueryCancellation(Runnable action) {", "originalCommit": "183da1740e1380abba936dd676eba04694717bb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczODcxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387738719", "bodyText": "I prefer the addQueryCancellation since the cancellation is used not only for the reader.\nWill rename the removal method and fix the javadoc though.", "author": "matriv", "createdAt": "2020-03-04T15:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNTkxOA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r388205918", "bodyText": "ok fine with me", "author": "jimczi", "createdAt": "2020-03-05T10:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg=="}], "type": "inlineReview"}, {"oid": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "url": "https://github.com/elastic/elasticsearch/commit/a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "message": "rename method, add more tests", "committedDate": "2020-03-04T15:37:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMTg5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387801891", "bodyText": "Please don't implement QueryTimeout, I think this introduces more issues than it helps, since its contract is that shouldExit should return true once the timeout is hit, while we instead use runnables that throw exceptions.", "author": "jpountz", "createdAt": "2020-03-04T16:57:25Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +338,34 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    private static class MutableQueryTimeout implements QueryTimeout {", "originalCommit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxMDAwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387810003", "bodyText": "Replaced with our own iface.", "author": "matriv", "createdAt": "2020-03-04T17:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMTg5MQ=="}], "type": "inlineReview"}, {"oid": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "url": "https://github.com/elastic/elasticsearch/commit/23c3adc7129b3ca912e5c19a4828dd01c26364bb", "message": "replace QueryTimeout with our own iface", "committedDate": "2020-03-04T17:10:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxMTE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387811140", "bodyText": "Can you document the contract?", "author": "jpountz", "createdAt": "2020-03-04T17:13:24Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.internal;\n+\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.FilterDirectoryReader;\n+import org.apache.lucene.index.FilterLeafReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.index.TermsEnum;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Wraps an {@link IndexReader} with a {@link QueryCancellation}\n+ * which checks for cancelled or timed-out query.\n+ */\n+class ExitableDirectoryReader extends FilterDirectoryReader {\n+\n+    interface QueryCancellation {\n+\n+        boolean isEnabled();\n+\n+        void checkCancelled();", "originalCommit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxNTEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387815120", "bodyText": "Sure!", "author": "matriv", "createdAt": "2020-03-04T17:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxMTE0MA=="}], "type": "inlineReview"}, {"oid": "087f2ad9a9d9cedaaae0ef718ec123858a08dd95", "url": "https://github.com/elastic/elasticsearch/commit/087f2ad9a9d9cedaaae0ef718ec123858a08dd95", "message": "document iface", "committedDate": "2020-03-04T17:19:38Z", "type": "commit"}, {"oid": "df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "url": "https://github.com/elastic/elasticsearch/commit/df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-03-04T17:19:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNzg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r388207896", "bodyText": "nit: s/while accessing/while fetching document/ this is confusing since we don't check the cancellation when visiting the stored fields ?", "author": "jimczi", "createdAt": "2020-03-05T10:34:50Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,25 +79,46 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+    }\n+\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n         this.profiler = profiler;\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the", "originalCommit": "df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "url": "https://github.com/elastic/elasticsearch/commit/eb158e54a363eda92f3e7830e6158f5e8da555eb", "message": "fix comment", "committedDate": "2020-03-05T10:40:42Z", "type": "commit"}]}