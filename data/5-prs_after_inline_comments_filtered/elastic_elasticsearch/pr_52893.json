{"pr_number": 52893, "pr_title": "Allow specifying an exclusive set of fields on ObjectParser", "pr_createdAt": "2020-02-27T15:02:17Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52893", "timeline": [{"oid": "448fb03dd184d84999cf1324590c20bcdd0d3f15", "url": "https://github.com/elastic/elasticsearch/commit/448fb03dd184d84999cf1324590c20bcdd0d3f15", "message": "Allow specifying an exclusive set of fields on ObjectParser", "committedDate": "2020-02-27T14:56:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4ODE3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r385688179", "bodyText": "This doesn't throw an exception though!", "author": "nik9000", "createdAt": "2020-02-28T13:14:35Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java", "diffHunk": "@@ -302,18 +306,40 @@ public Value parse(XContentParser parser, Value value, Context context) throws I\n                         }\n                     }\n \n+                    // Check if this field is in an exclusive set, if it is then mark\n+                    // it as seen.  If the set is already marked, then we have a duplicate", "originalCommit": "448fb03dd184d84999cf1324590c20bcdd0d3f15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4OTE2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r385689165", "bodyText": "Oh, I see. It does, but later. Got it. Maybe update the comment. Not sure.", "author": "nik9000", "createdAt": "2020-02-28T13:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4ODE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI4Mjg2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r386282867", "bodyText": "I rewrote the comments a bit to make things clearer", "author": "romseygeek", "createdAt": "2020-03-02T09:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4ODE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MDk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r385690951", "bodyText": "I think it might be worth mentioning that it doesn't make foo or bar required.", "author": "nik9000", "createdAt": "2020-02-28T13:20:55Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/AbstractObjectParser.java", "diffHunk": "@@ -294,6 +295,23 @@ public void declareRequiredFieldSet(String... requiredSet) {\n         this.requiredFieldSets.add(requiredSet);\n     }\n \n+    /**\n+     * Declares a set of fields of which at most one must appear for parsing to succeed\n+     *\n+     * E.g. <code>declareExclusiveFieldSet(\"foo\", \"bar\");</code> means that only one of 'foo'\n+     * or 'bar' must be present, and if both appear then an exception will be thrown.\n+     *\n+     * Multiple exclusive sets may be declared", "originalCommit": "448fb03dd184d84999cf1324590c20bcdd0d3f15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI4Mjc3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r386282771", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-03-02T09:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MDk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTYwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r385691605", "bodyText": "I tend to put this on the variable that needs it for extra paranoia.", "author": "nik9000", "createdAt": "2020-02-28T13:22:11Z", "path": "modules/percolator/src/main/java/org/elasticsearch/percolator/PercolateQueryBuilder.java", "diffHunk": "@@ -316,113 +318,52 @@ protected void doXContent(XContentBuilder builder, Params params) throws IOExcep\n         builder.endObject();\n     }\n \n-    public static PercolateQueryBuilder fromXContent(XContentParser parser) throws IOException {\n-        float boost = AbstractQueryBuilder.DEFAULT_BOOST;\n-\n-        String field = null;\n-        String name = null;\n-\n-        String indexedDocumentIndex = null;\n-        String indexedDocumentId = null;\n-        String indexedDocumentRouting = null;\n-        String indexedDocumentPreference = null;\n-        Long indexedDocumentVersion = null;\n-\n-        List<BytesReference> documents = new ArrayList<>();\n-\n-        String queryName = null;\n-        String currentFieldName = null;\n-\n-        boolean documentsSpecified = false;\n-        boolean documentSpecified = false;\n-\n-        XContentParser.Token token;\n-        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n-            if (token == XContentParser.Token.FIELD_NAME) {\n-                currentFieldName = parser.currentName();\n-            } else if (token == XContentParser.Token.START_ARRAY) {\n-                if (DOCUMENTS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    if (documentSpecified) {\n-                        throw new IllegalArgumentException(\"[\" + PercolateQueryBuilder.NAME +\n-                            \"] Either specified [document] or [documents], not both\");\n-                    }\n-                    documentsSpecified = true;\n-                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n-                        if (token == XContentParser.Token.START_OBJECT) {\n-                            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {\n-                                builder.copyCurrentStructure(parser);\n-                                builder.flush();\n-                                documents.add(BytesReference.bytes(builder));\n-                            }\n-                        } else {\n-                            throw new ParsingException(parser.getTokenLocation(), \"[\" + PercolateQueryBuilder.NAME +\n-                                \"] query does not support [\" + token + \"]\");\n-                        }\n-                    }\n-                } else {\n-                    throw new ParsingException(parser.getTokenLocation(), \"[\" + PercolateQueryBuilder.NAME +\n-                        \"] query does not field name [\" + currentFieldName + \"]\");\n-                }\n-            } else if (token == XContentParser.Token.START_OBJECT) {\n-                if (DOCUMENT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    if (documentsSpecified) {\n-                        throw new IllegalArgumentException(\"[\" + PercolateQueryBuilder.NAME +\n-                            \"] Either specified [document] or [documents], not both\");\n-                    }\n-                    documentSpecified = true;\n-                    try (XContentBuilder builder = XContentFactory.jsonBuilder()) {\n-                        builder.copyCurrentStructure(parser);\n-                        builder.flush();\n-                        documents.add(BytesReference.bytes(builder));\n-                    }\n-                } else {\n-                    throw new ParsingException(parser.getTokenLocation(), \"[\" + PercolateQueryBuilder.NAME +\n-                            \"] query does not support field name [\" + currentFieldName + \"]\");\n-                }\n-            } else if (token.isValue() || token == XContentParser.Token.VALUE_NULL) {\n-                if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    field = parser.text();\n-                } else if (NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    name = parser.textOrNull();\n-                } else if (INDEXED_DOCUMENT_FIELD_INDEX.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    indexedDocumentIndex = parser.text();\n-                } else if (INDEXED_DOCUMENT_FIELD_ID.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    indexedDocumentId = parser.text();\n-                } else if (INDEXED_DOCUMENT_FIELD_ROUTING.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    indexedDocumentRouting = parser.text();\n-                } else if (INDEXED_DOCUMENT_FIELD_PREFERENCE.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    indexedDocumentPreference = parser.text();\n-                } else if (INDEXED_DOCUMENT_FIELD_VERSION.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    indexedDocumentVersion = parser.longValue();\n-                } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    boost = parser.floatValue();\n-                } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n-                    queryName = parser.text();\n-                } else {\n-                    throw new ParsingException(parser.getTokenLocation(), \"[\" + PercolateQueryBuilder.NAME +\n-                            \"] query does not support [\" + currentFieldName + \"]\");\n-                }\n-            } else {\n-                throw new ParsingException(parser.getTokenLocation(), \"[\" + PercolateQueryBuilder.NAME +\n-                        \"] query does not support [\" + token + \"]\");\n-            }\n-        }\n-\n-        PercolateQueryBuilder queryBuilder;\n-        if (documents.isEmpty() == false) {\n-            queryBuilder = new PercolateQueryBuilder(field, documents, XContentType.JSON);\n-        } else if (indexedDocumentId != null) {\n-            queryBuilder = new PercolateQueryBuilder(field, indexedDocumentIndex, indexedDocumentId, indexedDocumentRouting,\n-                indexedDocumentPreference, indexedDocumentVersion);\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "448fb03dd184d84999cf1324590c20bcdd0d3f15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI4MjcxOA==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r386282718", "bodyText": "TIL you can do this on variables - thanks!", "author": "romseygeek", "createdAt": "2020-03-02T09:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/52893#discussion_r385691834", "bodyText": "Nice to see all this go!", "author": "nik9000", "createdAt": "2020-02-28T13:22:40Z", "path": "modules/percolator/src/main/java/org/elasticsearch/percolator/PercolateQueryBuilder.java", "diffHunk": "@@ -316,113 +318,52 @@ protected void doXContent(XContentBuilder builder, Params params) throws IOExcep\n         builder.endObject();\n     }\n \n-    public static PercolateQueryBuilder fromXContent(XContentParser parser) throws IOException {\n-        float boost = AbstractQueryBuilder.DEFAULT_BOOST;\n-\n-        String field = null;", "originalCommit": "448fb03dd184d84999cf1324590c20bcdd0d3f15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f34c7ea2f42187f90688bd121eed5b2f819fa87d", "url": "https://github.com/elastic/elasticsearch/commit/f34c7ea2f42187f90688bd121eed5b2f819fa87d", "message": "feedback", "committedDate": "2020-03-02T09:37:05Z", "type": "commit"}, {"oid": "6811f01cd4452b6383c893443ff157266cf5eaca", "url": "https://github.com/elastic/elasticsearch/commit/6811f01cd4452b6383c893443ff157266cf5eaca", "message": "Merge remote-tracking branch 'origin/master' into objectparser/exclusive-set", "committedDate": "2020-03-02T09:50:20Z", "type": "commit"}]}