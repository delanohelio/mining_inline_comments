{"pr_number": 52986, "pr_title": "Make ServiceProvider lookup asynchronous", "pr_createdAt": "2020-03-01T01:48:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52986", "timeline": [{"oid": "266792188f375864492a9e6bf6254e8ed694e0cb", "url": "https://github.com/elastic/elasticsearch/commit/266792188f375864492a9e6bf6254e8ed694e0cb", "message": "Make ServiceProvider lookup asynchronous\n\nThis prepares for reading the real Service Provider data from the saml\nindex.\n\nWe intend to support a large number of ServiceProviders within a\nsingle cluster, so it is not reasible to keep them all cached in\nmemory. Since the read from the underyling index will be asynchronous,\nall methods that make use of a service provider also need to be\nasychronous.", "committedDate": "2020-03-01T01:45:41Z", "type": "commit"}, {"oid": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "url": "https://github.com/elastic/elasticsearch/commit/d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "message": "Revert whitespace change", "committedDate": "2020-03-01T04:24:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwMjU0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r386802546", "bodyText": "TODO: This return value (boolean) is obsolete. It was there from IntelliJ's refactoring and I forgot to fix it.", "author": "tvernum", "createdAt": "2020-03-03T05:11:54Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -73,76 +74,108 @@ public SamlAuthnRequestValidator(SamlFactory samlFactory, SamlIdentityProvider i\n     }\n \n     public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+\n+        final ParsedQueryString parsedQueryString;\n+        try {\n+            parsedQueryString = parseQueryString(queryString);\n+        } catch (ElasticsearchSecurityException e) {\n+            logger.debug(\"Failed to parse query string for SAML AuthnRequest\", e);\n+            listener.onFailure(e);\n+            return;\n+        }\n+\n         try {\n-            final Map<String, String> parameters = new HashMap<>();\n-            RestUtils.decodeQueryString(queryString, 0, parameters);\n-            if (parameters.isEmpty()) {\n-                logAndRespond(\"Invalid Authentication Request query string (zero parameters)\", listener);\n-                return;\n-            }\n-            logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n-            final String samlRequest = parameters.get(\"SAMLRequest\");\n-            final String relayState = parameters.get(\"RelayState\");\n-            final String sigAlg = parameters.get(\"SigAlg\");\n-            final String signature = parameters.get(\"Signature\");\n-            if (null == samlRequest) {\n-                logAndRespond(new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString),\n-                    listener);\n-                return;\n-            }\n             // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n             // verify if we know of this SP and get its credentials for signature verification\n-            final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+            final Element root = parseSamlMessage(inflate(decodeBase64(parsedQueryString.samlRequest)));\n             if (samlFactory.elementNameMatches(root, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\") == false) {\n                 logAndRespond(new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", samlFactory.text(root, 128)), listener);\n                 return;\n             }\n             final AuthnRequest authnRequest = samlFactory.buildXmlObject(root, AuthnRequest.class);\n-            final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n-            // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n-            if (sp.shouldSignAuthnRequests()) {\n-                if (Strings.hasText(signature)) {\n-                    if (Strings.hasText(sigAlg) == false) {\n-                        logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n-                            queryString), listener);\n-                        return;\n+            getSpFromIssuer(authnRequest.getIssuer(), ActionListener.wrap(\n+                sp -> {\n+                    try {\n+                        validateAuthnRequest(authnRequest, sp, parsedQueryString, listener);\n+                    } catch (ElasticsearchSecurityException e) {\n+                        logger.debug(\"Could not validate AuthnRequest\", e);\n+                        listener.onFailure(e);\n+                    } catch (Exception e) {\n+                        logAndRespond(\"Could not validate AuthnRequest\", e, listener);\n                     }\n-                    final X509Credential spSigningCredential = sp.getSpSigningCredential();\n-                    if (spSigningCredential == null) {\n-                        logAndRespond(\n-                            \"Unable to validate signature of authentication request, \" +\n-                                \"Service Provider hasn't registered signing credentials\",\n-                            listener);\n-                        return;\n-                    }\n-                    if (validateSignature(samlRequest, sigAlg, signature, spSigningCredential, relayState) == false) {\n-                        logAndRespond(\n-                            new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n-                            queryString, samlFactory.describeCredentials(Collections.singletonList(spSigningCredential))), listener);\n-                        return;\n-                    }\n-                } else if (Strings.hasText(sigAlg)) {\n-                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n-                        queryString), listener);\n-                    return;\n-                } else {\n-                    logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n-                    return;\n-                }\n-            }\n-            validateAuthnRequest(authnRequest, sp);\n-            Map<String, Object> authnState = buildAuthnState(authnRequest, sp);\n-            final SamlValidateAuthnRequestResponse response = new SamlValidateAuthnRequestResponse(sp.getEntityId(),\n-                authnRequest.isForceAuthn(), authnState);\n-            logger.trace(new ParameterizedMessage(\"Validated AuthnResponse from queryString [{}] and extracted [{}]\",\n-                queryString, response));\n-            listener.onResponse(response);\n+                },\n+                listener::onFailure\n+            ));\n         } catch (ElasticsearchSecurityException e) {\n-            logger.debug(\"Could not process and validate AuthnRequest\", e);\n+            logger.debug(\"Could not process AuthnRequest\", e);\n             listener.onFailure(e);\n         } catch (Exception e) {\n-            logAndRespond(\"Could not process and validate AuthnRequest\", e, listener);\n+            logAndRespond(\"Could not process AuthnRequest\", e, listener);\n+        }\n+    }\n+\n+    private ParsedQueryString parseQueryString(String queryString) throws ElasticsearchSecurityException {\n+\n+        final Map<String, String> parameters = new HashMap<>();\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        if (parameters.isEmpty()) {\n+            throw new ElasticsearchSecurityException(\"Invalid Authentication Request query string (zero parameters)\");\n+        }\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        if (null == samlRequest) {\n+            throw new ElasticsearchSecurityException(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString);\n         }\n+        return new ParsedQueryString(\n+            queryString,\n+            samlRequest,\n+            parameters.get(\"RelayState\"),\n+            parameters.get(\"SigAlg\"),\n+            parameters.get(\"Signature\"));\n+    }\n+\n+    private boolean validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwOTAyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387309027", "bodyText": "ack", "author": "jkakavas", "createdAt": "2020-03-03T21:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwMjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNjA3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387306074", "bodyText": "nit: I think we don't benefit much from splitting this to two methods. Totally personal preference, fine eitherway with me", "author": "jkakavas", "createdAt": "2020-03-03T21:32:40Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportSamlInitiateSingleSignOnAction.java", "diffHunk": "@@ -35,25 +35,35 @@\n public class TransportSamlInitiateSingleSignOnAction\n     extends HandledTransportAction<SamlInitiateSingleSignOnRequest, SamlInitiateSingleSignOnResponse> {\n \n+    private final Logger logger = LogManager.getLogger();\n+\n     private final SecurityContext securityContext;\n     private final Environment env;\n-    private final Logger logger = LogManager.getLogger(TransportSamlInitiateSingleSignOnAction.class);\n+    private final SamlFactory samlFactory;\n \n     @Inject\n-    public TransportSamlInitiateSingleSignOnAction(TransportService transportService,\n-                                                   SecurityContext securityContext, ActionFilters actionFilters, Environment environment) {\n+    public TransportSamlInitiateSingleSignOnAction(TransportService transportService, ActionFilters actionFilters,\n+                                                   SecurityContext securityContext, Environment environment, SamlFactory samlFactory) {\n         super(SamlInitiateSingleSignOnAction.NAME, transportService, actionFilters, SamlInitiateSingleSignOnRequest::new);\n         this.securityContext = securityContext;\n         this.env = environment;\n+        this.samlFactory = samlFactory;\n     }\n \n     @Override\n     protected void doExecute(Task task, SamlInitiateSingleSignOnRequest request,\n                              ActionListener<SamlInitiateSingleSignOnResponse> listener) {\n-        final SamlFactory samlFactory = new SamlFactory();\n+        // TODO : Inject this IDP from the plugin\n         final SamlIdentityProvider idp = new CloudIdp(env, env.settings());\n+        idp.getRegisteredServiceProvider(request.getSpEntityId(), ActionListener.wrap(\n+            sp -> doExecute(request, idp, sp, listener),\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private void doExecute(SamlInitiateSingleSignOnRequest request, SamlIdentityProvider idp, SamlServiceProvider sp,", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMTk4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387311985", "bodyText": "Again - I see the pattern here.. - I dislike the fact that we have multiple methods with the same name doing similar stuff. Arguments can be made that signature verification is part of the validation of the AuthnRequest so I'm fine with how you moved that around but could we simple replace this with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    validateAuthnRequest(authnRequest, sp);\n          \n          \n            \n                    checkDestination(authnRequest);\n          \n          \n            \n                    checkAcs(authnRequest, sp);\n          \n      \n    \n    \n  \n\n? I see no reason keeping the second validateAuthnRequest now", "author": "jkakavas", "createdAt": "2020-03-03T21:44:30Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -73,76 +74,108 @@ public SamlAuthnRequestValidator(SamlFactory samlFactory, SamlIdentityProvider i\n     }\n \n     public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+\n+        final ParsedQueryString parsedQueryString;\n+        try {\n+            parsedQueryString = parseQueryString(queryString);\n+        } catch (ElasticsearchSecurityException e) {\n+            logger.debug(\"Failed to parse query string for SAML AuthnRequest\", e);\n+            listener.onFailure(e);\n+            return;\n+        }\n+\n         try {\n-            final Map<String, String> parameters = new HashMap<>();\n-            RestUtils.decodeQueryString(queryString, 0, parameters);\n-            if (parameters.isEmpty()) {\n-                logAndRespond(\"Invalid Authentication Request query string (zero parameters)\", listener);\n-                return;\n-            }\n-            logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n-            final String samlRequest = parameters.get(\"SAMLRequest\");\n-            final String relayState = parameters.get(\"RelayState\");\n-            final String sigAlg = parameters.get(\"SigAlg\");\n-            final String signature = parameters.get(\"Signature\");\n-            if (null == samlRequest) {\n-                logAndRespond(new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString),\n-                    listener);\n-                return;\n-            }\n             // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n             // verify if we know of this SP and get its credentials for signature verification\n-            final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+            final Element root = parseSamlMessage(inflate(decodeBase64(parsedQueryString.samlRequest)));\n             if (samlFactory.elementNameMatches(root, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\") == false) {\n                 logAndRespond(new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", samlFactory.text(root, 128)), listener);\n                 return;\n             }\n             final AuthnRequest authnRequest = samlFactory.buildXmlObject(root, AuthnRequest.class);\n-            final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n-            // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n-            if (sp.shouldSignAuthnRequests()) {\n-                if (Strings.hasText(signature)) {\n-                    if (Strings.hasText(sigAlg) == false) {\n-                        logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n-                            queryString), listener);\n-                        return;\n+            getSpFromIssuer(authnRequest.getIssuer(), ActionListener.wrap(\n+                sp -> {\n+                    try {\n+                        validateAuthnRequest(authnRequest, sp, parsedQueryString, listener);\n+                    } catch (ElasticsearchSecurityException e) {\n+                        logger.debug(\"Could not validate AuthnRequest\", e);\n+                        listener.onFailure(e);\n+                    } catch (Exception e) {\n+                        logAndRespond(\"Could not validate AuthnRequest\", e, listener);\n                     }\n-                    final X509Credential spSigningCredential = sp.getSpSigningCredential();\n-                    if (spSigningCredential == null) {\n-                        logAndRespond(\n-                            \"Unable to validate signature of authentication request, \" +\n-                                \"Service Provider hasn't registered signing credentials\",\n-                            listener);\n-                        return;\n-                    }\n-                    if (validateSignature(samlRequest, sigAlg, signature, spSigningCredential, relayState) == false) {\n-                        logAndRespond(\n-                            new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n-                            queryString, samlFactory.describeCredentials(Collections.singletonList(spSigningCredential))), listener);\n-                        return;\n-                    }\n-                } else if (Strings.hasText(sigAlg)) {\n-                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n-                        queryString), listener);\n-                    return;\n-                } else {\n-                    logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n-                    return;\n-                }\n-            }\n-            validateAuthnRequest(authnRequest, sp);\n-            Map<String, Object> authnState = buildAuthnState(authnRequest, sp);\n-            final SamlValidateAuthnRequestResponse response = new SamlValidateAuthnRequestResponse(sp.getEntityId(),\n-                authnRequest.isForceAuthn(), authnState);\n-            logger.trace(new ParameterizedMessage(\"Validated AuthnResponse from queryString [{}] and extracted [{}]\",\n-                queryString, response));\n-            listener.onResponse(response);\n+                },\n+                listener::onFailure\n+            ));\n         } catch (ElasticsearchSecurityException e) {\n-            logger.debug(\"Could not process and validate AuthnRequest\", e);\n+            logger.debug(\"Could not process AuthnRequest\", e);\n             listener.onFailure(e);\n         } catch (Exception e) {\n-            logAndRespond(\"Could not process and validate AuthnRequest\", e, listener);\n+            logAndRespond(\"Could not process AuthnRequest\", e, listener);\n+        }\n+    }\n+\n+    private ParsedQueryString parseQueryString(String queryString) throws ElasticsearchSecurityException {\n+\n+        final Map<String, String> parameters = new HashMap<>();\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        if (parameters.isEmpty()) {\n+            throw new ElasticsearchSecurityException(\"Invalid Authentication Request query string (zero parameters)\");\n+        }\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        if (null == samlRequest) {\n+            throw new ElasticsearchSecurityException(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString);\n         }\n+        return new ParsedQueryString(\n+            queryString,\n+            samlRequest,\n+            parameters.get(\"RelayState\"),\n+            parameters.get(\"SigAlg\"),\n+            parameters.get(\"Signature\"));\n+    }\n+\n+    private boolean validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,\n+                                         ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+        // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n+        if (sp.shouldSignAuthnRequests()) {\n+            if (Strings.hasText(parsedQueryString.signature)) {\n+                if (Strings.hasText(parsedQueryString.sigAlg) == false) {\n+                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                        parsedQueryString.queryString), listener);\n+                    return true;\n+                }\n+                final X509Credential spSigningCredential = sp.getSpSigningCredential();\n+                if (spSigningCredential == null) {\n+                    logAndRespond(\n+                        \"Unable to validate signature of authentication request, \" +\n+                            \"Service Provider hasn't registered signing credentials\",\n+                        listener);\n+                    return true;\n+                }\n+                if (validateSignature(parsedQueryString, spSigningCredential) == false) {\n+                    logAndRespond(\n+                        new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n+                            parsedQueryString.queryString,\n+                            samlFactory.describeCredentials(Collections.singletonList(spSigningCredential))), listener);\n+                    return true;\n+                }\n+            } else if (Strings.hasText(parsedQueryString.sigAlg)) {\n+                logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n+                    parsedQueryString.queryString), listener);\n+                return true;\n+            } else {\n+                logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n+                return true;\n+            }\n+        }\n+        validateAuthnRequest(authnRequest, sp);", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDcwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387314702", "bodyText": "nit: entityId, EntityID, EntityId all work better than entity-id :)", "author": "jkakavas", "createdAt": "2020-03-03T21:49:57Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/CloudIdp.java", "diffHunk": "@@ -93,9 +94,15 @@ public URL getSingleLogoutEndpoint(String binding) {\n         return sloEndpoints.get(binding);\n     }\n \n+    /**\n+     * Asynchronously lookup the specified {@link SamlServiceProvider} by entity-id.", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8026224c5a1a69931ed6076322e81f150b996699", "url": "https://github.com/elastic/elasticsearch/commit/8026224c5a1a69931ed6076322e81f150b996699", "message": "Merge branch 'feature-internal-idp' into idp/sp-async-lookup", "committedDate": "2020-03-05T03:49:17Z", "type": "commit"}, {"oid": "dd45983a5113267e48e26333098241fa8b0cf57c", "url": "https://github.com/elastic/elasticsearch/commit/dd45983a5113267e48e26333098241fa8b0cf57c", "message": "Inline some methods", "committedDate": "2020-03-05T04:14:25Z", "type": "commit"}]}