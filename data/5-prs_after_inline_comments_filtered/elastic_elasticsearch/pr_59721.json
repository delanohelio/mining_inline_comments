{"pr_number": 59721, "pr_title": "Add long flavored script field", "pr_createdAt": "2020-07-16T18:42:16Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59721", "timeline": [{"oid": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "url": "https://github.com/elastic/elasticsearch/commit/5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "message": "Add long flavored script field\n\nThis adds the `long` runtime type to `script` fields and implements doc\nvalues, field data, the `term` and `exists` query.", "committedDate": "2020-07-16T18:42:07Z", "type": "commit"}, {"oid": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "url": "https://github.com/elastic/elasticsearch/commit/5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "message": "Add long flavored script field\n\nThis adds the `long` runtime type to `script` fields and implements doc\nvalues, field data, the `term` and `exists` query.", "committedDate": "2020-07-16T18:42:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjg5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456432891", "bodyText": "does it need to be protected? Also maybe rename to something like collectValue ? I find it weird to call add against the script itself", "author": "javanna", "createdAt": "2020-07-17T13:12:40Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/LongScriptFieldScript.java", "diffHunk": "@@ -32,14 +32,47 @@\n     }\n \n     public interface LeafFactory {\n-        LongScriptFieldScript newInstance(LeafReaderContext ctx, LongConsumer sync) throws IOException;\n+        LongScriptFieldScript newInstance(LeafReaderContext ctx) throws IOException;\n     }\n \n-    private final LongConsumer sync;\n+    private long[] values = new long[1];\n+    private int count;\n \n-    public LongScriptFieldScript(Map<String, Object> params, SearchLookup searchLookup, LeafReaderContext ctx, LongConsumer sync) {\n+    public LongScriptFieldScript(Map<String, Object> params, SearchLookup searchLookup, LeafReaderContext ctx) {\n         super(params, searchLookup, ctx);\n-        this.sync = sync;\n+    }\n+\n+    /**\n+     * Execute the script for the provided {@code docId}.\n+     */\n+    public final void runForDoc(int docId) {\n+        count = 0;\n+        setDocument(docId);\n+        execute();\n+    }\n+\n+    /**\n+     * Values from the last time {@link #runForDoc(int)} was called. This array\n+     * is mutable and will change with the next call of {@link #runForDoc(int)}.\n+     * It is also oversized and will contain garbage at all indices at and\n+     * above {@link #count()}.\n+     */\n+    public final long[] values() {\n+        return values;\n+    }\n+\n+    /**\n+     * The number of results produced the last time {@link #runForDoc(int)} was called.\n+     */\n+    public final int count() {\n+        return count;\n+    }\n+\n+    protected final void add(long v) {", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0NTkxMg==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456445912", "bodyText": "does it need to be protected?\n\nI thought so, but I'll take a look.\n\nAlso maybe rename to something like collectValue\n\n\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-07-17T13:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMzg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456433889", "bodyText": "you can use SortingNumericDocValues?", "author": "javanna", "createdAt": "2020-07-17T13:14:28Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/fielddata/ScriptLongDocValues.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.fielddata;\n+\n+import org.elasticsearch.index.fielddata.AbstractSortedNumericDocValues;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public final class ScriptLongDocValues extends AbstractSortedNumericDocValues {", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0Njc3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456446777", "bodyText": "It'd force me to copy the longs from one array to the other rather than just sort. We already have to copy string because of BytesRef vs String stuff. But here I don't have to copy unless I want to.", "author": "nik9000", "createdAt": "2020-07-17T13:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMzg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0ODc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456448753", "bodyText": "I see, makes sense then", "author": "javanna", "createdAt": "2020-07-17T13:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMzg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDQzMw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456434433", "bodyText": "For now we need to the same as I proposed in #59762 so that we can carry the params around. That will go away once we can change the signature of fielddataBuilder", "author": "javanna", "createdAt": "2020-07-17T13:15:27Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/fielddata/ScriptLongFieldData.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.fielddata;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.FieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldDataCache;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.LeafNumericFieldData;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.index.fielddata.SearchLookupAware;\n+import org.elasticsearch.index.fielddata.SortedBinaryDocValues;\n+import org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class ScriptLongFieldData extends IndexNumericFieldData implements SearchLookupAware {\n+\n+    public static class Builder implements IndexFieldData.Builder {\n+\n+        private final LongScriptFieldScript.Factory scriptFactory;", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDg2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456434861", "bodyText": "if you carry the script around you can remove this TODO :)", "author": "javanna", "createdAt": "2020-07-17T13:16:15Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/fielddata/ScriptLongFieldData.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.fielddata;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.FieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldDataCache;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.LeafNumericFieldData;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.index.fielddata.SearchLookupAware;\n+import org.elasticsearch.index.fielddata.SortedBinaryDocValues;\n+import org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class ScriptLongFieldData extends IndexNumericFieldData implements SearchLookupAware {\n+\n+    public static class Builder implements IndexFieldData.Builder {\n+\n+        private final LongScriptFieldScript.Factory scriptFactory;\n+\n+        public Builder(LongScriptFieldScript.Factory scriptFactory) {\n+            this.scriptFactory = scriptFactory;\n+        }\n+\n+        @Override\n+        public ScriptLongFieldData build(\n+            IndexSettings indexSettings,\n+            MappedFieldType fieldType,\n+            IndexFieldDataCache cache,\n+            CircuitBreakerService breakerService,\n+            MapperService mapperService\n+        ) {\n+            return new ScriptLongFieldData(indexSettings.getIndex(), fieldType.name(), scriptFactory);\n+        }\n+    }\n+\n+    private final Index index;\n+    private final String fieldName;\n+    private final LongScriptFieldScript.Factory scriptFactory;\n+    private final SetOnce<LongScriptFieldScript.LeafFactory> leafFactory = new SetOnce<>();\n+\n+    private ScriptLongFieldData(Index index, String fieldName, LongScriptFieldScript.Factory scriptFactory) {\n+        this.index = index;\n+        this.fieldName = fieldName;\n+        this.scriptFactory = scriptFactory;\n+    }\n+\n+    @Override\n+    public void setSearchLookup(SearchLookup searchLookup) {\n+        // TODO wire the params from the mappings definition, we don't parse them yet", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2NTUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456565525", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-07-17T17:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNTQ2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456435463", "bodyText": "another change that I lost somehow, but this should rather be ExceptionsHelper#convertToElastic . Can you make the same change in the binary one too?", "author": "javanna", "createdAt": "2020-07-17T13:17:29Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/fielddata/ScriptLongFieldData.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.fielddata;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.FieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldDataCache;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.LeafNumericFieldData;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.index.fielddata.SearchLookupAware;\n+import org.elasticsearch.index.fielddata.SortedBinaryDocValues;\n+import org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class ScriptLongFieldData extends IndexNumericFieldData implements SearchLookupAware {\n+\n+    public static class Builder implements IndexFieldData.Builder {\n+\n+        private final LongScriptFieldScript.Factory scriptFactory;\n+\n+        public Builder(LongScriptFieldScript.Factory scriptFactory) {\n+            this.scriptFactory = scriptFactory;\n+        }\n+\n+        @Override\n+        public ScriptLongFieldData build(\n+            IndexSettings indexSettings,\n+            MappedFieldType fieldType,\n+            IndexFieldDataCache cache,\n+            CircuitBreakerService breakerService,\n+            MapperService mapperService\n+        ) {\n+            return new ScriptLongFieldData(indexSettings.getIndex(), fieldType.name(), scriptFactory);\n+        }\n+    }\n+\n+    private final Index index;\n+    private final String fieldName;\n+    private final LongScriptFieldScript.Factory scriptFactory;\n+    private final SetOnce<LongScriptFieldScript.LeafFactory> leafFactory = new SetOnce<>();\n+\n+    private ScriptLongFieldData(Index index, String fieldName, LongScriptFieldScript.Factory scriptFactory) {\n+        this.index = index;\n+        this.fieldName = fieldName;\n+        this.scriptFactory = scriptFactory;\n+    }\n+\n+    @Override\n+    public void setSearchLookup(SearchLookup searchLookup) {\n+        // TODO wire the params from the mappings definition, we don't parse them yet\n+        this.leafFactory.set(scriptFactory.newFactory(Collections.emptyMap(), searchLookup));\n+    }\n+\n+    @Override\n+    public String getFieldName() {\n+        return fieldName;\n+    }\n+\n+    @Override\n+    public ValuesSourceType getValuesSourceType() {\n+        return CoreValuesSourceType.NUMERIC;\n+    }\n+\n+    @Override\n+    public ScriptLongLeafFieldData load(LeafReaderContext context) {\n+        try {\n+            return loadDirect(context);\n+        } catch (Exception e) {\n+            if (e instanceof ElasticsearchException) {", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2NjA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456566096", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-07-17T17:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNTkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456435902", "bodyText": "this is not needed right?", "author": "javanna", "createdAt": "2020-07-17T13:18:19Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/fielddata/ScriptLongFieldData.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.fielddata;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.FieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexFieldDataCache;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.LeafNumericFieldData;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.index.fielddata.SearchLookupAware;\n+import org.elasticsearch.index.fielddata.SortedBinaryDocValues;\n+import org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class ScriptLongFieldData extends IndexNumericFieldData implements SearchLookupAware {\n+\n+    public static class Builder implements IndexFieldData.Builder {\n+\n+        private final LongScriptFieldScript.Factory scriptFactory;\n+\n+        public Builder(LongScriptFieldScript.Factory scriptFactory) {\n+            this.scriptFactory = scriptFactory;\n+        }\n+\n+        @Override\n+        public ScriptLongFieldData build(\n+            IndexSettings indexSettings,\n+            MappedFieldType fieldType,\n+            IndexFieldDataCache cache,\n+            CircuitBreakerService breakerService,\n+            MapperService mapperService\n+        ) {\n+            return new ScriptLongFieldData(indexSettings.getIndex(), fieldType.name(), scriptFactory);\n+        }\n+    }\n+\n+    private final Index index;\n+    private final String fieldName;\n+    private final LongScriptFieldScript.Factory scriptFactory;\n+    private final SetOnce<LongScriptFieldScript.LeafFactory> leafFactory = new SetOnce<>();\n+\n+    private ScriptLongFieldData(Index index, String fieldName, LongScriptFieldScript.Factory scriptFactory) {\n+        this.index = index;\n+        this.fieldName = fieldName;\n+        this.scriptFactory = scriptFactory;\n+    }\n+\n+    @Override\n+    public void setSearchLookup(SearchLookup searchLookup) {\n+        // TODO wire the params from the mappings definition, we don't parse them yet\n+        this.leafFactory.set(scriptFactory.newFactory(Collections.emptyMap(), searchLookup));\n+    }\n+\n+    @Override\n+    public String getFieldName() {\n+        return fieldName;\n+    }\n+\n+    @Override\n+    public ValuesSourceType getValuesSourceType() {\n+        return CoreValuesSourceType.NUMERIC;\n+    }\n+\n+    @Override\n+    public ScriptLongLeafFieldData load(LeafReaderContext context) {\n+        try {\n+            return loadDirect(context);\n+        } catch (Exception e) {\n+            if (e instanceof ElasticsearchException) {\n+                throw (ElasticsearchException) e;\n+            } else {\n+                throw new ElasticsearchException(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ScriptLongLeafFieldData loadDirect(LeafReaderContext context) throws IOException {\n+        return new ScriptLongLeafFieldData(new ScriptLongDocValues(leafFactory.get().newInstance(context)));\n+    }\n+\n+    @Override\n+    public NumericType getNumericType() {\n+        return NumericType.LONG;\n+    }\n+\n+    @Override\n+    protected boolean sortRequiresCustomComparator() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void clear() {}\n+\n+    @Override\n+    public Index index() {\n+        return index;\n+    }\n+\n+    public static class ScriptLongLeafFieldData implements LeafNumericFieldData {\n+        private final ScriptLongDocValues scriptBinaryDocValues;\n+\n+        ScriptLongLeafFieldData(ScriptLongDocValues scriptBinaryDocValues) {\n+            this.scriptBinaryDocValues = scriptBinaryDocValues;\n+        }\n+\n+        @Override\n+        public ScriptDocValues<?> getScriptValues() {\n+            return new ScriptDocValues.Longs(getLongValues());\n+        }\n+\n+        @Override\n+        public SortedBinaryDocValues getBytesValues() {\n+            return FieldData.toString(scriptBinaryDocValues);\n+        }\n+\n+        @Override\n+        public SortedNumericDoubleValues getDoubleValues() {\n+            return FieldData.castToDouble(getLongValues());\n+        }\n+\n+        @Override\n+        public SortedNumericDocValues getLongValues() {\n+            return scriptBinaryDocValues;\n+        }\n+\n+        @Override\n+        public long ramBytesUsed() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public void close() {\n+\n+        }\n+    }\n+\n+    static class ScriptBinaryResult {", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNjA0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456436049", "bodyText": "needs to be removed also in the binary one, it's unused :)", "author": "javanna", "createdAt": "2020-07-17T13:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNTkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2NjQ2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456566467", "bodyText": "\ud83d\udc4d\nI remember looking at it and thinking \"this isn't used\" and then forgetting.....", "author": "nik9000", "createdAt": "2020-07-17T17:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNjY1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456436655", "bodyText": "shall we add some way to not forget about overriding familyType for all the subclasses? Maybe we could override the method and make it call some other new abstract method?", "author": "javanna", "createdAt": "2020-07-17T13:19:40Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptMappedFieldType.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.ToXContent.Params;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.script.Script;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.elasticsearch.search.SearchService.ALLOW_EXPENSIVE_QUERIES;\n+\n+/**\n+ * Abstract base {@linkplain MappedFieldType} for scripted fields.\n+ */\n+abstract class AbstractScriptMappedFieldType extends MappedFieldType {\n+    protected final Script script;\n+\n+    AbstractScriptMappedFieldType(String name, Script script, Map<String, String> meta) {\n+        super(name, false, false, TextSearchInfo.NONE, meta);\n+        this.script = script;\n+    }\n+\n+    @Override\n+    public final String typeName() {\n+        return ScriptFieldMapper.CONTENT_TYPE;\n+    }", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNzA4OA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456437088", "bodyText": "oh well I see below that you have runtimeType, so it would be enough to override familyTypeName and call runtimeType in there.", "author": "javanna", "createdAt": "2020-07-17T13:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNjY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2NzM4NA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456567384", "bodyText": "Got it!", "author": "nik9000", "createdAt": "2020-07-17T17:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNzU3NA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456437574", "bodyText": "use the existing constant from KeywordFieldMapper#CONTENT_TYPE?", "author": "javanna", "createdAt": "2020-07-17T13:21:15Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptKeywordMappedFieldType.java", "diffHunk": "@@ -31,27 +26,30 @@\n import org.elasticsearch.xpack.runtimefields.query.StringScriptFieldTermsQuery;\n import org.elasticsearch.xpack.runtimefields.query.StringScriptFieldWildcardQuery;\n \n-import java.io.IOException;\n import java.time.ZoneId;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n \n import static java.util.stream.Collectors.toSet;\n-import static org.elasticsearch.search.SearchService.ALLOW_EXPENSIVE_QUERIES;\n \n-public final class RuntimeKeywordMappedFieldType extends MappedFieldType {\n+public final class ScriptKeywordMappedFieldType extends AbstractScriptMappedFieldType {\n \n     private final Script script;\n     private final StringScriptFieldScript.Factory scriptFactory;\n \n-    RuntimeKeywordMappedFieldType(String name, Script script, StringScriptFieldScript.Factory scriptFactory, Map<String, String> meta) {\n-        super(name, false, false, TextSearchInfo.NONE, meta);\n+    ScriptKeywordMappedFieldType(String name, Script script, StringScriptFieldScript.Factory scriptFactory, Map<String, String> meta) {\n+        super(name, script, meta);\n         this.script = script;\n         this.scriptFactory = scriptFactory;\n     }\n \n+    @Override\n+    protected String runtimeType() {\n+        return \"keyword\";", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2NzUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456567521", "bodyText": "I'm going to use the lookup that you built instead.", "author": "nik9000", "createdAt": "2020-07-17T17:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODE3OA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456438178", "bodyText": "I was making changes to the lookup as well in #59762 , let's use the constants from the existing mappers for their type?", "author": "javanna", "createdAt": "2020-07-17T13:22:16Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -131,6 +125,27 @@ public ScriptFieldMapper build(BuilderContext context) {\n             );\n         }\n \n+        private MappedFieldType buildType(String fullName) {\n+            switch (runtimeType.getValue()) {", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2NzYxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456567611", "bodyText": "I'll use your lookup, sure.", "author": "nik9000", "createdAt": "2020-07-17T17:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODk1MA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456438950", "bodyText": "should we introduce some way to not forget the check? like having this done in the base class, and define queries through new abstract methods?", "author": "javanna", "createdAt": "2020-07-17T13:23:38Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptLongMappedFieldType.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.lucene.search.Queries;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.fielddata.ScriptLongFieldData;\n+import org.elasticsearch.xpack.runtimefields.query.LongScriptFieldExistsQuery;\n+import org.elasticsearch.xpack.runtimefields.query.LongScriptFieldTermQuery;\n+\n+import java.util.Map;\n+\n+public class ScriptLongMappedFieldType extends AbstractScriptMappedFieldType {\n+    private final LongScriptFieldScript.Factory scriptFactory;\n+\n+    ScriptLongMappedFieldType(String name, Script script, LongScriptFieldScript.Factory scriptFactory, Map<String, String> meta) {\n+        super(name, script, meta);\n+        this.scriptFactory = scriptFactory;\n+    }\n+\n+    @Override\n+    protected String runtimeType() {\n+        return \"long\";\n+    }\n+\n+    @Override\n+    public Object valueForDisplay(Object value) {\n+        return value; // These should come back as a Long\n+    }\n+\n+    @Override\n+    public ScriptLongFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+        // TODO once we get SearchLookup as an argument, we can already call scriptFactory.newFactory here and pass through the result\n+        return new ScriptLongFieldData.Builder(scriptFactory);\n+    }\n+\n+    private LongScriptFieldScript.LeafFactory leafFactory(QueryShardContext context) {\n+        return scriptFactory.newFactory(script.getParams(), context.lookup());\n+    }\n+\n+    @Override\n+    public Query existsQuery(QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2ODE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456568140", "bodyText": "That is tricky because not all subclasses will override all queries......\nI wonder if we can wait on this one until we have more subclasses.", "author": "nik9000", "createdAt": "2020-07-17T17:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4MjEzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456582139", "bodyText": "I see, it is fine to wait. Though this will require us to extend every single query at least for this check and then call super? Maybe it is actually a reason to force overriding every query? Not sure though", "author": "javanna", "createdAt": "2020-07-17T17:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4Nzg1NA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456587854", "bodyText": "Me neither!\nI wonder if I could move this into the query ctor. It'd be a bit wonky, but I think it'd force the check fairly easilly.", "author": "nik9000", "createdAt": "2020-07-17T17:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5ODc1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456598755", "bodyText": "know what? I am having second thoughts about this check and the way it is performed. We are going to fail on all shards which is not desirable. We should rather have a way to fail on the coordinating node, but I know that is hard. Maybe we should reconsider and discuss this?", "author": "javanna", "createdAt": "2020-07-17T18:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxOTMxMA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456619310", "bodyText": "let's leave this for now, we will revisit this later", "author": "javanna", "createdAt": "2020-07-17T18:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzODk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzOTM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456439389", "bodyText": "Shall we make this a shared constant somewhere, and remove the TODO as that is what we will keep for the time being?", "author": "javanna", "createdAt": "2020-07-17T13:24:13Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/AbstractLongScriptFieldQuery.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.ConstantScoreScorer;\n+import org.apache.lucene.search.ConstantScoreWeight;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Abstract base class for building queries based on {@link StringScriptFieldScript}.\n+ */\n+abstract class AbstractLongScriptFieldQuery extends AbstractScriptFieldQuery {\n+    private final LongScriptFieldScript.LeafFactory leafFactory;\n+\n+    AbstractLongScriptFieldQuery(Script script, LongScriptFieldScript.LeafFactory leafFactory, String fieldName) {\n+        super(script, fieldName);\n+        this.leafFactory = Objects.requireNonNull(leafFactory);\n+    }\n+\n+    /**\n+     * Does the value match this query?\n+     */\n+    protected abstract boolean matches(long[] values, int count);\n+\n+    @Override\n+    public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new ConstantScoreWeight(this, boost) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false; // scripts aren't really cacheable at this point\n+            }\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext ctx) throws IOException {\n+                LongScriptFieldScript script = leafFactory.newInstance(ctx);\n+                DocIdSetIterator approximation = DocIdSetIterator.all(ctx.reader().maxDoc());\n+                TwoPhaseIterator twoPhase = new TwoPhaseIterator(approximation) {\n+                    @Override\n+                    public boolean matches() throws IOException {\n+                        script.runForDoc(approximation().docID());\n+                        return AbstractLongScriptFieldQuery.this.matches(script.values(), script.count());\n+                    }\n+\n+                    @Override\n+                    public float matchCost() {\n+                        // TODO we don't have a good way of estimating the complexity of the script so we just go with 9000\n+                        return 9000f;", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2ODIyNg==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456568226", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-07-17T17:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzOTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzOTc3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456439772", "bodyText": "I would be fine with even printing the getSimpleName", "author": "javanna", "createdAt": "2020-07-17T13:24:55Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldExistsQuery.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+\n+public class LongScriptFieldExistsQuery extends AbstractLongScriptFieldQuery {\n+    public LongScriptFieldExistsQuery(Script script, LongScriptFieldScript.LeafFactory leafFactory, String fieldName) {\n+        super(script, leafFactory, fieldName);\n+    }\n+\n+    @Override\n+    protected boolean matches(long[] values, int count) {\n+        return count > 0;\n+    }\n+\n+    @Override\n+    public final String toString(String field) {\n+        if (fieldName().contentEquals(field)) {\n+            return \"ScriptFieldExists\";", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjI5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456572297", "bodyText": "Sure!", "author": "nik9000", "createdAt": "2020-07-17T17:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzOTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0MTU4OA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456441588", "bodyText": "we are going to have ton of conflicts here with #59672, but I like the direction :)", "author": "javanna", "createdAt": "2020-07-17T13:28:01Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapperTests.java", "diffHunk": "@@ -93,27 +95,43 @@ public void testStoredScriptsAreNotSupported() throws Exception {\n         );\n     }\n \n-    public void testDefaultMapping() throws Exception {\n-        XContentBuilder mapping = XContentFactory.jsonBuilder()\n-            .startObject()\n-            .startObject(\"_doc\")\n-            .startObject(\"properties\")\n-            .startObject(\"field\")\n-            .field(\"type\", \"script\")\n-            .field(\"runtime_type\", randomFrom(SUPPORTED_RUNTIME_TYPES))\n-            .startObject(\"script\")\n-            .field(\"source\", \"value('test')\")\n-            .field(\"lang\", \"test\")\n-            .endObject()\n-            .endObject()\n-            .endObject()\n-            .endObject()\n-            .endObject();\n+    public void testKeyword() throws IOException {\n+        MapperService mapperService = createIndex(\"test\", Settings.EMPTY, mapping(\"keyword\")).mapperService();\n+        FieldMapper mapper = (FieldMapper) mapperService.documentMapper().mappers().getMapper(\"field\");\n+        assertThat(mapper, instanceOf(ScriptFieldMapper.class));\n+        assertEquals(Strings.toString(mapping(\"keyword\")), Strings.toString(mapperService.documentMapper()));\n+    }\n \n-        MapperService mapperService = createIndex(\"test\", Settings.EMPTY, mapping).mapperService();\n+    public void testLong() throws IOException {\n+        MapperService mapperService = createIndex(\"test\", Settings.EMPTY, mapping(\"long\")).mapperService();\n         FieldMapper mapper = (FieldMapper) mapperService.documentMapper().mappers().getMapper(\"field\");\n         assertThat(mapper, instanceOf(ScriptFieldMapper.class));\n-        assertEquals(Strings.toString(mapping), Strings.toString(mapperService.documentMapper()));\n+        assertEquals(Strings.toString(mapping(\"long\")), Strings.toString(mapperService.documentMapper()));\n+    }\n+\n+    private XContentBuilder mapping(String type) throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject();\n+        {\n+            mapping.startObject(\"_doc\");\n+            {\n+                mapping.startObject(\"properties\");\n+                {\n+                    mapping.startObject(\"field\");\n+                    {\n+                        mapping.field(\"type\", \"script\").field(\"runtime_type\", type);\n+                        mapping.startObject(\"script\");\n+                        {\n+                            mapping.field(\"source\", \"dummy_source\").field(\"lang\", \"test\");\n+                        }\n+                        mapping.endObject();\n+                    }\n+                    mapping.endObject();\n+                }\n+                mapping.endObject();\n+            }\n+            mapping.endObject();\n+        }\n+        return mapping.endObject();", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0MjE2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456442161", "bodyText": "shall we have a test for aggs and a test for term query that use script params?", "author": "javanna", "createdAt": "2020-07-17T13:29:03Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptLongMappedFieldTypeTests.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.search.Collector;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.LeafCollector;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.Scorable;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessPlugin;\n+import org.elasticsearch.plugins.ExtensiblePlugin.ExtensionLoader;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.xpack.runtimefields.LongScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFieldsPainlessExtension;\n+import org.elasticsearch.xpack.runtimefields.fielddata.ScriptLongFieldData;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class ScriptLongMappedFieldTypeTests extends AbstractScriptMappedFieldTypeTestCase {\n+    public void testDocValues() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [1]}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [2, 1]}\"))));\n+            List<Long> results = new ArrayList<>();\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                ScriptLongMappedFieldType ft = build(\"for (def v : source.foo) {value(v)}\");\n+                IndexMetadata imd = IndexMetadata.builder(\"test\")\n+                    .settings(Settings.builder().put(\"index.version.created\", Version.CURRENT))\n+                    .numberOfShards(1)\n+                    .numberOfReplicas(1)\n+                    .build();\n+                ScriptLongFieldData ifd = ft.fielddataBuilder(\"test\").build(new IndexSettings(imd, Settings.EMPTY), ft, null, null, null);", "originalCommit": "5ff1e756de5c87f130f5514d5ea94b46bbeb50fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjYzNw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456572637", "bodyText": "I've added a test for field data and for the term query that use script params.", "author": "nik9000", "createdAt": "2020-07-17T17:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0MjE2MQ=="}], "type": "inlineReview"}, {"oid": "f5ea47aa794360fde4c9ca4c6af5a20ebf3040b1", "url": "https://github.com/elastic/elasticsearch/commit/f5ea47aa794360fde4c9ca4c6af5a20ebf3040b1", "message": "Merge branch 'feature/runtime_fields' into script_field_long_1", "committedDate": "2020-07-17T16:57:20Z", "type": "commit"}, {"oid": "66f11a0ca071e3403f453cb145d21a3b610a5791", "url": "https://github.com/elastic/elasticsearch/commit/66f11a0ca071e3403f453cb145d21a3b610a5791", "message": "iter", "committedDate": "2020-07-17T17:19:41Z", "type": "commit"}, {"oid": "1763c20dea8df05bafa2bb9a7813b2d27267ddd7", "url": "https://github.com/elastic/elasticsearch/commit/1763c20dea8df05bafa2bb9a7813b2d27267ddd7", "message": "checkstyle", "committedDate": "2020-07-17T17:36:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNzY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456617649", "bodyText": "thanks! that was my bad after all :D", "author": "javanna", "createdAt": "2020-07-17T18:51:32Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/StringScriptFieldScript.java", "diffHunk": "@@ -35,7 +35,7 @@\n         StringScriptFieldScript newInstance(LeafReaderContext ctx) throws IOException;\n     }\n \n-    protected final List<String> results = new ArrayList<>();\n+    private final List<String> results = new ArrayList<>();", "originalCommit": "1763c20dea8df05bafa2bb9a7813b2d27267ddd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxODQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456618403", "bodyText": "I no longer remember what this TODO is about. what can we do to address it? and what do we need this method for, again?", "author": "javanna", "createdAt": "2020-07-17T18:53:13Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptMappedFieldType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.xcontent.ToXContent.Params;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.script.Script;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.elasticsearch.search.SearchService.ALLOW_EXPENSIVE_QUERIES;\n+\n+/**\n+ * Abstract base {@linkplain MappedFieldType} for scripted fields.\n+ */\n+abstract class AbstractScriptMappedFieldType extends MappedFieldType {\n+    protected final Script script;\n+\n+    AbstractScriptMappedFieldType(String name, Script script, Map<String, String> meta) {\n+        super(name, false, false, TextSearchInfo.NONE, meta);\n+        this.script = script;\n+    }\n+\n+    protected abstract String runtimeType();\n+\n+    void mapperXContentBody(XContentBuilder builder, Params params) throws IOException {\n+        builder.field(\"runtime_type\", runtimeType());\n+        builder.field(\"script\", script.getIdOrCode()); // TODO For some reason this doesn't allow us to do the full xcontent of the script.", "originalCommit": "1763c20dea8df05bafa2bb9a7813b2d27267ddd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzNTc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456635783", "bodyText": "It spits out the script in the xcontent of the mapper. I think we might want to merge it into the FieldMapper's xcontent rendering. I can have a look in a follow up.\nThat TODO is basically complaining that I can render the whole script - it won't parse properly if I do. I don't remember why. I'll dig.", "author": "nik9000", "createdAt": "2020-07-17T19:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxODQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0OTEyNw==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456649127", "bodyText": "I opened #59813 for the TODO.", "author": "nik9000", "createdAt": "2020-07-17T20:03:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxODQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxODg1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456618859", "bodyText": "++ thanks!", "author": "javanna", "createdAt": "2020-07-17T18:54:11Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptKeywordMappedFieldType.java", "diffHunk": "@@ -32,27 +27,30 @@\n import org.elasticsearch.xpack.runtimefields.query.StringScriptFieldTermsQuery;\n import org.elasticsearch.xpack.runtimefields.query.StringScriptFieldWildcardQuery;\n \n-import java.io.IOException;\n import java.time.ZoneId;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n \n import static java.util.stream.Collectors.toSet;\n-import static org.elasticsearch.search.SearchService.ALLOW_EXPENSIVE_QUERIES;\n \n-public final class RuntimeKeywordMappedFieldType extends MappedFieldType {\n+public final class ScriptKeywordMappedFieldType extends AbstractScriptMappedFieldType {", "originalCommit": "1763c20dea8df05bafa2bb9a7813b2d27267ddd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyMDg1OA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456620858", "bodyText": "maybe adding one of these methods could even be automatic once a new supported field type is added to the map? not sure that it's important now though", "author": "javanna", "createdAt": "2020-07-17T18:58:21Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapperTests.java", "diffHunk": "@@ -106,46 +107,32 @@ public void testStoredScriptsAreNotSupported() throws Exception {\n     }\n \n     public void testUnsupportedRuntimeType() throws Exception {\n-        XContentBuilder mapping = XContentFactory.jsonBuilder()\n-            .startObject()\n-            .startObject(\"_doc\")\n-            .startObject(\"properties\")\n-            .startObject(\"field\")\n-            .field(\"type\", \"script\")\n-            .field(\"runtime_type\", \"unsupported\")\n-            .startObject(\"script\")\n-            .field(\"source\", \"keyword('test')\")\n-            .field(\"lang\", \"test\")\n-            .endObject()\n-            .endObject()\n-            .endObject()\n-            .endObject()\n-            .endObject();\n-\n-        MapperParsingException exc = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        MapperParsingException exc = expectThrows(\n+            MapperParsingException.class,\n+            () -> createIndex(\"test\", Settings.EMPTY, mapping(\"unsupported\"))\n+        );\n         assertEquals(\"Failed to parse mapping: runtime_type [unsupported] not supported\", exc.getMessage());\n     }\n \n+    public void testKeyword() throws IOException {\n+        MapperService mapperService = createIndex(\"test\", Settings.EMPTY, mapping(\"keyword\")).mapperService();\n+        FieldMapper mapper = (FieldMapper) mapperService.documentMapper().mappers().getMapper(\"field\");\n+        assertThat(mapper, instanceOf(ScriptFieldMapper.class));\n+        assertEquals(Strings.toString(mapping(\"keyword\")), Strings.toString(mapperService.documentMapper()));\n+    }\n+\n+    public void testLong() throws IOException {\n+        MapperService mapperService = createIndex(\"test\", Settings.EMPTY, mapping(\"long\")).mapperService();\n+        FieldMapper mapper = (FieldMapper) mapperService.documentMapper().mappers().getMapper(\"field\");\n+        assertThat(mapper, instanceOf(ScriptFieldMapper.class));\n+        assertEquals(Strings.toString(mapping(\"long\")), Strings.toString(mapperService.documentMapper()));\n+    }", "originalCommit": "1763c20dea8df05bafa2bb9a7813b2d27267ddd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzNTk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/59721#discussion_r456635948", "bodyText": "Its a good idea. We could loop through the list but I kind of like having a method for each one.", "author": "nik9000", "createdAt": "2020-07-17T19:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyMDg1OA=="}], "type": "inlineReview"}]}