{"pr_number": 58650, "pr_title": "SQL: Redact credentials in connection exceptions", "pr_createdAt": "2020-06-29T08:09:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58650", "timeline": [{"oid": "523ee4f48ca090d08315e92bfaae4588b1c233f1", "url": "https://github.com/elastic/elasticsearch/commit/523ee4f48ca090d08315e92bfaae4588b1c233f1", "message": "Redact credentials in connection exceptions\n\nThis commit adds the functionality to redact the credentials from the\nexceptions generated when a connection attempt fails, preventing them\nfrom leaking into logs, console history etc.\n\nThere are a few causes that can lead to failed connections. The most\nchallenging to deal with is a malformed connection string. The redaction\ntries to get around it by modifying the URI to a parsable state, so that\nthe redaction can be applied reliably. If there's no reliability\nguarantee, the redaction will bluntly replace the entire connection\nstring and the user informed about the option to modify it so that the\nredaction won't apply. (This is done by using a caplitalized scheme,\nwhich is legal, but otherwise never used in practice.)\n\nThe commit fixes a couple of other issues with the URI parser:\n- it allows an empty hostname, or even entire connection string (as per\nthe existing documentation);\n- it reduces the editing of the connection string in the exception\nmessages (so that the user easier recognize their input);\n- it uses the default URI as source for the scheme and hostname.", "committedDate": "2020-06-29T07:55:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1MTY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r447551651", "bodyText": "Minor: Those 2 lines seem to have inconsistent identation compared to the rest of the file.", "author": "matriv", "createdAt": "2020-06-30T09:39:45Z", "path": "x-pack/plugin/sql/sql-client/src/test/java/org/elasticsearch/xpack/sql/client/UriUtilsTests.java", "diffHunk": "@@ -59,15 +82,197 @@ public void testHttpQuery() throws Exception {\n \n     public void testUnsupportedProtocol() throws Exception {\n         assertEquals(\n-                \"Invalid connection configuration [ftp://server:9201/]: Only http and https protocols are supported\",\n+                \"Invalid connection scheme [ftp] configuration: only http and https protocols are supported\",\n                 expectThrows(IllegalArgumentException.class, () -> parseURI(\"ftp://server:9201/\", DEFAULT_URI)).getMessage()\n         );\n     }\n \n-    public void testMalformed() throws Exception {\n+    public void testMalformedWhiteSpace() throws Exception {\n         assertEquals(\n-                \"Invalid connection configuration []: Expected authority at index 7: http://\",\n-                expectThrows(IllegalArgumentException.class, () -> parseURI(\"\", DEFAULT_URI)).getMessage()\n+            \"Invalid connection configuration: Illegal character in authority at index 7: http:// \",\n+            expectThrows(IllegalArgumentException.class, () -> parseURI(\" \", DEFAULT_URI)).getMessage()\n+        );\n+    }\n+\n+    public void testNoRedaction() {\n+        assertEquals(\n+                \"Invalid connection configuration: Illegal character in fragment at index 16: HTTP://host#frag#ment\",", "originalCommit": "523ee4f48ca090d08315e92bfaae4588b1c233f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5Nzg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r447597890", "bodyText": "Ah, rite. Thanks!\nThis file had a bit of a styles mix. I've aligned it to what seems to have been an initial one, but happy to re-adjust it if I got it wrong.", "author": "bpintea", "createdAt": "2020-06-30T11:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1MTY1MQ=="}], "type": "inlineReview"}, {"oid": "b600ed7ff99fcd52f82eab0284957da202329d55", "url": "https://github.com/elastic/elasticsearch/commit/b600ed7ff99fcd52f82eab0284957da202329d55", "message": "style corrections\n\nAllign code in file w.r.t.:\n- indentation size;\n- parameters placement;\n- closing paranthesis placement.", "committedDate": "2020-06-30T10:56:41Z", "type": "commit"}, {"oid": "74a53b4d55123a3fa072c6c052d941d974f85b3a", "url": "https://github.com/elastic/elasticsearch/commit/74a53b4d55123a3fa072c6c052d941d974f85b3a", "message": "Merge branch 'master' into enh/redact_credentials_in_invalid_uri", "committedDate": "2020-06-30T13:03:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE3NDgyNA==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448174824", "bodyText": "This url is not used anymore. Can be removed.", "author": "astefan", "createdAt": "2020-07-01T07:38:37Z", "path": "x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/JdbcConfiguration.java", "diffHunk": "@@ -115,15 +115,15 @@ public static JdbcConfiguration create(String u, Properties props, int loginTime\n \n     private static URI parseUrl(String u) throws JdbcSQLException {\n         String url = u;", "originalCommit": "74a53b4d55123a3fa072c6c052d941d974f85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMDUyOA==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448320528", "bodyText": "good point, thanks.", "author": "bpintea", "createdAt": "2020-07-01T12:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE3NDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE3NjU3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448176575", "bodyText": "I know this comment is not the focus of this PR, but if you can add the missing description, that would great.", "author": "astefan", "createdAt": "2020-07-01T07:42:00Z", "path": "x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/UriUtils.java", "diffHunk": "@@ -7,18 +7,32 @@\n \n import java.net.URI;\n import java.net.URISyntaxException;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n \n public final class UriUtils {\n     private UriUtils() {\n \n     }\n \n+    static final String HTTP_SCHEME = \"http\";\n+    static final String HTTPS_SCHEME = \"https\";\n+    static final String HTTP_PREFIX = HTTP_SCHEME + \"://\";\n+    static final String HTTPS_PREFIX = HTTPS_SCHEME + \"://\";\n+\n     /**\n      * Parses the URL provided by the user and", "originalCommit": "74a53b4d55123a3fa072c6c052d941d974f85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMDgzOA==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448320838", "bodyText": "Sure, makes sense.", "author": "bpintea", "createdAt": "2020-07-01T12:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE3NjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4MTExNw==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448181117", "bodyText": "Do we have a good/strong argument in favor of \"deactivating\" the redaction if URLs when the schema is uppercase and activating it when it's lowercase?\nWouldn't a URL parameter do the job, similar to validate.properties? Thoughts @costin @matriv ?", "author": "astefan", "createdAt": "2020-07-01T07:50:29Z", "path": "x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/UriUtils.java", "diffHunk": "@@ -42,42 +56,211 @@ public static URI parseURI(String connectionString, URI defaultURI) {\n         }\n     }\n \n-    private static URI parseWithNoScheme(String connectionString) {\n+    private static URI parseMaybeWithScheme(String connectionString, String defaultPrefix) {\n         URI uri;\n-        // check if URI can be parsed correctly without adding scheme\n-        // if the connection string is in format host:port or just host, the host is going to be null\n-        // if the connection string contains IPv6 localhost [::1] the parsing will fail\n-        URISyntaxException firstException = null;\n+        String c = connectionString.toLowerCase(Locale.ROOT);\n+        boolean hasAnHttpPrefix = c.startsWith(HTTP_PREFIX) || c.startsWith(HTTPS_PREFIX);\n         try {\n             uri = new URI(connectionString);\n-            if (uri.getHost() == null || uri.getScheme() == null) {\n-                uri = null;\n-            }\n         } catch (URISyntaxException e) {\n-            firstException = e;\n-            uri = null;\n+            // If the connection string contains no scheme plus an IP address with semicolon - like an IPv6 ([::1]), or an IPv4 plus port\n+            // (127.0.0.1:9200) - the URI parser will fail, as it'll try to interpret the pre-`:` chars as a scheme.\n+            if (hasAnHttpPrefix == false) {\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+            URISyntaxException s = CredentialsRedaction.redactedURISyntaxException(e);\n+            throw new IllegalArgumentException(\"Invalid connection configuration: \" + s.getMessage(), s);\n         }\n \n-        if (uri == null) {\n-            // We couldn't parse URI without adding scheme, let's try again with scheme this time\n-            try {\n-                return new URI(\"http://\" + connectionString);\n-            } catch (URISyntaxException e) {\n-                IllegalArgumentException ie =\n-                    new IllegalArgumentException(\"Invalid connection configuration [\" + connectionString + \"]: \" + e.getMessage(), e);\n-                if (firstException != null) {\n-                    ie.addSuppressed(firstException);\n+        if (hasAnHttpPrefix == false) {\n+            if (uri.getHost() != null) { // URI is valid and with a host, so there's a scheme (otherwise host==null), but just not HTTP(S)\n+                throw new IllegalArgumentException(\n+                    \"Invalid connection scheme [\" + uri.getScheme() + \"] configuration: only \" + HTTP_SCHEME + \" and \" + HTTPS_SCHEME\n+                        + \" protocols are supported\");\n+            }\n+            // no host and either (1) no scheme (like for input 'host') or (2) invalid scheme (produced by parsing 'user:pass@host' or\n+            // 'host:9200' or just erroneous: 'ftp:/?foo' etc.): try with a HTTP scheme\n+            if (connectionString.length() > 0) { // an empty string is a valid connection string\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+        }\n+\n+        return uri;\n+    }\n+\n+    public static class CredentialsRedaction {\n+        public static final Character REDACTION_CHAR = '*';\n+        private static final String USER_ATTR_NAME = \"user\";\n+        private static final String PASS_ATTR_NAME = \"password\";\n+\n+        // redacts the value of a named attribute in a given string, by finding the substring `attrName=`; everything following that is\n+        // considered as attribute's value.\n+        private static String redactAttributeInString(String string, String attrName, Character replacement) {\n+            String needle = attrName + \"=\";\n+            int attrIdx = string.toLowerCase(Locale.ROOT).indexOf(needle); // note: won't catch \"valid\" `=password[%20]+=` cases\n+            if (attrIdx >= 0) { // ex: `...=[value]password=foo...`\n+                int attrEndIdx = attrIdx + needle.length();\n+                return string.substring(0, attrEndIdx) + String.valueOf(replacement).repeat(string.length() - attrEndIdx);\n+            }\n+            return string;\n+        }\n+\n+        private static void redactValueForSimilarKey(String key, List<String> options, List<Map.Entry<String, String>> attrs,\n+                                                     Character replacement) {\n+            List<String> similar = StringUtils.findSimilar(key, options);\n+            for (String k : similar) {\n+                for (Map.Entry<String, String> e : attrs) {\n+                    if (e.getKey().equals(k)) {\n+                        e.setValue(String.valueOf(replacement).repeat(e.getValue().length()));\n+                    }\n                 }\n-                throw ie;\n             }\n-        } else {\n-            // We managed to parse URI and all necessary pieces are present, let's make sure the scheme is correct\n-            if (\"http\".equals(uri.getScheme()) == false && \"https\".equals(uri.getScheme()) == false) {\n-                throw new IllegalArgumentException(\n-                        \"Invalid connection configuration [\" + connectionString + \"]: Only http and https protocols are supported\");\n+        }\n+\n+        public static String redactCredentialsInRawUriQuery(String rawQuery, Character replacement) {\n+            List<Map.Entry<String, String>> attrs = new ArrayList<>();\n+            List<String> options = new ArrayList<>();\n+\n+            // break down the query in (key, value) tuples, redacting any malformed attribute values\n+            String key, value;\n+            for (String param : StringUtils.tokenize(rawQuery, \"&\")) {\n+                int eqIdx = param.indexOf('=');\n+                if (eqIdx <= 0) { // malformed param: no, or leading `=`: record entire param string as key and empty string as value\n+                    value = eqIdx < 0 ? null : StringUtils.EMPTY;\n+                    key = redactAttributeInString(param, USER_ATTR_NAME, replacement);\n+                    key = redactAttributeInString(key, PASS_ATTR_NAME, replacement);\n+                } else {\n+                    key = param.substring(0, eqIdx);\n+                    value = param.substring(eqIdx + 1);\n+                    if (value.indexOf('=') >= 0) { // `...&user=FOOpassword=BAR&...`\n+                        value = redactAttributeInString(value, USER_ATTR_NAME, replacement);\n+                        value = redactAttributeInString(value, PASS_ATTR_NAME, replacement);\n+                    }\n+                    options.add(key);\n+                }\n+                attrs.add(new AbstractMap.SimpleEntry<>(key, value));\n             }\n-            return uri;\n+\n+            // redact the credential attributes, as well as any other attribute that is similar to them, i.e. mistyped\n+            redactValueForSimilarKey(USER_ATTR_NAME, options, attrs, replacement);\n+            redactValueForSimilarKey(PASS_ATTR_NAME, options, attrs, replacement);\n+\n+            // re-construct the query\n+            StringBuilder sb = new StringBuilder(rawQuery.length());\n+            for (Map.Entry<String, String> a : attrs) {\n+                sb.append(\"&\");\n+                sb.append(a.getKey());\n+                if (a.getValue() != null) {\n+                    sb.append(\"=\");\n+                    sb.append(a.getValue());\n+                }\n+            }\n+            return sb.substring(1);\n         }\n+\n+        private static String editURI(URI uri, List<Map.Entry<Integer, Character>> faults, boolean hasPort) {\n+            StringBuilder sb = new StringBuilder();\n+            if (uri.getScheme() != null) {\n+                sb.append(uri.getScheme());\n+                sb.append(\"://\");\n+            }\n+            if (uri.getRawUserInfo() != null) {\n+                sb.append(\"\\0\".repeat(uri.getRawUserInfo().length()));\n+                if (uri.getHost() != null) {\n+                    sb.append('@');\n+                }\n+            }\n+            if (uri.getHost() != null) {\n+                sb.append(uri.getHost());\n+            }\n+            if (hasPort || uri.getPort() > 0) {\n+                sb.append(':');\n+            }\n+            if (uri.getPort() > 0) {\n+                sb.append(uri.getPort());\n+            }\n+            if (uri.getRawPath() != null) {\n+                sb.append(uri.getRawPath());\n+            }\n+            if (uri.getQuery() != null) {\n+                sb.append('?');\n+                // redact with the null character; this will later allow safe reinsertion of any character removed from the URI to make\n+                // it parsable\n+                sb.append(redactCredentialsInRawUriQuery(uri.getRawQuery(), '\\0'));\n+            }\n+            if (uri.getRawFragment() != null) {\n+                sb.append('#');\n+                sb.append(uri.getRawFragment());\n+            }\n+\n+            // reinsert any removed character back into the URI: if the reinsertion should be made between null characters, replace its\n+            // value with a null character, since it's part of the credential value\n+            Collections.reverse(faults);\n+            for (Map.Entry<Integer, Character> e : faults) {\n+                int idx = e.getKey();\n+                if (idx >= sb.length()) {\n+                    sb.append(e.getValue());\n+                } else {\n+                    sb.insert(idx,\n+                        (sb.charAt(idx) == '\\0' && (idx + 1 >= sb.length() || sb.charAt(idx + 1) == '\\0')) ? '\\0' : e.getValue());\n+                }\n+            }\n+\n+            StringBuilder ret = new StringBuilder();\n+            sb.chars().forEach(x -> ret.append(x == '\\0' ? REDACTION_CHAR : (char) x));\n+\n+            return ret.toString();\n+        }\n+\n+        private static String redactCredentialsInURLString(String urlString) {\n+            List<Map.Entry<Integer, Character>> faults = new ArrayList<>();\n+\n+            boolean hasPort = false;\n+            for (StringBuilder sb = new StringBuilder(urlString); sb.length() > 0; ) {\n+                try {\n+                    // parse as URL; ex. `http://ho~st` parses as URI, but with unparsable authority\n+                    URI uri = new URI(sb.toString()).parseServerAuthority();\n+                    return editURI(uri, faults, hasPort);\n+                } catch (URISyntaxException use) {\n+                    int idx = use.getIndex();\n+                    if (idx < 0 || idx >= sb.length()) {\n+                        break; // not a faulty character-related error\n+                    }\n+                    if (use.getReason().equals(\"Illegal character in port number\")) {\n+                        // if entire port part is broken (ex. `localhost:noDigit`), the trailing `:` will be lost in the resulting URI\n+                        hasPort = true;\n+                    }\n+                    faults.add(new AbstractMap.SimpleImmutableEntry<>(use.getIndex(), sb.charAt(idx)));\n+                    sb.deleteCharAt(idx);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public static String redactCredentialsInConnectionString(String connectionString) {\n+            if (connectionString.startsWith(HTTP_PREFIX.toUpperCase(Locale.ROOT))", "originalCommit": "74a53b4d55123a3fa072c6c052d941d974f85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMzMjU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448332596", "bodyText": "Do we have a good/strong argument in favor of \"deactivating\" the redaction if URLs when the schema is uppercase and activating it when it's lowercase?\n\nJust a small clarification: redaction is currently active in all cases, except an all-uppercase schema.\nAs @astefan pointed out, this can be an issue if the user provides it like that unknowingly initially (potentially generated all-uppercase by software). Hopefully this happens very rarely, but we can choose something else if we are concerned about it (like some HttP camelcase or even a completely different schema, though that might be a bit confusing).\n\nWouldn't a URL parameter do the job, similar to validate.properties?\n\nThe trick here would be to reliably recognise that parameter in case the URI itself is broken. We could also do a simple string scanning (lower_case_uri.contains(\"redaction=false\")) and hope for no false positives - should be indeed very unlikely -, but the downside of that is that the user would potentially no longer get the same error message if offsets change (which is however a possibility with current mechanism as well, in case the user didn't provide a schema in the first place), or they could introduce new errors.", "author": "bpintea", "createdAt": "2020-07-01T12:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4MTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM2MzkzNg==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448363936", "bodyText": "We would default the redaction parameter to true and if the the URL is broken and the parameter is not recognizable the URL sensitive data wouldn't leak anyway. If the user is interested in disabling the redaction step, then will look into the URL correctness anyway.", "author": "astefan", "createdAt": "2020-07-01T13:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4MTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM5Nzk0MA==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448397940", "bodyText": "Yep, that could also work.\nMyself I'm still biased towards the existing implementation as it's slightly simpler and doesn't require an extra param, but \"close to the fence\", so if anyone would have a swaying opinion I'll change to the above (or potentially new) suggestion. CC: @matriv @costin", "author": "bpintea", "createdAt": "2020-07-01T14:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4MTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQwMzcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448403727", "bodyText": "Personally I'd vote to keep it as is instead of introducing a new parameter. Do we have any experience/demand in the past for this uppercase URIs? To me seems like a super edge case and wouldn't invest too much to have the perfect handling for it.", "author": "matriv", "createdAt": "2020-07-01T14:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4MTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4OTMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448189335", "bodyText": "When can the idx be > sb.length()? And why the equality is not a valid use case to be redacted?", "author": "astefan", "createdAt": "2020-07-01T08:05:38Z", "path": "x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/UriUtils.java", "diffHunk": "@@ -42,42 +56,211 @@ public static URI parseURI(String connectionString, URI defaultURI) {\n         }\n     }\n \n-    private static URI parseWithNoScheme(String connectionString) {\n+    private static URI parseMaybeWithScheme(String connectionString, String defaultPrefix) {\n         URI uri;\n-        // check if URI can be parsed correctly without adding scheme\n-        // if the connection string is in format host:port or just host, the host is going to be null\n-        // if the connection string contains IPv6 localhost [::1] the parsing will fail\n-        URISyntaxException firstException = null;\n+        String c = connectionString.toLowerCase(Locale.ROOT);\n+        boolean hasAnHttpPrefix = c.startsWith(HTTP_PREFIX) || c.startsWith(HTTPS_PREFIX);\n         try {\n             uri = new URI(connectionString);\n-            if (uri.getHost() == null || uri.getScheme() == null) {\n-                uri = null;\n-            }\n         } catch (URISyntaxException e) {\n-            firstException = e;\n-            uri = null;\n+            // If the connection string contains no scheme plus an IP address with semicolon - like an IPv6 ([::1]), or an IPv4 plus port\n+            // (127.0.0.1:9200) - the URI parser will fail, as it'll try to interpret the pre-`:` chars as a scheme.\n+            if (hasAnHttpPrefix == false) {\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+            URISyntaxException s = CredentialsRedaction.redactedURISyntaxException(e);\n+            throw new IllegalArgumentException(\"Invalid connection configuration: \" + s.getMessage(), s);\n         }\n \n-        if (uri == null) {\n-            // We couldn't parse URI without adding scheme, let's try again with scheme this time\n-            try {\n-                return new URI(\"http://\" + connectionString);\n-            } catch (URISyntaxException e) {\n-                IllegalArgumentException ie =\n-                    new IllegalArgumentException(\"Invalid connection configuration [\" + connectionString + \"]: \" + e.getMessage(), e);\n-                if (firstException != null) {\n-                    ie.addSuppressed(firstException);\n+        if (hasAnHttpPrefix == false) {\n+            if (uri.getHost() != null) { // URI is valid and with a host, so there's a scheme (otherwise host==null), but just not HTTP(S)\n+                throw new IllegalArgumentException(\n+                    \"Invalid connection scheme [\" + uri.getScheme() + \"] configuration: only \" + HTTP_SCHEME + \" and \" + HTTPS_SCHEME\n+                        + \" protocols are supported\");\n+            }\n+            // no host and either (1) no scheme (like for input 'host') or (2) invalid scheme (produced by parsing 'user:pass@host' or\n+            // 'host:9200' or just erroneous: 'ftp:/?foo' etc.): try with a HTTP scheme\n+            if (connectionString.length() > 0) { // an empty string is a valid connection string\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+        }\n+\n+        return uri;\n+    }\n+\n+    public static class CredentialsRedaction {\n+        public static final Character REDACTION_CHAR = '*';\n+        private static final String USER_ATTR_NAME = \"user\";\n+        private static final String PASS_ATTR_NAME = \"password\";\n+\n+        // redacts the value of a named attribute in a given string, by finding the substring `attrName=`; everything following that is\n+        // considered as attribute's value.\n+        private static String redactAttributeInString(String string, String attrName, Character replacement) {\n+            String needle = attrName + \"=\";\n+            int attrIdx = string.toLowerCase(Locale.ROOT).indexOf(needle); // note: won't catch \"valid\" `=password[%20]+=` cases\n+            if (attrIdx >= 0) { // ex: `...=[value]password=foo...`\n+                int attrEndIdx = attrIdx + needle.length();\n+                return string.substring(0, attrEndIdx) + String.valueOf(replacement).repeat(string.length() - attrEndIdx);\n+            }\n+            return string;\n+        }\n+\n+        private static void redactValueForSimilarKey(String key, List<String> options, List<Map.Entry<String, String>> attrs,\n+                                                     Character replacement) {\n+            List<String> similar = StringUtils.findSimilar(key, options);\n+            for (String k : similar) {\n+                for (Map.Entry<String, String> e : attrs) {\n+                    if (e.getKey().equals(k)) {\n+                        e.setValue(String.valueOf(replacement).repeat(e.getValue().length()));\n+                    }\n                 }\n-                throw ie;\n             }\n-        } else {\n-            // We managed to parse URI and all necessary pieces are present, let's make sure the scheme is correct\n-            if (\"http\".equals(uri.getScheme()) == false && \"https\".equals(uri.getScheme()) == false) {\n-                throw new IllegalArgumentException(\n-                        \"Invalid connection configuration [\" + connectionString + \"]: Only http and https protocols are supported\");\n+        }\n+\n+        public static String redactCredentialsInRawUriQuery(String rawQuery, Character replacement) {\n+            List<Map.Entry<String, String>> attrs = new ArrayList<>();\n+            List<String> options = new ArrayList<>();\n+\n+            // break down the query in (key, value) tuples, redacting any malformed attribute values\n+            String key, value;\n+            for (String param : StringUtils.tokenize(rawQuery, \"&\")) {\n+                int eqIdx = param.indexOf('=');\n+                if (eqIdx <= 0) { // malformed param: no, or leading `=`: record entire param string as key and empty string as value\n+                    value = eqIdx < 0 ? null : StringUtils.EMPTY;\n+                    key = redactAttributeInString(param, USER_ATTR_NAME, replacement);\n+                    key = redactAttributeInString(key, PASS_ATTR_NAME, replacement);\n+                } else {\n+                    key = param.substring(0, eqIdx);\n+                    value = param.substring(eqIdx + 1);\n+                    if (value.indexOf('=') >= 0) { // `...&user=FOOpassword=BAR&...`\n+                        value = redactAttributeInString(value, USER_ATTR_NAME, replacement);\n+                        value = redactAttributeInString(value, PASS_ATTR_NAME, replacement);\n+                    }\n+                    options.add(key);\n+                }\n+                attrs.add(new AbstractMap.SimpleEntry<>(key, value));\n             }\n-            return uri;\n+\n+            // redact the credential attributes, as well as any other attribute that is similar to them, i.e. mistyped\n+            redactValueForSimilarKey(USER_ATTR_NAME, options, attrs, replacement);\n+            redactValueForSimilarKey(PASS_ATTR_NAME, options, attrs, replacement);\n+\n+            // re-construct the query\n+            StringBuilder sb = new StringBuilder(rawQuery.length());\n+            for (Map.Entry<String, String> a : attrs) {\n+                sb.append(\"&\");\n+                sb.append(a.getKey());\n+                if (a.getValue() != null) {\n+                    sb.append(\"=\");\n+                    sb.append(a.getValue());\n+                }\n+            }\n+            return sb.substring(1);\n         }\n+\n+        private static String editURI(URI uri, List<Map.Entry<Integer, Character>> faults, boolean hasPort) {\n+            StringBuilder sb = new StringBuilder();\n+            if (uri.getScheme() != null) {\n+                sb.append(uri.getScheme());\n+                sb.append(\"://\");\n+            }\n+            if (uri.getRawUserInfo() != null) {\n+                sb.append(\"\\0\".repeat(uri.getRawUserInfo().length()));\n+                if (uri.getHost() != null) {\n+                    sb.append('@');\n+                }\n+            }\n+            if (uri.getHost() != null) {\n+                sb.append(uri.getHost());\n+            }\n+            if (hasPort || uri.getPort() > 0) {\n+                sb.append(':');\n+            }\n+            if (uri.getPort() > 0) {\n+                sb.append(uri.getPort());\n+            }\n+            if (uri.getRawPath() != null) {\n+                sb.append(uri.getRawPath());\n+            }\n+            if (uri.getQuery() != null) {\n+                sb.append('?');\n+                // redact with the null character; this will later allow safe reinsertion of any character removed from the URI to make\n+                // it parsable\n+                sb.append(redactCredentialsInRawUriQuery(uri.getRawQuery(), '\\0'));\n+            }\n+            if (uri.getRawFragment() != null) {\n+                sb.append('#');\n+                sb.append(uri.getRawFragment());\n+            }\n+\n+            // reinsert any removed character back into the URI: if the reinsertion should be made between null characters, replace its\n+            // value with a null character, since it's part of the credential value\n+            Collections.reverse(faults);\n+            for (Map.Entry<Integer, Character> e : faults) {\n+                int idx = e.getKey();\n+                if (idx >= sb.length()) {\n+                    sb.append(e.getValue());\n+                } else {\n+                    sb.insert(idx,\n+                        (sb.charAt(idx) == '\\0' && (idx + 1 >= sb.length() || sb.charAt(idx + 1) == '\\0')) ? '\\0' : e.getValue());\n+                }\n+            }\n+\n+            StringBuilder ret = new StringBuilder();\n+            sb.chars().forEach(x -> ret.append(x == '\\0' ? REDACTION_CHAR : (char) x));\n+\n+            return ret.toString();\n+        }\n+\n+        private static String redactCredentialsInURLString(String urlString) {\n+            List<Map.Entry<Integer, Character>> faults = new ArrayList<>();\n+\n+            boolean hasPort = false;\n+            for (StringBuilder sb = new StringBuilder(urlString); sb.length() > 0; ) {\n+                try {\n+                    // parse as URL; ex. `http://ho~st` parses as URI, but with unparsable authority\n+                    URI uri = new URI(sb.toString()).parseServerAuthority();\n+                    return editURI(uri, faults, hasPort);\n+                } catch (URISyntaxException use) {\n+                    int idx = use.getIndex();\n+                    if (idx < 0 || idx >= sb.length()) {", "originalCommit": "74a53b4d55123a3fa072c6c052d941d974f85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMzcxNg==", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448323716", "bodyText": "When can the idx be > sb.length()?\n\nProbably never, but not sure what URISyntaxException can provide as \"valid\" value there.\n\nAnd why the equality is not a valid use case to be redacted?\n\nIn this case the index would fall outside the input string; for instance parsing \"http://\" as URI will return Expected authority at index 7: http://, for which the equality holds.", "author": "bpintea", "createdAt": "2020-07-01T12:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4OTMzNQ=="}], "type": "inlineReview"}, {"oid": "43874ae97837177f4829f03ce95b0663104b4b72", "url": "https://github.com/elastic/elasticsearch/commit/43874ae97837177f4829f03ce95b0663104b4b72", "message": "Address review comments\n\n- remove unused var;\n- complete code comment.", "committedDate": "2020-07-01T12:12:29Z", "type": "commit"}, {"oid": "9c9236871362f6375f86d71a227deace09b62245", "url": "https://github.com/elastic/elasticsearch/commit/9c9236871362f6375f86d71a227deace09b62245", "message": "Merge branch 'master' into enh/redact_credentials_in_invalid_uri", "committedDate": "2020-07-01T14:15:41Z", "type": "commit"}, {"oid": "cf2ae3a58b5908ade04b32acb0f92924b2566a98", "url": "https://github.com/elastic/elasticsearch/commit/cf2ae3a58b5908ade04b32acb0f92924b2566a98", "message": "Merge branch 'master' into enh/redact_credentials_in_invalid_uri", "committedDate": "2020-07-01T17:58:56Z", "type": "commit"}]}