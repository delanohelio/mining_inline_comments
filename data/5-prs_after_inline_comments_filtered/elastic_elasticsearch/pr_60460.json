{"pr_number": 60460, "pr_title": "Introduce integ tests for high disk watermark", "pr_createdAt": "2020-07-30T14:38:34Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60460", "timeline": [{"oid": "d36ab784dc4a66fc48880a240b5f7dbe14129263", "url": "https://github.com/elastic/elasticsearch/commit/d36ab784dc4a66fc48880a240b5f7dbe14129263", "message": "Introduce integ tests for high disk watermark\n\nAn important goal of the disk threshold decider is to ensure that nodes\nuse less disk space than the high watermark, and to take action if a\nnode ever exceeds this watermark. Today we do not have any\nintegration-style tests of this high-level behaviour. This commit\nintroduces a small test harness that can adjust the apparent size of the\ndisk and verify that the disk threshold decider moves shards around in\nresponse.", "committedDate": "2020-07-30T14:36:03Z", "type": "commit"}, {"oid": "02ce50039ef32f6cd591daaa50a79ed8ce32b2ae", "url": "https://github.com/elastic/elasticsearch/commit/02ce50039ef32f6cd591daaa50a79ed8ce32b2ae", "message": "Defeat the is-spinning-disk check", "committedDate": "2020-07-30T15:43:15Z", "type": "commit"}, {"oid": "ff6b96b64218a1b6aa9d0ac78ffb85509cc05653", "url": "https://github.com/elastic/elasticsearch/commit/ff6b96b64218a1b6aa9d0ac78ffb85509cc05653", "message": "More hacker", "committedDate": "2020-07-30T15:54:05Z", "type": "commit"}, {"oid": "dab520506715d7b5a085233c9a40761e17322530", "url": "https://github.com/elastic/elasticsearch/commit/dab520506715d7b5a085233c9a40761e17322530", "message": "Mock filesystem at suite level, don't replace it every test", "committedDate": "2020-08-05T08:42:13Z", "type": "commit"}, {"oid": "53194c9f10eb367856617f4c046e23ad35d28ad5", "url": "https://github.com/elastic/elasticsearch/commit/53194c9f10eb367856617f4c046e23ad35d28ad5", "message": "Merge branch 'master' into 2020-07-30-high-watermark-integ-tests-WIP", "committedDate": "2020-08-05T08:43:22Z", "type": "commit"}, {"oid": "946e2b6e54f0148af499fa495965e99282f69967", "url": "https://github.com/elastic/elasticsearch/commit/946e2b6e54f0148af499fa495965e99282f69967", "message": "Wrong IOUtils", "committedDate": "2020-08-05T08:59:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwNjQ1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60460#discussion_r466206452", "bodyText": "why the force-merge?", "author": "ywelsch", "createdAt": "2020-08-06T07:39:52Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderIT.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.routing.allocation.decider;\n+\n+import org.apache.lucene.mockfile.FilterFileStore;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.apache.lucene.mockfile.FilterPath;\n+import org.apache.lucene.util.Constants;\n+import org.elasticsearch.action.admin.indices.stats.ShardStats;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.ClusterInfoService;\n+import org.elasticsearch.cluster.InternalClusterInfoService;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.fs.FsService;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.util.concurrent.ConcurrentCollections.newConcurrentMap;\n+import static org.elasticsearch.index.store.Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.anyOf;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n+public class DiskThresholdDeciderIT extends ESIntegTestCase {\n+\n+    private static TestFileSystemProvider fileSystemProvider;\n+\n+    @BeforeClass\n+    public static void installFilesystemProvider() {\n+        assertNull(fileSystemProvider);\n+        fileSystemProvider = new TestFileSystemProvider(PathUtils.getDefaultFileSystem(), createTempDir());\n+        PathUtilsForTesting.installMock(fileSystemProvider.getFileSystem(null));\n+    }\n+\n+    @AfterClass\n+    public static void removeFilesystemProvider() {\n+        fileSystemProvider = null;\n+        // ESIntegTestCase takes care of tearing down the mock file system\n+    }\n+\n+    @Before\n+    public void clearTrackedPaths() throws IOException {\n+        fileSystemProvider.clearTrackedPaths();\n+    }\n+\n+    private static final long WATERMARK_BYTES = new ByteSizeValue(10, ByteSizeUnit.KB).getBytes();\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        final Path dataPath = fileSystemProvider.getRootDir().resolve(\"node-\" + nodeOrdinal);\n+        try {\n+            Files.createDirectories(dataPath);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"unexpected\", e);\n+        }\n+        fileSystemProvider.addTrackedPath(dataPath);\n+        return Settings.builder()\n+                .put(super.nodeSettings(nodeOrdinal))\n+                .put(Environment.PATH_DATA_SETTING.getKey(), dataPath)\n+                .put(FsService.ALWAYS_REFRESH_SETTING.getKey(), true)\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), \"0b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(), \"0ms\")\n+                .build();\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return List.of(InternalSettingsPlugin.class);\n+    }\n+\n+    public void testHighWatermarkNotExceeded() throws InterruptedException {\n+        internalCluster().startMasterOnlyNode();\n+        internalCluster().startDataOnlyNode();\n+        final String dataNodeName = internalCluster().startDataOnlyNode();\n+\n+        final InternalClusterInfoService clusterInfoService\n+                = (InternalClusterInfoService) internalCluster().getMasterNodeInstance(ClusterInfoService.class);\n+        internalCluster().getMasterNodeInstance(ClusterService.class).addListener(event -> clusterInfoService.refresh());\n+\n+        final String dataNode0Id = internalCluster().getInstance(NodeEnvironment.class, dataNodeName).nodeId();\n+        final Path dataNode0Path = internalCluster().getInstance(Environment.class, dataNodeName).dataFiles()[0];\n+\n+        createIndex(\"test\", Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 6)\n+                .put(INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), \"0ms\")\n+                .build());\n+        final long minShardSize = createReasonableSizedShards();\n+\n+        // reduce disk size of node 0 so that no shards fit below the high watermark, forcing all shards onto the other data node\n+        // (subtract the translog size since the disk threshold decider ignores this and may therefore move the shard back again)\n+        fileSystemProvider.getTestFileStore(dataNode0Path).setTotalSpace(minShardSize + WATERMARK_BYTES - 1L);\n+        refreshDiskUsage();\n+        assertThat(getShardRoutings(dataNode0Id), empty());\n+\n+        // increase disk size of node 0 to allow just enough room for one shard, and check that it's rebalanced back\n+        fileSystemProvider.getTestFileStore(dataNode0Path).setTotalSpace(minShardSize + WATERMARK_BYTES + 1L);\n+        refreshDiskUsage();\n+        assertThat(getShardRoutings(dataNode0Id), hasSize(1));\n+    }\n+\n+    private Set<ShardRouting> getShardRoutings(String nodeId) {\n+        final Set<ShardRouting> shardRoutings = new HashSet<>();\n+        for (IndexShardRoutingTable indexShardRoutingTable : client().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .get().getState().getRoutingTable().index(\"test\")) {\n+            for (ShardRouting shard : indexShardRoutingTable.shards()) {\n+                assertThat(shard.state(), equalTo(ShardRoutingState.STARTED));\n+                if (shard.currentNodeId().equals(nodeId)) {\n+                    shardRoutings.add(shard);\n+                }\n+            }\n+        }\n+        return shardRoutings;\n+    }\n+\n+    /**\n+     * Index documents until all the shards are at least WATERMARK_BYTES in size, and return the size of the smallest shard\n+     */\n+    private long createReasonableSizedShards() throws InterruptedException {\n+        while (true) {\n+            final IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[scaledRandomIntBetween(100, 10000)];\n+            for (int i = 0; i < indexRequestBuilders.length; i++) {\n+                indexRequestBuilders[i] = client().prepareIndex(\"test\").setSource(\"field\", randomAlphaOfLength(10));\n+            }\n+            indexRandom(true, indexRequestBuilders);\n+            forceMerge();", "originalCommit": "946e2b6e54f0148af499fa495965e99282f69967", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3NjM1OA==", "url": "https://github.com/elastic/elasticsearch/pull/60460#discussion_r483576358", "bodyText": "seems not to work otherwise. Not really relevant whether or not we  force-merge, so I left as is", "author": "ywelsch", "createdAt": "2020-09-04T12:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwNjQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwNzEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/60460#discussion_r466207126", "bodyText": "can we somehow only conditionally do this reroute here, i.e.  if all nodes under low watermark?", "author": "ywelsch", "createdAt": "2020-08-06T07:41:03Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderIT.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.routing.allocation.decider;\n+\n+import org.apache.lucene.mockfile.FilterFileStore;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.apache.lucene.mockfile.FilterPath;\n+import org.apache.lucene.util.Constants;\n+import org.elasticsearch.action.admin.indices.stats.ShardStats;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.ClusterInfoService;\n+import org.elasticsearch.cluster.InternalClusterInfoService;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.fs.FsService;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.util.concurrent.ConcurrentCollections.newConcurrentMap;\n+import static org.elasticsearch.index.store.Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.anyOf;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n+public class DiskThresholdDeciderIT extends ESIntegTestCase {\n+\n+    private static TestFileSystemProvider fileSystemProvider;\n+\n+    @BeforeClass\n+    public static void installFilesystemProvider() {\n+        assertNull(fileSystemProvider);\n+        fileSystemProvider = new TestFileSystemProvider(PathUtils.getDefaultFileSystem(), createTempDir());\n+        PathUtilsForTesting.installMock(fileSystemProvider.getFileSystem(null));\n+    }\n+\n+    @AfterClass\n+    public static void removeFilesystemProvider() {\n+        fileSystemProvider = null;\n+        // ESIntegTestCase takes care of tearing down the mock file system\n+    }\n+\n+    @Before\n+    public void clearTrackedPaths() throws IOException {\n+        fileSystemProvider.clearTrackedPaths();\n+    }\n+\n+    private static final long WATERMARK_BYTES = new ByteSizeValue(10, ByteSizeUnit.KB).getBytes();\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        final Path dataPath = fileSystemProvider.getRootDir().resolve(\"node-\" + nodeOrdinal);\n+        try {\n+            Files.createDirectories(dataPath);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"unexpected\", e);\n+        }\n+        fileSystemProvider.addTrackedPath(dataPath);\n+        return Settings.builder()\n+                .put(super.nodeSettings(nodeOrdinal))\n+                .put(Environment.PATH_DATA_SETTING.getKey(), dataPath)\n+                .put(FsService.ALWAYS_REFRESH_SETTING.getKey(), true)\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), \"0b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(), \"0ms\")\n+                .build();\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return List.of(InternalSettingsPlugin.class);\n+    }\n+\n+    public void testHighWatermarkNotExceeded() throws InterruptedException {\n+        internalCluster().startMasterOnlyNode();\n+        internalCluster().startDataOnlyNode();\n+        final String dataNodeName = internalCluster().startDataOnlyNode();\n+\n+        final InternalClusterInfoService clusterInfoService\n+                = (InternalClusterInfoService) internalCluster().getMasterNodeInstance(ClusterInfoService.class);\n+        internalCluster().getMasterNodeInstance(ClusterService.class).addListener(event -> clusterInfoService.refresh());\n+\n+        final String dataNode0Id = internalCluster().getInstance(NodeEnvironment.class, dataNodeName).nodeId();\n+        final Path dataNode0Path = internalCluster().getInstance(Environment.class, dataNodeName).dataFiles()[0];\n+\n+        createIndex(\"test\", Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 6)\n+                .put(INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), \"0ms\")\n+                .build());\n+        final long minShardSize = createReasonableSizedShards();\n+\n+        // reduce disk size of node 0 so that no shards fit below the high watermark, forcing all shards onto the other data node\n+        // (subtract the translog size since the disk threshold decider ignores this and may therefore move the shard back again)\n+        fileSystemProvider.getTestFileStore(dataNode0Path).setTotalSpace(minShardSize + WATERMARK_BYTES - 1L);\n+        refreshDiskUsage();\n+        assertThat(getShardRoutings(dataNode0Id), empty());\n+\n+        // increase disk size of node 0 to allow just enough room for one shard, and check that it's rebalanced back\n+        fileSystemProvider.getTestFileStore(dataNode0Path).setTotalSpace(minShardSize + WATERMARK_BYTES + 1L);\n+        refreshDiskUsage();\n+        assertThat(getShardRoutings(dataNode0Id), hasSize(1));\n+    }\n+\n+    private Set<ShardRouting> getShardRoutings(String nodeId) {\n+        final Set<ShardRouting> shardRoutings = new HashSet<>();\n+        for (IndexShardRoutingTable indexShardRoutingTable : client().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .get().getState().getRoutingTable().index(\"test\")) {\n+            for (ShardRouting shard : indexShardRoutingTable.shards()) {\n+                assertThat(shard.state(), equalTo(ShardRoutingState.STARTED));\n+                if (shard.currentNodeId().equals(nodeId)) {\n+                    shardRoutings.add(shard);\n+                }\n+            }\n+        }\n+        return shardRoutings;\n+    }\n+\n+    /**\n+     * Index documents until all the shards are at least WATERMARK_BYTES in size, and return the size of the smallest shard\n+     */\n+    private long createReasonableSizedShards() throws InterruptedException {\n+        while (true) {\n+            final IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[scaledRandomIntBetween(100, 10000)];\n+            for (int i = 0; i < indexRequestBuilders.length; i++) {\n+                indexRequestBuilders[i] = client().prepareIndex(\"test\").setSource(\"field\", randomAlphaOfLength(10));\n+            }\n+            indexRandom(true, indexRequestBuilders);\n+            forceMerge();\n+            refresh();\n+\n+            final ShardStats[] shardStatses = client().admin().indices().prepareStats(\"test\")\n+                    .clear().setStore(true).setTranslog(true).get().getShards();\n+            final long[] shardSizes = new long[shardStatses.length];\n+            for (ShardStats shardStats : shardStatses) {\n+                shardSizes[shardStats.getShardRouting().id()] = shardStats.getStats().getStore().sizeInBytes();\n+            }\n+\n+            final long minShardSize = Arrays.stream(shardSizes).min().orElseThrow(() -> new AssertionError(\"no shards\"));\n+            if (minShardSize > WATERMARK_BYTES) {\n+                return minShardSize;\n+            }\n+        }\n+    }\n+\n+    private void refreshDiskUsage() {\n+        ((InternalClusterInfoService) internalCluster().getMasterNodeInstance(ClusterInfoService.class)).refresh();\n+        // if the nodes were all under the low watermark already (but unbalanced) then a change in the disk usage doesn't trigger a reroute\n+        // even though it's now possible to achieve better balance, so we have to do an explicit reroute. TODO fix this?\n+        assertAcked(client().admin().cluster().prepareReroute());", "originalCommit": "946e2b6e54f0148af499fa495965e99282f69967", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwOTI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60460#discussion_r466209252", "bodyText": "Instead of excluding _state and  translog path, should we select the index folder explicitly? Or  assert that  there are  no other paths?", "author": "ywelsch", "createdAt": "2020-08-06T07:45:12Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderIT.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.routing.allocation.decider;\n+\n+import org.apache.lucene.mockfile.FilterFileStore;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.apache.lucene.mockfile.FilterPath;\n+import org.apache.lucene.util.Constants;\n+import org.elasticsearch.action.admin.indices.stats.ShardStats;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.ClusterInfoService;\n+import org.elasticsearch.cluster.InternalClusterInfoService;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.fs.FsService;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.util.concurrent.ConcurrentCollections.newConcurrentMap;\n+import static org.elasticsearch.index.store.Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.anyOf;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n+public class DiskThresholdDeciderIT extends ESIntegTestCase {\n+\n+    private static TestFileSystemProvider fileSystemProvider;\n+\n+    @BeforeClass\n+    public static void installFilesystemProvider() {\n+        assertNull(fileSystemProvider);\n+        fileSystemProvider = new TestFileSystemProvider(PathUtils.getDefaultFileSystem(), createTempDir());\n+        PathUtilsForTesting.installMock(fileSystemProvider.getFileSystem(null));\n+    }\n+\n+    @AfterClass\n+    public static void removeFilesystemProvider() {\n+        fileSystemProvider = null;\n+        // ESIntegTestCase takes care of tearing down the mock file system\n+    }\n+\n+    @Before\n+    public void clearTrackedPaths() throws IOException {\n+        fileSystemProvider.clearTrackedPaths();\n+    }\n+\n+    private static final long WATERMARK_BYTES = new ByteSizeValue(10, ByteSizeUnit.KB).getBytes();\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        final Path dataPath = fileSystemProvider.getRootDir().resolve(\"node-\" + nodeOrdinal);\n+        try {\n+            Files.createDirectories(dataPath);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"unexpected\", e);\n+        }\n+        fileSystemProvider.addTrackedPath(dataPath);\n+        return Settings.builder()\n+                .put(super.nodeSettings(nodeOrdinal))\n+                .put(Environment.PATH_DATA_SETTING.getKey(), dataPath)\n+                .put(FsService.ALWAYS_REFRESH_SETTING.getKey(), true)\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), \"0b\")\n+                .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(), \"0ms\")\n+                .build();\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return List.of(InternalSettingsPlugin.class);\n+    }\n+\n+    public void testHighWatermarkNotExceeded() throws InterruptedException {\n+        internalCluster().startMasterOnlyNode();\n+        internalCluster().startDataOnlyNode();\n+        final String dataNodeName = internalCluster().startDataOnlyNode();\n+\n+        final InternalClusterInfoService clusterInfoService\n+                = (InternalClusterInfoService) internalCluster().getMasterNodeInstance(ClusterInfoService.class);\n+        internalCluster().getMasterNodeInstance(ClusterService.class).addListener(event -> clusterInfoService.refresh());\n+\n+        final String dataNode0Id = internalCluster().getInstance(NodeEnvironment.class, dataNodeName).nodeId();\n+        final Path dataNode0Path = internalCluster().getInstance(Environment.class, dataNodeName).dataFiles()[0];\n+\n+        createIndex(\"test\", Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 6)\n+                .put(INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), \"0ms\")\n+                .build());\n+        final long minShardSize = createReasonableSizedShards();\n+\n+        // reduce disk size of node 0 so that no shards fit below the high watermark, forcing all shards onto the other data node\n+        // (subtract the translog size since the disk threshold decider ignores this and may therefore move the shard back again)\n+        fileSystemProvider.getTestFileStore(dataNode0Path).setTotalSpace(minShardSize + WATERMARK_BYTES - 1L);\n+        refreshDiskUsage();\n+        assertThat(getShardRoutings(dataNode0Id), empty());\n+\n+        // increase disk size of node 0 to allow just enough room for one shard, and check that it's rebalanced back\n+        fileSystemProvider.getTestFileStore(dataNode0Path).setTotalSpace(minShardSize + WATERMARK_BYTES + 1L);\n+        refreshDiskUsage();\n+        assertThat(getShardRoutings(dataNode0Id), hasSize(1));\n+    }\n+\n+    private Set<ShardRouting> getShardRoutings(String nodeId) {\n+        final Set<ShardRouting> shardRoutings = new HashSet<>();\n+        for (IndexShardRoutingTable indexShardRoutingTable : client().admin().cluster().prepareState().clear().setRoutingTable(true)\n+                .get().getState().getRoutingTable().index(\"test\")) {\n+            for (ShardRouting shard : indexShardRoutingTable.shards()) {\n+                assertThat(shard.state(), equalTo(ShardRoutingState.STARTED));\n+                if (shard.currentNodeId().equals(nodeId)) {\n+                    shardRoutings.add(shard);\n+                }\n+            }\n+        }\n+        return shardRoutings;\n+    }\n+\n+    /**\n+     * Index documents until all the shards are at least WATERMARK_BYTES in size, and return the size of the smallest shard\n+     */\n+    private long createReasonableSizedShards() throws InterruptedException {\n+        while (true) {\n+            final IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[scaledRandomIntBetween(100, 10000)];\n+            for (int i = 0; i < indexRequestBuilders.length; i++) {\n+                indexRequestBuilders[i] = client().prepareIndex(\"test\").setSource(\"field\", randomAlphaOfLength(10));\n+            }\n+            indexRandom(true, indexRequestBuilders);\n+            forceMerge();\n+            refresh();\n+\n+            final ShardStats[] shardStatses = client().admin().indices().prepareStats(\"test\")\n+                    .clear().setStore(true).setTranslog(true).get().getShards();\n+            final long[] shardSizes = new long[shardStatses.length];\n+            for (ShardStats shardStats : shardStatses) {\n+                shardSizes[shardStats.getShardRouting().id()] = shardStats.getStats().getStore().sizeInBytes();\n+            }\n+\n+            final long minShardSize = Arrays.stream(shardSizes).min().orElseThrow(() -> new AssertionError(\"no shards\"));\n+            if (minShardSize > WATERMARK_BYTES) {\n+                return minShardSize;\n+            }\n+        }\n+    }\n+\n+    private void refreshDiskUsage() {\n+        ((InternalClusterInfoService) internalCluster().getMasterNodeInstance(ClusterInfoService.class)).refresh();\n+        // if the nodes were all under the low watermark already (but unbalanced) then a change in the disk usage doesn't trigger a reroute\n+        // even though it's now possible to achieve better balance, so we have to do an explicit reroute. TODO fix this?\n+        assertAcked(client().admin().cluster().prepareReroute());\n+        assertFalse(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID)\n+                .setWaitForNoRelocatingShards(true)\n+                .setWaitForNoInitializingShards(true).get().isTimedOut());\n+    }\n+\n+    private static class TestFileStore extends FilterFileStore {\n+\n+        private final Path path;\n+\n+        private volatile long totalSpace = -1;\n+\n+        TestFileStore(FileStore delegate, String scheme, Path path) {\n+            super(delegate, scheme);\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public String name() {\n+            return \"fake\"; // Lucene's is-spinning-disk check expects the device name here\n+        }\n+\n+        @Override\n+        public long getTotalSpace() throws IOException {\n+            final long totalSpace = this.totalSpace;\n+            if (totalSpace == -1) {\n+                return super.getTotalSpace();\n+            } else {\n+                return totalSpace;\n+            }\n+        }\n+\n+        public void setTotalSpace(long totalSpace) {\n+            assertThat(totalSpace, anyOf(is(-1L), greaterThan(0L)));\n+            this.totalSpace = totalSpace;\n+        }\n+\n+        @Override\n+        public long getUsableSpace() throws IOException {\n+            final long totalSpace = this.totalSpace;\n+            if (totalSpace == -1) {\n+                return super.getUsableSpace();\n+            } else {\n+                return Math.max(0L, totalSpace - getTotalFileSize(path));\n+            }\n+        }\n+\n+        @Override\n+        public long getUnallocatedSpace() throws IOException {\n+            final long totalSpace = this.totalSpace;\n+            if (totalSpace == -1) {\n+                return super.getUnallocatedSpace();\n+            } else {\n+                return Math.max(0L, totalSpace - getTotalFileSize(path));\n+            }\n+        }\n+\n+        private static long getTotalFileSize(Path path) throws IOException {\n+            if (Files.isRegularFile(path)) {\n+                try {\n+                    return Files.size(path);\n+                } catch (NoSuchFileException | FileNotFoundException e) {\n+                    // probably removed\n+                    return 0L;\n+                }\n+            } else if (path.getFileName().toString().equals(\"_state\") || path.getFileName().toString().equals(\"translog\")) {", "originalCommit": "946e2b6e54f0148af499fa495965e99282f69967", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3NjY3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60460#discussion_r483576676", "bodyText": "we recursively step into these directories from the root path. including folder is therefore  much trickier", "author": "ywelsch", "createdAt": "2020-09-04T12:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwOTI1Mg=="}], "type": "inlineReview"}, {"oid": "cd4bc074fbaa667c05bf6ccd2c5236f3659a6a0e", "url": "https://github.com/elastic/elasticsearch/commit/cd4bc074fbaa667c05bf6ccd2c5236f3659a6a0e", "message": "Merge remote-tracking branch 'elastic/master' into high-disk-tests", "committedDate": "2020-09-03T15:13:30Z", "type": "commit"}, {"oid": "4a40d5af10418fa3d58b805a2c7fb4fcca7d2ae5", "url": "https://github.com/elastic/elasticsearch/commit/4a40d5af10418fa3d58b805a2c7fb4fcca7d2ae5", "message": "Fix issue with overriding filesystem\n\nWhen tests were run in a loop, e.g. using\n\n./gradlew ':server:internalClusterTest' --tests \"org.elasticsearch.cluster.routing.allocation.decider.DiskThresholdDeciderIT.testHighWatermarkNotExceeded\" -Dtests.seed=CBF5914690DC5CAC -Dtests.security.manager=true -Dtests.jvms=4 -Dtests.locale=de-CH -Dtests.timezone=Asia/Chungking -Dtests.iters=2 -Dtests.failfast=true\n\nthey would fail due to the way filesystem are overridden, interfering with the filesystem setup done by ESTestCase", "committedDate": "2020-09-03T15:25:39Z", "type": "commit"}, {"oid": "14a8147df637da53d3f88ba2a235e84aacc1a174", "url": "https://github.com/elastic/elasticsearch/commit/14a8147df637da53d3f88ba2a235e84aacc1a174", "message": "conditionally reroute", "committedDate": "2020-09-04T12:04:28Z", "type": "commit"}, {"oid": "6ca2b00a67096139fd17b0aa561b43fa11eb4655", "url": "https://github.com/elastic/elasticsearch/commit/6ca2b00a67096139fd17b0aa561b43fa11eb4655", "message": "Merge remote-tracking branch 'elastic/master' into high-disk-tests", "committedDate": "2020-09-04T12:12:48Z", "type": "commit"}]}