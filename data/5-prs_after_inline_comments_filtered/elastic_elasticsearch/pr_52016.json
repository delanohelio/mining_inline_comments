{"pr_number": 52016, "pr_title": "Fix a DST error in date_histogram", "pr_createdAt": "2020-02-06T21:37:03Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52016", "timeline": [{"oid": "b6fd9be2edbc6d41e0a4590aae4970d23f15cb5d", "url": "https://github.com/elastic/elasticsearch/commit/b6fd9be2edbc6d41e0a4590aae4970d23f15cb5d", "message": "Fix a DST error in date_histogram\n\nWhen `date_histogram` attempts to optimize itself it for a particular\ntime zone it checks to see if the entire shard is within the same\n\"transition\". Most time zone transition once every size months or\nthereabouts so the optimization can usually kicks in.\n\n*But* it crashes when you attempt feed it a time zone who's last DST\ntransition was before epoch. The reason for this is a little twisted:\nbefore this patch it'd find the next and previous transitions in\nmilliseconds since epoch. Then it'd cast them to `Long`s and pass them\ninto the `DateFieldType` to check if the shard's contents were within\nthe range. The trouble is they are then converted to `String`s which are\n*then* parsed back to `Instant`s which are then convertd to `long`s. And\nthe parser doesn't like most negative numbers. And everything before\nepoch is negative.\n\nThis change removes the\n`long` -> `Long` -> `String` -> `Instant` -> `long` chain in favor of\npassing the `long`s directly into the `DateFieldType`. Sadly, this means\nthat `MappedFieldType` gets a `long` specialized implementation of\n`isFieldWithinQuery` which is a little lame, but given that we always\ncall it with a long in this context it feels like the lesser of two\nevils. Not because it is more efficient. It is a little. No. This is the\nless evil way to solve this problem because it is less confusing to\ntrace the execution. The parsing code is fairly complex and we can just\nskip it entirely because we already *have* longs.\n\nCloses #50265", "committedDate": "2020-02-06T21:27:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5ODU4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52016#discussion_r376098582", "bodyText": "I think you mean they're always longs?", "author": "not-napoleon", "createdAt": "2020-02-06T21:43:33Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -419,10 +419,27 @@ public IntervalsSource intervals(String query, int max_gaps, boolean ordered,\n      *  {@link Relation#INTERSECTS}, which is always fine to return when there is\n      *  no way to check whether values are actually within bounds. */\n     public Relation isFieldWithinQuery(\n-        IndexReader reader,\n-        Object from, Object to,\n-        boolean includeLower, boolean includeUpper,\n-        ZoneId timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {\n+            IndexReader reader,\n+            Object from, Object to,\n+            boolean includeLower, boolean includeUpper,\n+            ZoneId timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {\n+        return Relation.INTERSECTS;\n+    }\n+\n+    /**\n+     * Return whether all values of the given {@link IndexReader} are within the range,\n+     * outside the range or cross the range. The default implementation returns\n+     * {@link Relation#INTERSECTS}, which is always fine to return when there is\n+     * no way to check whether values are actually within bounds.\n+     *\n+     * Use this instead of\n+     * {@link #isFieldWithinQuery(IndexReader, Object, Object, boolean, boolean, ZoneId, DateMathParser, QueryRewriteContext)}\n+     * when you *know* the {@code fromInclusive} and {@code toInclusive} are always\n+     * floats.", "originalCommit": "b6fd9be2edbc6d41e0a4590aae4970d23f15cb5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwMTI0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52016#discussion_r376101246", "bodyText": "+1", "author": "nik9000", "createdAt": "2020-02-06T21:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5ODU4Mg=="}], "type": "inlineReview"}, {"oid": "ab6fb90198d44cd0515ca462b502615ac9266e96", "url": "https://github.com/elastic/elasticsearch/commit/ab6fb90198d44cd0515ca462b502615ac9266e96", "message": "Can't keep my types strait", "committedDate": "2020-02-06T21:49:17Z", "type": "commit"}, {"oid": "b8cc224045aad93c1da4083d0ece84a906437630", "url": "https://github.com/elastic/elasticsearch/commit/b8cc224045aad93c1da4083d0ece84a906437630", "message": "Merge branch 'master' into no_dst", "committedDate": "2020-02-10T19:31:29Z", "type": "commit"}, {"oid": "74e9463674530223a03c6e7bb15197f6a8ad7cdc", "url": "https://github.com/elastic/elasticsearch/commit/74e9463674530223a03c6e7bb15197f6a8ad7cdc", "message": "Update from feedback", "committedDate": "2020-02-10T20:00:19Z", "type": "commit"}, {"oid": "53355f00d1db8e322685484bf3f40101843be7af", "url": "https://github.com/elastic/elasticsearch/commit/53355f00d1db8e322685484bf3f40101843be7af", "message": "Handle nanos", "committedDate": "2020-02-11T14:38:36Z", "type": "commit"}, {"oid": "5a1c96356aa02a0788dbf4f1f3b11e9dd4c32619", "url": "https://github.com/elastic/elasticsearch/commit/5a1c96356aa02a0788dbf4f1f3b11e9dd4c32619", "message": "Merge branch 'master' into no_dst", "committedDate": "2020-02-11T16:06:55Z", "type": "commit"}]}