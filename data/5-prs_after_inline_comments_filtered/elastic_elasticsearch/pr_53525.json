{"pr_number": 53525, "pr_title": "SQL: add support for index aliases for SYS COLUMNS command", "pr_createdAt": "2020-03-13T00:03:32Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53525", "timeline": [{"oid": "947e5010125f25a5f1ab8bf6f0494ea73fde14a6", "url": "https://github.com/elastic/elasticsearch/commit/947e5010125f25a5f1ab8bf6f0494ea73fde14a6", "message": "Add support for index aliases for SYS COLUMNS command", "committedDate": "2020-03-12T23:36:15Z", "type": "commit"}, {"oid": "dabcccf6804d2ebd8334c74ba2800d55bd054311", "url": "https://github.com/elastic/elasticsearch/commit/dabcccf6804d2ebd8334c74ba2800d55bd054311", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-12T23:38:34Z", "type": "commit"}, {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da", "url": "https://github.com/elastic/elasticsearch/commit/3aa01f30490b36d998aa965c3c23acb32e8717da", "message": "Update to test after branch update", "committedDate": "2020-03-12T23:52:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNTEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392115136", "bodyText": "The IndicesOption depends on whether includeFrozen is true or not.", "author": "costin", "createdAt": "2020-03-13T09:28:04Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {\n+                            String[] indicesList = response.getIndices();\n+                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n+                                    .local(true)\n+                                    .aliases(\"*\")\n+                                    .indices(indicesList)\n+                                    .indicesOptions(IndicesOptions.lenientExpandOpen());", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNTg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392115876", "bodyText": "Maybe use static imports on ActionListener to make the code a bit more readable.", "author": "costin", "createdAt": "2020-03-13T09:29:27Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117147", "bodyText": "Small nit - maybe it makes sense to extract this method into a separate one - it's not reusable but it might make the call easier to read:\nclient.fieldCaps(fieldRequest, wrap(response -> getIndexAliases(response, wrap(aliases -> ...))", "author": "costin", "createdAt": "2020-03-13T09:32:03Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzQyOA==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117428", "bodyText": "Why use ImmutableOpenMap instead of Map ?", "author": "costin", "createdAt": "2020-03-13T09:32:45Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117635", "bodyText": "What was wrong with Map ?", "author": "costin", "createdAt": "2020-03-13T09:33:08Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {\n+                            String[] indicesList = response.getIndices();\n+                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n+                                    .local(true)\n+                                    .aliases(\"*\")\n+                                    .indices(indicesList)\n+                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n+                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n+                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n+                                        aliases.getAliases())),\n+                                ex -> {\n+                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n+                                    } else {\n+                                        listener.onFailure(ex);\n+                                    }\n+                                }));\n+                        },\n                         listener::onFailure));\n \n     }\n     \n-    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String indexPattern, String javaRegex, String[] indexNames,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps) {\n-        return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, Function.identity(), (s, cap) -> null);\n+    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjQ0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392352443", "bodyText": "ImmutableOpenMap is not actually a java.util.Map.", "author": "astefan", "createdAt": "2020-03-13T16:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExODY4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392118683", "bodyText": "The size is incorrect - use CollectionUtils.mapSize", "author": "costin", "createdAt": "2020-03-13T09:35:15Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new LinkedHashSet<>();\n+        if (aliases != null) {\n+            Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n+            while (iterator.hasNext()) {\n+                for(AliasMetaData alias : iterator.next().value) {\n+                    resolvedAliases.add(alias.getAlias());\n+                }\n+            }\n+        }\n+\n+        List<String> resolvedIndices = new ArrayList<>(asList(indexNames));\n+        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size() + resolvedAliases.size());", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392119122", "bodyText": "Is it okay to put all aliases in the same map?", "author": "costin", "createdAt": "2020-03-13T09:36:08Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new LinkedHashSet<>();", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjEyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392352121", "bodyText": "With this I wanted to count them and create a list of indices and aliases appropriately sized.", "author": "astefan", "createdAt": "2020-03-13T16:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392120962", "bodyText": "this creates a HashSet regardless of the key presence - better to do the check", "author": "costin", "createdAt": "2020-03-13T09:39:58Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -590,4 +646,134 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>();\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                typesErrors.putIfAbsent(aliasName, new HashSet<>());", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAyNzczMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393027731", "bodyText": "Actually, this was intended like this.  See this line where the field type for this field belonging to this alias is added to the list of unique field types.  And here the size of the set is checked to see if there is more than one field type across all indices belonging to this alias. If there is more than one field type, then the field is considered \"invalid\" for this alias.", "author": "astefan", "createdAt": "2020-03-16T13:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NzIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393097217", "bodyText": "I don't follow - putIfAbsent does if (key == null) put(key, value) - I'm pointing out that a new HashSet is created every time.\nWhat I'm suggesting:\nif (key == null) {\n   put(key, new HashSet())\n}", "author": "costin", "createdAt": "2020-03-16T15:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MDk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393160977", "bodyText": "I am aware of the putIfAbsent functionality. I think I can simplify the logic a bit.", "author": "astefan", "createdAt": "2020-03-16T16:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}], "type": "inlineReview"}, {"oid": "26bf119aaa30d170b7932116172326e7661b415c", "url": "https://github.com/elastic/elasticsearch/commit/26bf119aaa30d170b7932116172326e7661b415c", "message": "Address reviews", "committedDate": "2020-03-16T13:41:48Z", "type": "commit"}, {"oid": "93d8162de832826f1d920ee31a58c177ed51eb49", "url": "https://github.com/elastic/elasticsearch/commit/93d8162de832826f1d920ee31a58c177ed51eb49", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-16T13:46:15Z", "type": "commit"}, {"oid": "80f0b63a90d2db8032100b50659db27a9d787f05", "url": "https://github.com/elastic/elasticsearch/commit/80f0b63a90d2db8032100b50659db27a9d787f05", "message": "Fix one integration test after update branch", "committedDate": "2020-03-16T14:02:37Z", "type": "commit"}, {"oid": "d34271a85cae13da46deff6a1d20075f26ef156e", "url": "https://github.com/elastic/elasticsearch/commit/d34271a85cae13da46deff6a1d20075f26ef156e", "message": "Address further review", "committedDate": "2020-03-16T16:40:42Z", "type": "commit"}, {"oid": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "url": "https://github.com/elastic/elasticsearch/commit/bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-16T16:43:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI2MDYxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393260619", "bodyText": "nit: s/accross/across.", "author": "bpintea", "createdAt": "2020-03-16T19:23:55Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -605,4 +662,141 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393329168", "bodyText": "Use org.elasticsearch.common.util.CollectionUtils.isEmpty instead.", "author": "costin", "createdAt": "2020-03-16T21:49:42Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -496,16 +515,27 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ1NTA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393455047", "bodyText": "That's not possible unfortunately, because aliases is an ImmutableOpenMap, which is not a Collection.", "author": "astefan", "createdAt": "2020-03-17T05:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTE2OA=="}], "type": "inlineReview"}, {"oid": "9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "url": "https://github.com/elastic/elasticsearch/commit/9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "message": "Address more reviews", "committedDate": "2020-03-17T05:45:38Z", "type": "commit"}, {"oid": "cd6c420a37c8156d5fd6d2280c1b84ecda0f5492", "url": "https://github.com/elastic/elasticsearch/commit/cd6c420a37c8156d5fd6d2280c1b84ecda0f5492", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-17T05:45:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3ODUzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393378536", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            for(AliasMetaData alias : iterator.next().value) {\n          \n          \n            \n                            for (AliasMetaData alias : iterator.next().value) {", "author": "matriv", "createdAt": "2020-03-17T00:13:22Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -496,16 +515,27 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new HashSet<>();\n+        if (aliases != null) {\n+            Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n+            while (iterator.hasNext()) {\n+                for(AliasMetaData alias : iterator.next().value) {", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MTM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393381394", "bodyText": "Can it be simply <>?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            aliasToIndices.putIfAbsent(aliasName, new HashSet<String>());\n          \n          \n            \n                            aliasToIndices.putIfAbsent(aliasName, new HashSet<>());", "author": "matriv", "createdAt": "2020-03-17T00:25:46Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -605,4 +662,141 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                aliasToIndices.putIfAbsent(aliasName, new HashSet<String>());", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "079be6ba8fa806f4851be9af529bc72ede5e8d0e", "url": "https://github.com/elastic/elasticsearch/commit/079be6ba8fa806f4851be9af529bc72ede5e8d0e", "message": "Small updates", "committedDate": "2020-03-17T08:43:37Z", "type": "commit"}]}