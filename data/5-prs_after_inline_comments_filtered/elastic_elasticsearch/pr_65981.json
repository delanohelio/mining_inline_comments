{"pr_number": 65981, "pr_title": "Remove BigArrays from SearchContext", "pr_createdAt": "2020-12-07T20:45:25Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65981", "timeline": [{"oid": "e29290b14a8efac8a9ea9066f0575240905f603f", "url": "https://github.com/elastic/elasticsearch/commit/e29290b14a8efac8a9ea9066f0575240905f603f", "message": "Remove BigArrays from SearchContext\n\nWe've been trying to shrink the big, mutable `SearchContext`. I'm doing\nmy part by removing `BigArrays` from it. Doing that required reworking\nhow we test `Aggregator`s to not need `SearchContext`. So I did that\ntoo. Mostly. `top_hits` still needs a `SubSearchContext` which we can\nstill build, but it is now quite contained.", "committedDate": "2020-12-07T20:47:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyMDM0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65981#discussion_r537820349", "bodyText": "clusterService was unused so I removed it while I was clearing bigArrays.", "author": "nik9000", "createdAt": "2020-12-07T20:46:06Z", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -768,8 +768,8 @@ private DefaultSearchContext createSearchContext(ReaderContext reader, ShardSear\n         try {\n             SearchShardTarget shardTarget = new SearchShardTarget(clusterService.localNode().getId(),\n                 reader.indexShard().shardId(), request.getClusterAlias(), OriginalIndices.NONE);\n-            searchContext = new DefaultSearchContext(reader, request, shardTarget, clusterService,\n-                bigArrays, threadPool::relativeTimeInMillis, timeout, fetchPhase, lowLevelCancellation);\n+            searchContext = new DefaultSearchContext(reader, request, shardTarget,\n+                threadPool::relativeTimeInMillis, timeout, fetchPhase, lowLevelCancellation);\n             // we clone the query shard context here just for rewriting otherwise we", "originalCommit": "e29290b14a8efac8a9ea9066f0575240905f603f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyMDQ3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65981#discussion_r537820470", "bodyText": "This didn't do anything....", "author": "nik9000", "createdAt": "2020-12-07T20:46:19Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java", "diffHunk": "@@ -401,11 +400,6 @@ public String getType() {\n         return NAME;\n     }\n \n-    @Override\n-    protected AggregationBuilder doRewrite(QueryRewriteContext queryShardContext) throws IOException {\n-        return super.doRewrite(queryShardContext);\n-    }", "originalCommit": "e29290b14a8efac8a9ea9066f0575240905f603f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyMDgwMA==", "url": "https://github.com/elastic/elasticsearch/pull/65981#discussion_r537820800", "bodyText": "These are required by tests. I could avoid adding it with some terrible casting stuff in tests but I think it is better to be up front about it.", "author": "nik9000", "createdAt": "2020-12-07T20:46:49Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -230,6 +230,12 @@ public final AggregationUsageService getUsageService() {\n      */\n     public abstract Analyzer getIndexAnalyzer(Function<String, NamedAnalyzer> unindexedFieldAnalyzer);\n \n+    /**\n+     * Is this request cacheable? Requests that have\n+     * non-deterministic queries or scripts aren't cachable.\n+     */\n+    public abstract boolean isCacheable();", "originalCommit": "e29290b14a8efac8a9ea9066f0575240905f603f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyMTQ0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65981#discussion_r537821445", "bodyText": "Had to move with withCircuitBreaking from SearchContext.", "author": "nik9000", "createdAt": "2020-12-07T20:47:48Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -277,6 +284,7 @@ public ProductionAggregationContext(\n             Supplier<Boolean> isCancelled\n         ) {\n             this.context = context;\n+            this.bigArrays = context.bigArrays().withCircuitBreaking();  // We can break in searches.", "originalCommit": "e29290b14a8efac8a9ea9066f0575240905f603f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyMjA1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65981#discussion_r537822051", "bodyText": "I'd love to use a specialized testing subclass but this change is large enough as it is without me changing it.", "author": "nik9000", "createdAt": "2020-12-07T20:48:48Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -297,25 +291,64 @@ public boolean shouldCache(Query query) {\n             return null;\n         });\n \n-        NestedDocuments nestedDocuments = new NestedDocuments(mapperService, searchContext.bitsetFilterCache()::getBitSetProducer);\n-        when(searchContext.getNestedDocuments())\n-            .thenReturn(nestedDocuments);\n+        MultiBucketConsumer consumer = new MultiBucketConsumer(maxBucket, breakerService.getBreaker(CircuitBreaker.REQUEST));\n+        BitsetFilterCache bitsetFilterCache = new BitsetFilterCache(indexSettings, mock(Listener.class));\n+        return new ProductionAggregationContext(\n+            queryShardContext,\n+            query,\n+            null,\n+            consumer,\n+            () -> buildSubSearchContext(mapperService, queryShardContext, bitsetFilterCache),\n+            releasables::add,\n+            bitsetFilterCache,\n+            randomInt(),\n+            () -> 0L,\n+            () -> false\n+        );", "originalCommit": "e29290b14a8efac8a9ea9066f0575240905f603f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyMzM2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65981#discussion_r537823369", "bodyText": "Now all of this is contained to only be called for top_hits.", "author": "nik9000", "createdAt": "2020-12-07T20:51:05Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -297,25 +291,64 @@ public boolean shouldCache(Query query) {\n             return null;\n         });\n \n-        NestedDocuments nestedDocuments = new NestedDocuments(mapperService, searchContext.bitsetFilterCache()::getBitSetProducer);\n-        when(searchContext.getNestedDocuments())\n-            .thenReturn(nestedDocuments);\n+        MultiBucketConsumer consumer = new MultiBucketConsumer(maxBucket, breakerService.getBreaker(CircuitBreaker.REQUEST));\n+        BitsetFilterCache bitsetFilterCache = new BitsetFilterCache(indexSettings, mock(Listener.class));\n+        return new ProductionAggregationContext(\n+            queryShardContext,\n+            query,\n+            null,\n+            consumer,\n+            () -> buildSubSearchContext(mapperService, queryShardContext, bitsetFilterCache),\n+            releasables::add,\n+            bitsetFilterCache,\n+            randomInt(),\n+            () -> 0L,\n+            () -> false\n+        );\n+    }\n \n-        Map<String, MappedFieldType> fieldNameToType = new HashMap<>();\n-        fieldNameToType.putAll(Arrays.stream(fieldTypes)\n-            .filter(Objects::nonNull)\n-            .collect(Collectors.toMap(MappedFieldType::name, Function.identity())));\n-        fieldNameToType.putAll(getFieldAliases(fieldTypes));\n+    /**\n+     * Build a {@link SubSearchContext}s to power {@code top_hits}.\n+     */\n+    private SubSearchContext buildSubSearchContext(\n+        MapperService mapperService,\n+        QueryShardContext queryShardContext,\n+        BitsetFilterCache bitsetFilterCache\n+    ) {\n+        SearchContext ctx = mock(SearchContext.class);\n+        QueryCache queryCache = new DisabledQueryCache(mapperService.getIndexSettings());\n+        QueryCachingPolicy queryCachingPolicy = new QueryCachingPolicy() {\n+            @Override\n+            public void onUse(Query query) {\n+            }\n \n-        registerFieldTypes(searchContext, mapperService,\n-            fieldNameToType);\n-        doAnswer(invocation -> {\n-            /* Store the release-ables so we can release them at the end of the test case. This is important because aggregations don't\n-             * close their sub-aggregations. This is fairly similar to what the production code does. */\n-            releasables.add((Releasable) invocation.getArguments()[0]);\n-            return null;\n-        }).when(searchContext).addReleasable(anyObject());\n-        return searchContext;\n+            @Override\n+            public boolean shouldCache(Query query) {\n+                // never cache a query\n+                return false;\n+            }\n+        };\n+        try {\n+            when(ctx.searcher()).thenReturn(\n+                new ContextIndexSearcher(\n+                    queryShardContext.searcher().getIndexReader(),\n+                    queryShardContext.searcher().getSimilarity(),\n+                    queryCache,\n+                    queryCachingPolicy,\n+                    false\n+                )\n+            );\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        when(ctx.fetchPhase()).thenReturn(new FetchPhase(Arrays.asList(new FetchSourcePhase(), new FetchDocValuesPhase())));\n+        when(ctx.getQueryShardContext()).thenReturn(queryShardContext);\n+        NestedDocuments nestedDocuments = new NestedDocuments(mapperService, bitsetFilterCache::getBitSetProducer);\n+        when(ctx.getNestedDocuments()).thenReturn(nestedDocuments);\n+        IndexShard indexShard = mock(IndexShard.class);\n+        when(indexShard.shardId()).thenReturn(new ShardId(\"test\", \"test\", 0));\n+        when(ctx.indexShard()).thenReturn(indexShard);\n+        return new SubSearchContext(ctx);", "originalCommit": "e29290b14a8efac8a9ea9066f0575240905f603f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "68af24f6f129a9c121ada8f4250d8afdcdeff6a0", "url": "https://github.com/elastic/elasticsearch/commit/68af24f6f129a9c121ada8f4250d8afdcdeff6a0", "message": "Move mocking", "committedDate": "2020-12-07T20:53:06Z", "type": "commit"}, {"oid": "152e014f8ed7d3cfad35778a2644b6c3dc04a87f", "url": "https://github.com/elastic/elasticsearch/commit/152e014f8ed7d3cfad35778a2644b6c3dc04a87f", "message": "Oh checkstyle", "committedDate": "2020-12-07T21:13:34Z", "type": "commit"}, {"oid": "9ed67c6e11d24a057adb044a491a37f1dd1c0c6b", "url": "https://github.com/elastic/elasticsearch/commit/9ed67c6e11d24a057adb044a491a37f1dd1c0c6b", "message": "Fixup test", "committedDate": "2020-12-08T13:41:05Z", "type": "commit"}]}