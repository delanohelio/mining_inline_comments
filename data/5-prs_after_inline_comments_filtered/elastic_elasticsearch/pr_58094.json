{"pr_number": 58094, "pr_title": "Add index block api", "pr_createdAt": "2020-06-15T09:01:52Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58094", "timeline": [{"oid": "ed6f7e50081585356840c3503e24117263ec3eb4", "url": "https://github.com/elastic/elasticsearch/commit/ed6f7e50081585356840c3503e24117263ec3eb4", "message": "Add API for adding index blocks", "committedDate": "2020-06-12T12:43:13Z", "type": "commit"}, {"oid": "634bb387ee395488623291e2284feca9c040f6ee", "url": "https://github.com/elastic/elasticsearch/commit/634bb387ee395488623291e2284feca9c040f6ee", "message": "Towards REST API", "committedDate": "2020-06-12T13:12:38Z", "type": "commit"}, {"oid": "67511f81d70c7ca219a6dfc24df1eeee8415e6ec", "url": "https://github.com/elastic/elasticsearch/commit/67511f81d70c7ca219a6dfc24df1eeee8415e6ec", "message": "Make metadatta block idempotent as well", "committedDate": "2020-06-12T13:54:07Z", "type": "commit"}, {"oid": "877b46582a5dcea9c88dace7ad4d7880856efa47", "url": "https://github.com/elastic/elasticsearch/commit/877b46582a5dcea9c88dace7ad4d7880856efa47", "message": "more REST test changes", "committedDate": "2020-06-12T15:24:14Z", "type": "commit"}, {"oid": "f2c19345f296d44c085110f1d9923c53bba1ec51", "url": "https://github.com/elastic/elasticsearch/commit/f2c19345f296d44c085110f1d9923c53bba1ec51", "message": "Add docs", "committedDate": "2020-06-15T08:50:15Z", "type": "commit"}, {"oid": "66be434544d139f5c0bd926e421ef61d1fa94733", "url": "https://github.com/elastic/elasticsearch/commit/66be434544d139f5c0bd926e421ef61d1fa94733", "message": "No HLRC yet", "committedDate": "2020-06-16T13:17:43Z", "type": "commit"}, {"oid": "31dbfea48db143781ac850bdd4dded7e2d8b05fb", "url": "https://github.com/elastic/elasticsearch/commit/31dbfea48db143781ac850bdd4dded7e2d8b05fb", "message": "fix test", "committedDate": "2020-06-16T13:23:20Z", "type": "commit"}, {"oid": "0a5c01df7acd31c75dec1e2037b893fcd502daab", "url": "https://github.com/elastic/elasticsearch/commit/0a5c01df7acd31c75dec1e2037b893fcd502daab", "message": "Merge remote-tracking branch 'elastic/master' into add-index-block-api", "committedDate": "2020-06-16T13:23:36Z", "type": "commit"}, {"oid": "04460323090829fbdceaf89ecd991ca3b8bec3c6", "url": "https://github.com/elastic/elasticsearch/commit/04460323090829fbdceaf89ecd991ca3b8bec3c6", "message": "chstyl", "committedDate": "2020-06-16T13:45:19Z", "type": "commit"}, {"oid": "5ba6928ff5c1e389f15f9279f4ea34882f44205f", "url": "https://github.com/elastic/elasticsearch/commit/5ba6928ff5c1e389f15f9279f4ea34882f44205f", "message": "fix test", "committedDate": "2020-06-16T15:36:41Z", "type": "commit"}, {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776", "url": "https://github.com/elastic/elasticsearch/commit/a87646578660c0fa2f77543fcf03b0277dd3c776", "message": "Get basic stuff right", "committedDate": "2020-06-17T07:00:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxNTM1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441615355", "bodyText": "I think closeIndexResponse is a confusing name here?", "author": "dakrone", "createdAt": "2020-06-17T15:02:36Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/blocks/SimpleBlocksIT.java", "diffHunk": "@@ -133,11 +163,320 @@ private void canNotIndexDocument(String index) {\n \n     private void setIndexReadOnly(String index, Object value) {\n         HashMap<String, Object> newSettings = new HashMap<>();\n-        newSettings.put(IndexMetadata.SETTING_READ_ONLY, value);\n+        newSettings.put(SETTING_READ_ONLY, value);\n \n         UpdateSettingsRequestBuilder settingsRequest = client().admin().indices().prepareUpdateSettings(index);\n         settingsRequest.setSettings(newSettings);\n         AcknowledgedResponse settingsResponse = settingsRequest.execute().actionGet();\n         assertThat(settingsResponse, notNullValue());\n     }\n+\n+\n+    public void testAddBlocksWhileExistingBlocks() {\n+        createIndex(\"test\");\n+        ensureGreen(\"test\");\n+\n+        for (APIBlock otherBlock : APIBlock.values()) {\n+\n+            for (APIBlock block : Arrays.asList(APIBlock.READ, APIBlock.WRITE)) {\n+                try {\n+                    enableIndexBlock(\"test\", block.settingName());\n+\n+                    // Adding a block is not blocked\n+                    AcknowledgedResponse closeIndexResponse = client().admin().indices()", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxODcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441618723", "bodyText": "A lot of our action names follow a hierarchy, so I'd suggest\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"indices:admin/add-index-block\";\n          \n          \n            \n                public static final String NAME = \"indices:admin/block/add\";\n          \n      \n    \n    \n  \n\nWhich gives us the chance to set permissions for indices:admin/block/* in the event we ever add another API (think indices:admin/block/remove for example)", "author": "dakrone", "createdAt": "2020-06-17T15:06:46Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionType;\n+\n+public class AddIndexBlockAction extends ActionType<AddIndexBlockResponse> {\n+\n+    public static final AddIndexBlockAction INSTANCE = new AddIndexBlockAction();\n+    public static final String NAME = \"indices:admin/add-index-block\";", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyMjYyMw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441622623", "bodyText": "This docstring needs to be updated", "author": "dakrone", "createdAt": "2020-06-17T15:11:33Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockClusterStateUpdateRequest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.cluster.ack.IndicesClusterStateUpdateRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+\n+/**\n+ * Cluster state update request that allows to close one or more indices", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNDMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441624333", "bodyText": "This needs to be updated as well :)", "author": "dakrone", "createdAt": "2020-06-17T15:13:36Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441625230", "bodyText": "I think we may also want to validate that a block was specified and non-null?", "author": "dakrone", "createdAt": "2020-06-17T15:14:51Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.\n+     */\n+    public AddIndexBlockRequest(APIBlock block, String... indices) {\n+        this.block = block;\n+        this.indices = indices;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (CollectionUtils.isEmpty(indices)) {\n+            validationException = addValidationError(\"index is missing\", validationException);\n+        }\n+        return validationException;", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4MTUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444781527", "bodyText": "I've made it so that it never can be null (as also requested below)", "author": "ywelsch", "createdAt": "2020-06-24T09:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441625323", "bodyText": "Needs to be updated :)", "author": "dakrone", "createdAt": "2020-06-17T15:14:59Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTU3MA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441625570", "bodyText": "Needs to be updated (last time I'll mention it for this file)", "author": "dakrone", "createdAt": "2020-06-17T15:15:16Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.\n+     */\n+    public AddIndexBlockRequest(APIBlock block, String... indices) {\n+        this.block = block;\n+        this.indices = indices;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (CollectionUtils.isEmpty(indices)) {\n+            validationException = addValidationError(\"index is missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * The indices to be closed\n+     * @return the indices to be closed", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNjI2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441626269", "bodyText": "Can you wrap these in Objects.requireNonNull? I'd rather catch NPEs here than in serialization", "author": "dakrone", "createdAt": "2020-06-17T15:16:12Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.\n+     */\n+    public AddIndexBlockRequest(APIBlock block, String... indices) {\n+        this.block = block;\n+        this.indices = indices;", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNjgxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441626819", "bodyText": "I think we should make this private (or even better, remove it entirely) since leaving block and indices as null would lead to an NPE on serialization", "author": "dakrone", "createdAt": "2020-06-17T15:16:54Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4MTc2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444781767", "bodyText": "I've removed it", "author": "ywelsch", "createdAt": "2020-06-24T09:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNjgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMDM4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441630387", "bodyText": "To be 100% honest, I don't think we need this class, the request itself is pretty simple, and we haven't been adding builders for quite a while since the transport client is no more. I think it could be removed?", "author": "dakrone", "createdAt": "2020-06-17T15:21:44Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequestBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+\n+/**\n+ * Builder for close index request\n+ */\n+public class AddIndexBlockRequestBuilder", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NDU0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444784549", "bodyText": "I would prefer to keep the builder, in particular as this is being backported to 7.x, which still has the transport client. I also prefer to keep things consistent in the code base.", "author": "ywelsch", "createdAt": "2020-06-24T10:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441655951", "bodyText": "We are trying to get away from dynamically keyed objects in our REST APIs, would it be possible to change this to an array of objects with name: ... and failures: [...] keys?", "author": "dakrone", "createdAt": "2020-06-17T15:59:30Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.master.ShardsAcknowledgedResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+public class AddIndexBlockResponse extends ShardsAcknowledgedResponse {\n+\n+    private final List<AddBlockResult> indices;\n+\n+    AddIndexBlockResponse(StreamInput in) throws IOException {\n+        super(in, true);\n+        indices = unmodifiableList(in.readList(AddBlockResult::new));\n+    }\n+\n+    public AddIndexBlockResponse(final boolean acknowledged, final boolean shardsAcknowledged, final List<AddBlockResult> indices) {\n+        super(acknowledged, shardsAcknowledged);\n+        this.indices = unmodifiableList(Objects.requireNonNull(indices));\n+    }\n+\n+    public List<AddBlockResult> getIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        writeShardsAcknowledged(out);\n+        out.writeList(indices);\n+    }\n+\n+    @Override\n+    protected void addCustomFields(final XContentBuilder builder, final Params params) throws IOException {\n+        super.addCustomFields(builder, params);\n+        builder.startObject(\"indices\");\n+        for (AddBlockResult index : indices) {\n+            index.toXContent(builder, params);\n+        }\n+        builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    public static class AddBlockResult implements Writeable, ToXContentFragment {\n+\n+        private final Index index;\n+        private final @Nullable Exception exception;\n+        private final @Nullable AddBlockShardResult[] shards;\n+\n+        public AddBlockResult(final Index index) {\n+            this(index, null, null);\n+        }\n+\n+        public AddBlockResult(final Index index, final Exception failure) {\n+            this(index, Objects.requireNonNull(failure), null);\n+        }\n+\n+        public AddBlockResult(final Index index, final AddBlockShardResult[] shards) {\n+            this(index, null, Objects.requireNonNull(shards));\n+        }\n+\n+        private AddBlockResult(final Index index, @Nullable final Exception exception, @Nullable final AddBlockShardResult[] shards) {\n+            this.index = Objects.requireNonNull(index);\n+            this.exception = exception;\n+            this.shards = shards;\n+        }\n+\n+        AddBlockResult(final StreamInput in) throws IOException {\n+            this.index = new Index(in);\n+            this.exception = in.readException();\n+            this.shards = in.readOptionalArray(AddBlockShardResult::new, AddBlockShardResult[]::new);\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            index.writeTo(out);\n+            out.writeException(exception);\n+            out.writeOptionalArray(shards);\n+        }\n+\n+        public Index getIndex() {\n+            return index;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public AddBlockShardResult[] getShards() {\n+            return shards;\n+        }\n+\n+        public boolean hasFailures() {\n+            if (exception != null) {\n+                return true;\n+            }\n+            if (shards != null) {\n+                for (AddBlockShardResult shard : shards) {\n+                    if (shard.hasFailures()) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {\n+            builder.startObject(index.getName());", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjYxOA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444786618", "bodyText": "Looking at other similar APIs here (close index, or index stats), they all dynamically key by index name. For consistency reasons, I prefer to go with what we currently have today. I understand that we want to eventually move to a different place, but would prefer doing so consistently across these APIs.", "author": "ywelsch", "createdAt": "2020-06-24T10:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MDAzNw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445880037", "bodyText": "I don't agree, I think if we go with consistency with our earlier APIs, then we would never eventually transition to the change. Since this is introducing a new API if we make the change now it's one less that we have to change in the future when we eventually have REST versioning.\nWe've discussed this a lot on the core/features team and always ended up with newly introduced APIs using the newer format, rather than matching the existing dynamically keyed format.", "author": "dakrone", "createdAt": "2020-06-25T22:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg0MjgwNg==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r446842806", "bodyText": "I've adapted the PR to your wishes now, but I don't agree with the general principle. What the team is suggesting is making our lives easier (less stuff to transition), but at the same time is leaving the user with an inconsistent set of APIs (every API having a slightly different look and feel). I think it's the wrong tradeoff to do, especially with the versioned HTTP API looming around the corner (where the need to strive for consistency within the same API version should be an even stronger guiding principle).", "author": "ywelsch", "createdAt": "2020-06-29T08:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NjI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441656281", "bodyText": "I think this should be failed_shards rather than camel case to match our usual API conventions", "author": "dakrone", "createdAt": "2020-06-17T16:00:02Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.master.ShardsAcknowledgedResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+public class AddIndexBlockResponse extends ShardsAcknowledgedResponse {\n+\n+    private final List<AddBlockResult> indices;\n+\n+    AddIndexBlockResponse(StreamInput in) throws IOException {\n+        super(in, true);\n+        indices = unmodifiableList(in.readList(AddBlockResult::new));\n+    }\n+\n+    public AddIndexBlockResponse(final boolean acknowledged, final boolean shardsAcknowledged, final List<AddBlockResult> indices) {\n+        super(acknowledged, shardsAcknowledged);\n+        this.indices = unmodifiableList(Objects.requireNonNull(indices));\n+    }\n+\n+    public List<AddBlockResult> getIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        writeShardsAcknowledged(out);\n+        out.writeList(indices);\n+    }\n+\n+    @Override\n+    protected void addCustomFields(final XContentBuilder builder, final Params params) throws IOException {\n+        super.addCustomFields(builder, params);\n+        builder.startObject(\"indices\");\n+        for (AddBlockResult index : indices) {\n+            index.toXContent(builder, params);\n+        }\n+        builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    public static class AddBlockResult implements Writeable, ToXContentFragment {\n+\n+        private final Index index;\n+        private final @Nullable Exception exception;\n+        private final @Nullable AddBlockShardResult[] shards;\n+\n+        public AddBlockResult(final Index index) {\n+            this(index, null, null);\n+        }\n+\n+        public AddBlockResult(final Index index, final Exception failure) {\n+            this(index, Objects.requireNonNull(failure), null);\n+        }\n+\n+        public AddBlockResult(final Index index, final AddBlockShardResult[] shards) {\n+            this(index, null, Objects.requireNonNull(shards));\n+        }\n+\n+        private AddBlockResult(final Index index, @Nullable final Exception exception, @Nullable final AddBlockShardResult[] shards) {\n+            this.index = Objects.requireNonNull(index);\n+            this.exception = exception;\n+            this.shards = shards;\n+        }\n+\n+        AddBlockResult(final StreamInput in) throws IOException {\n+            this.index = new Index(in);\n+            this.exception = in.readException();\n+            this.shards = in.readOptionalArray(AddBlockShardResult::new, AddBlockShardResult[]::new);\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            index.writeTo(out);\n+            out.writeException(exception);\n+            out.writeOptionalArray(shards);\n+        }\n+\n+        public Index getIndex() {\n+            return index;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public AddBlockShardResult[] getShards() {\n+            return shards;\n+        }\n+\n+        public boolean hasFailures() {\n+            if (exception != null) {\n+                return true;\n+            }\n+            if (shards != null) {\n+                for (AddBlockShardResult shard : shards) {\n+                    if (shard.hasFailures()) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {\n+            builder.startObject(index.getName());\n+            {\n+                if (hasFailures()) {\n+                    builder.field(\"blocked\", false);\n+                    if (exception != null) {\n+                        builder.startObject(\"exception\");\n+                        ElasticsearchException.generateFailureXContent(builder, params, exception, true);\n+                        builder.endObject();\n+                    } else {\n+                        builder.startObject(\"failedShards\");", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NzA4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441657081", "bodyText": "Documentation needs to be updated", "author": "dakrone", "createdAt": "2020-06-17T16:01:19Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportAddIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DestructiveOperations;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetadataIndexStateService;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+\n+/**\n+ * Close index action", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1Nzk3OA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441657978", "bodyText": "Can you add javadocs for this class please?", "author": "dakrone", "createdAt": "2020-06-17T16:02:42Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.replication.ReplicationOperation;\n+import org.elasticsearch.action.support.replication.ReplicationRequest;\n+import org.elasticsearch.action.support.replication.ReplicationResponse;\n+import org.elasticsearch.action.support.replication.TransportReplicationAction;\n+import org.elasticsearch.cluster.action.shard.ShardStateAction;\n+import org.elasticsearch.cluster.block.ClusterBlock;\n+import org.elasticsearch.cluster.block.ClusterBlocks;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class TransportVerifyShardIndexBlockAction extends TransportReplicationAction<", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTIwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441659201", "bodyText": "I don't think we need to add these since we are not supporting the transport client any longer?", "author": "dakrone", "createdAt": "2020-06-17T16:04:48Z", "path": "server/src/main/java/org/elasticsearch/client/IndicesAdminClient.java", "diffHunk": "@@ -284,6 +288,23 @@\n      */\n     void open(OpenIndexRequest request, ActionListener<OpenIndexResponse> listener);\n \n+    /**\n+     * Adds a block to an index\n+     *\n+     * @param block   The block to add\n+     * @param indices The name of the indices to add the block to\n+     */\n+    AddIndexBlockRequestBuilder prepareAddBlock(APIBlock block, String... indices);", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444786910", "bodyText": "see comment above about transport client", "author": "ywelsch", "createdAt": "2020-06-24T10:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441659335", "bodyText": "Same about no need to add since we aren't supporting the transport client", "author": "dakrone", "createdAt": "2020-06-17T16:05:03Z", "path": "server/src/main/java/org/elasticsearch/client/support/AbstractClient.java", "diffHunk": "@@ -1331,6 +1336,16 @@ public void open(final OpenIndexRequest request, final ActionListener<OpenIndexR\n             execute(OpenIndexAction.INSTANCE, request, listener);\n         }\n \n+        @Override\n+        public AddIndexBlockRequestBuilder prepareAddBlock(APIBlock block, String... indices) {", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTgyNg==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441659826", "bodyText": "Can you add javadocs for this method please?", "author": "dakrone", "createdAt": "2020-06-17T16:05:48Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2MjIzOA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441662238", "bodyText": "Super minor, but perhaps\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    clusterService.submitStateUpdateTask(\"add-index-block \" + Arrays.toString(concreteIndices),\n          \n          \n            \n                    clusterService.submitStateUpdateTask(\"add-index-block-[\" + request.getBlock() + \"]-\" Arrays.toString(concreteIndices),\n          \n      \n    \n    \n  \n\nSo we can see the intended block in the pending tasks list", "author": "dakrone", "createdAt": "2020-06-17T16:09:39Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));\n+        return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n+    }\n+\n+    public void addIndexBlock(AddIndexBlockClusterStateUpdateRequest request,\n+                              ActionListener<AddIndexBlockResponse> listener) {\n+        final Index[] concreteIndices = request.indices();\n+        if (concreteIndices == null || concreteIndices.length == 0) {\n+            throw new IllegalArgumentException(\"Index name is required\");\n+        }\n+        List<String> writeIndices = new ArrayList<>();\n+        SortedMap<String, IndexAbstraction> lookup = clusterService.state().metadata().getIndicesLookup();\n+        for (Index index : concreteIndices) {\n+            IndexAbstraction ia = lookup.get(index.getName());\n+            if (ia != null && ia.getParentDataStream() != null && ia.getParentDataStream().getWriteIndex().getIndex().equals(index)) {\n+                writeIndices.add(index.getName());\n+            }\n+        }\n+        if (writeIndices.size() > 0) {\n+            throw new IllegalArgumentException(\"cannot add a block to the following data stream write indices [\" +\n+                Strings.collectionToCommaDelimitedString(writeIndices) + \"]\");\n+        }\n+\n+        clusterService.submitStateUpdateTask(\"add-index-block \" + Arrays.toString(concreteIndices),", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2Mzg3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441663873", "bodyText": "Can you add the block type and blockedIndices list to this state update task as well?", "author": "dakrone", "createdAt": "2020-06-17T16:12:20Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));\n+        return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n+    }\n+\n+    public void addIndexBlock(AddIndexBlockClusterStateUpdateRequest request,\n+                              ActionListener<AddIndexBlockResponse> listener) {\n+        final Index[] concreteIndices = request.indices();\n+        if (concreteIndices == null || concreteIndices.length == 0) {\n+            throw new IllegalArgumentException(\"Index name is required\");\n+        }\n+        List<String> writeIndices = new ArrayList<>();\n+        SortedMap<String, IndexAbstraction> lookup = clusterService.state().metadata().getIndicesLookup();\n+        for (Index index : concreteIndices) {\n+            IndexAbstraction ia = lookup.get(index.getName());\n+            if (ia != null && ia.getParentDataStream() != null && ia.getParentDataStream().getWriteIndex().getIndex().equals(index)) {\n+                writeIndices.add(index.getName());\n+            }\n+        }\n+        if (writeIndices.size() > 0) {\n+            throw new IllegalArgumentException(\"cannot add a block to the following data stream write indices [\" +\n+                Strings.collectionToCommaDelimitedString(writeIndices) + \"]\");\n+        }\n+\n+        clusterService.submitStateUpdateTask(\"add-index-block \" + Arrays.toString(concreteIndices),\n+            new ClusterStateUpdateTask(Priority.URGENT) {\n+\n+                private final Map<Index, ClusterBlock> blockedIndices = new HashMap<>();\n+\n+                @Override\n+                public ClusterState execute(final ClusterState currentState) {\n+                    return addIndexBlock(concreteIndices, blockedIndices, currentState, request.getBlock());\n+                }\n+\n+                @Override\n+                public void clusterStateProcessed(final String source, final ClusterState oldState, final ClusterState newState) {\n+                    if (oldState == newState) {\n+                        assert blockedIndices.isEmpty() : \"List of blocked indices is not empty but cluster state wasn't changed\";\n+                        listener.onResponse(new AddIndexBlockResponse(true, false, Collections.emptyList()));\n+                    } else {\n+                        assert blockedIndices.isEmpty() == false : \"List of blocked indices is empty but cluster state was changed\";\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT)\n+                            .execute(new WaitForBlocksApplied(blockedIndices, request,\n+                                    ActionListener.wrap(verifyResults ->\n+                                            clusterService.submitStateUpdateTask(\"finalize-index-block\",", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NTA4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441665082", "bodyText": "Docstrings in this file need to be updated :)", "author": "dakrone", "createdAt": "2020-06-17T16:14:23Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequestBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+\n+/**\n+ * Builder for close index request", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2ODQyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441668425", "bodyText": "I'm really uncomfortable mutating the blockedIndices map that was passed in as a parameter. I had to read this over and over to see what was happening. Can we refactor this method so that it becomes part of the return value (maybe using a Tuple if we don't want to add an object) so that it's easier to reason about?", "author": "dakrone", "createdAt": "2020-06-17T16:20:01Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NzIyMw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444787223", "bodyText": "Good idea, changed  this to a tuple", "author": "ywelsch", "createdAt": "2020-06-24T10:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2ODQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2OTU4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441669587", "bodyText": "Why use a lambda and parameterized message here? Usually it's used when also passing an exception we want to preserve as a cause. Am I missing something?", "author": "dakrone", "createdAt": "2020-06-17T16:21:57Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NzM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444787389", "bodyText": "No reason, code was copy-pasted from elsewhere", "author": "ywelsch", "createdAt": "2020-06-24T10:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2OTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2OTcyOA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441669728", "bodyText": "Could you add javadocs please?", "author": "dakrone", "createdAt": "2020-06-17T16:22:09Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));\n+        return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n+    }\n+\n+    public void addIndexBlock(AddIndexBlockClusterStateUpdateRequest request,", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MDA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441670040", "bodyText": "Javadocs please :)", "author": "dakrone", "createdAt": "2020-06-17T16:22:41Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -429,6 +578,108 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    class WaitForBlocksApplied extends ActionRunnable<Map<Index, AddBlockResult>> {", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MTY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441671644", "bodyText": "Javadocs please :) they really do help when code spelunking in the future (at least I find them incredibly useful)", "author": "dakrone", "createdAt": "2020-06-17T16:25:17Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -618,6 +869,60 @@ ClusterState openIndices(final Index[] indices, final ClusterState currentState)\n         return ClusterState.builder(updatedState).routingTable(routingTable.build()).build();\n     }\n \n+    static Tuple<ClusterState, Collection<AddBlockResult>> finalizeBlock(final ClusterState currentState,", "originalCommit": "a87646578660c0fa2f77543fcf03b0277dd3c776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "558c3b84da222c1bef470b59bf33cedcc54f487e", "url": "https://github.com/elastic/elasticsearch/commit/558c3b84da222c1bef470b59bf33cedcc54f487e", "message": "Merge remote-tracking branch 'elastic/master' into add-index-block-api", "committedDate": "2020-06-23T08:46:49Z", "type": "commit"}, {"oid": "db583d46f6a9fbedf3356dd421310dd444ca7e4c", "url": "https://github.com/elastic/elasticsearch/commit/db583d46f6a9fbedf3356dd421310dd444ca7e4c", "message": "Use singular", "committedDate": "2020-06-23T08:50:19Z", "type": "commit"}, {"oid": "97a6e933109994025f79ebbfa55fa0c50fb78f43", "url": "https://github.com/elastic/elasticsearch/commit/97a6e933109994025f79ebbfa55fa0c50fb78f43", "message": "Review comments", "committedDate": "2020-06-23T09:39:11Z", "type": "commit"}, {"oid": "22e0195274d56c8e2ca6c6282bd013fd25d48bde", "url": "https://github.com/elastic/elasticsearch/commit/22e0195274d56c8e2ca6c6282bd013fd25d48bde", "message": "Merge remote-tracking branch 'elastic/master' into add-index-block-api", "committedDate": "2020-06-24T08:11:55Z", "type": "commit"}, {"oid": "85ab5bef223995dff4fc2a0051d2e71b5008ff9b", "url": "https://github.com/elastic/elasticsearch/commit/85ab5bef223995dff4fc2a0051d2e71b5008ff9b", "message": "checkstyleo", "committedDate": "2020-06-24T09:32:32Z", "type": "commit"}, {"oid": "6d23195e47c62f614373ddce54ea9e825ae73c57", "url": "https://github.com/elastic/elasticsearch/commit/6d23195e47c62f614373ddce54ea9e825ae73c57", "message": "change action  name", "committedDate": "2020-06-24T09:55:21Z", "type": "commit"}, {"oid": "27fa80077c0039b1f848e70cafe6f19e8f39b572", "url": "https://github.com/elastic/elasticsearch/commit/27fa80077c0039b1f848e70cafe6f19e8f39b572", "message": "fix test", "committedDate": "2020-06-24T10:33:08Z", "type": "commit"}, {"oid": "695356983b5ce9cf1e15ab49ad472a864f802d1b", "url": "https://github.com/elastic/elasticsearch/commit/695356983b5ce9cf1e15ab49ad472a864f802d1b", "message": "One more  occurrence of close", "committedDate": "2020-06-24T10:43:26Z", "type": "commit"}, {"oid": "39498f6d7950cdc8bde62b6ec25f4d5be093030d", "url": "https://github.com/elastic/elasticsearch/commit/39498f6d7950cdc8bde62b6ec25f4d5be093030d", "message": "Fix docs CI", "committedDate": "2020-06-24T12:43:51Z", "type": "commit"}, {"oid": "a3069556007927fb98cb80d7cbf3c0a8e152ebab", "url": "https://github.com/elastic/elasticsearch/commit/a3069556007927fb98cb80d7cbf3c0a8e152ebab", "message": "Additional doc changes", "committedDate": "2020-06-24T13:22:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MzE3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445883171", "bodyText": "This javadoc could definitely be more helpful, since the basic text here could be inferred from the name of the class. I was thinking something along the lines of:\n\nThe {@link TransportAddIndexBlockAction} class adds a single index level block to a given set of indices. Not only does it set the correct setting, but it ensures that, once successfully returning to the user, all shards of the index are properly accounting for the block, for instance, when adding a write block all in-flight writes to an index have been completed prior to the response being returned. These actions are done in multiple cluster state updates (at least two). See also {@link TransportVerifyShardIndexBlockAction} for the eventual delegation for shard-level verification.", "author": "dakrone", "createdAt": "2020-06-25T22:58:33Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportAddIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DestructiveOperations;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetadataIndexStateService;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+\n+/**\n+ * Add index block action", "originalCommit": "a3069556007927fb98cb80d7cbf3c0a8e152ebab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MzM2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445883367", "bodyText": "Minor nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalStateException(\"Index shard \" + shardId + \" is not blocking all operations during read-only marking\");\n          \n          \n            \n                        throw new IllegalStateException(\"index shard \" + shardId + \" is not blocking all operations during read-only marking\");", "author": "dakrone", "createdAt": "2020-06-25T22:59:09Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.replication.ReplicationOperation;\n+import org.elasticsearch.action.support.replication.ReplicationRequest;\n+import org.elasticsearch.action.support.replication.ReplicationResponse;\n+import org.elasticsearch.action.support.replication.TransportReplicationAction;\n+import org.elasticsearch.cluster.action.shard.ShardStateAction;\n+import org.elasticsearch.cluster.block.ClusterBlock;\n+import org.elasticsearch.cluster.block.ClusterBlocks;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Action used to verify whether shards have properly applied a given index block,\n+ * and are no longer executing any operations in violation of that block. This action\n+ * requests all operation permits of the shard in order to wait for all write operations\n+ * to complete.\n+ */\n+public class TransportVerifyShardIndexBlockAction extends TransportReplicationAction<\n+    TransportVerifyShardIndexBlockAction.ShardRequest, TransportVerifyShardIndexBlockAction.ShardRequest, ReplicationResponse> {\n+\n+    public static final String NAME = AddIndexBlockAction.NAME + \"[s]\";\n+    public static final ActionType<ReplicationResponse> TYPE = new ActionType<>(NAME, ReplicationResponse::new);\n+    protected Logger logger = LogManager.getLogger(getClass());\n+\n+    @Inject\n+    public TransportVerifyShardIndexBlockAction(final Settings settings, final TransportService transportService,\n+                                                final ClusterService clusterService, final IndicesService indicesService,\n+                                                final ThreadPool threadPool, final ShardStateAction stateAction,\n+                                                final ActionFilters actionFilters) {\n+        super(settings, NAME, transportService, clusterService, indicesService, threadPool, stateAction, actionFilters,\n+            ShardRequest::new, ShardRequest::new, ThreadPool.Names.MANAGEMENT);\n+    }\n+\n+    @Override\n+    protected ReplicationResponse newResponseInstance(StreamInput in) throws IOException {\n+        return new ReplicationResponse(in);\n+    }\n+\n+    @Override\n+    protected void acquirePrimaryOperationPermit(final IndexShard primary,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired) {\n+        primary.acquireAllPrimaryOperationsPermits(onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void acquireReplicaOperationPermit(final IndexShard replica,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired,\n+                                                 final long primaryTerm,\n+                                                 final long globalCheckpoint,\n+                                                 final long maxSeqNoOfUpdateOrDeletes) {\n+        replica.acquireAllReplicaOperationsPermits(primaryTerm, globalCheckpoint, maxSeqNoOfUpdateOrDeletes, onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void shardOperationOnPrimary(final ShardRequest shardRequest, final IndexShard primary,\n+            ActionListener<PrimaryResult<ShardRequest, ReplicationResponse>> listener) {\n+        ActionListener.completeWith(listener, () -> {\n+            executeShardOperation(shardRequest, primary);\n+            return new PrimaryResult<>(shardRequest, new ReplicationResponse());\n+        });\n+    }\n+\n+    @Override\n+    protected ReplicaResult shardOperationOnReplica(final ShardRequest shardRequest, final IndexShard replica) throws IOException {\n+        executeShardOperation(shardRequest, replica);\n+        return new ReplicaResult();\n+    }\n+\n+    private void executeShardOperation(final ShardRequest request, final IndexShard indexShard) throws IOException {\n+        final ShardId shardId = indexShard.shardId();\n+        if (indexShard.getActiveOperationsCount() != IndexShard.OPERATIONS_BLOCKED) {\n+            throw new IllegalStateException(\"Index shard \" + shardId + \" is not blocking all operations during read-only marking\");", "originalCommit": "a3069556007927fb98cb80d7cbf3c0a8e152ebab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MzQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445883420", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalStateException(\"Index shard \" + shardId + \" must be blocked by \" + request.clusterBlock() +\n          \n          \n            \n                        throw new IllegalStateException(\"index shard \" + shardId + \" must be blocked by \" + request.clusterBlock() +", "author": "dakrone", "createdAt": "2020-06-25T22:59:20Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.replication.ReplicationOperation;\n+import org.elasticsearch.action.support.replication.ReplicationRequest;\n+import org.elasticsearch.action.support.replication.ReplicationResponse;\n+import org.elasticsearch.action.support.replication.TransportReplicationAction;\n+import org.elasticsearch.cluster.action.shard.ShardStateAction;\n+import org.elasticsearch.cluster.block.ClusterBlock;\n+import org.elasticsearch.cluster.block.ClusterBlocks;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Action used to verify whether shards have properly applied a given index block,\n+ * and are no longer executing any operations in violation of that block. This action\n+ * requests all operation permits of the shard in order to wait for all write operations\n+ * to complete.\n+ */\n+public class TransportVerifyShardIndexBlockAction extends TransportReplicationAction<\n+    TransportVerifyShardIndexBlockAction.ShardRequest, TransportVerifyShardIndexBlockAction.ShardRequest, ReplicationResponse> {\n+\n+    public static final String NAME = AddIndexBlockAction.NAME + \"[s]\";\n+    public static final ActionType<ReplicationResponse> TYPE = new ActionType<>(NAME, ReplicationResponse::new);\n+    protected Logger logger = LogManager.getLogger(getClass());\n+\n+    @Inject\n+    public TransportVerifyShardIndexBlockAction(final Settings settings, final TransportService transportService,\n+                                                final ClusterService clusterService, final IndicesService indicesService,\n+                                                final ThreadPool threadPool, final ShardStateAction stateAction,\n+                                                final ActionFilters actionFilters) {\n+        super(settings, NAME, transportService, clusterService, indicesService, threadPool, stateAction, actionFilters,\n+            ShardRequest::new, ShardRequest::new, ThreadPool.Names.MANAGEMENT);\n+    }\n+\n+    @Override\n+    protected ReplicationResponse newResponseInstance(StreamInput in) throws IOException {\n+        return new ReplicationResponse(in);\n+    }\n+\n+    @Override\n+    protected void acquirePrimaryOperationPermit(final IndexShard primary,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired) {\n+        primary.acquireAllPrimaryOperationsPermits(onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void acquireReplicaOperationPermit(final IndexShard replica,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired,\n+                                                 final long primaryTerm,\n+                                                 final long globalCheckpoint,\n+                                                 final long maxSeqNoOfUpdateOrDeletes) {\n+        replica.acquireAllReplicaOperationsPermits(primaryTerm, globalCheckpoint, maxSeqNoOfUpdateOrDeletes, onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void shardOperationOnPrimary(final ShardRequest shardRequest, final IndexShard primary,\n+            ActionListener<PrimaryResult<ShardRequest, ReplicationResponse>> listener) {\n+        ActionListener.completeWith(listener, () -> {\n+            executeShardOperation(shardRequest, primary);\n+            return new PrimaryResult<>(shardRequest, new ReplicationResponse());\n+        });\n+    }\n+\n+    @Override\n+    protected ReplicaResult shardOperationOnReplica(final ShardRequest shardRequest, final IndexShard replica) throws IOException {\n+        executeShardOperation(shardRequest, replica);\n+        return new ReplicaResult();\n+    }\n+\n+    private void executeShardOperation(final ShardRequest request, final IndexShard indexShard) throws IOException {\n+        final ShardId shardId = indexShard.shardId();\n+        if (indexShard.getActiveOperationsCount() != IndexShard.OPERATIONS_BLOCKED) {\n+            throw new IllegalStateException(\"Index shard \" + shardId + \" is not blocking all operations during read-only marking\");\n+        }\n+\n+        final ClusterBlocks clusterBlocks = clusterService.state().blocks();\n+        if (clusterBlocks.hasIndexBlock(shardId.getIndexName(), request.clusterBlock()) == false) {\n+            throw new IllegalStateException(\"Index shard \" + shardId + \" must be blocked by \" + request.clusterBlock() +", "originalCommit": "a3069556007927fb98cb80d7cbf3c0a8e152ebab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4NDc0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445884741", "bodyText": "super minor, but since we usually wrap things in []:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\")));\n          \n          \n            \n                        blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.toList()));", "author": "dakrone", "createdAt": "2020-06-25T23:03:42Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,176 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    /**\n+     * Updates the cluster state for the given indices with the given index block,\n+     * and also returns the updated indices (and their blocks) in a map.\n+     * @param indices The indices to add blocks to if needed\n+     * @param currentState The current cluster state\n+     * @param block The type of block to add\n+     * @return a tuple of the updated cluster state, as well as the blocks that got added\n+     */\n+    static Tuple<ClusterState, Map<Index, ClusterBlock>> addIndexBlock(final Index[] indices, final ClusterState currentState,\n+                                                                       final APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return Tuple.tuple(currentState, Collections.emptyMap());\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+        final Map<Index, ClusterBlock> blockedIndices = new HashMap<>();\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\")));", "originalCommit": "a3069556007927fb98cb80d7cbf3c0a8e152ebab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e20b9f7e072f0c90eeac9e1926a3322e6847aeb7", "url": "https://github.com/elastic/elasticsearch/commit/e20b9f7e072f0c90eeac9e1926a3322e6847aeb7", "message": "Merge remote-tracking branch 'elastic/master' into add-index-block-api", "committedDate": "2020-06-29T07:32:22Z", "type": "commit"}, {"oid": "dff8526d29def30654074eb1a0c2cde3c0c40e1e", "url": "https://github.com/elastic/elasticsearch/commit/dff8526d29def30654074eb1a0c2cde3c0c40e1e", "message": "Nits", "committedDate": "2020-06-29T07:38:23Z", "type": "commit"}, {"oid": "1f9ccb0ef2e931877de7b3549afae4ef277843c4", "url": "https://github.com/elastic/elasticsearch/commit/1f9ccb0ef2e931877de7b3549afae4ef277843c4", "message": "Only for write blocks", "committedDate": "2020-06-29T07:41:32Z", "type": "commit"}, {"oid": "0f39c54e28a705c81365db2222bd93607471ac3c", "url": "https://github.com/elastic/elasticsearch/commit/0f39c54e28a705c81365db2222bd93607471ac3c", "message": "API", "committedDate": "2020-06-29T08:13:47Z", "type": "commit"}, {"oid": "0bf1c91d14aca6860c030f3dde8794f7b5215506", "url": "https://github.com/elastic/elasticsearch/commit/0bf1c91d14aca6860c030f3dde8794f7b5215506", "message": "touched wrong class", "committedDate": "2020-06-29T10:22:15Z", "type": "commit"}]}