{"pr_number": 58933, "pr_title": "[ML] add exponent output aggregator to inference", "pr_createdAt": "2020-07-02T15:30:42Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58933", "timeline": [{"oid": "93f057c9eeffcb055e339d809f9b7e529d4efdee", "url": "https://github.com/elastic/elasticsearch/commit/93f057c9eeffcb055e339d809f9b7e529d4efdee", "message": "[ML] add exponent output aggregator to inference", "committedDate": "2020-07-02T15:29:09Z", "type": "commit"}, {"oid": "84748c3519196f7db3d65dcf37e604ffe49446fc", "url": "https://github.com/elastic/elasticsearch/commit/84748c3519196f7db3d65dcf37e604ffe49446fc", "message": "fixing docs", "committedDate": "2020-07-02T15:40:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU1MzY2OA==", "url": "https://github.com/elastic/elasticsearch/pull/58933#discussion_r449553668", "bodyText": "You've got the math right! \ud83d\udc4d", "author": "valeriy42", "createdAt": "2020-07-03T12:18:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/ensemble/Exponent.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel.ensemble;\n+\n+import org.apache.lucene.util.RamUsageEstimator;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.TargetType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class Exponent implements StrictlyParsedOutputAggregator, LenientlyParsedOutputAggregator {\n+\n+    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Exponent.class);\n+    public static final ParseField NAME = new ParseField(\"exponent\");\n+    public static final ParseField WEIGHTS = new ParseField(\"weights\");\n+\n+    private static final ConstructingObjectParser<Exponent, Void> LENIENT_PARSER = createParser(true);\n+    private static final ConstructingObjectParser<Exponent, Void> STRICT_PARSER = createParser(false);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static ConstructingObjectParser<Exponent, Void> createParser(boolean lenient) {\n+        ConstructingObjectParser<Exponent, Void> parser = new ConstructingObjectParser<>(\n+            NAME.getPreferredName(),\n+            lenient,\n+            a -> new Exponent((List<Double>)a[0]));\n+        parser.declareDoubleArray(ConstructingObjectParser.optionalConstructorArg(), WEIGHTS);\n+        return parser;\n+    }\n+\n+    public static Exponent fromXContentStrict(XContentParser parser) {\n+        return STRICT_PARSER.apply(parser, null);\n+    }\n+\n+    public static Exponent fromXContentLenient(XContentParser parser) {\n+        return LENIENT_PARSER.apply(parser, null);\n+    }\n+\n+    private final double[] weights;\n+\n+    Exponent() {\n+        this((List<Double>) null);\n+    }\n+\n+    private Exponent(List<Double> weights) {\n+        this(weights == null ? null : weights.stream().mapToDouble(Double::valueOf).toArray());\n+    }\n+\n+    public Exponent(double[] weights) {\n+        this.weights = weights;\n+    }\n+\n+    public Exponent(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            this.weights = in.readDoubleArray();\n+        } else {\n+            this.weights = null;\n+        }\n+    }\n+\n+    @Override\n+    public Integer expectedValueSize() {\n+        return this.weights == null ? null : this.weights.length;\n+    }\n+\n+    @Override\n+    public double[] processValues(double[][] values) {\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        if (weights != null && values.length != weights.length) {\n+            throw new IllegalArgumentException(\"values must be the same length as weights.\");\n+        }\n+        assert values[0].length == 1;\n+        double[] processed = new double[values.length];\n+        for (int i = 0; i < values.length; ++i) {\n+            if (weights != null) {\n+                processed[i] = weights[i] * values[i][0];\n+            } else {\n+                processed[i] = values[i][0];\n+            }\n+        }\n+        return processed;\n+    }\n+\n+    @Override\n+    public double aggregate(double[] values) {\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        double sum = 0.0;\n+        for (double val : values) {\n+            if (Double.isFinite(val)) {\n+                sum += val;\n+            }\n+        }\n+        return Math.exp(sum);", "originalCommit": "84748c3519196f7db3d65dcf37e604ffe49446fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}