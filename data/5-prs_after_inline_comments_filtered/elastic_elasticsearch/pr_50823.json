{"pr_number": 50823, "pr_title": "SQL: change the way unsupported data types fields are handled", "pr_createdAt": "2020-01-09T22:18:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50823", "timeline": [{"oid": "b2b553a174bf291af8ccff9edca88ca75f1b119e", "url": "https://github.com/elastic/elasticsearch/commit/b2b553a174bf291af8ccff9edca88ca75f1b119e", "message": "Properly ignore (for the moment) the \"flattened\" data type, treating it\nas of UNSUPPORTED type", "committedDate": "2020-01-09T22:12:40Z", "type": "commit"}, {"oid": "920e14334928482f0d8cd9dae57385c058133c9b", "url": "https://github.com/elastic/elasticsearch/commit/920e14334928482f0d8cd9dae57385c058133c9b", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into ignore_flattened_fields", "committedDate": "2020-01-09T22:12:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE0NDM3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r365144371", "bodyText": "I wonder if we cannot make this a bit generic by looking for field names that have leaves starting with _ and if so, look at their type  - if its not recognized, mark the field as unsupported.", "author": "costin", "createdAt": "2020-01-10T09:35:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/index/IndexResolver.java", "diffHunk": "@@ -493,6 +495,12 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n                 if (typeEntry.getKey().startsWith(\"_\") && typeCap.getType().startsWith(\"_\")) {\n                     continue;\n                 }\n+                \n+                // skip the \"flattened\" type of field's \"_keyed\" subfield", "originalCommit": "920e14334928482f0d8cd9dae57385c058133c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba09e3e25360d1cd6f18c5aa46e70421ebd3489f", "url": "https://github.com/elastic/elasticsearch/commit/ba09e3e25360d1cd6f18c5aa46e70421ebd3489f", "message": "Make the unsupported fields handling a generic one", "committedDate": "2020-01-13T16:20:34Z", "type": "commit"}, {"oid": "007d6cdfa0310b0cd36e2387d23b16861065f4b8", "url": "https://github.com/elastic/elasticsearch/commit/007d6cdfa0310b0cd36e2387d23b16861065f4b8", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into ignore_flattened_fields", "committedDate": "2020-01-13T16:21:04Z", "type": "commit"}, {"oid": "c1809e585e7c357451795af9fea79c352400c673", "url": "https://github.com/elastic/elasticsearch/commit/c1809e585e7c357451795af9fea79c352400c673", "message": "Small cleanup", "committedDate": "2020-01-13T16:32:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2MTA4NA==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r366461084", "bodyText": "minor: extra new line", "author": "matriv", "createdAt": "2020-01-14T17:04:17Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -495,6 +501,7 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n                 if (typeEntry.getKey().startsWith(\"_\") && typeCap.getType().startsWith(\"_\")) {\n                     continue;\n                 }\n+                ", "originalCommit": "44cf2049aacaec835df2d0b487f316cc41b5706a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0e51f4376d9992afb83d13a72289cf2e5e423d73", "url": "https://github.com/elastic/elasticsearch/commit/0e51f4376d9992afb83d13a72289cf2e5e423d73", "message": "Add one more test", "committedDate": "2020-01-15T12:05:13Z", "type": "commit"}, {"oid": "330557d24a9907ad227f861e70651566c00188d1", "url": "https://github.com/elastic/elasticsearch/commit/330557d24a9907ad227f861e70651566c00188d1", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into ignore_flattened_fields", "committedDate": "2020-01-15T12:05:28Z", "type": "commit"}, {"oid": "1d1d5dae44d28fce1179b6031b0de0725f130e14", "url": "https://github.com/elastic/elasticsearch/commit/1d1d5dae44d28fce1179b6031b0de0725f130e14", "message": "Added a way to remember the first unsupported data type in a hierarchy\nof fields to improve error reporting", "committedDate": "2020-01-15T15:51:52Z", "type": "commit"}, {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8", "url": "https://github.com/elastic/elasticsearch/commit/a9e92964d51ee46440627913aa6fb3aca81401c8", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into ignore_flattened_fields", "committedDate": "2020-01-15T15:57:15Z", "type": "commit"}, {"oid": "a9e92964d51ee46440627913aa6fb3aca81401c8", "url": "https://github.com/elastic/elasticsearch/commit/a9e92964d51ee46440627913aa6fb3aca81401c8", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into ignore_flattened_fields", "committedDate": "2020-01-15T15:57:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NTg3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367345873", "bodyText": "The whole block can be further simplified by\nesField = new UnsupportedEsField(esField.getName(), type, inherited != null ? inherited : unsupportedParent.getName(), esField.getProperties());", "author": "costin", "createdAt": "2020-01-16T10:37:54Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -387,7 +388,22 @@ private static EsField createField(String fieldName, Map<String, Map<String, Fie\n         }\n \n         EsField esField = field.apply(fieldName);\n-        \n+\n+        if (parent != null && parent instanceof UnsupportedEsField) {\n+            UnsupportedEsField unsupportedParent = (UnsupportedEsField) parent;\n+            String inherited = unsupportedParent.getInherited();\n+            String type = unsupportedParent.getOriginalType();\n+            \n+            if (inherited == null) {", "originalCommit": "a9e92964d51ee46440627913aa6fb3aca81401c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NjkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367346901", "bodyText": "Why is the if needed - the result will be the same regardless of whether field is UnsupportedEsField or not.", "author": "costin", "createdAt": "2020-01-16T10:40:03Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "diffHunk": "@@ -113,4 +114,21 @@ private static boolean boolSetting(Object value, boolean defaultValue) {\n     private static int intSetting(Object value, int defaultValue) {\n         return value == null ? defaultValue : Integer.parseInt(value.toString());\n     }\n+    \n+    private static void propagateUnsupportedType(String inherited, String originalType, Map<String, EsField> properties) {\n+        if (properties != null && properties.isEmpty() == false) {\n+            for (Entry<String, EsField> entry : properties.entrySet()) {\n+                EsField field = entry.getValue();\n+                UnsupportedEsField u;\n+                if (field instanceof UnsupportedEsField) {", "originalCommit": "a9e92964d51ee46440627913aa6fb3aca81401c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0ODg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367348844", "bodyText": "Since the message is the same in the branch, simply do the if on the prefix\nString inheritedMessage = \"\";\nif (unsupportedField.hasInherited()) {\n   inheritedMessage = format(\"in hierarchy (field [{}\"], unsupportedField.getInherited()));\n}\nnamed = u.withUnresolvedMessage(... + inheritedMessage);\n\nFurther more replace the string concatenation in the message with MessageFormat.format to trim it a bit.", "author": "costin", "createdAt": "2020-01-16T10:44:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "diffHunk": "@@ -217,8 +217,14 @@ private static Attribute handleSpecialFields(UnresolvedAttribute u, Attribute na\n             // unsupported types\n             else if (DataTypes.isUnsupported(fa.dataType())) {\n                 UnsupportedEsField unsupportedField = (UnsupportedEsField) fa.field();\n-                named = u.withUnresolvedMessage(\n-                        \"Cannot use field [\" + fa.name() + \"] type [\" + unsupportedField.getOriginalType() + \"] as is unsupported\");\n+                if (unsupportedField.hasInherited()) {", "originalCommit": "a9e92964d51ee46440627913aa6fb3aca81401c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDQ3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367350472", "bodyText": "Why is propagated needed? The parents should always be discovered before children which means an unsupported parent will discovered before its children, which in turn, will already know their parent is unsupported and thus become unsupported as well.", "author": "costin", "createdAt": "2020-01-16T10:47:49Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/type/Types.java", "diffHunk": "@@ -91,7 +91,8 @@ private static void walkMapping(String name, Object value, Map<String, EsField>\n                     break;\n                 case UNSUPPORTED:\n                     String type = content.get(\"type\").toString();\n-                    field = new UnsupportedEsField(name, type);\n+                    field = new UnsupportedEsField(name, type, null, properties);\n+                    propagateUnsupportedType(name, type, properties);", "originalCommit": "a9e92964d51ee46440627913aa6fb3aca81401c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1OTcxMw==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367359713", "bodyText": "@costin  If I remember well, the method pair startWalking-walkMapping does the discovery the other way around: start with a mapping looking like parent=[child=[another_child=[type:keyword]], type:text], type:foobar]], get the parent, look at properties like \"it's nested\", or \"it's object\", or \"has sub-fields\" here, if yes, dig into those and so on and so forth.\nThen after discovering all the children, create the parent itself here. So, by the time the algorithm finds out that a root field is unsupported, the children already have some types (their own).", "author": "astefan", "createdAt": "2020-01-16T11:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MDc3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50823#discussion_r367790773", "bodyText": "This approach is used only in the case of some tests that use a .json file with mappings. I made this change because I wanted to also test the error message (here) that gets printed out from the Analyzer.", "author": "astefan", "createdAt": "2020-01-17T06:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDQ3Mg=="}], "type": "inlineReview"}]}