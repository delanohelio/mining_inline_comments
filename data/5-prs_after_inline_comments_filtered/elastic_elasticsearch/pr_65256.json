{"pr_number": 65256, "pr_title": "Phase 1 support for operator privileges", "pr_createdAt": "2020-11-19T12:06:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65256", "timeline": [{"oid": "4966365adbe68efdde84088bb1afe0ca253fcfb8", "url": "https://github.com/elastic/elasticsearch/commit/4966365adbe68efdde84088bb1afe0ca253fcfb8", "message": "WIP: operator privileges initial working code with smoke tests", "committedDate": "2020-11-23T10:49:26Z", "type": "commit"}, {"oid": "96ccc048e65339698920f94c1f56323212320bc2", "url": "https://github.com/elastic/elasticsearch/commit/96ccc048e65339698920f94c1f56323212320bc2", "message": "WIP: working on tests", "committedDate": "2020-11-23T13:00:13Z", "type": "forcePushed"}, {"oid": "ceef13c8444ffc4cabf31e8450004048abec7b0a", "url": "https://github.com/elastic/elasticsearch/commit/ceef13c8444ffc4cabf31e8450004048abec7b0a", "message": "WIP: working on tests", "committedDate": "2020-11-23T23:54:59Z", "type": "forcePushed"}, {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "url": "https://github.com/elastic/elasticsearch/commit/3d5f3b0417388819e4bc8bef73cc76321b16e046", "message": "WIP: working on tests", "committedDate": "2020-11-24T01:18:23Z", "type": "commit"}, {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "url": "https://github.com/elastic/elasticsearch/commit/3d5f3b0417388819e4bc8bef73cc76321b16e046", "message": "WIP: working on tests", "committedDate": "2020-11-24T01:18:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529195729", "bodyText": "Other than adding the new enum here, what else is needed for telemetry? The XPackUsageFeatureAction is for feature usage which means billing and is not telemetry?", "author": "ywangd", "createdAt": "2020-11-24T04:32:04Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java", "diffHunk": "@@ -98,7 +98,9 @@\n \n         ANALYTICS(OperationMode.MISSING, true),\n \n-        SEARCHABLE_SNAPSHOTS(OperationMode.ENTERPRISE, true);\n+        SEARCHABLE_SNAPSHOTS(OperationMode.ENTERPRISE, true),\n+\n+        OPERATOR_PRIVILEGES(OperationMode.ENTERPRISE, true);", "originalCommit": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NjU3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529196579", "bodyText": "XPackUsageFeatureAction is telemetry, not billing.\nBilling is GetFeatureUsageResponse.FeatureUsageInfo", "author": "tvernum", "createdAt": "2020-11-24T04:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwNzk1OA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531007958", "bodyText": "Thanks. The names are pretty confusing. It's now added.\nFun fact, the new telemetry action is the first one that trips the test of \"every acton is either operator-only or non-operator\".", "author": "ywangd", "createdAt": "2020-11-26T12:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTcyOQ=="}], "type": "inlineReview"}, {"oid": "cd5f33999d1edbb12a58c9bdfda5e97b7cf9379c", "url": "https://github.com/elastic/elasticsearch/commit/cd5f33999d1edbb12a58c9bdfda5e97b7cf9379c", "message": "Remove unnecessary file", "committedDate": "2020-11-24T05:07:47Z", "type": "commit"}, {"oid": "9834e47680d6aeec804f98807566a2727a543e04", "url": "https://github.com/elastic/elasticsearch/commit/9834e47680d6aeec804f98807566a2727a543e04", "message": "Use javaRestTest instead of test to align with recent changes", "committedDate": "2020-11-24T05:22:19Z", "type": "commit"}, {"oid": "9b63010318840d5ccd19ca3b4242b25c4d39942c", "url": "https://github.com/elastic/elasticsearch/commit/9b63010318840d5ccd19ca3b4242b25c4d39942c", "message": "Add a test plugin to ensure every action is declared either operator-only or not", "committedDate": "2020-11-24T08:14:18Z", "type": "commit"}, {"oid": "be893ec7f85f2080676bedd20b3b97cfbbd8fb26", "url": "https://github.com/elastic/elasticsearch/commit/be893ec7f85f2080676bedd20b3b97cfbbd8fb26", "message": "spotless", "committedDate": "2020-11-24T09:01:44Z", "type": "commit"}, {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "url": "https://github.com/elastic/elasticsearch/commit/2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "message": "testingConventions test", "committedDate": "2020-11-24T09:37:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5Njg0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529196840", "bodyText": "Can you explain?", "author": "tvernum", "createdAt": "2020-11-24T04:35:49Z", "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/NonOperatorOnlyActions.java", "diffHunk": "@@ -0,0 +1,13 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+class NonOperatorOnlyActions {", "originalCommit": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEyNzE3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530127171", "bodyText": "This file is deleted.", "author": "ywangd", "createdAt": "2020-11-25T06:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5Njg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529203459", "bodyText": "It's minor, but I find that to be a weird way to express containsNone (or not containsAny).\nAlso, it's going to be hard to debug if it fails.\nIf it were me, I'd implement a custom hasAny() matcher, and wrap it in a not", "author": "tvernum", "createdAt": "2020-11-24T04:58:55Z", "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.inject.Binding;\n+import org.elasticsearch.common.inject.Injector;\n+import org.elasticsearch.common.inject.TypeLiteral;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + OPERATOR_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"limited_operator:\\n\"\n+            + \"  cluster:\\n\"\n+            + \"    - 'cluster:admin/voting_config/clear_exclusions'\\n\"\n+            + \"    - 'monitor'\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"limited_operator:\" + OPERATOR_USER_NAME + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configOperatorUsers() {\n+        return super.configOperatorUsers()\n+            + \"operator:\\n\"\n+            + \"  - usernames: ['\" + OPERATOR_USER_NAME + \"']\\n\";\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings() {\n+        Settings.Builder builder = Settings.builder().put(super.nodeSettings());\n+        // Ensure the new settings can be configured\n+        builder.put(\"xpack.security.operator_privileges.enabled\", \"true\");\n+        return builder.build();\n+    }\n+\n+    // TODO: Not all plugins are available in internal cluster tests. Hence not all action names can be checked.\n+    public void testActionsAreEitherOperatorOnlyOrNot() {\n+        final Injector injector = node().injector();\n+        final List<Binding<TransportAction>> bindings = injector.findBindingsByType(TypeLiteral.get(TransportAction.class));\n+\n+        final List<String> allActionNames = new ArrayList<>(bindings.size());\n+        for (final Binding<TransportAction> binding : bindings) {\n+            allActionNames.add(binding.getProvider().get().actionName);\n+        }\n+\n+        final Set<String> nonOperatorActions = Set.of(NON_OPERATOR_ACTIONS);\n+        final Set<String> expectedOperatorOnlyActions = Sets.difference(Set.copyOf(allActionNames), nonOperatorActions);\n+        final Set<String> actualOperatorOnlyActions = new HashSet<>(CompositeOperatorOnly.ActionOperatorOnly.SIMPLE_ACTIONS);\n+        assertTrue(actualOperatorOnlyActions.containsAll(expectedOperatorOnlyActions));\n+        assertFalse(actualOperatorOnlyActions.removeAll(nonOperatorActions));", "originalCommit": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEyOTkzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530129939", "bodyText": "Sorry there are some messiness in the code because I tried different ideas and didn't clean it up after settled. This is the earlier attempt for ensuring every action is marked as either operator or non-operator. However, as discussed, SingleNodeTest is not the right approach because it does not cover all xpack plugins. I have since added the test with an external cluster + plugin test (OpTestPlugin, it's a bad name and I'll work on it). So I will remove all these code in SingleNodeTest and turn it into just a feature tests, i.e. whether the feature works or not. So in summary, we will have:\n\nSingleNodeTest for features\nExternal cluster + plugin for testing \"action completeness\" and also features. There will be some overlap in terms of feature testing. But I think it also provides addtional value cocmpared to a SingleNodeTest, e.g. cross-nodes, actual file reading, and settings via yml config.\nOther unit tests.", "author": "ywangd", "createdAt": "2020-11-25T06:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNDEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529204136", "bodyText": "Should we have this method too?\npublic void testOperatorUserIsStillSubjectToRoleLimits()", "author": "tvernum", "createdAt": "2020-11-24T05:01:12Z", "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.inject.Binding;\n+import org.elasticsearch.common.inject.Injector;\n+import org.elasticsearch.common.inject.TypeLiteral;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + OPERATOR_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"limited_operator:\\n\"\n+            + \"  cluster:\\n\"\n+            + \"    - 'cluster:admin/voting_config/clear_exclusions'\\n\"\n+            + \"    - 'monitor'\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"limited_operator:\" + OPERATOR_USER_NAME + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configOperatorUsers() {\n+        return super.configOperatorUsers()\n+            + \"operator:\\n\"\n+            + \"  - usernames: ['\" + OPERATOR_USER_NAME + \"']\\n\";\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings() {\n+        Settings.Builder builder = Settings.builder().put(super.nodeSettings());\n+        // Ensure the new settings can be configured\n+        builder.put(\"xpack.security.operator_privileges.enabled\", \"true\");\n+        return builder.build();\n+    }\n+\n+    // TODO: Not all plugins are available in internal cluster tests. Hence not all action names can be checked.\n+    public void testActionsAreEitherOperatorOnlyOrNot() {\n+        final Injector injector = node().injector();\n+        final List<Binding<TransportAction>> bindings = injector.findBindingsByType(TypeLiteral.get(TransportAction.class));\n+\n+        final List<String> allActionNames = new ArrayList<>(bindings.size());\n+        for (final Binding<TransportAction> binding : bindings) {\n+            allActionNames.add(binding.getProvider().get().actionName);\n+        }\n+\n+        final Set<String> nonOperatorActions = Set.of(NON_OPERATOR_ACTIONS);\n+        final Set<String> expectedOperatorOnlyActions = Sets.difference(Set.copyOf(allActionNames), nonOperatorActions);\n+        final Set<String> actualOperatorOnlyActions = new HashSet<>(CompositeOperatorOnly.ActionOperatorOnly.SIMPLE_ACTIONS);\n+        assertTrue(actualOperatorOnlyActions.containsAll(expectedOperatorOnlyActions));\n+        assertFalse(actualOperatorOnlyActions.removeAll(nonOperatorActions));\n+    }\n+\n+    public void testSuperuserWillFailToCallOperatorOnlyAction() {\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        final ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class,\n+            () -> client().execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet());\n+        assertThat(e.getCause().getMessage(), containsString(\"Operator privileges are required for action\"));\n+    }\n+\n+    public void testOperatorUserWillSucceedToCallOperatorOnlyAction() {\n+        final Client client = client().filterWithHeader(Map.of(\n+            \"Authorization\",\n+            basicAuthHeaderValue(OPERATOR_USER_NAME, new SecureString(TEST_PASSWORD.toCharArray()))));\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        client.execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet();\n+    }\n+", "originalCommit": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNjE0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530706148", "bodyText": "Yes will add more tests. See also above.", "author": "ywangd", "createdAt": "2020-11-26T00:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNDEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNDI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529204296", "bodyText": "Its a subjective view, but I'd probably put this in a separate class just for neatness.", "author": "tvernum", "createdAt": "2020-11-24T05:01:53Z", "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.inject.Binding;\n+import org.elasticsearch.common.inject.Injector;\n+import org.elasticsearch.common.inject.TypeLiteral;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + OPERATOR_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"limited_operator:\\n\"\n+            + \"  cluster:\\n\"\n+            + \"    - 'cluster:admin/voting_config/clear_exclusions'\\n\"\n+            + \"    - 'monitor'\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"limited_operator:\" + OPERATOR_USER_NAME + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configOperatorUsers() {\n+        return super.configOperatorUsers()\n+            + \"operator:\\n\"\n+            + \"  - usernames: ['\" + OPERATOR_USER_NAME + \"']\\n\";\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings() {\n+        Settings.Builder builder = Settings.builder().put(super.nodeSettings());\n+        // Ensure the new settings can be configured\n+        builder.put(\"xpack.security.operator_privileges.enabled\", \"true\");\n+        return builder.build();\n+    }\n+\n+    // TODO: Not all plugins are available in internal cluster tests. Hence not all action names can be checked.\n+    public void testActionsAreEitherOperatorOnlyOrNot() {\n+        final Injector injector = node().injector();\n+        final List<Binding<TransportAction>> bindings = injector.findBindingsByType(TypeLiteral.get(TransportAction.class));\n+\n+        final List<String> allActionNames = new ArrayList<>(bindings.size());\n+        for (final Binding<TransportAction> binding : bindings) {\n+            allActionNames.add(binding.getProvider().get().actionName);\n+        }\n+\n+        final Set<String> nonOperatorActions = Set.of(NON_OPERATOR_ACTIONS);\n+        final Set<String> expectedOperatorOnlyActions = Sets.difference(Set.copyOf(allActionNames), nonOperatorActions);\n+        final Set<String> actualOperatorOnlyActions = new HashSet<>(CompositeOperatorOnly.ActionOperatorOnly.SIMPLE_ACTIONS);\n+        assertTrue(actualOperatorOnlyActions.containsAll(expectedOperatorOnlyActions));\n+        assertFalse(actualOperatorOnlyActions.removeAll(nonOperatorActions));\n+    }\n+\n+    public void testSuperuserWillFailToCallOperatorOnlyAction() {\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        final ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class,\n+            () -> client().execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet());\n+        assertThat(e.getCause().getMessage(), containsString(\"Operator privileges are required for action\"));\n+    }\n+\n+    public void testOperatorUserWillSucceedToCallOperatorOnlyAction() {\n+        final Client client = client().filterWithHeader(Map.of(\n+            \"Authorization\",\n+            basicAuthHeaderValue(OPERATOR_USER_NAME, new SecureString(TEST_PASSWORD.toCharArray()))));\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        client.execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet();\n+    }\n+\n+    public static final String[] NON_OPERATOR_ACTIONS = new String[] {", "originalCommit": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEzMDIwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530130209", "bodyText": "As commented earlier, this will be removed since it is better handled by the external cluster test, where this list is indeed in a separate class.", "author": "ywangd", "createdAt": "2020-11-25T06:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNDg3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530104877", "bodyText": "This seems more complex than we need. Don't we just need\nboolean isOperatorRequest(String action, TransportRequest request);", "author": "tvernum", "createdAt": "2020-11-25T04:44:09Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnly.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.function.Supplier;\n+\n+public interface OperatorOnly {\n+\n+    Result check(String action, TransportRequest request);\n+\n+    enum Status {\n+        YES, NO, CONTINUE;\n+    }", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMyODcxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530328711", "bodyText": "I can get rid of the Status enum. But if we want to leave spaces for settings (or even partial operator API), the return type needs to be more than just a boolean. Because an error/info message needs to be returned as well for meaningful errors, e.g. exactly which setting(s) is operator-only among all the settings being requested.", "author": "ywangd", "createdAt": "2020-11-25T12:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNDg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwOTg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530709841", "bodyText": "I think the enum is overkill. An Optional<String> would be an OK return type, but it's not perfect.\nWe use that pattern in Validatable in the HLRC (validate in transport returns Exception|null which is similar)", "author": "tvernum", "createdAt": "2020-11-26T00:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNDg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzk2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530713967", "bodyText": "I took a similar approach and it now returns a Supplier<String>. I use Supplier because the string may not be needed even the user is an operator user. It is only needed for \"non-operator-user meets operator-only action\".", "author": "ywangd", "createdAt": "2020-11-26T00:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNTg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530105896", "bodyText": "I think we should reverse the order of these if statements.\nIt will often be more efficient to check for whether the thread context is an operator, so I think we should just let operator users go through without checking the request/action.", "author": "tvernum", "createdAt": "2020-11-25T04:48:10Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorPrivileges.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.transport.TransportRequest;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+\n+public class OperatorPrivileges {\n+\n+    public static final Setting<Boolean> OPERATOR_PRIVILEGES_ENABLED =\n+        Setting.boolSetting(\"xpack.security.operator_privileges.enabled\", false, Setting.Property.NodeScope);\n+\n+    private final OperatorUserDescriptor operatorUserDescriptor;\n+    private final CompositeOperatorOnly compositeOperatorOnly;\n+    private final XPackLicenseState licenseState;\n+    private final boolean enabled;\n+\n+    public OperatorPrivileges(Settings settings, XPackLicenseState licenseState,\n+                              OperatorUserDescriptor operatorUserDescriptor, CompositeOperatorOnly compositeOperatorOnly) {\n+        this.operatorUserDescriptor = operatorUserDescriptor;\n+        this.compositeOperatorOnly = compositeOperatorOnly;\n+        this.licenseState = licenseState;\n+        this.enabled = OPERATOR_PRIVILEGES_ENABLED.get(settings);\n+    }\n+\n+    public void maybeMarkOperatorUser(Authentication authentication, ThreadContext threadContext) {\n+        if (shouldProcess() && operatorUserDescriptor.isOperatorUser(authentication)) {\n+            threadContext.putHeader(\n+                AuthenticationField.PRIVILEGE_CATEGORY_KEY,\n+                AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR);\n+        }\n+    }\n+\n+    public ElasticsearchSecurityException check(String action, TransportRequest request, ThreadContext threadContext) {\n+        if (false == shouldProcess()) {\n+            return null;\n+        }\n+        final OperatorOnly.Result operatorOnlyCheckResult = compositeOperatorOnly.check(action, request);\n+        if (operatorOnlyCheckResult.getStatus() == OperatorOnly.Status.YES) {\n+            if (false == AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR.equals(\n+                threadContext.getHeader(AuthenticationField.PRIVILEGE_CATEGORY_KEY))) {", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDM1ODE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530358149", "bodyText": "This is an excellent point. Thanks!", "author": "ywangd", "createdAt": "2020-11-25T13:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNjQxNw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530106417", "bodyText": "This shouldn't be lenient. If the file is missing or incorrect then it should fail the node on startup.", "author": "tvernum", "createdAt": "2020-11-25T04:50:23Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMDcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531010706", "bodyText": "Updated accordingly", "author": "ywangd", "createdAt": "2020-11-26T12:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNjQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMwNjg3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531306877", "bodyText": "Sorry I forgot to mention that the updated code still allows the file to be missing because I think it could be a valid use case. Because operator users are node specific, it might be useful to enable this feature, but only allow operator users to connect on specific nodes for performing the actions. In this case, a missing file would come in handy to block certain nodes from being used to issue operator-only requests. The same thing can be achieved by having an empty list for usernames in the config file. But it could provide convenience to allow the file to be simply deleted. Please let me know if you think this is still too much lenience and would prefer to not have it.", "author": "ywangd", "createdAt": "2020-11-27T01:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNjQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530107147", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return usernames.equals(group.usernames) && Objects.equals(realmName,\n          \n          \n            \n                            group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n          \n          \n            \n                        return usernames.equals(group.usernames) \n          \n          \n            \n                          && Objects.equals(realmName, group.realmName) \n          \n          \n            \n                          && realmType.equals(group.realmType) \n          \n          \n            \n                          && authenticationType == group.authenticationType;", "author": "tvernum", "createdAt": "2020-11-25T04:53:02Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDM3MTUyNA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530371524", "bodyText": "My IntelliJ format settings are not doing its job ...", "author": "ywangd", "createdAt": "2020-11-25T13:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530107885", "bodyText": "I think we need to wrap all this in an if-operator-privileges-configured, and then have a NoOperatorPrivileges impl.\nThen we can be strict in the parsing of operator privilege files, and warn loudly if they get deleted.", "author": "tvernum", "createdAt": "2020-11-25T04:56:00Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java", "diffHunk": "@@ -473,8 +476,10 @@ protected Clock getClock() {\n         getLicenseState().addListener(new SecurityStatusChangeListener(getLicenseState()));\n \n         final AuthenticationFailureHandler failureHandler = createAuthenticationFailureHandler(realms, extensionComponents);\n+        final OperatorPrivileges operatorPrivileges = new OperatorPrivileges(settings, getLicenseState(),\n+            new OperatorUserDescriptor(environment, resourceWatcherService), new CompositeOperatorOnly());", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwODM5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531008397", "bodyText": "Thanks for the suggestion. I have updated as suggested.", "author": "ywangd", "createdAt": "2020-11-26T12:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzk4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530107982", "bodyText": "I think this should be an error (assuming we only load this class if oper-privs are enabled).", "author": "tvernum", "createdAt": "2020-11-25T04:56:27Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static List<Group> parseFileLenient(Path path, Logger logger) {\n+        if (false == Files.exists(path)) {\n+            logger.debug(\"Skip reading operator user file since it does not exist\");", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwODU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531008566", "bodyText": "Removed", "author": "ywangd", "createdAt": "2020-11-26T12:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTEyOA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530111128", "bodyText": "You could use XContentParserUtils.ensureFieldName for this, couldn't you?", "author": "tvernum", "createdAt": "2020-11-25T05:08:21Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static List<Group> parseFileLenient(Path path, Logger logger) {\n+        if (false == Files.exists(path)) {\n+            logger.debug(\"Skip reading operator user file since it does not exist\");\n+            return List.of();\n+        }\n+        logger.debug(\"Reading operator users file [{}]\", path.toAbsolutePath());\n+        try {\n+            return parseFile(path);\n+        } catch (IOException | RuntimeException e) {\n+            logger.error(\"Failed to parse operator_users file [\" + path + \"].\", e);\n+            return List.of();\n+        }\n+    }\n+\n+    public static List<Group> parseFile(Path path) throws IOException {\n+        try (InputStream in = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            return parseConfig(in);\n+        }\n+    }\n+\n+    public static List<Group> parseConfig(InputStream in) throws IOException {\n+        final List<Group> groups = new ArrayList<>();\n+        try (XContentParser parser = yamlParser(in)) {\n+            XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser);\n+            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                XContentParserUtils.ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser);\n+                final String categoryName = parser.currentName();\n+                if (false == AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR.equals(categoryName)) {", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwOTE5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531009193", "bodyText": "No longer needed as the manual parsing is replaced by ObjectParser.", "author": "ywangd", "createdAt": "2020-11-26T12:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTUzMA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530111530", "bodyText": "Is it not possible to do this with ObjectParser?", "author": "tvernum", "createdAt": "2020-11-25T05:09:40Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static List<Group> parseFileLenient(Path path, Logger logger) {\n+        if (false == Files.exists(path)) {\n+            logger.debug(\"Skip reading operator user file since it does not exist\");\n+            return List.of();\n+        }\n+        logger.debug(\"Reading operator users file [{}]\", path.toAbsolutePath());\n+        try {\n+            return parseFile(path);\n+        } catch (IOException | RuntimeException e) {\n+            logger.error(\"Failed to parse operator_users file [\" + path + \"].\", e);\n+            return List.of();\n+        }\n+    }\n+\n+    public static List<Group> parseFile(Path path) throws IOException {\n+        try (InputStream in = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            return parseConfig(in);\n+        }\n+    }\n+\n+    public static List<Group> parseConfig(InputStream in) throws IOException {\n+        final List<Group> groups = new ArrayList<>();\n+        try (XContentParser parser = yamlParser(in)) {\n+            XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser);\n+            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                XContentParserUtils.ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser);\n+                final String categoryName = parser.currentName();\n+                if (false == AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR.equals(categoryName)) {\n+                    throw new IllegalArgumentException(\"Operator user config file must begin with operator, got [\" + categoryName + \"]\");\n+                }\n+                XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_ARRAY, parser.nextToken(), parser);\n+                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n+                    groups.add(parseOneGroup(parser));\n+                }\n+            }\n+        }\n+        return List.copyOf(groups);\n+    }\n+\n+    private static Group parseOneGroup(XContentParser parser) throws IOException {", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwODk4OA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531008988", "bodyText": "It is possible. I was just more comfortable with manual parsing. Anyway, I changed it to be ObjectParser.", "author": "ywangd", "createdAt": "2020-11-26T12:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMjU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530112599", "bodyText": "You can move this as an inner class of GetActionsAction (like autoscaling does) if you want.", "author": "tvernum", "createdAt": "2020-11-25T05:14:02Z", "path": "x-pack/qa/operator-privileges-tests/src/main/java/org/elasticsearch/example/actions/GetActionsRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.example.actions;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+\n+import java.io.IOException;\n+\n+public class GetActionsRequest extends ActionRequest {", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMDQ0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531010449", "bodyText": "All transport stuff is not needed because its handled with reflection in RestAction.", "author": "ywangd", "createdAt": "2020-11-26T12:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMjU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMjc3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530112777", "bodyText": "I would be fine with that.", "author": "tvernum", "createdAt": "2020-11-25T05:14:33Z", "path": "x-pack/qa/operator-privileges-tests/src/main/java/org/elasticsearch/example/actions/RestGetActionsAction.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.example.actions;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+public class RestGetActionsAction extends BaseRestHandler {\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(new Route(GET, \"/_test/get_actions\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"test_get_actions\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        // It is also possible to use reflection to get NodeClient#actions and save all the transport related classes", "originalCommit": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b284760b6abbc4996208c644ae731b1e1b5dd8e", "url": "https://github.com/elastic/elasticsearch/commit/1b284760b6abbc4996208c644ae731b1e1b5dd8e", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-11-25T13:25:33Z", "type": "commit"}, {"oid": "892840f780d89465a78a55ca4343e7aaee2a1b38", "url": "https://github.com/elastic/elasticsearch/commit/892840f780d89465a78a55ca4343e7aaee2a1b38", "message": "address feedback", "committedDate": "2020-11-25T20:58:52Z", "type": "commit"}, {"oid": "9314789eac46196c338749976e6db3a7f745dd2d", "url": "https://github.com/elastic/elasticsearch/commit/9314789eac46196c338749976e6db3a7f745dd2d", "message": "Simplify the plugin IT test with reflection", "committedDate": "2020-11-25T20:58:52Z", "type": "commit"}, {"oid": "5dedd54c3ae9e696ef2d12af95afdb1267792536", "url": "https://github.com/elastic/elasticsearch/commit/5dedd54c3ae9e696ef2d12af95afdb1267792536", "message": "spotless", "committedDate": "2020-11-25T21:41:44Z", "type": "commit"}, {"oid": "901ecd2d907653c956bf0718719908b579dd1602", "url": "https://github.com/elastic/elasticsearch/commit/901ecd2d907653c956bf0718719908b579dd1602", "message": "Refactor as suggested", "committedDate": "2020-11-26T07:40:56Z", "type": "commit"}, {"oid": "b52c8147e66d4236f6b12c1f001b0592c5a30302", "url": "https://github.com/elastic/elasticsearch/commit/b52c8147e66d4236f6b12c1f001b0592c5a30302", "message": "Move plugin test package", "committedDate": "2020-11-26T08:02:57Z", "type": "commit"}, {"oid": "5883923520fb9418330ef726d3a8fb460fbca498", "url": "https://github.com/elastic/elasticsearch/commit/5883923520fb9418330ef726d3a8fb460fbca498", "message": "Fix authenticationService tests", "committedDate": "2020-11-26T08:58:50Z", "type": "commit"}, {"oid": "1b3344f199b70b3db51de6c49d5efe4b289791f1", "url": "https://github.com/elastic/elasticsearch/commit/1b3344f199b70b3db51de6c49d5efe4b289791f1", "message": "Fix tests and telemetry", "committedDate": "2020-11-26T12:48:21Z", "type": "commit"}, {"oid": "0e170d913fd8517850477397d709dbd1911841d5", "url": "https://github.com/elastic/elasticsearch/commit/0e170d913fd8517850477397d709dbd1911841d5", "message": "Merge remote-tracking branch 'origin/master' into meta-101-operator-privileges-phase-one", "committedDate": "2020-11-26T12:58:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMzcxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531013715", "bodyText": "This test was skipped for a long time because of the naming convention mismatch. I fixed it but it's not 100% the same as it was because things evolved.", "author": "ywangd", "createdAt": "2020-11-26T13:01:24Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/AuthenticationServiceTests.java", "diffHunk": "@@ -567,24 +582,23 @@ public void testTokenRestMissing() throws Exception {\n         });\n     }\n \n-    public void authenticationInContextAndHeader() throws Exception {\n+    public void testAuthenticationInContextAndHeader() throws Exception {", "originalCommit": "0e170d913fd8517850477397d709dbd1911841d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNTA5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531015094", "bodyText": "I think auditing can be a follow up PR.", "author": "ywangd", "createdAt": "2020-11-26T13:04:07Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java", "diffHunk": "@@ -202,6 +205,16 @@ public void authorize(final Authentication authentication, final String action,\n             // sometimes a request might be wrapped within another, which is the case for proxied\n             // requests and concrete shard requests\n             final TransportRequest unwrappedRequest = maybeUnwrapRequest(authentication, originalRequest, action, auditId);\n+\n+            // Check operator privileges\n+            // TODO: audit?", "originalCommit": "0e170d913fd8517850477397d709dbd1911841d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1082b139f548520b4b790fbca6dace8c26410093", "url": "https://github.com/elastic/elasticsearch/commit/1082b139f548520b4b790fbca6dace8c26410093", "message": "fix test failures", "committedDate": "2020-11-26T22:09:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3NTg1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532375852", "bodyText": "Oh, I didn't realise this would need reflection - that's pretty ugly. Are you sure this is the best option?", "author": "tvernum", "createdAt": "2020-11-30T06:42:19Z", "path": "x-pack/plugin/security/qa/operator-privileges-tests/src/main/java/org/elasticsearch/xpack/security/operator/actions/RestGetActionsAction.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator.actions;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+public class RestGetActionsAction extends BaseRestHandler {\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(new Route(GET, \"/_test/get_actions\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"test_get_actions\";\n+    }\n+\n+    @SuppressForbidden(reason = \"Use reflection for testing only\")\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        final Map<ActionType, TransportAction> actions = AccessController.doPrivileged(\n+            (PrivilegedAction<Map<ActionType, TransportAction>>) () -> {\n+                try {\n+                    final Field actionsField = client.getClass().getDeclaredField(\"actions\");\n+                    actionsField.setAccessible(true);\n+                    return (Map<ActionType, TransportAction>) actionsField.get(client);\n+                } catch (NoSuchFieldException | IllegalAccessException e) {\n+                    throw new ElasticsearchException(e);\n+                }", "originalCommit": "1082b139f548520b4b790fbca6dace8c26410093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1NzM3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532557376", "bodyText": "The earlier version is to have Guice injection for the transport action. It comes with additional bolierplate code for transportAction handling which the reflection version helps to remove. I don't mind changing back to the Guice approach again, but I probably prefer reflection because:\n\nIt is more concise\nThe team wants to get rid of Guice. Though it may take a long time, Guice is on its way out. In contrast, we do have support for Plugins to use reflection with Java policy file. So it is more formal if you ask me.\n\nThe downside is that reflection relies on NodeClient's internals, which could change without notice. But since these are test code, I am not too worried.\nOther than these two approach, I cannot think of anything else without touching the production code.", "author": "ywangd", "createdAt": "2020-11-30T12:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3NTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3ODMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532378333", "bodyText": "Per my earlier comment I don't think we should be randomising this. The OperatorPrivilegesSingleNodeTests should run with operator privileges turned on.\nIf we need another set of tests without operator privileges, then let's add them, but randomisation is intended to deal with things that aren't supposed to affect the core of the test, rather than be a way to merge 2 test cases into 1 (but only run them half the time).", "author": "tvernum", "createdAt": "2020-11-30T06:50:12Z", "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.user.GetUsersAction;\n+import org.elasticsearch.xpack.core.security.action.user.GetUsersRequest;\n+import org.junit.BeforeClass;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    private static boolean OPERATOR_PRIVILEGES_ENABLED;\n+\n+    @BeforeClass\n+    public static void randomOperatorPrivilegesEnabled() {\n+        OPERATOR_PRIVILEGES_ENABLED = randomBoolean();", "originalCommit": "1082b139f548520b4b790fbca6dace8c26410093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1NzkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532557910", "bodyText": "Agreed. I remove it. The randomization is not necessary. For example, the clearVotingConfiguration is already tested by MinimumMasterNodesIT.", "author": "ywangd", "createdAt": "2020-11-30T12:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3ODMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MDAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532390002", "bodyText": "This message should use SINGLETON_REALM_TYPES", "author": "tvernum", "createdAt": "2020-11-30T07:25:23Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/FileOperatorUsersStore.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.esnative.NativeRealmSettings;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.security.operator.OperatorPrivileges.OPERATOR_PRIVILEGES_ENABLED;\n+\n+public class FileOperatorUsersStore {\n+    private static final Logger logger = LogManager.getLogger(FileOperatorUsersStore.class);\n+\n+    private final Path file;\n+    private volatile OperatorUsersDescriptor operatorUsersDescriptor;\n+\n+    public FileOperatorUsersStore(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.operatorUsersDescriptor = parseFile(this.file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new FileOperatorUsersStore.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        // Other than realm name, other criteria must always be an exact match for the user to be an operator.\n+        // Realm name of a descriptor can be null. When it is null, it is ignored for comparison.\n+        // If not null, it will be compared exactly as well.\n+        // The special handling for realm name is because there can only be one file or native realm and it does\n+        // not matter what the name is.\n+        return operatorUsersDescriptor.groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (group.realmName == null || group.realmName.equals(realm.getName()));\n+        });\n+    }\n+\n+    // Package private for tests\n+    public OperatorUsersDescriptor getOperatorUsersDescriptor() {\n+        return operatorUsersDescriptor;\n+    }\n+\n+    static final class OperatorUsersDescriptor {\n+        private final List<Group> groups;\n+\n+        private OperatorUsersDescriptor(List<Group> groups) {\n+            this.groups = groups;\n+        }\n+\n+        // Package private for tests\n+        List<Group> getGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            OperatorUsersDescriptor that = (OperatorUsersDescriptor) o;\n+            return groups.equals(that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(groups);\n+        }\n+    }\n+\n+    private static final OperatorUsersDescriptor EMPTY_OPERATOR_USERS_DESCRIPTOR = new OperatorUsersDescriptor(List.of());\n+\n+    static final class Group {\n+        private static final Set<String> SINGLETON_REALM_TYPES = Set.of(\n+            FileRealmSettings.TYPE, NativeRealmSettings.TYPE, ReservedRealm.TYPE);\n+\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        Group(Set<String> usernames) {\n+            this(usernames, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName) {\n+            this(usernames, realmName, null, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName, @Nullable String realmType,\n+                     @Nullable String authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType == null ? FileRealmSettings.TYPE : realmType;\n+            this.authenticationType = authenticationType == null ? Authentication.AuthenticationType.REALM :\n+                Authentication.AuthenticationType.valueOf(authenticationType.toUpperCase(Locale.ROOT));\n+            validate();\n+        }\n+\n+        private void validate() {\n+            final ValidationException validationException = new ValidationException();\n+            if (false == FileRealmSettings.TYPE.equals(realmType)) {\n+                validationException.addValidationError(\"[realm_type] only supports [file]\");\n+            }\n+            if (Authentication.AuthenticationType.REALM != authenticationType) {\n+                validationException.addValidationError(\"[auth_type] only supports [realm]\");\n+            }\n+            if (realmName == null) {\n+                if (false == SINGLETON_REALM_TYPES.contains(realmType)) {\n+                    validationException.addValidationError(\n+                        \"[realm_name] must be specified for realm types other than [reserved], [file] and [native]\");", "originalCommit": "1082b139f548520b4b790fbca6dace8c26410093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1OTE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532559149", "bodyText": "Right. Not sure why I used it in the above lines and didn't use it here ..", "author": "ywangd", "createdAt": "2020-11-30T12:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MDAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MDY3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532390677", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.error(\"Failed to parse operator users file [\" + file + \"].\", e);\n          \n          \n            \n                            logger.error(new ParameterizedMessage(\"Failed to parse operator users file [{}].\", file), e);", "author": "tvernum", "createdAt": "2020-11-30T07:27:12Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/FileOperatorUsersStore.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.esnative.NativeRealmSettings;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.security.operator.OperatorPrivileges.OPERATOR_PRIVILEGES_ENABLED;\n+\n+public class FileOperatorUsersStore {\n+    private static final Logger logger = LogManager.getLogger(FileOperatorUsersStore.class);\n+\n+    private final Path file;\n+    private volatile OperatorUsersDescriptor operatorUsersDescriptor;\n+\n+    public FileOperatorUsersStore(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.operatorUsersDescriptor = parseFile(this.file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new FileOperatorUsersStore.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        // Other than realm name, other criteria must always be an exact match for the user to be an operator.\n+        // Realm name of a descriptor can be null. When it is null, it is ignored for comparison.\n+        // If not null, it will be compared exactly as well.\n+        // The special handling for realm name is because there can only be one file or native realm and it does\n+        // not matter what the name is.\n+        return operatorUsersDescriptor.groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (group.realmName == null || group.realmName.equals(realm.getName()));\n+        });\n+    }\n+\n+    // Package private for tests\n+    public OperatorUsersDescriptor getOperatorUsersDescriptor() {\n+        return operatorUsersDescriptor;\n+    }\n+\n+    static final class OperatorUsersDescriptor {\n+        private final List<Group> groups;\n+\n+        private OperatorUsersDescriptor(List<Group> groups) {\n+            this.groups = groups;\n+        }\n+\n+        // Package private for tests\n+        List<Group> getGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            OperatorUsersDescriptor that = (OperatorUsersDescriptor) o;\n+            return groups.equals(that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(groups);\n+        }\n+    }\n+\n+    private static final OperatorUsersDescriptor EMPTY_OPERATOR_USERS_DESCRIPTOR = new OperatorUsersDescriptor(List.of());\n+\n+    static final class Group {\n+        private static final Set<String> SINGLETON_REALM_TYPES = Set.of(\n+            FileRealmSettings.TYPE, NativeRealmSettings.TYPE, ReservedRealm.TYPE);\n+\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        Group(Set<String> usernames) {\n+            this(usernames, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName) {\n+            this(usernames, realmName, null, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName, @Nullable String realmType,\n+                     @Nullable String authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType == null ? FileRealmSettings.TYPE : realmType;\n+            this.authenticationType = authenticationType == null ? Authentication.AuthenticationType.REALM :\n+                Authentication.AuthenticationType.valueOf(authenticationType.toUpperCase(Locale.ROOT));\n+            validate();\n+        }\n+\n+        private void validate() {\n+            final ValidationException validationException = new ValidationException();\n+            if (false == FileRealmSettings.TYPE.equals(realmType)) {\n+                validationException.addValidationError(\"[realm_type] only supports [file]\");\n+            }\n+            if (Authentication.AuthenticationType.REALM != authenticationType) {\n+                validationException.addValidationError(\"[auth_type] only supports [realm]\");\n+            }\n+            if (realmName == null) {\n+                if (false == SINGLETON_REALM_TYPES.contains(realmType)) {\n+                    validationException.addValidationError(\n+                        \"[realm_name] must be specified for realm types other than [reserved], [file] and [native]\");\n+                }\n+            }\n+            if (false == validationException.validationErrors().isEmpty()) {\n+                throw validationException;\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames)\n+              && Objects.equals(realmName, group.realmName)\n+              && realmType.equals(group.realmType)\n+              && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static OperatorUsersDescriptor parseFile(Path file, Logger logger) {\n+        if (false == Files.exists(file)) {\n+            logger.warn(\"Operator privileges [{}] is enabled, but operator user file does not exist. \" +\n+                    \"No user will be able to perform operator-only actions.\", OPERATOR_PRIVILEGES_ENABLED.getKey());\n+            return EMPTY_OPERATOR_USERS_DESCRIPTOR;\n+        } else {\n+            logger.debug(\"Reading operator users file [{}]\", file.toAbsolutePath());\n+            try (InputStream in = Files.newInputStream(file, StandardOpenOption.READ)) {\n+                return parseConfig(in);\n+            } catch (IOException | RuntimeException e) {\n+                logger.error(\"Failed to parse operator users file [\" + file + \"].\", e);", "originalCommit": "1082b139f548520b4b790fbca6dace8c26410093", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MTAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532391008", "bodyText": "Should we remove these now?", "author": "tvernum", "createdAt": "2020-11-30T07:28:12Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsAction;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.license.DeleteLicenseAction;\n+import org.elasticsearch.license.PutLicenseAction;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_HTTP_SETTING;\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_SETTING;\n+\n+public class OperatorOnlyRegistry {\n+\n+    public static final Set<String> SIMPLE_ACTIONS = Set.of(AddVotingConfigExclusionsAction.NAME,\n+        ClearVotingConfigExclusionsAction.NAME,\n+        PutLicenseAction.NAME,\n+        DeleteLicenseAction.NAME,\n+        // Autoscaling does not publish its actions to core, literal strings are needed.\n+        \"cluster:admin/autoscaling/put_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/delete_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_capacity\");\n+\n+    // This class is a prototype to showcase what it would look like for operator only settings\n+    // It may NOT be included in phase 1 delivery. Also this may end up using Enum Property to\n+    // mark operator only settings instead of using the list here.\n+    public static final Set<String> SIMPLE_SETTINGS = Set.of(IP_FILTER_ENABLED_HTTP_SETTING.getKey(), IP_FILTER_ENABLED_SETTING.getKey(),\n+        // TODO: Use literal strings due to dependency. Alternatively we can let each plugin publish names of operator settings\n+        \"xpack.ml.max_machine_memory_percent\", \"xpack.ml.max_model_memory_limit\");", "originalCommit": "1082b139f548520b4b790fbca6dace8c26410093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1ODM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532558354", "bodyText": "Yes removed. Even if we include settings for phase 1, I think it is very likely going to take the Enum property approach.", "author": "ywangd", "createdAt": "2020-11-30T12:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MjM5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532392396", "bodyText": "This might feel less weird if we had a custom interface instead.\npublic interface OperatorPrivilegeViolation {\n   public String message();\n}\n\nThen it feel more natural to return null if there's no violation.", "author": "tvernum", "createdAt": "2020-11-30T07:32:00Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsAction;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.license.DeleteLicenseAction;\n+import org.elasticsearch.license.PutLicenseAction;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_HTTP_SETTING;\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_SETTING;\n+\n+public class OperatorOnlyRegistry {\n+\n+    public static final Set<String> SIMPLE_ACTIONS = Set.of(AddVotingConfigExclusionsAction.NAME,\n+        ClearVotingConfigExclusionsAction.NAME,\n+        PutLicenseAction.NAME,\n+        DeleteLicenseAction.NAME,\n+        // Autoscaling does not publish its actions to core, literal strings are needed.\n+        \"cluster:admin/autoscaling/put_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/delete_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_capacity\");\n+\n+    // This class is a prototype to showcase what it would look like for operator only settings\n+    // It may NOT be included in phase 1 delivery. Also this may end up using Enum Property to\n+    // mark operator only settings instead of using the list here.\n+    public static final Set<String> SIMPLE_SETTINGS = Set.of(IP_FILTER_ENABLED_HTTP_SETTING.getKey(), IP_FILTER_ENABLED_SETTING.getKey(),\n+        // TODO: Use literal strings due to dependency. Alternatively we can let each plugin publish names of operator settings\n+        \"xpack.ml.max_machine_memory_percent\", \"xpack.ml.max_model_memory_limit\");\n+\n+    // This map is just to showcase how \"partial\" operator-only API would work.\n+    // It will be REMOVED before phase 1 delivery.\n+    public static final Map<String, Function<TransportRequest, Supplier<String>>> PARAMETER_SENSITIVE_ACTIONS =\n+        Map.of(DeleteRepositoryAction.NAME, (request) -> {\n+            assert request instanceof DeleteRepositoryRequest;\n+            final DeleteRepositoryRequest deleteRepositoryRequest = (DeleteRepositoryRequest) request;\n+            if (\"found-snapshots\".equals(deleteRepositoryRequest.name())) {\n+                return () -> \"action [\" + DeleteRepositoryAction.NAME + \"] with repository [\" + deleteRepositoryRequest.name();\n+            } else {\n+                return null;\n+            }\n+        });\n+\n+    // The return type is a bit weird, but it is a shortcut to avoid having to use either\n+    // a Tuple or a new class to hold true/false and a message/null.\n+    // Since the combination is either true+message or false+null, it is possible to just\n+    // use the existence of the message to also indicate whether the result is true or false.\n+    public Supplier<String> check(String action, TransportRequest request) {", "originalCommit": "1082b139f548520b4b790fbca6dace8c26410093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1ODY5OA==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532558698", "bodyText": "Great suggestion! Names matter!", "author": "ywangd", "createdAt": "2020-11-30T12:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MjM5Ng=="}], "type": "inlineReview"}, {"oid": "c3fa2bae4dd76fc02dbbd19564d5d10e27c76190", "url": "https://github.com/elastic/elasticsearch/commit/c3fa2bae4dd76fc02dbbd19564d5d10e27c76190", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/FileOperatorUsersStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-11-30T11:54:42Z", "type": "commit"}, {"oid": "4cf5b0873ebe60edc70d6c263774bcf0ad78e73a", "url": "https://github.com/elastic/elasticsearch/commit/4cf5b0873ebe60edc70d6c263774bcf0ad78e73a", "message": "wip", "committedDate": "2020-11-30T11:55:18Z", "type": "commit"}, {"oid": "973e7a5da693e247dbc61ba6b7c67daf91d0203a", "url": "https://github.com/elastic/elasticsearch/commit/973e7a5da693e247dbc61ba6b7c67daf91d0203a", "message": "Address feedback", "committedDate": "2020-11-30T11:55:18Z", "type": "commit"}, {"oid": "2ae1bef7a0e39fe51d2d9c5e0cc150f4acb00a1d", "url": "https://github.com/elastic/elasticsearch/commit/2ae1bef7a0e39fe51d2d9c5e0cc150f4acb00a1d", "message": "Fix import", "committedDate": "2020-11-30T11:59:32Z", "type": "commit"}, {"oid": "91d2ef0b150150e69cc4b8b7a9c3c352e3663fa6", "url": "https://github.com/elastic/elasticsearch/commit/91d2ef0b150150e69cc4b8b7a9c3c352e3663fa6", "message": "Tweak", "committedDate": "2020-11-30T22:10:39Z", "type": "commit"}, {"oid": "6bddcff16232142d958ca17ac50644f21fdccdf1", "url": "https://github.com/elastic/elasticsearch/commit/6bddcff16232142d958ca17ac50644f21fdccdf1", "message": "fix test", "committedDate": "2020-11-30T23:24:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkzNTQwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r533935401", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public interface OperatorPrivilegesViolation {\n          \n          \n            \n                @FunctionalInterface\n          \n          \n            \n                public interface OperatorPrivilegesViolation {", "author": "tvernum", "createdAt": "2020-12-02T06:56:56Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.license.DeleteLicenseAction;\n+import org.elasticsearch.license.PutLicenseAction;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.Set;\n+\n+public class OperatorOnlyRegistry {\n+\n+    public static final Set<String> SIMPLE_ACTIONS = Set.of(AddVotingConfigExclusionsAction.NAME,\n+        ClearVotingConfigExclusionsAction.NAME,\n+        PutLicenseAction.NAME,\n+        DeleteLicenseAction.NAME,\n+        // Autoscaling does not publish its actions to core, literal strings are needed.\n+        \"cluster:admin/autoscaling/put_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/delete_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_capacity\");\n+\n+    /**\n+     * Check whether the given action and request qualify as operator-only. The method returns\n+     * null if the action+request is NOT operator-only. Other it returns a violation object\n+     * that contains the message for details.\n+     */\n+    public OperatorPrivilegesViolation check(String action, TransportRequest request) {\n+        if (SIMPLE_ACTIONS.contains(action)) {\n+            return () -> \"action [\" + action + \"]\";\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public interface OperatorPrivilegesViolation {", "originalCommit": "6bddcff16232142d958ca17ac50644f21fdccdf1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e7042f90b146b48791cd07fc3f2711f918ad7197", "url": "https://github.com/elastic/elasticsearch/commit/e7042f90b146b48791cd07fc3f2711f918ad7197", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-12-03T04:31:08Z", "type": "commit"}, {"oid": "5807b330cb310858780ca808e6fe51a55a474ee8", "url": "https://github.com/elastic/elasticsearch/commit/5807b330cb310858780ca808e6fe51a55a474ee8", "message": "Merge remote-tracking branch 'origin/master' into meta-101-operator-privileges-phase-one", "committedDate": "2020-12-03T04:32:02Z", "type": "commit"}]}