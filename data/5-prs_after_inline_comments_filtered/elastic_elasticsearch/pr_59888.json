{"pr_number": 59888, "pr_title": "Simplify CheckSumBlobStoreFormat and make it more Reusable", "pr_createdAt": "2020-07-20T14:28:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59888", "timeline": [{"oid": "fd9139784f3785e8c9bb2886d03c26effa1336f0", "url": "https://github.com/elastic/elasticsearch/commit/fd9139784f3785e8c9bb2886d03c26effa1336f0", "message": "Simplify CheckSumBlobStoreFormat and make it more Reusable\n\nRefactored `CheckSumBlobStoreFormat` so it can more easily be reused in\nother functionality (i.e. upcoming repair logic).\nSimplified away constant `failIfAlreadyExists` parameter and removed the atomic\nwrite method and its tests.\nThe atomic write method was only used in a single spot and that spot has now been adjusted to\nwork the same way writing root level metadata works.", "committedDate": "2020-07-20T14:25:35Z", "type": "commit"}, {"oid": "e9e6ff16d218514cfbbe22576187cdde096ce7ac", "url": "https://github.com/elastic/elasticsearch/commit/e9e6ff16d218514cfbbe22576187cdde096ce7ac", "message": "simpler", "committedDate": "2020-07-20T14:42:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ2MzEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59888#discussion_r457463101", "bodyText": "This test and the other removed test were both fairly pointless to begin with. We never did any kind of streaming write in ChecksumBlobStoreFormat, so blocking in toXContent doesn't really test anything about atomic writes and the same tests would pass for non-atomic writes just the same.\nI simplified the code in the write path of ChecksumBlobStoreFormat a bit to make it clearer that we always serialize first, then physically write.", "author": "original-brownbear", "createdAt": "2020-07-20T14:55:01Z", "path": "server/src/test/java/org/elasticsearch/snapshots/BlobStoreFormatTests.java", "diffHunk": "@@ -163,79 +148,6 @@ public void testBlobCorruption() throws IOException {\n         }\n     }\n \n-    public void testAtomicWrite() throws Exception {\n-        final BlobStore blobStore = createTestBlobStore();\n-        final BlobContainer blobContainer = blobStore.blobContainer(BlobPath.cleanPath());\n-        String testString = randomAlphaOfLength(randomInt(10000));\n-        final CountDownLatch block = new CountDownLatch(1);\n-        final CountDownLatch unblock = new CountDownLatch(1);\n-        final BlobObj blobObj = new BlobObj(testString) {\n-            @Override\n-            public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {\n-                super.toXContent(builder, params);\n-                // Block before finishing writing\n-                try {\n-                    block.countDown();\n-                    unblock.await(5, TimeUnit.SECONDS);\n-                } catch (InterruptedException ex) {\n-                    Thread.currentThread().interrupt();\n-                }\n-                return builder;\n-            }\n-        };\n-        final ChecksumBlobStoreFormat<BlobObj> checksumFormat = new ChecksumBlobStoreFormat<>(BLOB_CODEC, \"%s\", BlobObj::fromXContent,\n-            xContentRegistry(), randomBoolean());\n-        ExecutorService threadPool = Executors.newFixedThreadPool(1);\n-        try {\n-            Future<Void> future = threadPool.submit(new Callable<Void>() {\n-                @Override\n-                public Void call() throws Exception {\n-                    checksumFormat.writeAtomic(blobObj, blobContainer, \"test-blob\");\n-                    return null;\n-                }\n-            });\n-            // signalling\n-            block.await(5, TimeUnit.SECONDS);\n-            assertFalse(blobContainer.blobExists(\"test-blob\"));\n-            unblock.countDown();\n-            future.get();\n-            assertTrue(blobContainer.blobExists(\"test-blob\"));\n-        } finally {\n-            threadPool.shutdown();\n-        }\n-    }\n-\n-    public void testAtomicWriteFailures() throws Exception {", "originalCommit": "e9e6ff16d218514cfbbe22576187cdde096ce7ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ2NTE3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59888#discussion_r457465173", "bodyText": "Exposing this here for the mock repo tests for now but this is needed for the repair logic as well.", "author": "original-brownbear", "createdAt": "2020-07-20T14:57:20Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/ChecksumBlobStoreFormat.java", "diffHunk": "@@ -112,23 +101,16 @@ public ChecksumBlobStoreFormat(String codec, String blobNameFormat, CheckedFunct\n      * @param name          name to be translated into\n      * @return parsed blob object\n      */\n-    public T read(BlobContainer blobContainer, String name) throws IOException {\n+    public T read(BlobContainer blobContainer, String name, NamedXContentRegistry namedXContentRegistry) throws IOException {\n         String blobName = blobName(name);\n-        return readBlob(blobContainer, blobName);\n+        return deserialize(blobName, namedXContentRegistry, Streams.readFully(blobContainer.readBlob(blobName)));\n     }\n \n     public String blobName(String name) {\n         return String.format(Locale.ROOT, blobNameFormat, name);\n     }\n \n-    /**\n-     * Reads blob with specified name without resolving the blobName using using {@link #blobName} method.\n-     *\n-     * @param blobContainer blob container\n-     * @param blobName blob name\n-     */\n-    public T readBlob(BlobContainer blobContainer, String blobName) throws IOException {\n-        final BytesReference bytes = Streams.readFully(blobContainer.readBlob(blobName));\n+    public T deserialize(String blobName, NamedXContentRegistry namedXContentRegistry, BytesReference bytes) throws IOException {", "originalCommit": "e9e6ff16d218514cfbbe22576187cdde096ce7ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}