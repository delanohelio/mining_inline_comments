{"pr_number": 52401, "pr_title": "Write SAML SP data to a dedicated index", "pr_createdAt": "2020-02-17T08:04:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52401", "timeline": [{"oid": "f03f61d4d3edf4273c23033877a2d0735a95f572", "url": "https://github.com/elastic/elasticsearch/commit/f03f61d4d3edf4273c23033877a2d0735a95f572", "message": "Write SAML SP data to a dedicated index\n\nThis adds low level classes for reading & writing documents that\nmodel a SAML Service Provider in the IdP.\n(These classes are not currently used)", "committedDate": "2020-02-17T08:00:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzg1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380303856", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            \"field [\" + Fields.LAST_MODIFIED.getPreferredName() + \"] is required, but was [\" + lastModified + \"]\");\n          \n          \n            \n                            \"field [\" + Fields.LAST_MODIFIED.getPreferredName() + \"] is required, but was [null]\");", "author": "jkakavas", "createdAt": "2020-02-17T17:31:12Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ssl.CertParsingUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.ReadableDuration;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class models the storage of a {@link SamlServiceProvider} as an Elasticsearch document.\n+ */\n+public class SamlServiceProviderDocument implements ToXContentObject {\n+\n+    public static class Privileges {\n+        @Nullable\n+        public String application;\n+        public String resource;\n+        @Nullable\n+        public String loginAction;\n+        public Map<String, String> groupActions;\n+\n+        public void setApplication(String application) {\n+            this.application = application;\n+        }\n+\n+        public void setResource(String resource) {\n+            this.resource = resource;\n+        }\n+\n+        public void setLoginAction(String loginAction) {\n+            this.loginAction = loginAction;\n+        }\n+\n+        public void setGroupActions(Map<String, String> groupActions) {\n+            this.groupActions = groupActions;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Privileges that = (Privileges) o;\n+            return Objects.equals(application, that.application) &&\n+                Objects.equals(resource, that.resource) &&\n+                Objects.equals(loginAction, that.loginAction) &&\n+                Objects.equals(groupActions, that.groupActions);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(application, resource, loginAction, groupActions);\n+        }\n+    }\n+\n+    public static class AttributeNames {\n+        public String principal;\n+        @Nullable\n+        public String email;\n+        @Nullable\n+        public String name;\n+        @Nullable\n+        public String groups;\n+\n+        public void setPrincipal(String principal) {\n+            this.principal = principal;\n+        }\n+\n+        public void setEmail(String email) {\n+            this.email = email;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public void setGroups(String groups) {\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final AttributeNames that = (AttributeNames) o;\n+            return Objects.equals(principal, that.principal) &&\n+                Objects.equals(email, that.email) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(groups, that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(principal, email, name, groups);\n+        }\n+    }\n+\n+    public String docId;\n+\n+    public String name;\n+\n+    public String entityId;\n+\n+    public String acs;\n+\n+    public boolean enabled = true;\n+    public Instant created;\n+    public Instant lastModified;\n+\n+    @Nullable\n+    public String nameIdFormat;\n+\n+    @Nullable\n+    public Long authenticationExpiryMillis;\n+\n+    public List<String> signingCertificates = List.of();\n+\n+    public final Privileges privileges = new Privileges();\n+    public final AttributeNames attributeNames = new AttributeNames();\n+\n+    public String getDocId() {\n+        return docId;\n+    }\n+\n+    public void setDocId(String docId) {\n+        this.docId = docId;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public void setEntityId(String entityId) {\n+        this.entityId = entityId;\n+    }\n+\n+    public void setAcs(String acs) {\n+        this.acs = acs;\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setCreatedMillis(Long millis) {\n+        this.created = Instant.ofEpochMilli(millis);\n+    }\n+\n+    public void setLastModifiedMillis(Long millis) {\n+        this.lastModified = Instant.ofEpochMilli(millis);\n+    }\n+\n+    public void setNameIdFormat(String nameIdFormat) {\n+        this.nameIdFormat = nameIdFormat;\n+    }\n+\n+    public void setAuthenticationExpiryMillis(Long authenticationExpiryMillis) {\n+        this.authenticationExpiryMillis = authenticationExpiryMillis;\n+    }\n+\n+    public void setAuthenticationExpiry(ReadableDuration authnExpiry) {\n+        this.authenticationExpiryMillis = authnExpiry.getMillis();\n+    }\n+\n+    public ReadableDuration getAuthenticationExpiryMillis() {\n+        return Duration.millis(this.authenticationExpiryMillis);\n+    }\n+\n+    public void setSigningCertificates(Collection<String> signingCertificates) {\n+        this.signingCertificates = signingCertificates == null ? List.of() : List.copyOf(signingCertificates);\n+    }\n+\n+    public void setX509SigningCertificates(Collection<X509Certificate> certificates) throws CertificateEncodingException {\n+        this.signingCertificates = certificates == null ? List.of() : certificates.stream()\n+            .map(cert -> {\n+                try {\n+                    return cert.getEncoded();\n+                } catch (CertificateEncodingException e) {\n+                    throw new ElasticsearchException(\"Cannot read certificate\", e);\n+                }\n+            })\n+            .map(Base64.getEncoder()::encodeToString)\n+            .collect(Collectors.toUnmodifiableList());\n+    }\n+\n+    public List<X509Certificate> getX509SigningCertificates() {\n+        if (this.signingCertificates == null || this.signingCertificates.isEmpty()) {\n+            return List.of();\n+        }\n+        return this.signingCertificates.stream().map(this::toX509Certificate).collect(Collectors.toUnmodifiableList());\n+    }\n+\n+    private X509Certificate toX509Certificate(String base64Cert) {\n+        final byte[] bytes = base64Cert.getBytes(StandardCharsets.UTF_8);\n+        try (InputStream stream = new ByteArrayInputStream(bytes)) {\n+            final List<Certificate> certificates = CertParsingUtils.readCertificates(Base64.getDecoder().wrap(stream));\n+            if (certificates.size() == 1) {\n+                final Certificate certificate = certificates.get(0);\n+                if (certificate instanceof X509Certificate) {\n+                    return (X509Certificate) certificate;\n+                } else {\n+                    throw new ElasticsearchException(\"Certificate ({}) is not a X.509 certificate\", certificate.getClass());\n+                }\n+            } else {\n+                throw new ElasticsearchException(\"Expected a single certificate, but found {}\", certificates.size());\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (CertificateException e) {\n+            throw new ElasticsearchException(\"Cannot parse certificate(s)\", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        final SamlServiceProviderDocument that = (SamlServiceProviderDocument) o;\n+        return Objects.equals(docId, that.docId) &&\n+            Objects.equals(name, that.name) &&\n+            Objects.equals(entityId, that.entityId) &&\n+            Objects.equals(acs, that.acs) &&\n+            Objects.equals(enabled, that.enabled) &&\n+            Objects.equals(created, that.created) &&\n+            Objects.equals(lastModified, that.lastModified) &&\n+            Objects.equals(nameIdFormat, that.nameIdFormat) &&\n+            Objects.equals(authenticationExpiryMillis, that.authenticationExpiryMillis) &&\n+            Objects.equals(signingCertificates, that.signingCertificates) &&\n+            Objects.equals(privileges, that.privileges) &&\n+            Objects.equals(attributeNames, that.attributeNames);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(docId, name, entityId, acs, enabled, created, lastModified, nameIdFormat, authenticationExpiryMillis,\n+            signingCertificates, privileges, attributeNames);\n+    }\n+\n+    private static final ObjectParser<SamlServiceProviderDocument, SamlServiceProviderDocument> DOC_PARSER\n+        = new ObjectParser<>(\"service_provider_doc\", true, SamlServiceProviderDocument::new);\n+    private static final ObjectParser<Privileges, Void> PRIVILEGES_PARSER = new ObjectParser<>(\"service_provider_priv\", true, null);\n+    private static final ObjectParser<AttributeNames, Void> ATTRIBUTES_PARSER = new ObjectParser<>(\"service_provider_attr\", true, null);\n+\n+    private static final BiConsumer<SamlServiceProviderDocument, Object> NULL_CONSUMER = (doc, obj) -> {\n+    };\n+\n+    static {\n+        DOC_PARSER.declareString(SamlServiceProviderDocument::setName, Fields.NAME);\n+        DOC_PARSER.declareString(SamlServiceProviderDocument::setEntityId, Fields.ENTITY_ID);\n+        DOC_PARSER.declareString(SamlServiceProviderDocument::setAcs, Fields.ACS);\n+        DOC_PARSER.declareBoolean(SamlServiceProviderDocument::setEnabled, Fields.ENABLED);\n+        DOC_PARSER.declareLong(SamlServiceProviderDocument::setCreatedMillis, Fields.CREATED_DATE);\n+        DOC_PARSER.declareLong(SamlServiceProviderDocument::setLastModifiedMillis, Fields.LAST_MODIFIED);\n+        DOC_PARSER.declareStringOrNull(SamlServiceProviderDocument::setNameIdFormat, Fields.NAME_ID);\n+        // Using a method reference here angers some compilers\n+        DOC_PARSER.declareField(SamlServiceProviderDocument::setAuthenticationExpiryMillis,\n+            parser -> parser.currentToken() == XContentParser.Token.VALUE_NULL ? null : parser.longValue(),\n+            Fields.AUTHN_EXPIRY, ObjectParser.ValueType.LONG_OR_NULL);\n+        DOC_PARSER.declareStringArray(SamlServiceProviderDocument::setSigningCertificates, Fields.SIGNING_CERT);\n+\n+        DOC_PARSER.declareObject(NULL_CONSUMER, (parser, doc) -> PRIVILEGES_PARSER.parse(parser, doc.privileges, null), Fields.PRIVILEGES);\n+        PRIVILEGES_PARSER.declareStringOrNull(Privileges::setApplication, Fields.Privileges.APPLICATION);\n+        PRIVILEGES_PARSER.declareString(Privileges::setResource, Fields.Privileges.RESOURCE);\n+        PRIVILEGES_PARSER.declareStringOrNull(Privileges::setLoginAction, Fields.Privileges.LOGIN_ACTION);\n+        PRIVILEGES_PARSER.declareField(Privileges::setGroupActions,\n+            (parser, ignore) -> parser.currentToken() == XContentParser.Token.VALUE_NULL ? null : parser.mapStrings(),\n+            Fields.Privileges.GROUPS, ObjectParser.ValueType.OBJECT_OR_NULL);\n+\n+        DOC_PARSER.declareObject(NULL_CONSUMER, (p, doc) -> ATTRIBUTES_PARSER.parse(p, doc.attributeNames, null), Fields.ATTRIBUTES);\n+        ATTRIBUTES_PARSER.declareString(AttributeNames::setPrincipal, Fields.Attributes.PRINCIPAL);\n+        ATTRIBUTES_PARSER.declareStringOrNull(AttributeNames::setEmail, Fields.Attributes.EMAIL);\n+        ATTRIBUTES_PARSER.declareStringOrNull(AttributeNames::setName, Fields.Attributes.NAME);\n+        ATTRIBUTES_PARSER.declareStringOrNull(AttributeNames::setGroups, Fields.Attributes.GROUPS);\n+    }\n+\n+    public static SamlServiceProviderDocument fromXContent(String docId, XContentParser parser) throws IOException {\n+        SamlServiceProviderDocument doc = new SamlServiceProviderDocument();\n+        doc.setDocId(docId);\n+        return DOC_PARSER.parse(parser, doc, doc);\n+    }\n+\n+    public ValidationException validate() {\n+        final ValidationException validation = new ValidationException();\n+        if (Strings.isNullOrEmpty(name)) {\n+            validation.addValidationError(\"field [\" + Fields.NAME.getPreferredName() + \"] is required, but was [\" + name + \"]\");\n+        }\n+        if (Strings.isNullOrEmpty(entityId)) {\n+            validation.addValidationError(\"field [\" + Fields.ENTITY_ID.getPreferredName() + \"] is required, but was [\" + entityId + \"]\");\n+        }\n+        if (Strings.isNullOrEmpty(acs)) {\n+            validation.addValidationError(\"field [\" + Fields.ACS.getPreferredName() + \"] is required, but was [\" + acs + \"]\");\n+        }\n+        if (created == null) {\n+            validation.addValidationError(\"field [\" + Fields.CREATED_DATE.getPreferredName() + \"] is required, but was [\" + created + \"]\");\n+        }\n+        if (lastModified == null) {\n+            validation.addValidationError(\n+                \"field [\" + Fields.LAST_MODIFIED.getPreferredName() + \"] is required, but was [\" + lastModified + \"]\");", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1MDY1MA==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380450650", "bodyText": "Is there a reason you prefer that change?\nI like the existing code because the error message is isolated from potential changes in the if condition.\ne.g. If we decide that we need to check lastModified.toEpochMilli() != 0 then the error message would be misleading (because \"required\" isn't a great descriptor, but it would at least print out the correct current value.\nThe suggestion saves the tiny cost of a string addition, but risks printing incorrect information if it gets out of sync with the if clause.", "author": "tvernum", "createdAt": "2020-02-18T04:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ2OTI2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380469262", "bodyText": "I'm fine with it, it's just how I would have done it - no need to iterate on this ;)", "author": "jkakavas", "createdAt": "2020-02-18T06:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380303989", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        validation.addValidationError(\"field [\" + Fields.CREATED_DATE.getPreferredName() + \"] is required, but was [\" + created + \"]\");\n          \n          \n            \n                        validation.addValidationError(\"field [\" + Fields.CREATED_DATE.getPreferredName() + \"] is required, but was [\"null\"]\");", "author": "jkakavas", "createdAt": "2020-02-17T17:31:34Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ssl.CertParsingUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.ReadableDuration;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class models the storage of a {@link SamlServiceProvider} as an Elasticsearch document.\n+ */\n+public class SamlServiceProviderDocument implements ToXContentObject {\n+\n+    public static class Privileges {\n+        @Nullable\n+        public String application;\n+        public String resource;\n+        @Nullable\n+        public String loginAction;\n+        public Map<String, String> groupActions;\n+\n+        public void setApplication(String application) {\n+            this.application = application;\n+        }\n+\n+        public void setResource(String resource) {\n+            this.resource = resource;\n+        }\n+\n+        public void setLoginAction(String loginAction) {\n+            this.loginAction = loginAction;\n+        }\n+\n+        public void setGroupActions(Map<String, String> groupActions) {\n+            this.groupActions = groupActions;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Privileges that = (Privileges) o;\n+            return Objects.equals(application, that.application) &&\n+                Objects.equals(resource, that.resource) &&\n+                Objects.equals(loginAction, that.loginAction) &&\n+                Objects.equals(groupActions, that.groupActions);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(application, resource, loginAction, groupActions);\n+        }\n+    }\n+\n+    public static class AttributeNames {\n+        public String principal;\n+        @Nullable\n+        public String email;\n+        @Nullable\n+        public String name;\n+        @Nullable\n+        public String groups;\n+\n+        public void setPrincipal(String principal) {\n+            this.principal = principal;\n+        }\n+\n+        public void setEmail(String email) {\n+            this.email = email;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public void setGroups(String groups) {\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final AttributeNames that = (AttributeNames) o;\n+            return Objects.equals(principal, that.principal) &&\n+                Objects.equals(email, that.email) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(groups, that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(principal, email, name, groups);\n+        }\n+    }\n+\n+    public String docId;\n+\n+    public String name;\n+\n+    public String entityId;\n+\n+    public String acs;\n+\n+    public boolean enabled = true;\n+    public Instant created;\n+    public Instant lastModified;\n+\n+    @Nullable\n+    public String nameIdFormat;\n+\n+    @Nullable\n+    public Long authenticationExpiryMillis;\n+\n+    public List<String> signingCertificates = List.of();\n+\n+    public final Privileges privileges = new Privileges();\n+    public final AttributeNames attributeNames = new AttributeNames();\n+\n+    public String getDocId() {\n+        return docId;\n+    }\n+\n+    public void setDocId(String docId) {\n+        this.docId = docId;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public void setEntityId(String entityId) {\n+        this.entityId = entityId;\n+    }\n+\n+    public void setAcs(String acs) {\n+        this.acs = acs;\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setCreatedMillis(Long millis) {\n+        this.created = Instant.ofEpochMilli(millis);\n+    }\n+\n+    public void setLastModifiedMillis(Long millis) {\n+        this.lastModified = Instant.ofEpochMilli(millis);\n+    }\n+\n+    public void setNameIdFormat(String nameIdFormat) {\n+        this.nameIdFormat = nameIdFormat;\n+    }\n+\n+    public void setAuthenticationExpiryMillis(Long authenticationExpiryMillis) {\n+        this.authenticationExpiryMillis = authenticationExpiryMillis;\n+    }\n+\n+    public void setAuthenticationExpiry(ReadableDuration authnExpiry) {\n+        this.authenticationExpiryMillis = authnExpiry.getMillis();\n+    }\n+\n+    public ReadableDuration getAuthenticationExpiryMillis() {\n+        return Duration.millis(this.authenticationExpiryMillis);\n+    }\n+\n+    public void setSigningCertificates(Collection<String> signingCertificates) {\n+        this.signingCertificates = signingCertificates == null ? List.of() : List.copyOf(signingCertificates);\n+    }\n+\n+    public void setX509SigningCertificates(Collection<X509Certificate> certificates) throws CertificateEncodingException {\n+        this.signingCertificates = certificates == null ? List.of() : certificates.stream()\n+            .map(cert -> {\n+                try {\n+                    return cert.getEncoded();\n+                } catch (CertificateEncodingException e) {\n+                    throw new ElasticsearchException(\"Cannot read certificate\", e);\n+                }\n+            })\n+            .map(Base64.getEncoder()::encodeToString)\n+            .collect(Collectors.toUnmodifiableList());\n+    }\n+\n+    public List<X509Certificate> getX509SigningCertificates() {\n+        if (this.signingCertificates == null || this.signingCertificates.isEmpty()) {\n+            return List.of();\n+        }\n+        return this.signingCertificates.stream().map(this::toX509Certificate).collect(Collectors.toUnmodifiableList());\n+    }\n+\n+    private X509Certificate toX509Certificate(String base64Cert) {\n+        final byte[] bytes = base64Cert.getBytes(StandardCharsets.UTF_8);\n+        try (InputStream stream = new ByteArrayInputStream(bytes)) {\n+            final List<Certificate> certificates = CertParsingUtils.readCertificates(Base64.getDecoder().wrap(stream));\n+            if (certificates.size() == 1) {\n+                final Certificate certificate = certificates.get(0);\n+                if (certificate instanceof X509Certificate) {\n+                    return (X509Certificate) certificate;\n+                } else {\n+                    throw new ElasticsearchException(\"Certificate ({}) is not a X.509 certificate\", certificate.getClass());\n+                }\n+            } else {\n+                throw new ElasticsearchException(\"Expected a single certificate, but found {}\", certificates.size());\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (CertificateException e) {\n+            throw new ElasticsearchException(\"Cannot parse certificate(s)\", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        final SamlServiceProviderDocument that = (SamlServiceProviderDocument) o;\n+        return Objects.equals(docId, that.docId) &&\n+            Objects.equals(name, that.name) &&\n+            Objects.equals(entityId, that.entityId) &&\n+            Objects.equals(acs, that.acs) &&\n+            Objects.equals(enabled, that.enabled) &&\n+            Objects.equals(created, that.created) &&\n+            Objects.equals(lastModified, that.lastModified) &&\n+            Objects.equals(nameIdFormat, that.nameIdFormat) &&\n+            Objects.equals(authenticationExpiryMillis, that.authenticationExpiryMillis) &&\n+            Objects.equals(signingCertificates, that.signingCertificates) &&\n+            Objects.equals(privileges, that.privileges) &&\n+            Objects.equals(attributeNames, that.attributeNames);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(docId, name, entityId, acs, enabled, created, lastModified, nameIdFormat, authenticationExpiryMillis,\n+            signingCertificates, privileges, attributeNames);\n+    }\n+\n+    private static final ObjectParser<SamlServiceProviderDocument, SamlServiceProviderDocument> DOC_PARSER\n+        = new ObjectParser<>(\"service_provider_doc\", true, SamlServiceProviderDocument::new);\n+    private static final ObjectParser<Privileges, Void> PRIVILEGES_PARSER = new ObjectParser<>(\"service_provider_priv\", true, null);\n+    private static final ObjectParser<AttributeNames, Void> ATTRIBUTES_PARSER = new ObjectParser<>(\"service_provider_attr\", true, null);\n+\n+    private static final BiConsumer<SamlServiceProviderDocument, Object> NULL_CONSUMER = (doc, obj) -> {\n+    };\n+\n+    static {\n+        DOC_PARSER.declareString(SamlServiceProviderDocument::setName, Fields.NAME);\n+        DOC_PARSER.declareString(SamlServiceProviderDocument::setEntityId, Fields.ENTITY_ID);\n+        DOC_PARSER.declareString(SamlServiceProviderDocument::setAcs, Fields.ACS);\n+        DOC_PARSER.declareBoolean(SamlServiceProviderDocument::setEnabled, Fields.ENABLED);\n+        DOC_PARSER.declareLong(SamlServiceProviderDocument::setCreatedMillis, Fields.CREATED_DATE);\n+        DOC_PARSER.declareLong(SamlServiceProviderDocument::setLastModifiedMillis, Fields.LAST_MODIFIED);\n+        DOC_PARSER.declareStringOrNull(SamlServiceProviderDocument::setNameIdFormat, Fields.NAME_ID);\n+        // Using a method reference here angers some compilers\n+        DOC_PARSER.declareField(SamlServiceProviderDocument::setAuthenticationExpiryMillis,\n+            parser -> parser.currentToken() == XContentParser.Token.VALUE_NULL ? null : parser.longValue(),\n+            Fields.AUTHN_EXPIRY, ObjectParser.ValueType.LONG_OR_NULL);\n+        DOC_PARSER.declareStringArray(SamlServiceProviderDocument::setSigningCertificates, Fields.SIGNING_CERT);\n+\n+        DOC_PARSER.declareObject(NULL_CONSUMER, (parser, doc) -> PRIVILEGES_PARSER.parse(parser, doc.privileges, null), Fields.PRIVILEGES);\n+        PRIVILEGES_PARSER.declareStringOrNull(Privileges::setApplication, Fields.Privileges.APPLICATION);\n+        PRIVILEGES_PARSER.declareString(Privileges::setResource, Fields.Privileges.RESOURCE);\n+        PRIVILEGES_PARSER.declareStringOrNull(Privileges::setLoginAction, Fields.Privileges.LOGIN_ACTION);\n+        PRIVILEGES_PARSER.declareField(Privileges::setGroupActions,\n+            (parser, ignore) -> parser.currentToken() == XContentParser.Token.VALUE_NULL ? null : parser.mapStrings(),\n+            Fields.Privileges.GROUPS, ObjectParser.ValueType.OBJECT_OR_NULL);\n+\n+        DOC_PARSER.declareObject(NULL_CONSUMER, (p, doc) -> ATTRIBUTES_PARSER.parse(p, doc.attributeNames, null), Fields.ATTRIBUTES);\n+        ATTRIBUTES_PARSER.declareString(AttributeNames::setPrincipal, Fields.Attributes.PRINCIPAL);\n+        ATTRIBUTES_PARSER.declareStringOrNull(AttributeNames::setEmail, Fields.Attributes.EMAIL);\n+        ATTRIBUTES_PARSER.declareStringOrNull(AttributeNames::setName, Fields.Attributes.NAME);\n+        ATTRIBUTES_PARSER.declareStringOrNull(AttributeNames::setGroups, Fields.Attributes.GROUPS);\n+    }\n+\n+    public static SamlServiceProviderDocument fromXContent(String docId, XContentParser parser) throws IOException {\n+        SamlServiceProviderDocument doc = new SamlServiceProviderDocument();\n+        doc.setDocId(docId);\n+        return DOC_PARSER.parse(parser, doc, doc);\n+    }\n+\n+    public ValidationException validate() {\n+        final ValidationException validation = new ValidationException();\n+        if (Strings.isNullOrEmpty(name)) {\n+            validation.addValidationError(\"field [\" + Fields.NAME.getPreferredName() + \"] is required, but was [\" + name + \"]\");\n+        }\n+        if (Strings.isNullOrEmpty(entityId)) {\n+            validation.addValidationError(\"field [\" + Fields.ENTITY_ID.getPreferredName() + \"] is required, but was [\" + entityId + \"]\");\n+        }\n+        if (Strings.isNullOrEmpty(acs)) {\n+            validation.addValidationError(\"field [\" + Fields.ACS.getPreferredName() + \"] is required, but was [\" + acs + \"]\");\n+        }\n+        if (created == null) {\n+            validation.addValidationError(\"field [\" + Fields.CREATED_DATE.getPreferredName() + \"] is required, but was [\" + created + \"]\");", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNjA3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380306076", "bodyText": "We don't have to limit to one NameID format. We could allow a Set here and grant the requirements of the NameID policy in the authn request. Not an actionable comment at this time, maybe something to think about for a later phase", "author": "jkakavas", "createdAt": "2020-02-17T17:37:31Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ssl.CertParsingUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.ReadableDuration;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class models the storage of a {@link SamlServiceProvider} as an Elasticsearch document.\n+ */\n+public class SamlServiceProviderDocument implements ToXContentObject {\n+\n+    public static class Privileges {\n+        @Nullable\n+        public String application;\n+        public String resource;\n+        @Nullable\n+        public String loginAction;\n+        public Map<String, String> groupActions;\n+\n+        public void setApplication(String application) {\n+            this.application = application;\n+        }\n+\n+        public void setResource(String resource) {\n+            this.resource = resource;\n+        }\n+\n+        public void setLoginAction(String loginAction) {\n+            this.loginAction = loginAction;\n+        }\n+\n+        public void setGroupActions(Map<String, String> groupActions) {\n+            this.groupActions = groupActions;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Privileges that = (Privileges) o;\n+            return Objects.equals(application, that.application) &&\n+                Objects.equals(resource, that.resource) &&\n+                Objects.equals(loginAction, that.loginAction) &&\n+                Objects.equals(groupActions, that.groupActions);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(application, resource, loginAction, groupActions);\n+        }\n+    }\n+\n+    public static class AttributeNames {\n+        public String principal;\n+        @Nullable\n+        public String email;\n+        @Nullable\n+        public String name;\n+        @Nullable\n+        public String groups;\n+\n+        public void setPrincipal(String principal) {\n+            this.principal = principal;\n+        }\n+\n+        public void setEmail(String email) {\n+            this.email = email;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public void setGroups(String groups) {\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final AttributeNames that = (AttributeNames) o;\n+            return Objects.equals(principal, that.principal) &&\n+                Objects.equals(email, that.email) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(groups, that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(principal, email, name, groups);\n+        }\n+    }\n+\n+    public String docId;\n+\n+    public String name;\n+\n+    public String entityId;\n+\n+    public String acs;\n+\n+    public boolean enabled = true;\n+    public Instant created;\n+    public Instant lastModified;\n+\n+    @Nullable\n+    public String nameIdFormat;", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1MDk0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380450945", "bodyText": "I thought we agreed that we would limit to one NameID format so that we don't have to retain state from the AuthnRequest to the Response. At the time of validation of the AuthnRequest, if there's only 1 acceptable NameID we can validate and then rely on the Response being consistent with that.", "author": "tvernum", "createdAt": "2020-02-18T04:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNjA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ3MDQxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380470412", "bodyText": "We ended up keeping a state though (on the caller side). We can be more configurable at a low cost is all I'm saying here", "author": "jkakavas", "createdAt": "2020-02-18T06:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNjA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNjQ0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380306443", "bodyText": "Should we also add encryption certificates now ?", "author": "jkakavas", "createdAt": "2020-02-17T17:38:41Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ssl.CertParsingUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.ReadableDuration;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class models the storage of a {@link SamlServiceProvider} as an Elasticsearch document.\n+ */\n+public class SamlServiceProviderDocument implements ToXContentObject {\n+\n+    public static class Privileges {\n+        @Nullable\n+        public String application;\n+        public String resource;\n+        @Nullable\n+        public String loginAction;\n+        public Map<String, String> groupActions;\n+\n+        public void setApplication(String application) {\n+            this.application = application;\n+        }\n+\n+        public void setResource(String resource) {\n+            this.resource = resource;\n+        }\n+\n+        public void setLoginAction(String loginAction) {\n+            this.loginAction = loginAction;\n+        }\n+\n+        public void setGroupActions(Map<String, String> groupActions) {\n+            this.groupActions = groupActions;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Privileges that = (Privileges) o;\n+            return Objects.equals(application, that.application) &&\n+                Objects.equals(resource, that.resource) &&\n+                Objects.equals(loginAction, that.loginAction) &&\n+                Objects.equals(groupActions, that.groupActions);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(application, resource, loginAction, groupActions);\n+        }\n+    }\n+\n+    public static class AttributeNames {\n+        public String principal;\n+        @Nullable\n+        public String email;\n+        @Nullable\n+        public String name;\n+        @Nullable\n+        public String groups;\n+\n+        public void setPrincipal(String principal) {\n+            this.principal = principal;\n+        }\n+\n+        public void setEmail(String email) {\n+            this.email = email;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public void setGroups(String groups) {\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final AttributeNames that = (AttributeNames) o;\n+            return Objects.equals(principal, that.principal) &&\n+                Objects.equals(email, that.email) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(groups, that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(principal, email, name, groups);\n+        }\n+    }\n+\n+    public String docId;\n+\n+    public String name;\n+\n+    public String entityId;\n+\n+    public String acs;\n+\n+    public boolean enabled = true;\n+    public Instant created;\n+    public Instant lastModified;\n+\n+    @Nullable\n+    public String nameIdFormat;\n+\n+    @Nullable\n+    public Long authenticationExpiryMillis;\n+\n+    public List<String> signingCertificates = List.of();\n+", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1MTA2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380451060", "bodyText": "I don't think so, because we don't have encryption support, and might not in the immediate future.", "author": "tvernum", "createdAt": "2020-02-18T04:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNjQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ3MDU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380470541", "bodyText": "Happy to do this in the encryption support effort", "author": "jkakavas", "createdAt": "2020-02-18T06:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNjQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNzA2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380307061", "bodyText": "Should we also support per SP metadata signing? I see this as a similar use case to per SP signing certificates so I suggest we support  a metadataSigningCertificate here", "author": "jkakavas", "createdAt": "2020-02-17T17:40:31Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ssl.CertParsingUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.ReadableDuration;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class models the storage of a {@link SamlServiceProvider} as an Elasticsearch document.\n+ */\n+public class SamlServiceProviderDocument implements ToXContentObject {\n+\n+    public static class Privileges {\n+        @Nullable\n+        public String application;\n+        public String resource;\n+        @Nullable\n+        public String loginAction;\n+        public Map<String, String> groupActions;\n+\n+        public void setApplication(String application) {\n+            this.application = application;\n+        }\n+\n+        public void setResource(String resource) {\n+            this.resource = resource;\n+        }\n+\n+        public void setLoginAction(String loginAction) {\n+            this.loginAction = loginAction;\n+        }\n+\n+        public void setGroupActions(Map<String, String> groupActions) {\n+            this.groupActions = groupActions;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Privileges that = (Privileges) o;\n+            return Objects.equals(application, that.application) &&\n+                Objects.equals(resource, that.resource) &&\n+                Objects.equals(loginAction, that.loginAction) &&\n+                Objects.equals(groupActions, that.groupActions);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(application, resource, loginAction, groupActions);\n+        }\n+    }\n+\n+    public static class AttributeNames {\n+        public String principal;\n+        @Nullable\n+        public String email;\n+        @Nullable\n+        public String name;\n+        @Nullable\n+        public String groups;\n+\n+        public void setPrincipal(String principal) {\n+            this.principal = principal;\n+        }\n+\n+        public void setEmail(String email) {\n+            this.email = email;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public void setGroups(String groups) {\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final AttributeNames that = (AttributeNames) o;\n+            return Objects.equals(principal, that.principal) &&\n+                Objects.equals(email, that.email) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(groups, that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(principal, email, name, groups);\n+        }\n+    }\n+\n+    public String docId;\n+\n+    public String name;\n+\n+    public String entityId;\n+\n+    public String acs;\n+\n+    public boolean enabled = true;\n+    public Instant created;\n+    public Instant lastModified;\n+\n+    @Nullable\n+    public String nameIdFormat;\n+\n+    @Nullable\n+    public Long authenticationExpiryMillis;\n+\n+    public List<String> signingCertificates = List.of();\n+", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1MTI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380451266", "bodyText": "How would that work? We you proposing that we poll for metadata automatically? I wasn't expecting that we'd do that (at least, not now)", "author": "tvernum", "createdAt": "2020-02-18T04:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNzA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ3MTI4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380471282", "bodyText": "I meant that we can support signing the IDP metadata with a different key, depending on who the SP that will consume/validate them ( For the same reasons that we support different keys for SAML message signing , i.e. so that weird/specific requirements from SPs will not force us to rotate signing keys for all SPs )", "author": "jkakavas", "createdAt": "2020-02-18T06:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNzA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwODQ5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380308492", "bodyText": "We could easily support multiple acs URLs, I can make the adjustments needed in #52018. This might be useful for multiple instances under the same administrative and security domain", "author": "jkakavas", "createdAt": "2020-02-17T17:44:43Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ssl.CertParsingUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.ReadableDuration;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class models the storage of a {@link SamlServiceProvider} as an Elasticsearch document.\n+ */\n+public class SamlServiceProviderDocument implements ToXContentObject {\n+\n+    public static class Privileges {\n+        @Nullable\n+        public String application;\n+        public String resource;\n+        @Nullable\n+        public String loginAction;\n+        public Map<String, String> groupActions;\n+\n+        public void setApplication(String application) {\n+            this.application = application;\n+        }\n+\n+        public void setResource(String resource) {\n+            this.resource = resource;\n+        }\n+\n+        public void setLoginAction(String loginAction) {\n+            this.loginAction = loginAction;\n+        }\n+\n+        public void setGroupActions(Map<String, String> groupActions) {\n+            this.groupActions = groupActions;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Privileges that = (Privileges) o;\n+            return Objects.equals(application, that.application) &&\n+                Objects.equals(resource, that.resource) &&\n+                Objects.equals(loginAction, that.loginAction) &&\n+                Objects.equals(groupActions, that.groupActions);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(application, resource, loginAction, groupActions);\n+        }\n+    }\n+\n+    public static class AttributeNames {\n+        public String principal;\n+        @Nullable\n+        public String email;\n+        @Nullable\n+        public String name;\n+        @Nullable\n+        public String groups;\n+\n+        public void setPrincipal(String principal) {\n+            this.principal = principal;\n+        }\n+\n+        public void setEmail(String email) {\n+            this.email = email;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public void setGroups(String groups) {\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final AttributeNames that = (AttributeNames) o;\n+            return Objects.equals(principal, that.principal) &&\n+                Objects.equals(email, that.email) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(groups, that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(principal, email, name, groups);\n+        }\n+    }\n+\n+    public String docId;\n+\n+    public String name;\n+\n+    public String entityId;\n+\n+    public String acs;", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1MTQ5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380451492", "bodyText": "I don't think we have any requirement for that right now though. We don't have multiple instances under a single domain. Each Kibana needs its own resource, which means its own SP.", "author": "tvernum", "createdAt": "2020-02-18T04:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwODQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMxMjUyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380312522", "bodyText": "use ParameterizedMessage or if logger.isTraceEnabled() ?", "author": "jkakavas", "createdAt": "2020-02-17T17:55:56Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderIndex.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.template.TemplateUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * This class provides utility methods to read/write {@link SamlServiceProviderDocument} to an Elasticsearch index.\n+ */\n+public class SamlServiceProviderIndex implements Closeable {\n+\n+    private final Logger logger = LogManager.getLogger();\n+\n+    private final Client client;\n+    private final ClusterService clusterService;\n+    private volatile boolean aliasExists;\n+\n+    static final String ALIAS_NAME = \"saml-service-provider\";\n+    static final String INDEX_NAME = \"saml-service-provider-v1\";\n+    static final String TEMPLATE_NAME = ALIAS_NAME;\n+\n+    private static final String TEMPLATE_RESOURCE = \"/index/saml-service-provider-template.json\";\n+    private static final String TEMPLATE_META_VERSION_KEY = \"idp-version\";\n+    private static final String TEMPLATE_VERSION_SUBSTITUTE = Pattern.quote(\"${idp.template.version}\");\n+    private final ClusterStateListener clusterStateListener;\n+\n+    public SamlServiceProviderIndex(Client client, ClusterService clusterService) {\n+        this.client = new OriginSettingClient(client, ClientHelper.IDP_ORIGIN);\n+        this.clusterService = clusterService;\n+        clusterStateListener = this::clusterChanged;\n+        clusterService.addListener(clusterStateListener);\n+    }\n+\n+    private void clusterChanged(ClusterChangedEvent clusterChangedEvent) {\n+        final ClusterState state = clusterChangedEvent.state();\n+        final AliasOrIndex aliasInfo = state.getMetaData().getAliasAndIndexLookup().get(ALIAS_NAME);\n+        final boolean previousState = aliasExists;\n+        this.aliasExists = aliasInfo != null;\n+        if (aliasExists != previousState) {\n+            logChangedAliasState(aliasInfo);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        logger.debug(\"Closing ... removing cluster state listener\");\n+        clusterService.removeListener(clusterStateListener);\n+    }\n+\n+    private void logChangedAliasState(AliasOrIndex aliasInfo) {\n+        if (aliasInfo == null) {\n+            logger.warn(\"service provider index/alias [{}] no longer exists\", ALIAS_NAME);\n+        } else if (aliasInfo.isAlias() == false) {\n+            logger.warn(\"service provider index [{}] exists as a concrete index, but it should be an alias\", ALIAS_NAME);\n+        } else if (aliasInfo.getIndices().size() != 1) {\n+            logger.warn(\"service provider alias [{}] refers to multiple indices [{}] - this is unexpected and is likely to cause problems\",\n+                ALIAS_NAME, Strings.collectionToCommaDelimitedString(aliasInfo.getIndices()));\n+        } else {\n+            logger.info(\"service provider alias [{}] refers to [{}]\", ALIAS_NAME, aliasInfo.getIndices().get(0).getIndex());\n+        }\n+    }\n+\n+    public void installIndexTemplate(ActionListener<Boolean> listener) {\n+        final ClusterState state = clusterService.state();\n+        if (TemplateUtils.checkTemplateExistsAndIsUpToDate(TEMPLATE_NAME, TEMPLATE_META_VERSION_KEY, state, logger)) {\n+            listener.onResponse(false);\n+        }\n+        final String template = TemplateUtils.loadTemplate(TEMPLATE_RESOURCE, Version.CURRENT.toString(), TEMPLATE_VERSION_SUBSTITUTE);\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(TEMPLATE_NAME).source(template, XContentType.JSON);\n+        client.admin().indices().putTemplate(request, ActionListener.wrap(\n+            response -> listener.onResponse(response.isAcknowledged()), listener::onFailure));\n+    }\n+\n+    public void writeDocument(SamlServiceProviderDocument document, ActionListener<String> listener) {\n+        final ValidationException exception = document.validate();\n+        if (exception != null) {\n+            listener.onFailure(exception);\n+            return;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream();\n+             XContentBuilder xContentBuilder = new XContentBuilder(XContentType.JSON.xContent(), out)) {\n+            document.toXContent(xContentBuilder, ToXContent.EMPTY_PARAMS);\n+            // Due to the lack of \"alias templates\" (at the current time), we cannot write to the alias if it doesn't exist yet\n+            // - that would cause the alias to be created as a concrete index, which is not what we want.\n+            // So, until we know that the alias exists we have to write to the expected index name instead.\n+            final IndexRequest request = new IndexRequest(aliasExists ? ALIAS_NAME : INDEX_NAME)\n+                .source(xContentBuilder)\n+                .id(document.docId);\n+            client.index(request, ActionListener.wrap(response -> {\n+                logger.debug(\"Wrote service provider [{}][{}] as document [{}]\", document.name, document.entityId, response.getId());\n+                listener.onResponse(response.getId());\n+            }, listener::onFailure));\n+        } catch (IOException e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void readDocument(String documentId, ActionListener<SamlServiceProviderDocument> listener) {\n+        final GetRequest request = new GetRequest(ALIAS_NAME, documentId);\n+        client.get(request, ActionListener.wrap(response -> {\n+            final SamlServiceProviderDocument document = toDocument(documentId, response.getSourceAsBytesRef());\n+            listener.onResponse(document);\n+        }, listener::onFailure));\n+    }\n+\n+    public void findByEntityId(String entityId, ActionListener<Set<SamlServiceProviderDocument>> listener) {\n+        final QueryBuilder query = QueryBuilders.termQuery(SamlServiceProviderDocument.Fields.ENTITY_ID.getPreferredName(), entityId);\n+        findDocuments(query, listener);\n+    }\n+\n+    public void findAll(ActionListener<Set<SamlServiceProviderDocument>> listener) {\n+        final QueryBuilder query = QueryBuilders.matchAllQuery();\n+        findDocuments(query, listener);\n+    }\n+\n+    public void refresh(ActionListener<Void> listener) {\n+        client.admin().indices().refresh(new RefreshRequest(ALIAS_NAME), ActionListener.wrap(\n+            response -> listener.onResponse(null), listener::onFailure));\n+    }\n+\n+    private void findDocuments(QueryBuilder query, ActionListener<Set<SamlServiceProviderDocument>> listener) {\n+        logger.trace(\"Searching [{}] for [{}]\", ALIAS_NAME, query);", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1MjIxNA==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380452214", "bodyText": "There's not benefit in that. We only need to guard trace/debug messages if generating them is costly. This is a (more-or-less) zero cost call - there's no string addition or object access.\ne.g. This:\nlogger.trace(\"Searching [{}] for [{}]\", ALIAS_NAME, convertToString(query));\n\nis costly, because it calls convertToString even if tracing is disabled, so it should either be wrapped in a Supplier<ParameterizedMessage> or a logger.isTraceEnabled().\nBut without that cost, this line will just call Logger.trace(String, Object[] params) which will immediately check that trace is disabled and do nothing.", "author": "tvernum", "createdAt": "2020-02-18T04:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMxMjUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMxMjU1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380312553", "bodyText": "use ParameterizedMessage or if logger.isTraceEnabled() ?", "author": "jkakavas", "createdAt": "2020-02-17T17:56:02Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderIndex.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.template.TemplateUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * This class provides utility methods to read/write {@link SamlServiceProviderDocument} to an Elasticsearch index.\n+ */\n+public class SamlServiceProviderIndex implements Closeable {\n+\n+    private final Logger logger = LogManager.getLogger();\n+\n+    private final Client client;\n+    private final ClusterService clusterService;\n+    private volatile boolean aliasExists;\n+\n+    static final String ALIAS_NAME = \"saml-service-provider\";\n+    static final String INDEX_NAME = \"saml-service-provider-v1\";\n+    static final String TEMPLATE_NAME = ALIAS_NAME;\n+\n+    private static final String TEMPLATE_RESOURCE = \"/index/saml-service-provider-template.json\";\n+    private static final String TEMPLATE_META_VERSION_KEY = \"idp-version\";\n+    private static final String TEMPLATE_VERSION_SUBSTITUTE = Pattern.quote(\"${idp.template.version}\");\n+    private final ClusterStateListener clusterStateListener;\n+\n+    public SamlServiceProviderIndex(Client client, ClusterService clusterService) {\n+        this.client = new OriginSettingClient(client, ClientHelper.IDP_ORIGIN);\n+        this.clusterService = clusterService;\n+        clusterStateListener = this::clusterChanged;\n+        clusterService.addListener(clusterStateListener);\n+    }\n+\n+    private void clusterChanged(ClusterChangedEvent clusterChangedEvent) {\n+        final ClusterState state = clusterChangedEvent.state();\n+        final AliasOrIndex aliasInfo = state.getMetaData().getAliasAndIndexLookup().get(ALIAS_NAME);\n+        final boolean previousState = aliasExists;\n+        this.aliasExists = aliasInfo != null;\n+        if (aliasExists != previousState) {\n+            logChangedAliasState(aliasInfo);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        logger.debug(\"Closing ... removing cluster state listener\");\n+        clusterService.removeListener(clusterStateListener);\n+    }\n+\n+    private void logChangedAliasState(AliasOrIndex aliasInfo) {\n+        if (aliasInfo == null) {\n+            logger.warn(\"service provider index/alias [{}] no longer exists\", ALIAS_NAME);\n+        } else if (aliasInfo.isAlias() == false) {\n+            logger.warn(\"service provider index [{}] exists as a concrete index, but it should be an alias\", ALIAS_NAME);\n+        } else if (aliasInfo.getIndices().size() != 1) {\n+            logger.warn(\"service provider alias [{}] refers to multiple indices [{}] - this is unexpected and is likely to cause problems\",\n+                ALIAS_NAME, Strings.collectionToCommaDelimitedString(aliasInfo.getIndices()));\n+        } else {\n+            logger.info(\"service provider alias [{}] refers to [{}]\", ALIAS_NAME, aliasInfo.getIndices().get(0).getIndex());\n+        }\n+    }\n+\n+    public void installIndexTemplate(ActionListener<Boolean> listener) {\n+        final ClusterState state = clusterService.state();\n+        if (TemplateUtils.checkTemplateExistsAndIsUpToDate(TEMPLATE_NAME, TEMPLATE_META_VERSION_KEY, state, logger)) {\n+            listener.onResponse(false);\n+        }\n+        final String template = TemplateUtils.loadTemplate(TEMPLATE_RESOURCE, Version.CURRENT.toString(), TEMPLATE_VERSION_SUBSTITUTE);\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(TEMPLATE_NAME).source(template, XContentType.JSON);\n+        client.admin().indices().putTemplate(request, ActionListener.wrap(\n+            response -> listener.onResponse(response.isAcknowledged()), listener::onFailure));\n+    }\n+\n+    public void writeDocument(SamlServiceProviderDocument document, ActionListener<String> listener) {\n+        final ValidationException exception = document.validate();\n+        if (exception != null) {\n+            listener.onFailure(exception);\n+            return;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream();\n+             XContentBuilder xContentBuilder = new XContentBuilder(XContentType.JSON.xContent(), out)) {\n+            document.toXContent(xContentBuilder, ToXContent.EMPTY_PARAMS);\n+            // Due to the lack of \"alias templates\" (at the current time), we cannot write to the alias if it doesn't exist yet\n+            // - that would cause the alias to be created as a concrete index, which is not what we want.\n+            // So, until we know that the alias exists we have to write to the expected index name instead.\n+            final IndexRequest request = new IndexRequest(aliasExists ? ALIAS_NAME : INDEX_NAME)\n+                .source(xContentBuilder)\n+                .id(document.docId);\n+            client.index(request, ActionListener.wrap(response -> {\n+                logger.debug(\"Wrote service provider [{}][{}] as document [{}]\", document.name, document.entityId, response.getId());\n+                listener.onResponse(response.getId());\n+            }, listener::onFailure));\n+        } catch (IOException e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void readDocument(String documentId, ActionListener<SamlServiceProviderDocument> listener) {\n+        final GetRequest request = new GetRequest(ALIAS_NAME, documentId);\n+        client.get(request, ActionListener.wrap(response -> {\n+            final SamlServiceProviderDocument document = toDocument(documentId, response.getSourceAsBytesRef());\n+            listener.onResponse(document);\n+        }, listener::onFailure));\n+    }\n+\n+    public void findByEntityId(String entityId, ActionListener<Set<SamlServiceProviderDocument>> listener) {\n+        final QueryBuilder query = QueryBuilders.termQuery(SamlServiceProviderDocument.Fields.ENTITY_ID.getPreferredName(), entityId);\n+        findDocuments(query, listener);\n+    }\n+\n+    public void findAll(ActionListener<Set<SamlServiceProviderDocument>> listener) {\n+        final QueryBuilder query = QueryBuilders.matchAllQuery();\n+        findDocuments(query, listener);\n+    }\n+\n+    public void refresh(ActionListener<Void> listener) {\n+        client.admin().indices().refresh(new RefreshRequest(ALIAS_NAME), ActionListener.wrap(\n+            response -> listener.onResponse(null), listener::onFailure));\n+    }\n+\n+    private void findDocuments(QueryBuilder query, ActionListener<Set<SamlServiceProviderDocument>> listener) {\n+        logger.trace(\"Searching [{}] for [{}]\", ALIAS_NAME, query);\n+        final SearchRequest request = client.prepareSearch(ALIAS_NAME)\n+            .setQuery(query)\n+            .setSize(1000)\n+            .setFetchSource(true)\n+            .request();\n+        client.search(request, ActionListener.wrap(response -> {\n+            logger.trace(\"Search hits: [{}] [{}]\", response.getHits().getTotalHits(), Arrays.toString(response.getHits().getHits()));", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMxMjc2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52401#discussion_r380312765", "bodyText": "use ParameterizedMessage or if logger.isDebugEnabled() ?", "author": "jkakavas", "createdAt": "2020-02-17T17:56:38Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderIndex.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.template.TemplateUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * This class provides utility methods to read/write {@link SamlServiceProviderDocument} to an Elasticsearch index.\n+ */\n+public class SamlServiceProviderIndex implements Closeable {\n+\n+    private final Logger logger = LogManager.getLogger();\n+\n+    private final Client client;\n+    private final ClusterService clusterService;\n+    private volatile boolean aliasExists;\n+\n+    static final String ALIAS_NAME = \"saml-service-provider\";\n+    static final String INDEX_NAME = \"saml-service-provider-v1\";\n+    static final String TEMPLATE_NAME = ALIAS_NAME;\n+\n+    private static final String TEMPLATE_RESOURCE = \"/index/saml-service-provider-template.json\";\n+    private static final String TEMPLATE_META_VERSION_KEY = \"idp-version\";\n+    private static final String TEMPLATE_VERSION_SUBSTITUTE = Pattern.quote(\"${idp.template.version}\");\n+    private final ClusterStateListener clusterStateListener;\n+\n+    public SamlServiceProviderIndex(Client client, ClusterService clusterService) {\n+        this.client = new OriginSettingClient(client, ClientHelper.IDP_ORIGIN);\n+        this.clusterService = clusterService;\n+        clusterStateListener = this::clusterChanged;\n+        clusterService.addListener(clusterStateListener);\n+    }\n+\n+    private void clusterChanged(ClusterChangedEvent clusterChangedEvent) {\n+        final ClusterState state = clusterChangedEvent.state();\n+        final AliasOrIndex aliasInfo = state.getMetaData().getAliasAndIndexLookup().get(ALIAS_NAME);\n+        final boolean previousState = aliasExists;\n+        this.aliasExists = aliasInfo != null;\n+        if (aliasExists != previousState) {\n+            logChangedAliasState(aliasInfo);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        logger.debug(\"Closing ... removing cluster state listener\");\n+        clusterService.removeListener(clusterStateListener);\n+    }\n+\n+    private void logChangedAliasState(AliasOrIndex aliasInfo) {\n+        if (aliasInfo == null) {\n+            logger.warn(\"service provider index/alias [{}] no longer exists\", ALIAS_NAME);\n+        } else if (aliasInfo.isAlias() == false) {\n+            logger.warn(\"service provider index [{}] exists as a concrete index, but it should be an alias\", ALIAS_NAME);\n+        } else if (aliasInfo.getIndices().size() != 1) {\n+            logger.warn(\"service provider alias [{}] refers to multiple indices [{}] - this is unexpected and is likely to cause problems\",\n+                ALIAS_NAME, Strings.collectionToCommaDelimitedString(aliasInfo.getIndices()));\n+        } else {\n+            logger.info(\"service provider alias [{}] refers to [{}]\", ALIAS_NAME, aliasInfo.getIndices().get(0).getIndex());\n+        }\n+    }\n+\n+    public void installIndexTemplate(ActionListener<Boolean> listener) {\n+        final ClusterState state = clusterService.state();\n+        if (TemplateUtils.checkTemplateExistsAndIsUpToDate(TEMPLATE_NAME, TEMPLATE_META_VERSION_KEY, state, logger)) {\n+            listener.onResponse(false);\n+        }\n+        final String template = TemplateUtils.loadTemplate(TEMPLATE_RESOURCE, Version.CURRENT.toString(), TEMPLATE_VERSION_SUBSTITUTE);\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(TEMPLATE_NAME).source(template, XContentType.JSON);\n+        client.admin().indices().putTemplate(request, ActionListener.wrap(\n+            response -> listener.onResponse(response.isAcknowledged()), listener::onFailure));\n+    }\n+\n+    public void writeDocument(SamlServiceProviderDocument document, ActionListener<String> listener) {\n+        final ValidationException exception = document.validate();\n+        if (exception != null) {\n+            listener.onFailure(exception);\n+            return;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream();\n+             XContentBuilder xContentBuilder = new XContentBuilder(XContentType.JSON.xContent(), out)) {\n+            document.toXContent(xContentBuilder, ToXContent.EMPTY_PARAMS);\n+            // Due to the lack of \"alias templates\" (at the current time), we cannot write to the alias if it doesn't exist yet\n+            // - that would cause the alias to be created as a concrete index, which is not what we want.\n+            // So, until we know that the alias exists we have to write to the expected index name instead.\n+            final IndexRequest request = new IndexRequest(aliasExists ? ALIAS_NAME : INDEX_NAME)\n+                .source(xContentBuilder)\n+                .id(document.docId);\n+            client.index(request, ActionListener.wrap(response -> {\n+                logger.debug(\"Wrote service provider [{}][{}] as document [{}]\", document.name, document.entityId, response.getId());", "originalCommit": "f03f61d4d3edf4273c23033877a2d0735a95f572", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ccae3428bc23fbc80c360caf5fbdba1fa89d0b76", "url": "https://github.com/elastic/elasticsearch/commit/ccae3428bc23fbc80c360caf5fbdba1fa89d0b76", "message": "Add additional fields", "committedDate": "2020-02-21T13:33:00Z", "type": "commit"}, {"oid": "406fe0eb5f4785385bbd1e9b63ea4528571c69d2", "url": "https://github.com/elastic/elasticsearch/commit/406fe0eb5f4785385bbd1e9b63ea4528571c69d2", "message": "Merge branch 'feature-internal-idp' into idp/sp-doc", "committedDate": "2020-02-21T14:12:23Z", "type": "commit"}, {"oid": "36dc67479f02cfb15ef72a4087aa0681a9f86d49", "url": "https://github.com/elastic/elasticsearch/commit/36dc67479f02cfb15ef72a4087aa0681a9f86d49", "message": "Merge branch 'feature-internal-idp' into idp/sp-doc", "committedDate": "2020-02-23T12:23:25Z", "type": "commit"}, {"oid": "45df122f589c51c5661f5dc3fa1d2a5bd20886fa", "url": "https://github.com/elastic/elasticsearch/commit/45df122f589c51c5661f5dc3fa1d2a5bd20886fa", "message": "Fix template due to #51765", "committedDate": "2020-02-23T12:43:22Z", "type": "commit"}]}