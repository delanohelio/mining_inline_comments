{"pr_number": 55493, "pr_title": "Make ValuesSourceRegistry immutable after initilization", "pr_createdAt": "2020-04-20T20:57:45Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55493", "timeline": [{"oid": "835cf1b8b081a0900fe78f00189df40ab8744b63", "url": "https://github.com/elastic/elasticsearch/commit/835cf1b8b081a0900fe78f00189df40ab8744b63", "message": "Registry builder", "committedDate": "2020-04-16T20:49:05Z", "type": "commit"}, {"oid": "5f126737b9d45fac31a9db9abf6032a68903af33", "url": "https://github.com/elastic/elasticsearch/commit/5f126737b9d45fac31a9db9abf6032a68903af33", "message": "Merge branch 'master' into vs-refactor-immutable-registry", "committedDate": "2020-04-17T16:54:54Z", "type": "commit"}, {"oid": "229fde712ca5d00a9405e0497045c3aa08bdbb2a", "url": "https://github.com/elastic/elasticsearch/commit/229fde712ca5d00a9405e0497045c3aa08bdbb2a", "message": "Production design, still need to plumb through to tests", "committedDate": "2020-04-20T15:17:36Z", "type": "commit"}, {"oid": "429c21d36f8ef446c7e006e49d09416131afb7da", "url": "https://github.com/elastic/elasticsearch/commit/429c21d36f8ef446c7e006e49d09416131afb7da", "message": "Fix test aggregator loading", "committedDate": "2020-04-20T20:11:06Z", "type": "commit"}, {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901", "url": "https://github.com/elastic/elasticsearch/commit/bbf6315307642b0e3e8ffcd239032b167956f901", "message": "Copy to immutable data structures at build time", "committedDate": "2020-04-20T20:47:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3MDU2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412170565", "bodyText": "ValuesSourceRegistry.Builder?", "author": "nik9000", "createdAt": "2020-04-21T13:10:50Z", "path": "server/src/main/java/org/elasticsearch/plugins/SearchPlugin.java", "diffHunk": "@@ -117,8 +117,9 @@\n     /**\n      * Allows plugins to register new aggregations using aggregation names that are already defined\n      * in Core, as long as the new aggregations target different ValuesSourceTypes\n+     * @return A list of the new registrar functions\n      */\n-    default List<Consumer<ValuesSourceRegistry>> getBareAggregatorRegistrar() {\n+    default List<Consumer<ValuesSourceRegistry.ValuesSourceRegistryBuilder>> getBareAggregatorRegistrar() {", "originalCommit": "bbf6315307642b0e3e8ffcd239032b167956f901", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3MjMxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412172311", "bodyText": "Rename method to extendAggregations or something? Also, now that I'm looking at it, why return a list instead of just a method? Or even just:\ndefault void extendAggregations(ValuesSourceRegistry.Builder builder) {}\n\n?\nI know it doesn't line up with the other \"return lists of stuff\" methods on these classes but ValuesSourceRegistry is a different animal anyway.", "author": "nik9000", "createdAt": "2020-04-21T13:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3MDU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3Mzg2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412173869", "bodyText": "Maybe it isn't worth having the method named registerBareAggregatorRegistrar now.", "author": "nik9000", "createdAt": "2020-04-21T13:15:16Z", "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -322,144 +321,150 @@ public ValuesSourceRegistry getValuesSourceRegistry() {\n         return highlighters;\n     }\n \n-    private void registerAggregations(List<SearchPlugin> plugins) {\n+    private ValuesSourceRegistry registerAggregations(List<SearchPlugin> plugins) {\n+        ValuesSourceRegistry.ValuesSourceRegistryBuilder builder = new ValuesSourceRegistry.ValuesSourceRegistryBuilder();\n+\n         registerAggregation(new AggregationSpec(AvgAggregationBuilder.NAME, AvgAggregationBuilder::new, AvgAggregationBuilder.PARSER)\n             .addResultReader(InternalAvg::new)\n-            .setAggregatorRegistrar(AvgAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(AvgAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(WeightedAvgAggregationBuilder.NAME, WeightedAvgAggregationBuilder::new,\n-            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new));\n+            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new), builder);\n         registerAggregation(new AggregationSpec(SumAggregationBuilder.NAME, SumAggregationBuilder::new, SumAggregationBuilder.PARSER)\n             .addResultReader(InternalSum::new)\n-            .setAggregatorRegistrar(SumAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(SumAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MinAggregationBuilder.NAME, MinAggregationBuilder::new, MinAggregationBuilder.PARSER)\n             .addResultReader(InternalMin::new)\n-            .setAggregatorRegistrar(MinAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(MinAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MaxAggregationBuilder.NAME, MaxAggregationBuilder::new, MaxAggregationBuilder.PARSER)\n             .addResultReader(InternalMax::new)\n-            .setAggregatorRegistrar(MaxAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(MaxAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(StatsAggregationBuilder.NAME, StatsAggregationBuilder::new, StatsAggregationBuilder.PARSER)\n             .addResultReader(InternalStats::new)\n-            .setAggregatorRegistrar(StatsAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(StatsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder.NAME, ExtendedStatsAggregationBuilder::new,\n             ExtendedStatsAggregationBuilder.PARSER)\n                 .addResultReader(InternalExtendedStats::new)\n-                .setAggregatorRegistrar(ExtendedStatsAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(ExtendedStatsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ValueCountAggregationBuilder.NAME, ValueCountAggregationBuilder::new,\n             ValueCountAggregationBuilder.PARSER)\n                 .addResultReader(InternalValueCount::new)\n-                .setAggregatorRegistrar(ValueCountAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(ValueCountAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(PercentilesAggregationBuilder.NAME, PercentilesAggregationBuilder::new,\n             PercentilesAggregationBuilder.PARSER)\n                 .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                 .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new)\n-                .setAggregatorRegistrar(PercentilesAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(PercentilesAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder.NAME, PercentileRanksAggregationBuilder::new,\n             PercentileRanksAggregationBuilder.PARSER)\n                 .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                 .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new)\n-                .setAggregatorRegistrar(PercentileRanksAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(PercentileRanksAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MedianAbsoluteDeviationAggregationBuilder.NAME,\n             MedianAbsoluteDeviationAggregationBuilder::new, MedianAbsoluteDeviationAggregationBuilder.PARSER)\n                 .addResultReader(InternalMedianAbsoluteDeviation::new)\n-                .setAggregatorRegistrar(MedianAbsoluteDeviationAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(MedianAbsoluteDeviationAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(CardinalityAggregationBuilder.NAME, CardinalityAggregationBuilder::new,\n             CardinalityAggregationBuilder.PARSER).addResultReader(InternalCardinality::new)\n-                .setAggregatorRegistrar(CardinalityAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(CardinalityAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GlobalAggregationBuilder.NAME, GlobalAggregationBuilder::new,\n-                GlobalAggregationBuilder::parse).addResultReader(InternalGlobal::new));\n+                GlobalAggregationBuilder::parse).addResultReader(InternalGlobal::new), builder);\n         registerAggregation(new AggregationSpec(MissingAggregationBuilder.NAME, MissingAggregationBuilder::new,\n                 MissingAggregationBuilder.PARSER)\n                     .addResultReader(InternalMissing::new)\n-                    .setAggregatorRegistrar(MissingAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(MissingAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(FilterAggregationBuilder.NAME, FilterAggregationBuilder::new,\n-                FilterAggregationBuilder::parse).addResultReader(InternalFilter::new));\n+                FilterAggregationBuilder::parse).addResultReader(InternalFilter::new), builder);\n         registerAggregation(new AggregationSpec(FiltersAggregationBuilder.NAME, FiltersAggregationBuilder::new,\n-                FiltersAggregationBuilder::parse).addResultReader(InternalFilters::new));\n+                FiltersAggregationBuilder::parse).addResultReader(InternalFilters::new), builder);\n         registerAggregation(new AggregationSpec(AdjacencyMatrixAggregationBuilder.NAME, AdjacencyMatrixAggregationBuilder::new,\n-                AdjacencyMatrixAggregationBuilder::parse).addResultReader(InternalAdjacencyMatrix::new));\n+                AdjacencyMatrixAggregationBuilder::parse).addResultReader(InternalAdjacencyMatrix::new), builder);\n         registerAggregation(new AggregationSpec(SamplerAggregationBuilder.NAME, SamplerAggregationBuilder::new,\n                 SamplerAggregationBuilder::parse)\n                     .addResultReader(InternalSampler.NAME, InternalSampler::new)\n-                    .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new));\n+                    .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new),\n+            builder);\n         registerAggregation(new AggregationSpec(DiversifiedAggregationBuilder.NAME, DiversifiedAggregationBuilder::new,\n                 DiversifiedAggregationBuilder.PARSER)\n-                    /* Reuses result readers from SamplerAggregator*/);\n+                    /* Reuses result readers from SamplerAggregator*/, builder);\n         registerAggregation(new AggregationSpec(TermsAggregationBuilder.NAME, TermsAggregationBuilder::new,\n                 TermsAggregationBuilder.PARSER)\n                     .addResultReader(StringTerms.NAME, StringTerms::new)\n                     .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new)\n                     .addResultReader(LongTerms.NAME, LongTerms::new)\n                     .addResultReader(DoubleTerms.NAME, DoubleTerms::new)\n-            .setAggregatorRegistrar(TermsAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(TermsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(RareTermsAggregationBuilder.NAME, RareTermsAggregationBuilder::new,\n                 RareTermsAggregationBuilder.PARSER)\n                     .addResultReader(StringRareTerms.NAME, StringRareTerms::new)\n                     .addResultReader(UnmappedRareTerms.NAME, UnmappedRareTerms::new)\n                     .addResultReader(LongRareTerms.NAME, LongRareTerms::new)\n-                    .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(SignificantTermsAggregationBuilder.NAME, SignificantTermsAggregationBuilder::new,\n                 SignificantTermsAggregationBuilder::parse)\n                     .addResultReader(SignificantStringTerms.NAME, SignificantStringTerms::new)\n                     .addResultReader(SignificantLongTerms.NAME, SignificantLongTerms::new)\n                     .addResultReader(UnmappedSignificantTerms.NAME, UnmappedSignificantTerms::new)\n-                    .setAggregatorRegistrar(SignificantTermsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(SignificantTermsAggregationBuilder::registerAggregators),  builder);\n         registerAggregation(new AggregationSpec(SignificantTextAggregationBuilder.NAME, SignificantTextAggregationBuilder::new,\n-                SignificantTextAggregationBuilder::parse));\n+                SignificantTextAggregationBuilder::parse), builder);\n         registerAggregation(new AggregationSpec(RangeAggregationBuilder.NAME, RangeAggregationBuilder::new,\n                 RangeAggregationBuilder.PARSER)\n                     .addResultReader(InternalRange::new)\n-                    .setAggregatorRegistrar(RangeAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(RangeAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(DateRangeAggregationBuilder.NAME, DateRangeAggregationBuilder::new,\n                 DateRangeAggregationBuilder.PARSER)\n                     .addResultReader(InternalDateRange::new)\n-                    .setAggregatorRegistrar(DateRangeAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(DateRangeAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(IpRangeAggregationBuilder.NAME, IpRangeAggregationBuilder::new,\n-                IpRangeAggregationBuilder.PARSER).addResultReader(InternalBinaryRange::new));\n+                IpRangeAggregationBuilder.PARSER).addResultReader(InternalBinaryRange::new), builder);\n         registerAggregation(new AggregationSpec(HistogramAggregationBuilder.NAME, HistogramAggregationBuilder::new,\n                 HistogramAggregationBuilder.PARSER)\n                     .addResultReader(InternalHistogram::new)\n-                    .setAggregatorRegistrar(HistogramAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(HistogramAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(DateHistogramAggregationBuilder.NAME, DateHistogramAggregationBuilder::new,\n                 DateHistogramAggregationBuilder.PARSER)\n                     .addResultReader(InternalDateHistogram::new)\n-                    .setAggregatorRegistrar(DateHistogramAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(DateHistogramAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(AutoDateHistogramAggregationBuilder.NAME, AutoDateHistogramAggregationBuilder::new,\n-                AutoDateHistogramAggregationBuilder.PARSER).addResultReader(InternalAutoDateHistogram::new));\n+                AutoDateHistogramAggregationBuilder.PARSER).addResultReader(InternalAutoDateHistogram::new), builder);\n         registerAggregation(new AggregationSpec(GeoDistanceAggregationBuilder.NAME, GeoDistanceAggregationBuilder::new,\n-                GeoDistanceAggregationBuilder::parse).addResultReader(InternalGeoDistance::new));\n+                GeoDistanceAggregationBuilder::parse).addResultReader(InternalGeoDistance::new), builder);\n         registerAggregation(new AggregationSpec(GeoHashGridAggregationBuilder.NAME, GeoHashGridAggregationBuilder::new,\n                 GeoHashGridAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoHashGrid::new)\n-                    .setAggregatorRegistrar(GeoHashGridAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoHashGridAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GeoTileGridAggregationBuilder.NAME, GeoTileGridAggregationBuilder::new,\n                 GeoTileGridAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoTileGrid::new)\n-                    .setAggregatorRegistrar(GeoTileGridAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoTileGridAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(NestedAggregationBuilder.NAME, NestedAggregationBuilder::new,\n-                NestedAggregationBuilder::parse).addResultReader(InternalNested::new));\n+                NestedAggregationBuilder::parse).addResultReader(InternalNested::new), builder);\n         registerAggregation(new AggregationSpec(ReverseNestedAggregationBuilder.NAME, ReverseNestedAggregationBuilder::new,\n-                ReverseNestedAggregationBuilder::parse).addResultReader(InternalReverseNested::new));\n+                ReverseNestedAggregationBuilder::parse).addResultReader(InternalReverseNested::new), builder);\n         registerAggregation(new AggregationSpec(TopHitsAggregationBuilder.NAME, TopHitsAggregationBuilder::new,\n-                TopHitsAggregationBuilder::parse).addResultReader(InternalTopHits::new));\n+                TopHitsAggregationBuilder::parse).addResultReader(InternalTopHits::new), builder);\n         registerAggregation(new AggregationSpec(GeoBoundsAggregationBuilder.NAME, GeoBoundsAggregationBuilder::new,\n                 GeoBoundsAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoBounds::new)\n-                    .setAggregatorRegistrar(GeoBoundsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoBoundsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder.NAME, GeoCentroidAggregationBuilder::new,\n                 GeoCentroidAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoCentroid::new)\n-                    .setAggregatorRegistrar(GeoCentroidAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoCentroidAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder.NAME, ScriptedMetricAggregationBuilder::new,\n-                ScriptedMetricAggregationBuilder.PARSER).addResultReader(InternalScriptedMetric::new));\n+                ScriptedMetricAggregationBuilder.PARSER).addResultReader(InternalScriptedMetric::new), builder);\n         registerAggregation((new AggregationSpec(CompositeAggregationBuilder.NAME, CompositeAggregationBuilder::new,\n-                CompositeAggregationBuilder.PARSER).addResultReader(InternalComposite::new)));\n-        registerFromPlugin(plugins, SearchPlugin::getAggregations, this::registerAggregation);\n+                CompositeAggregationBuilder.PARSER).addResultReader(InternalComposite::new)), builder);\n+        registerFromPlugin(plugins, SearchPlugin::getAggregations, (agg) -> this.registerAggregation(agg, builder));\n \n         // after aggs have been registered, see if there are any new VSTypes that need to be linked to core fields\n-        registerFromPlugin(plugins, SearchPlugin::getBareAggregatorRegistrar, this::registerBareAggregatorRegistrar);\n+        registerFromPlugin(plugins, SearchPlugin::getBareAggregatorRegistrar,", "originalCommit": "bbf6315307642b0e3e8ffcd239032b167956f901", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3Mzk1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412173955", "bodyText": "Just use the lambda.", "author": "nik9000", "createdAt": "2020-04-21T13:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3Mzg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3NDYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412174635", "bodyText": "I don't think it needs to be synchronized any more because we do all plugin building in one thread.", "author": "nik9000", "createdAt": "2020-04-21T13:16:14Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -39,79 +41,101 @@\n  *\n  */\n public class ValuesSourceRegistry {\n-    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType\n-    private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = Map.of();\n-\n-    /**\n-     * Register a ValuesSource to Aggregator mapping.\n-     *\n-     * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n-     * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n-     * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n-     * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n-     * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n-     * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n-     * implementation of this method.\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be applied\n-     *                  to that type.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     */\n-    public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                      AggregatorSupplier aggregatorSupplier) {\n-        AbstractMap.SimpleEntry[] mappings;\n-        if (aggregatorRegistry.containsKey(aggregationName)) {\n-            List currentMappings = aggregatorRegistry.get(aggregationName);\n-            mappings = (AbstractMap.SimpleEntry[]) currentMappings.toArray(new AbstractMap.SimpleEntry[currentMappings.size() + 1]);\n-        } else {\n-            mappings = new AbstractMap.SimpleEntry[1];\n+    public static class ValuesSourceRegistryBuilder {\n+        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.\n+         *\n+         * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n+         * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n+         * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n+         * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n+         * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n+         * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n+         * implementation of this method.\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be\n+         *                  applied to that type.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         */\n+        public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,", "originalCommit": "bbf6315307642b0e3e8ffcd239032b167956f901", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3NTU3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412175574", "bodyText": "I think your import order config is a bit confused here. I believe we usually put static last. Not a big deal, but it makes the diff bigger.", "author": "nik9000", "createdAt": "2020-04-21T13:17:25Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -18,6 +18,26 @@\n  */\n package org.elasticsearch.search.aggregations;\n \n+import static org.elasticsearch.test.InternalAggregationTestCase.DEFAULT_MAX_BUCKETS;", "originalCommit": "bbf6315307642b0e3e8ffcd239032b167956f901", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85f1b3013ae3037781eeda1d3445d3e3cb49787e", "url": "https://github.com/elastic/elasticsearch/commit/85f1b3013ae3037781eeda1d3445d3e3cb49787e", "message": "Rename ValuesSourceRegistryBuilder -> Builder", "committedDate": "2020-04-21T16:24:13Z", "type": "commit"}, {"oid": "6b3cff655c8edb6e4c7d646b875e43225a2923b9", "url": "https://github.com/elastic/elasticsearch/commit/6b3cff655c8edb6e4c7d646b875e43225a2923b9", "message": "fix checkstyle", "committedDate": "2020-04-22T19:02:54Z", "type": "commit"}, {"oid": "fe58b1ff20b9497871385eb29c044192dda9e8a8", "url": "https://github.com/elastic/elasticsearch/commit/fe58b1ff20b9497871385eb29c044192dda9e8a8", "message": "Make register private and not synchronized", "committedDate": "2020-04-22T20:19:20Z", "type": "commit"}, {"oid": "b063ae419b53ad9ab9a891846a3d3f714cc68972", "url": "https://github.com/elastic/elasticsearch/commit/b063ae419b53ad9ab9a891846a3d3f714cc68972", "message": "Merge branch 'master' into vs-refactor-immutable-registry", "committedDate": "2020-04-22T20:19:24Z", "type": "commit"}, {"oid": "a3164675711e43d087f94e3154be17a86fdad895", "url": "https://github.com/elastic/elasticsearch/commit/a3164675711e43d087f94e3154be17a86fdad895", "message": "Wire up new agg extention", "committedDate": "2020-04-22T21:18:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MTEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413361122", "bodyText": "Is this still relevant ?", "author": "alx75", "createdAt": "2020-04-22T21:57:36Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -39,79 +41,101 @@\n  *\n  */\n public class ValuesSourceRegistry {\n-    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType\n-    private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = Map.of();\n-\n-    /**\n-     * Register a ValuesSource to Aggregator mapping.\n-     *\n-     * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n-     * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n-     * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n-     * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n-     * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n-     * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n-     * implementation of this method.\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be applied\n-     *                  to that type.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     */\n-    public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                      AggregatorSupplier aggregatorSupplier) {\n-        AbstractMap.SimpleEntry[] mappings;\n-        if (aggregatorRegistry.containsKey(aggregationName)) {\n-            List currentMappings = aggregatorRegistry.get(aggregationName);\n-            mappings = (AbstractMap.SimpleEntry[]) currentMappings.toArray(new AbstractMap.SimpleEntry[currentMappings.size() + 1]);\n-        } else {\n-            mappings = new AbstractMap.SimpleEntry[1];\n+    public static class Builder {\n+        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.\n+         *\n+         * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each", "originalCommit": "a3164675711e43d087f94e3154be17a86fdad895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d912671ee9a9b0ff666b9413072150e9fbc60194", "url": "https://github.com/elastic/elasticsearch/commit/d912671ee9a9b0ff666b9413072150e9fbc60194", "message": "Merge branch 'master' into vs-refactor-immutable-registry\n\n Conflicts:\n\tx-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "committedDate": "2020-04-23T13:01:55Z", "type": "commit"}, {"oid": "946a6e48c23bddf440539eb75032ce8ecedebacf", "url": "https://github.com/elastic/elasticsearch/commit/946a6e48c23bddf440539eb75032ce8ecedebacf", "message": "Removed no longer relevant javadoc", "committedDate": "2020-04-23T13:04:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwNzQzMw==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413807433", "bodyText": "\u2764\ufe0f", "author": "nik9000", "createdAt": "2020-04-23T13:44:59Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AvgAggregationBuilder.java", "diffHunk": "@@ -81,7 +81,8 @@ protected void innerWriteTo(StreamOutput out) {\n \n     @Override\n     protected AvgAggregatorFactory innerBuild(QueryShardContext queryShardContext, ValuesSourceConfig config,\n-                                              AggregatorFactory parent, Builder subFactoriesBuilder) throws IOException {\n+                                              AggregatorFactory parent,\n+                                              AggregatorFactories.Builder subFactoriesBuilder) throws IOException {", "originalCommit": "946a6e48c23bddf440539eb75032ce8ecedebacf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgzNjQwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413836401", "bodyText": "Glad you like it.  Intellij stuffed in the fully qualified package name there, and I did a manual pass yesterday to trim them down to just AggregatorFactories.Builder.", "author": "not-napoleon", "createdAt": "2020-04-23T14:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwNzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwODIxMA==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413808210", "bodyText": "Javadoc instead?", "author": "nik9000", "createdAt": "2020-04-23T13:46:02Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -39,79 +41,94 @@\n  *\n  */\n public class ValuesSourceRegistry {\n-    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType\n-    private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = Map.of();\n-\n-    /**\n-     * Register a ValuesSource to Aggregator mapping.\n-     *\n-     * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n-     * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n-     * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n-     * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n-     * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n-     * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n-     * implementation of this method.\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be applied\n-     *                  to that type.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     */\n-    public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                      AggregatorSupplier aggregatorSupplier) {\n-        AbstractMap.SimpleEntry[] mappings;\n-        if (aggregatorRegistry.containsKey(aggregationName)) {\n-            List currentMappings = aggregatorRegistry.get(aggregationName);\n-            mappings = (AbstractMap.SimpleEntry[]) currentMappings.toArray(new AbstractMap.SimpleEntry[currentMappings.size() + 1]);\n-        } else {\n-            mappings = new AbstractMap.SimpleEntry[1];\n+    public static class Builder {\n+        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.\n+         *\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be\n+         *                  applied to that type.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         */\n+        private void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n+                                          AggregatorSupplier aggregatorSupplier) {\n+            if (aggregatorRegistry.containsKey(aggregationName) == false) {\n+                aggregatorRegistry.put(aggregationName, new ArrayList<>());\n+            }\n+            aggregatorRegistry.get(aggregationName).add( new AbstractMap.SimpleEntry<>(appliesTo, aggregatorSupplier));\n         }\n-        mappings[mappings.length - 1] = new AbstractMap.SimpleEntry<>(appliesTo, aggregatorSupplier);\n-        aggregatorRegistry = copyAndAdd(aggregatorRegistry,new AbstractMap.SimpleEntry<>(aggregationName, List.of(mappings)));\n-    }\n \n-    /**\n-     * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a single\n-     * {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-     *  @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param valuesSourceType The ValuesSourceType this mapping applies to.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     *                           from the aggregation standard set of parameters\n-     */\n-    public void register(String aggregationName, ValuesSourceType valuesSourceType, AggregatorSupplier aggregatorSupplier) {\n-        register(aggregationName, (candidate) -> valuesSourceType.equals(candidate), aggregatorSupplier);\n-    }\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n+         * single {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceType The ValuesSourceType this mapping applies to.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                           from the aggregation standard set of parameters\n+         */\n+        public void register(String aggregationName, ValuesSourceType valuesSourceType, AggregatorSupplier aggregatorSupplier) {\n+            register(aggregationName, (candidate) -> valuesSourceType.equals(candidate), aggregatorSupplier);\n+        }\n \n-    /**\n-     * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a known\n-     * list of {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-     *  @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param valuesSourceTypes The ValuesSourceTypes this mapping applies to.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     *                           from the aggregation standard set of parameters\n-     */\n-    public void register(String aggregationName, List<ValuesSourceType> valuesSourceTypes, AggregatorSupplier aggregatorSupplier) {\n-        register(aggregationName, (candidate) -> {\n-            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n-                if (valuesSourceType.equals(candidate)) {\n-                    return true;\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n+         * known list of {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n+         *  @param aggregationName The name of the family of aggregations, typically found via\n+         *                         {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceTypes The ValuesSourceTypes this mapping applies to.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                           from the aggregation standard set of parameters\n+         */\n+        public void register(String aggregationName, List<ValuesSourceType> valuesSourceTypes, AggregatorSupplier aggregatorSupplier) {\n+            register(aggregationName, (candidate) -> {\n+                for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                    if (valuesSourceType.equals(candidate)) {\n+                        return true;\n+                    }\n                 }\n-            }\n-            return false;\n-        }, aggregatorSupplier);\n+                return false;\n+            }, aggregatorSupplier);\n+        }\n+\n+        /**\n+         * Register an aggregator that applies to any values source type.  This is a convenience method for aggregations that do not care at\n+         * all about the types of their inputs.  Aggregations using this version of registration should not make any other registrations, as\n+         * the aggregator registered using this function will be applied in all cases.\n+         *\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                           from the aggregation standard set of parameters.\n+         */\n+        public void registerAny(String aggregationName, AggregatorSupplier aggregatorSupplier) {\n+            register(aggregationName, (ignored) -> true, aggregatorSupplier);\n+        }\n+\n+\n+        public ValuesSourceRegistry build() {\n+            return new ValuesSourceRegistry(aggregatorRegistry);\n+        }\n     }\n \n-    /**\n-     * Register an aggregator that applies to any values source type.  This is a convenience method for aggregations that do not care at all\n-     * about the types of their inputs.  Aggregations using this version of registration should not make any other registrations, as the\n-     * aggregator registered using this function will be applied in all cases.\n-     *\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     *                           from the aggregation standard set of parameters.\n-     */\n-    public void registerAny(String aggregationName, AggregatorSupplier aggregatorSupplier) {\n-        register(aggregationName, (ignored) -> true, aggregatorSupplier);\n+    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType", "originalCommit": "946a6e48c23bddf440539eb75032ce8ecedebacf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgzNjc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413836747", "bodyText": "sure", "author": "not-napoleon", "createdAt": "2020-04-23T14:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwODIxMA=="}], "type": "inlineReview"}, {"oid": "05613f48a540208523b951d2c8723f523f31a024", "url": "https://github.com/elastic/elasticsearch/commit/05613f48a540208523b951d2c8723f523f31a024", "message": "Javadoc", "committedDate": "2020-04-23T14:20:59Z", "type": "commit"}]}