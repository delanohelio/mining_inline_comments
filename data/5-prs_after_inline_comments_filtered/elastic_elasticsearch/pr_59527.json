{"pr_number": 59527, "pr_title": "Two queries for keyword script field", "pr_createdAt": "2020-07-14T12:31:57Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59527", "timeline": [{"oid": "fb9b73823af60a88ef2bf49bbb19a29147593df4", "url": "https://github.com/elastic/elasticsearch/commit/fb9b73823af60a88ef2bf49bbb19a29147593df4", "message": "Two queries for keyword script field\n\nThis adds the `exits` and `terms` query for the `keyword` style of\nscripted field.", "committedDate": "2020-07-14T12:30:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQwMTkxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454401915", "bodyText": "I can imagine that we will want to have a base query class that deals with scorer, two phase iterator etc. and lets us only override matches? Are there challenges around this that I am missing?", "author": "javanna", "createdAt": "2020-07-14T14:33:20Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldExistsQuery.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.ConstantScoreScorer;\n+import org.apache.lucene.search.ConstantScoreWeight;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class StringScriptFieldExistsQuery extends Query {\n+    private final StringScriptFieldScript.LeafFactory leafFactory;\n+    private final String fieldName;\n+\n+    public StringScriptFieldExistsQuery(StringScriptFieldScript.LeafFactory leafFactory, String fieldName) {\n+        this.leafFactory = leafFactory;\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new ConstantScoreWeight(this, boost) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false; // scripts aren't really cacheable at this point\n+            }\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext ctx) throws IOException {\n+                StringScriptFieldScript script = leafFactory.newInstance(ctx);\n+                DocIdSetIterator approximation = DocIdSetIterator.all(ctx.reader().maxDoc());", "originalCommit": "fb9b73823af60a88ef2bf49bbb19a29147593df4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQxMDY4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454410689", "bodyText": "I just figured I'd do it after building a few more queries. I can do it now if you'd prefer. Either way.", "author": "nik9000", "createdAt": "2020-07-14T14:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQwMTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyMTI2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454421269", "bodyText": "I think it already makes sense to do it here unless it complicates things", "author": "javanna", "createdAt": "2020-07-14T14:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQwMTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyNDA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454424065", "bodyText": "I'll give it a go!", "author": "nik9000", "createdAt": "2020-07-14T15:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQwMTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ0NDc1NA==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454444754", "bodyText": "I've pushed an update, wanna take a look?", "author": "nik9000", "createdAt": "2020-07-14T15:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQwMTkxNQ=="}], "type": "inlineReview"}, {"oid": "fc970987e8d21b09b04129806148337c4cb540f6", "url": "https://github.com/elastic/elasticsearch/commit/fc970987e8d21b09b04129806148337c4cb540f6", "message": "Share code with queries", "committedDate": "2020-07-14T15:28:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1MjU2NA==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454452564", "bodyText": "I get it, but I find this cryptic. For instance looking at what DocValuesFieldExistsQuery does , that is clearer to me.", "author": "javanna", "createdAt": "2020-07-14T15:40:57Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldExistsQuery.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n+\n+import java.util.List;\n+\n+public class StringScriptFieldExistsQuery extends AbstractStringScriptFieldQuery {\n+    public StringScriptFieldExistsQuery(StringScriptFieldScript.LeafFactory leafFactory, String fieldName) {\n+        super(leafFactory, fieldName);\n+    }\n+\n+    @Override\n+    public boolean matches(List<String> values) {\n+        return false == values.isEmpty();\n+    }\n+\n+    @Override\n+    public String bareToString() {\n+        return \"*\";", "originalCommit": "fc970987e8d21b09b04129806148337c4cb540f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NjkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454486910", "bodyText": "I can keep the original toString impls.", "author": "nik9000", "createdAt": "2020-07-14T16:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1MjU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzA1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454457055", "bodyText": "should we have unit tests for equals/hashcode , toString and visit for all the queries that we introduce?", "author": "javanna", "createdAt": "2020-07-14T15:47:27Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class StringScriptFieldTermsQuery extends AbstractStringScriptFieldQuery {\n+    private final Set<String> terms;\n+\n+    public StringScriptFieldTermsQuery(StringScriptFieldScript.LeafFactory leafFactory, String fieldName, Set<String> terms) {\n+        super(leafFactory, fieldName);\n+        this.terms = terms;\n+    }\n+\n+    @Override\n+    public boolean matches(List<String> values) {\n+        for (String value : values) {\n+            if (terms.contains(value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void visit(QueryVisitor visitor) {\n+        if (visitor.acceptField(fieldName())) {\n+            for (String term : terms) {\n+                visitor.consumeTerms(this, new Term(fieldName(), term));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String bareToString() {\n+        return terms.toString();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), terms);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (false == super.equals(obj)) {\n+            return false;\n+        }\n+        StringScriptFieldTermsQuery other = (StringScriptFieldTermsQuery) obj;\n+        return other.terms.equals(other.terms);\n+    }", "originalCommit": "fc970987e8d21b09b04129806148337c4cb540f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzMzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454457331", "bodyText": "possibly also matches but that is already tested", "author": "javanna", "createdAt": "2020-07-14T15:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NjY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454486693", "bodyText": "Yeah. equals and hashcode are cache keys. toString probably isn't all that important but we may as well do it while we're there. Visit is important for highlighting, or, at least, it will be. So we should do it too.", "author": "nik9000", "createdAt": "2020-07-14T16:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzA1NQ=="}], "type": "inlineReview"}, {"oid": "9758ce98716b7b6d31fb3010f3e322c137428d08", "url": "https://github.com/elastic/elasticsearch/commit/9758ce98716b7b6d31fb3010f3e322c137428d08", "message": "Iter", "committedDate": "2020-07-14T18:41:08Z", "type": "commit"}, {"oid": "c52f212a062715591952614d2a0fc39adc369f17", "url": "https://github.com/elastic/elasticsearch/commit/c52f212a062715591952614d2a0fc39adc369f17", "message": "Merge branch 'feature/runtime_fields' into script_field_keyword_terms_exists", "committedDate": "2020-07-14T18:45:21Z", "type": "commit"}, {"oid": "1c8bcb16f479c8fba9f5c1c3ea358c262f230a13", "url": "https://github.com/elastic/elasticsearch/commit/1c8bcb16f479c8fba9f5c1c3ea358c262f230a13", "message": "Fixup", "committedDate": "2020-07-14T18:50:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MDgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454860807", "bodyText": "good point. what do we need to address this TODO? Would we need to pass in the Script itself?", "author": "javanna", "createdAt": "2020-07-15T07:52:23Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/AbstractStringScriptFieldQuery.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.ConstantScoreScorer;\n+import org.apache.lucene.search.ConstantScoreWeight;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript.LeafFactory;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Abstract base class for building queries based on {@link StringScriptFieldScript}.\n+ */\n+abstract class AbstractStringScriptFieldQuery extends Query {\n+    private final StringScriptFieldScript.LeafFactory leafFactory;\n+    private final String fieldName;\n+\n+    AbstractStringScriptFieldQuery(LeafFactory leafFactory, String fieldName) {\n+        this.leafFactory = Objects.requireNonNull(leafFactory);\n+        this.fieldName = Objects.requireNonNull(fieldName);\n+    }\n+\n+    /**\n+     * Does the value match this query?\n+     */\n+    public abstract boolean matches(List<String> values);\n+\n+    @Override\n+    public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new ConstantScoreWeight(this, boost) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false; // scripts aren't really cacheable at this point\n+            }\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext ctx) throws IOException {\n+                StringScriptFieldScript script = leafFactory.newInstance(ctx);\n+                DocIdSetIterator approximation = DocIdSetIterator.all(ctx.reader().maxDoc());\n+                TwoPhaseIterator twoPhase = new TwoPhaseIterator(approximation) {\n+                    @Override\n+                    public boolean matches() throws IOException {\n+                        return AbstractStringScriptFieldQuery.this.matches(script.resultsForDoc(approximation().docID()));\n+                    }\n+\n+                    @Override\n+                    public float matchCost() {\n+                        // TODO we don't have a good way of estimating the complexity of the script so we just go with 9000\n+                        return 9000f;\n+                    }\n+                };\n+                return new ConstantScoreScorer(this, score(), scoreMode, twoPhase);\n+            }\n+        };\n+    }\n+\n+    protected final String fieldName() {\n+        return fieldName;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        // TODO should leafFactory be here? Something about the script probably should be!", "originalCommit": "1c8bcb16f479c8fba9f5c1c3ea358c262f230a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MTMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454861333", "bodyText": "I thought we said we would adapt toString for the exists query to be something more aligned with DocValuesFieldExistsQuery in lucene", "author": "javanna", "createdAt": "2020-07-15T07:53:20Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldExistsQuery.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n+\n+import java.util.List;\n+\n+public class StringScriptFieldExistsQuery extends AbstractStringScriptFieldQuery {\n+    public StringScriptFieldExistsQuery(StringScriptFieldScript.LeafFactory leafFactory, String fieldName) {\n+        super(leafFactory, fieldName);\n+    }\n+\n+    @Override\n+    public boolean matches(List<String> values) {\n+        return false == values.isEmpty();\n+    }\n+\n+    @Override\n+    public final String toString(String field) {\n+        if (fieldName().contentEquals(field)) {\n+            return \"*\";\n+        }\n+        return fieldName() + \":*\";", "originalCommit": "1c8bcb16f479c8fba9f5c1c3ea358c262f230a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MjkyOA==", "url": "https://github.com/elastic/elasticsearch/pull/59527#discussion_r454862928", "bodyText": "thanks for adding all these tests!!!", "author": "javanna", "createdAt": "2020-07-15T07:56:08Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQueryTests.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.util.automaton.ByteRunAutomaton;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.function.Supplier;\n+\n+import static java.util.stream.Collectors.toCollection;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class StringScriptFieldTermsQueryTests extends AbstractStringScriptFieldQueryTestCase<StringScriptFieldTermsQuery> {\n+    @Override\n+    protected StringScriptFieldTermsQuery createTestInstance() {\n+        Set<String> terms = new TreeSet<>(Arrays.asList(generateRandomStringArray(4, 6, false, false)));\n+        return new StringScriptFieldTermsQuery(leafFactory, randomAlphaOfLength(5), terms);\n+    }\n+\n+    @Override\n+    protected StringScriptFieldTermsQuery copy(StringScriptFieldTermsQuery orig) {\n+        return new StringScriptFieldTermsQuery(leafFactory, orig.fieldName(), orig.terms());\n+    }\n+\n+    @Override\n+    protected StringScriptFieldTermsQuery mutate(StringScriptFieldTermsQuery orig) {\n+        if (randomBoolean()) {\n+            return new StringScriptFieldTermsQuery(leafFactory, orig.fieldName() + \"modified\", orig.terms());\n+        }\n+        Set<String> terms = new TreeSet<>(orig.terms());\n+        terms.add(randomAlphaOfLength(7));\n+        return new StringScriptFieldTermsQuery(leafFactory, orig.fieldName(), terms);\n+    }\n+\n+    @Override\n+    protected void assertToString(StringScriptFieldTermsQuery query) {\n+        assertThat(query.toString(query.fieldName()), equalTo(query.terms().toString()));\n+    }\n+\n+    @Override\n+    public void testVisit() {\n+        StringScriptFieldTermsQuery query = createTestInstance();\n+        Set<Term> allTerms = new TreeSet<>();\n+        query.visit(new QueryVisitor() {\n+            @Override\n+            public void consumeTerms(Query query, Term... terms) {\n+                allTerms.addAll(Arrays.asList(terms));\n+            }\n+\n+            @Override\n+            public void consumeTermsMatching(Query query, String field, Supplier<ByteRunAutomaton> automaton) {\n+                fail();\n+            }\n+        });\n+        assertThat(allTerms, equalTo(query.terms().stream().map(t -> new Term(query.fieldName(), t)).collect(toCollection(TreeSet::new))));\n+    }", "originalCommit": "1c8bcb16f479c8fba9f5c1c3ea358c262f230a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}