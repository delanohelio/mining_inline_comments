{"pr_number": 52018, "pr_title": "Handle incoming AuthnRequests", "pr_createdAt": "2020-02-06T21:53:01Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52018", "timeline": [{"oid": "f09d280de697c4187f679b79c6375ab1093f7ca7", "url": "https://github.com/elastic/elasticsearch/commit/f09d280de697c4187f679b79c6375ab1093f7ca7", "message": "Handle incoming AuthnRequests\n\n- Expose an API that consumes (possibly signed) AuthnRequests as\ndefined by the HTTP-Redirect binding.\n- Process AuthnRequests, validate and parse them into a minimum\nset of information to be used for subsequent API calls to get a\nSAML Response", "committedDate": "2020-02-06T21:43:33Z", "type": "commit"}, {"oid": "68a13c70b97f84c9a5e0ae039b539fc2b9204746", "url": "https://github.com/elastic/elasticsearch/commit/68a13c70b97f84c9a5e0ae039b539fc2b9204746", "message": "remove redundant schema files", "committedDate": "2020-02-06T21:51:19Z", "type": "commit"}, {"oid": "52583996b18c9fd1426610942e5571fc28ce62f6", "url": "https://github.com/elastic/elasticsearch/commit/52583996b18c9fd1426610942e5571fc28ce62f6", "message": "Merge branch 'feature-internal-idp' into idp-sp-init-handlers", "committedDate": "2020-02-07T06:04:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4ODMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376388335", "bodyText": "See similar comment on other PR.\nI think there are two options that make sense:\n\neither assume that there is only a single validation and simplify this down to if (isNullOrEmpty) { return addValidationError(); } else { return null; }\nor follow the standard pattern we use here, in preparation for additional validations, and pass validationException in the 2nd argument.", "author": "tvernum", "createdAt": "2020-02-07T13:27:21Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlValidateAuthnRequestRequest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class SamlValidateAuthnRequestRequest extends ActionRequest {\n+\n+    private String queryString;\n+\n+    public SamlValidateAuthnRequestRequest(StreamInput in) throws IOException {\n+        super(in);\n+        queryString = in.readString();\n+    }\n+\n+    public SamlValidateAuthnRequestRequest() {\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (Strings.isNullOrEmpty(queryString)) {\n+            validationException = addValidationError(\"Authentication request query string must be provided\", null);", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4OTE1NA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376389154", "bodyText": "Can we have null checks here, since the serialization assumes that they're not null?", "author": "tvernum", "createdAt": "2020-02-07T13:29:01Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlValidateAuthnRequestResponse.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class SamlValidateAuthnRequestResponse extends ActionResponse {\n+\n+    private String spEntityId;\n+    private boolean forceAuthn;\n+    private Map<String, Object> additionalData;\n+\n+    public SamlValidateAuthnRequestResponse(StreamInput in) throws IOException {\n+        super(in);\n+        this.spEntityId = in.readString();\n+        this.forceAuthn = in.readBoolean();\n+        this.additionalData = in.readMap();\n+    }\n+\n+    public SamlValidateAuthnRequestResponse(String spEntityId, boolean forceAuthn, Map<String, Object> additionalData) {\n+        this.spEntityId = spEntityId;\n+        this.forceAuthn = forceAuthn;\n+        this.additionalData = additionalData;", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4OTIyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376389223", "bodyText": "These can be final.", "author": "tvernum", "createdAt": "2020-02-07T13:29:11Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlValidateAuthnRequestResponse.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class SamlValidateAuthnRequestResponse extends ActionResponse {\n+\n+    private String spEntityId;\n+    private boolean forceAuthn;\n+    private Map<String, Object> additionalData;", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5MDMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376390303", "bodyText": "Per other PR, I think an object { \"service_provider\": { \"entity_id\": \"...\" } } sets us up for better future expansion.", "author": "tvernum", "createdAt": "2020-02-07T13:31:23Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/rest/RestSamlValidateAuthenticationRequestAction.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.rest;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestBuilderListener;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestAction;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestRequest;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+\n+public class RestSamlValidateAuthenticationRequestAction extends BaseRestHandler {\n+\n+    static final ObjectParser<SamlValidateAuthnRequestRequest, Void> PARSER =\n+        new ObjectParser<>(\"idp_validate_authn_request\", SamlValidateAuthnRequestRequest::new);\n+\n+    static {\n+        PARSER.declareString(SamlValidateAuthnRequestRequest::setQueryString, new ParseField(\"authn_request_query\"));\n+    }\n+\n+    public RestSamlValidateAuthenticationRequestAction(RestController controller) {\n+        controller.registerHandler(\n+            POST, \"/_idp/saml/validate\", this\n+        );\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"idp_validate_authn_request_action\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        try (XContentParser parser = request.contentParser()) {\n+            final SamlValidateAuthnRequestRequest validateRequest = PARSER.parse(parser, null);\n+            return channel -> client.execute(SamlValidateAuthnRequestAction.INSTANCE, validateRequest,\n+                new RestBuilderListener<SamlValidateAuthnRequestResponse>(channel) {\n+                    @Override\n+                    public RestResponse buildResponse(SamlValidateAuthnRequestResponse response, XContentBuilder builder) throws Exception {\n+                        builder.startObject();\n+                        builder.field(\"sp_entity_id\", response.getSpEntityId());", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5MTExNw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376391117", "bodyText": "I don't love this name. I wonder if we should be more explicit and call it xxx_state or something (authn_state, request_state ?)", "author": "tvernum", "createdAt": "2020-02-07T13:33:15Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/rest/RestSamlValidateAuthenticationRequestAction.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.rest;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestBuilderListener;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestAction;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestRequest;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+\n+public class RestSamlValidateAuthenticationRequestAction extends BaseRestHandler {\n+\n+    static final ObjectParser<SamlValidateAuthnRequestRequest, Void> PARSER =\n+        new ObjectParser<>(\"idp_validate_authn_request\", SamlValidateAuthnRequestRequest::new);\n+\n+    static {\n+        PARSER.declareString(SamlValidateAuthnRequestRequest::setQueryString, new ParseField(\"authn_request_query\"));\n+    }\n+\n+    public RestSamlValidateAuthenticationRequestAction(RestController controller) {\n+        controller.registerHandler(\n+            POST, \"/_idp/saml/validate\", this\n+        );\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"idp_validate_authn_request_action\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        try (XContentParser parser = request.contentParser()) {\n+            final SamlValidateAuthnRequestRequest validateRequest = PARSER.parse(parser, null);\n+            return channel -> client.execute(SamlValidateAuthnRequestAction.INSTANCE, validateRequest,\n+                new RestBuilderListener<SamlValidateAuthnRequestResponse>(channel) {\n+                    @Override\n+                    public RestResponse buildResponse(SamlValidateAuthnRequestResponse response, XContentBuilder builder) throws Exception {\n+                        builder.startObject();\n+                        builder.field(\"sp_entity_id\", response.getSpEntityId());\n+                        builder.field(\"force_authn\", response.isForceAuthn());\n+                        builder.field(\"additional_data\", response.getAdditionalData());", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMDUwNw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376410507", "bodyText": "I don't love this name.\n\nThat makes two of us. xxx_state works fine for me", "author": "jkakavas", "createdAt": "2020-02-07T14:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5MTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5MjM5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376392392", "bodyText": "Is this needed? Can't we just call decodeQueryString and check parameters.size()   ?", "author": "tvernum", "createdAt": "2020-02-07T13:36:07Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMTU4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376411588", "bodyText": "leftover from before I discovered RestUtils.decodeQueryString(queryString, 0, parameters);", "author": "jkakavas", "createdAt": "2020-02-07T14:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5MjM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5MzI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376393296", "bodyText": "I don't understand why we have a lambda here. Can't we just pass a ParameterizedMessage to logAndThrow? We know the message will be instantiated since it's going to be thrown.", "author": "tvernum", "createdAt": "2020-02-07T13:38:11Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzg2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376413863", "bodyText": "True, I carried this over from previous version where I wouldn't log_and_throw and it made sense then", "author": "jkakavas", "createdAt": "2020-02-07T14:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5MzI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5NDI2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376394267", "bodyText": "It's a preference, but I think I'd find this neater to have a SamlUtils.elementNameMatches(element, namespace, local) method.", "author": "tvernum", "createdAt": "2020-02-07T13:40:09Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5NTA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376395091", "bodyText": "The XML could be long, should we truncate at some reasonable point? We mostly only care about the namespace/name anyway.", "author": "tvernum", "createdAt": "2020-02-07T13:42:05Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5NTY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376395692", "bodyText": "Per other PR, I think getRegisteredServiceProvider(String) will serve us better.", "author": "tvernum", "createdAt": "2020-02-07T13:43:18Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));\n+        }\n+        try {\n+            authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+        } catch (Exception e) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Cannot process AuthnRequest [{}]\", SamlUtils.toString(root, true)), e);\n+        }\n+        final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+        if (signature != null) {\n+            if (sigAlg == null) {\n+                logAndThrow(() ->\n+                    new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                        queryString));\n+            }\n+            final X509Credential spSigningCredential = sp.getSigningCredential();\n+            if (spSigningCredential == null) {\n+                logAndThrow(\n+                    \"Unable to validate signature of authentication request, Service Provider hasn't registered signing credentials\");\n+            }\n+            validateSignature(samlRequest, sigAlg, signature, sp.getSigningCredential(), relayState);\n+        }\n+        validateAuthnRequest(authnRequest, sp);\n+        Map<String, Object> additionalData = buildAdditionalData(authnRequest, sp);\n+        return new SamlValidateAuthnRequestResponse(sp.getEntityId(), authnRequest.isForceAuthn(), additionalData);\n+    }\n+\n+    private Map<String, Object> buildAdditionalData(AuthnRequest request, SamlServiceProvider sp) {\n+        Map<String, Object> data = new HashMap<>();\n+        final NameIDPolicy nameIDPolicy = request.getNameIDPolicy();\n+        if (null != nameIDPolicy) {\n+            final String requestedFormat = request.getNameIDPolicy().getFormat();\n+            if (Strings.hasText(requestedFormat)) {\n+                data.put(\"nameid_format\", requestedFormat);\n+                // we should not throw an error. Pass this as additional data so that the /saml/init API can\n+                // return a SAML response with the appropriate status (3.4.1.1 in the core spec)\n+                if (requestedFormat.equals(UNSPECIFIED) == false &&\n+                    requestedFormat.equals(sp.getNameIDPolicyFormat()) == false) {\n+                    logger.warn(() ->\n+                        new ParameterizedMessage(\"The requested NameID format [{}] doesn't match the allowed NameID format\" +\n+                            \"for this Service Provider is [{}]\", requestedFormat, sp.getNameIDPolicyFormat()));\n+                    data.put(\"error\", \"invalid_nameid_policy\");\n+                }\n+            }\n+        }\n+        return data;\n+    }\n+\n+    private void validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp) {\n+        checkDestination(authnRequest);\n+        checkAcs(authnRequest, sp);\n+    }\n+\n+    private void validateSignature(String samlRequest, String sigAlg, String signature, X509Credential credential,\n+                                   @Nullable String relayState) {\n+        try {\n+            final String queryParam = relayState == null ?\n+                \"SAMLRequest=\" + urlEncode(samlRequest) + \"&SigAlg=\" + urlEncode(sigAlg) :\n+                \"SAMLRequest=\" + urlEncode(samlRequest) + \"&RelayState=\" + urlEncode(relayState) + \"&SigAlg=\" + urlEncode(sigAlg);\n+            Signature sig = Signature.getInstance(\"SHA256withRSA\");\n+            sig.initVerify(credential.getEntityCertificate().getPublicKey());\n+            sig.update(queryParam.getBytes(StandardCharsets.UTF_8));\n+            if (sig.verify(Base64.getDecoder().decode(signature)) == false) {\n+                logAndThrow(() ->\n+                    new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n+                        queryParam, SamlUtils.describeCredentials(Collections.singletonList(credential))));\n+            }\n+        } catch (Exception e) {\n+            logAndThrow(() ->\n+                new ParameterizedMessage(\"Unable to validate signature of authentication request using credentials [{}]\",\n+                    SamlUtils.describeCredentials(Collections.singletonList(credential))), e);\n+        }\n+    }\n+\n+    private SamlServiceProvider getSpFromIssuer(Issuer issuer) {\n+        if (issuer == null || issuer.getValue() == null) {\n+            logAndThrow(\"SAML authentication request has no issuer\");\n+        }\n+        final String issuerString = issuer.getValue();\n+        final Map<String, SamlServiceProvider> registeredSps = idp.getRegisteredServiceProviders();", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5NjE5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376396193", "bodyText": "I'm pretty sure this will end up async (needing to lookup SP in index).\nCan we structure it to have a listener now, so that it's a bit simpler to change later on?", "author": "tvernum", "createdAt": "2020-02-07T13:44:26Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxNDk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376414972", "bodyText": "I left this on purpose for the registration API PR but no objections to tackle this here, will do!", "author": "jkakavas", "createdAt": "2020-02-07T14:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5NjE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5NjQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376396498", "bodyText": "This method in particular will probably need to end up async.", "author": "tvernum", "createdAt": "2020-02-07T13:45:09Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));\n+        }\n+        try {\n+            authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+        } catch (Exception e) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Cannot process AuthnRequest [{}]\", SamlUtils.toString(root, true)), e);\n+        }\n+        final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5ODI1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376398257", "bodyText": "There's nothing here for empty string, and I think it's probably worth having an explicit error for that case.\nI don't fancy debugging the type of error messages we'd get from trying to process empty signatures/algs.", "author": "tvernum", "createdAt": "2020-02-07T13:48:42Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));\n+        }\n+        try {\n+            authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+        } catch (Exception e) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Cannot process AuthnRequest [{}]\", SamlUtils.toString(root, true)), e);\n+        }\n+        final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+        if (signature != null) {\n+            if (sigAlg == null) {\n+                logAndThrow(() ->\n+                    new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                        queryString));\n+            }", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxNTkyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376415920", "bodyText": "Good catch, I can already imagine the debugging session", "author": "jkakavas", "createdAt": "2020-02-07T14:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5ODI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5ODcxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376398710", "bodyText": "I can check the spec if you don't know, but should sigAlg != null && signature == null be an error too?", "author": "tvernum", "createdAt": "2020-02-07T13:49:37Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));\n+        }\n+        try {\n+            authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+        } catch (Exception e) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Cannot process AuthnRequest [{}]\", SamlUtils.toString(root, true)), e);\n+        }\n+        final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+        if (signature != null) {\n+            if (sigAlg == null) {", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxNTQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376415461", "bodyText": "Correct, it's either both or none", "author": "jkakavas", "createdAt": "2020-02-07T14:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5ODcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5OTY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376399643", "bodyText": "So we validate signatures, but we never care if a request is unsigned?\nI don't know what we want (should an SP have a config for what sorts of messages they will sign, and we enforce signatures there?), but perhaps we at least need a TODO here.", "author": "tvernum", "createdAt": "2020-02-07T13:51:42Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));\n+        }\n+        try {\n+            authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+        } catch (Exception e) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Cannot process AuthnRequest [{}]\", SamlUtils.toString(root, true)), e);\n+        }\n+        final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+        if (signature != null) {\n+            if (sigAlg == null) {\n+                logAndThrow(() ->\n+                    new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                        queryString));\n+            }\n+            final X509Credential spSigningCredential = sp.getSigningCredential();\n+            if (spSigningCredential == null) {\n+                logAndThrow(\n+                    \"Unable to validate signature of authentication request, Service Provider hasn't registered signing credentials\");\n+            }\n+            validateSignature(samlRequest, sigAlg, signature, sp.getSigningCredential(), relayState);\n+        }", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxOTc2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376419765", "bodyText": "This can go a few ways:\n\nWe can demand only signed AuthnRequests, declare that in our metadata too WantAuthnRequestsSigned and fail here.\nAllow SPs to sign and handle this but not mandate it ( what is what we have so far )\nSet this in configuration when an SP is registered and act accordingly.\n\nI'll add a TODO so that we don't miss this and we can discuss", "author": "jkakavas", "createdAt": "2020-02-07T14:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5OTY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIyMDczMA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r378220730", "bodyText": "Based on our discussion today, I went with the following:\n\nIf the SP should sign requests, this should be explicitly defined during registration\nIf the SP should sign requests, and the request has a signature, we validate it\nIf the SP should sign requests, and the request doesn't have a signature, we fail\nIf the SP should not sign requests, we do not attempt to parse and validate a signature even if one exists", "author": "jkakavas", "createdAt": "2020-02-12T12:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5OTY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjAwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376402001", "bodyText": "Are you intentionally saying that we would go through the user auth phase and then return an error to the SP?\nIs that necessary?\nI think we should indicate to the caller that validation failed, and either:\n\nreturn all the info they need to send back to the SP (but that seems like it duplicates the other API), OR\nprovide a new API that takes an error object from this response and turns it an Authn Response failure, OR\nmake it possible to call the Response API without user authc, if-and-only-if the state data indicates an error.", "author": "tvernum", "createdAt": "2020-02-07T13:56:45Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));\n+        }\n+        try {\n+            authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+        } catch (Exception e) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Cannot process AuthnRequest [{}]\", SamlUtils.toString(root, true)), e);\n+        }\n+        final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+        if (signature != null) {\n+            if (sigAlg == null) {\n+                logAndThrow(() ->\n+                    new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                        queryString));\n+            }\n+            final X509Credential spSigningCredential = sp.getSigningCredential();\n+            if (spSigningCredential == null) {\n+                logAndThrow(\n+                    \"Unable to validate signature of authentication request, Service Provider hasn't registered signing credentials\");\n+            }\n+            validateSignature(samlRequest, sigAlg, signature, sp.getSigningCredential(), relayState);\n+        }\n+        validateAuthnRequest(authnRequest, sp);\n+        Map<String, Object> additionalData = buildAdditionalData(authnRequest, sp);\n+        return new SamlValidateAuthnRequestResponse(sp.getEntityId(), authnRequest.isForceAuthn(), additionalData);\n+    }\n+\n+    private Map<String, Object> buildAdditionalData(AuthnRequest request, SamlServiceProvider sp) {\n+        Map<String, Object> data = new HashMap<>();\n+        final NameIDPolicy nameIDPolicy = request.getNameIDPolicy();\n+        if (null != nameIDPolicy) {\n+            final String requestedFormat = request.getNameIDPolicy().getFormat();\n+            if (Strings.hasText(requestedFormat)) {\n+                data.put(\"nameid_format\", requestedFormat);\n+                // we should not throw an error. Pass this as additional data so that the /saml/init API can\n+                // return a SAML response with the appropriate status (3.4.1.1 in the core spec)", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQyMzg4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376423884", "bodyText": "Are you intentionally saying that we would go through the user auth phase and then return an error to the SP?\nIs that necessary?\n\nYes. If the user can't authenticate to the IDP we should not return urn:oasis:names:tc:SAML:2.0:status:InvalidNameIdPolicy but urn:oasis:names:tc:SAML:2.0:status:AuthnFailed . Specific statues are optional in the spec and we can select to ignore them but it's very useful for debugging and important for interoperability.\n\nreturn all the info they need to send back to the SP (but that seems like it duplicates the other API)\n\nThat would require the caller of the API to be able to construct SAML Responses and I don't think we should expect that.\nBetween 2 and 3 I was leaning towards 3 and that we would handle that in the Transport action of the other API, so that we don't need to build additional logic in the UI/caller of the API. I'm ofcourse open to discuss this further", "author": "jkakavas", "createdAt": "2020-02-07T14:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjg4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376402888", "bodyText": "Shouldn't this reference sigAlg? or at least, should we validate & require that sigAlg is SHA256+RSA? (If we only want to support 1 algorithm).", "author": "tvernum", "createdAt": "2020-02-07T13:58:27Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.apache.logging.log4j.util.MessageSupplier;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public SamlValidateAuthnRequestResponse processQueryString(String queryString) {\n+        final List<String> parameterList = Arrays.asList(queryString.split(\"&\"));\n+        final Map<String, String> parameters = new HashMap<>();\n+        if (parameterList.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid Authentication Request query string\");\n+        }\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        // We either expect at least a single parameter named SAMLRequest or at least 3 ( SAMLRequest, SigAlg, Signature )\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        final String relayState = parameters.get(\"RelayState\");\n+        final String sigAlg = parameters.get(\"SigAlg\");\n+        final String signature = parameters.get(\"Signature\");\n+        if (null == samlRequest) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString));\n+        }\n+        AuthnRequest authnRequest = null;\n+        // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+        // verify if we know of this SP and get its credentials for signature verification\n+        final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+        if (\"AuthnRequest\".equals(root.getLocalName()) == false\n+            || \"urn:oasis:names:tc:SAML:2.0:protocol\".equals(root.getNamespaceURI()) == false) {\n+            logAndThrow(() -> new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.toString(root, true)));\n+        }\n+        try {\n+            authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+        } catch (Exception e) {\n+            logAndThrow(() -> new ParameterizedMessage(\"Cannot process AuthnRequest [{}]\", SamlUtils.toString(root, true)), e);\n+        }\n+        final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+        if (signature != null) {\n+            if (sigAlg == null) {\n+                logAndThrow(() ->\n+                    new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                        queryString));\n+            }\n+            final X509Credential spSigningCredential = sp.getSigningCredential();\n+            if (spSigningCredential == null) {\n+                logAndThrow(\n+                    \"Unable to validate signature of authentication request, Service Provider hasn't registered signing credentials\");\n+            }\n+            validateSignature(samlRequest, sigAlg, signature, sp.getSigningCredential(), relayState);\n+        }\n+        validateAuthnRequest(authnRequest, sp);\n+        Map<String, Object> additionalData = buildAdditionalData(authnRequest, sp);\n+        return new SamlValidateAuthnRequestResponse(sp.getEntityId(), authnRequest.isForceAuthn(), additionalData);\n+    }\n+\n+    private Map<String, Object> buildAdditionalData(AuthnRequest request, SamlServiceProvider sp) {\n+        Map<String, Object> data = new HashMap<>();\n+        final NameIDPolicy nameIDPolicy = request.getNameIDPolicy();\n+        if (null != nameIDPolicy) {\n+            final String requestedFormat = request.getNameIDPolicy().getFormat();\n+            if (Strings.hasText(requestedFormat)) {\n+                data.put(\"nameid_format\", requestedFormat);\n+                // we should not throw an error. Pass this as additional data so that the /saml/init API can\n+                // return a SAML response with the appropriate status (3.4.1.1 in the core spec)\n+                if (requestedFormat.equals(UNSPECIFIED) == false &&\n+                    requestedFormat.equals(sp.getNameIDPolicyFormat()) == false) {\n+                    logger.warn(() ->\n+                        new ParameterizedMessage(\"The requested NameID format [{}] doesn't match the allowed NameID format\" +\n+                            \"for this Service Provider is [{}]\", requestedFormat, sp.getNameIDPolicyFormat()));\n+                    data.put(\"error\", \"invalid_nameid_policy\");\n+                }\n+            }\n+        }\n+        return data;\n+    }\n+\n+    private void validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp) {\n+        checkDestination(authnRequest);\n+        checkAcs(authnRequest, sp);\n+    }\n+\n+    private void validateSignature(String samlRequest, String sigAlg, String signature, X509Credential credential,\n+                                   @Nullable String relayState) {\n+        try {\n+            final String queryParam = relayState == null ?\n+                \"SAMLRequest=\" + urlEncode(samlRequest) + \"&SigAlg=\" + urlEncode(sigAlg) :\n+                \"SAMLRequest=\" + urlEncode(samlRequest) + \"&RelayState=\" + urlEncode(relayState) + \"&SigAlg=\" + urlEncode(sigAlg);\n+            Signature sig = Signature.getInstance(\"SHA256withRSA\");", "originalCommit": "52583996b18c9fd1426610942e5571fc28ce62f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQyNDAxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r376424019", "bodyText": "\ud83e\udd26\u200d\u2642\ufe0f", "author": "jkakavas", "createdAt": "2020-02-07T14:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjg4OA=="}], "type": "inlineReview"}, {"oid": "9573ebdc06bbf51c8100c8fc82463a1250b8823e", "url": "https://github.com/elastic/elasticsearch/commit/9573ebdc06bbf51c8100c8fc82463a1250b8823e", "message": "address feedbacl and add Transport action tests", "committedDate": "2020-02-13T07:37:11Z", "type": "commit"}, {"oid": "f15cc9f5ccc6c8fe542a3706d9865913d4beb129", "url": "https://github.com/elastic/elasticsearch/commit/f15cc9f5ccc6c8fe542a3706d9865913d4beb129", "message": "Merge branch 'feature-internal-idp' into idp-sp-init-handlers", "committedDate": "2020-02-13T07:55:52Z", "type": "commit"}, {"oid": "eec55c1eca16ea62b0b1376bdc4a48900f656666", "url": "https://github.com/elastic/elasticsearch/commit/eec55c1eca16ea62b0b1376bdc4a48900f656666", "message": "Merge remote-tracking branch 'origin/feature-internal-idp' into idp-sp-init-handlers", "committedDate": "2020-02-18T08:04:39Z", "type": "commit"}, {"oid": "80b074540293413fe226b06f355d9bd5ff1a63ce", "url": "https://github.com/elastic/elasticsearch/commit/80b074540293413fe226b06f355d9bd5ff1a63ce", "message": "additions", "committedDate": "2020-02-18T08:13:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk2MjA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r381962096", "bodyText": "I think we probably want a Map.copyOf here.\nIf the provided Map is already immutable, then that's a (more or less) zero cost operation.", "author": "tvernum", "createdAt": "2020-02-20T12:14:10Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlValidateAuthnRequestResponse.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class SamlValidateAuthnRequestResponse extends ActionResponse {\n+\n+    private final String spEntityId;\n+    private final boolean forceAuthn;\n+    private final Map<String, Object> authnState;\n+\n+    public SamlValidateAuthnRequestResponse(StreamInput in) throws IOException {\n+        super(in);\n+        this.spEntityId = in.readString();\n+        this.forceAuthn = in.readBoolean();\n+        this.authnState = in.readMap();\n+    }\n+\n+    public SamlValidateAuthnRequestResponse(String spEntityId, boolean forceAuthn, Map<String, Object> authnState) {\n+        this.spEntityId = Objects.requireNonNull(spEntityId);\n+        this.forceAuthn = forceAuthn;\n+        this.authnState = Objects.requireNonNull(authnState);", "originalCommit": "80b074540293413fe226b06f355d9bd5ff1a63ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk2Mzk0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r381963943", "bodyText": "Can we add (empty string) or (zero parameters) or something like that to this message.\nFrom the code it will be clear, but it won't be obvious to the person reading the logs.", "author": "tvernum", "createdAt": "2020-02-20T12:18:21Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+        try {\n+            final Map<String, String> parameters = new HashMap<>();\n+            RestUtils.decodeQueryString(queryString, 0, parameters);\n+            if (parameters.isEmpty()) {\n+                logAndRespond(\"Invalid Authentication Request query string\", listener);", "originalCommit": "80b074540293413fe226b06f355d9bd5ff1a63ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk2NDI0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r381964247", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                            return;\n          \n          \n            \n                        }", "author": "tvernum", "createdAt": "2020-02-20T12:19:04Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+        try {\n+            final Map<String, String> parameters = new HashMap<>();\n+            RestUtils.decodeQueryString(queryString, 0, parameters);\n+            if (parameters.isEmpty()) {\n+                logAndRespond(\"Invalid Authentication Request query string\", listener);\n+            }", "originalCommit": "80b074540293413fe226b06f355d9bd5ff1a63ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk2NjU3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r381966579", "bodyText": "Should we log something? validateSignature throws an exception without logging it (e.g. if there's an invalid signature algorithm), but we don't log it here either.", "author": "tvernum", "createdAt": "2020-02-20T12:24:15Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+        try {\n+            final Map<String, String> parameters = new HashMap<>();\n+            RestUtils.decodeQueryString(queryString, 0, parameters);\n+            if (parameters.isEmpty()) {\n+                logAndRespond(\"Invalid Authentication Request query string\", listener);\n+            }\n+            logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+            final String samlRequest = parameters.get(\"SAMLRequest\");\n+            final String relayState = parameters.get(\"RelayState\");\n+            final String sigAlg = parameters.get(\"SigAlg\");\n+            final String signature = parameters.get(\"Signature\");\n+            if (null == samlRequest) {\n+                logAndRespond(new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString),\n+                    listener);\n+                return;\n+            }\n+            // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+            // verify if we know of this SP and get its credentials for signature verification\n+            final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+            if (SamlUtils.elementNameMatches(root, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\") == false) {\n+                logAndRespond(new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.text(root, 128)), listener);\n+                return;\n+            }\n+            final AuthnRequest authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+            final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+            // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n+            if (sp.shouldSignAuthnRequests()) {\n+                if (Strings.hasText(signature)) {\n+                    if (Strings.hasText(sigAlg) == false) {\n+                        logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                            queryString), listener);\n+                        return;\n+                    }\n+                    final X509Credential spSigningCredential = sp.getSigningCredential();\n+                    if (spSigningCredential == null) {\n+                        logAndRespond(\n+                            \"Unable to validate signature of authentication request, \" +\n+                                \"Service Provider hasn't registered signing credentials\",\n+                            listener);\n+                        return;\n+                    }\n+                    if (validateSignature(samlRequest, sigAlg, signature, sp.getSigningCredential(), relayState) == false) {\n+                        logAndRespond(\n+                            new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n+                            queryString, SamlUtils.describeCredentials(Collections.singletonList(sp.getSigningCredential()))), listener);\n+                        return;\n+                    }\n+                } else if (Strings.hasText(sigAlg)) {\n+                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n+                        queryString), listener);\n+                    return;\n+                } else {\n+                    logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n+                    return;\n+                }\n+            }\n+            validateAuthnRequest(authnRequest, sp);\n+            Map<String, Object> authnState = buildAuthnState(authnRequest, sp);\n+            final SamlValidateAuthnRequestResponse response = new SamlValidateAuthnRequestResponse(sp.getEntityId(),\n+                authnRequest.isForceAuthn(), authnState);\n+            logger.trace(new ParameterizedMessage(\"Validated AuthnResponse from queryString [{}] and extracted [{}]\",\n+                queryString, response));\n+            listener.onResponse(response);\n+        } catch (ElasticsearchSecurityException e) {\n+            listener.onFailure(e);", "originalCommit": "80b074540293413fe226b06f355d9bd5ff1a63ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAyODMzMA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r382028330", "bodyText": "Yes, I handled ESE here explicitly so that we don't wrap it in a new ESE in logAndRespond but forgot to log :/", "author": "jkakavas", "createdAt": "2020-02-20T14:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk2NjU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk2ODk5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r381968999", "bodyText": "Can we move this (\"redirect\") to a constant?", "author": "tvernum", "createdAt": "2020-02-20T12:29:41Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.saml.authn;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.core.internal.io.Streams;\n+import org.elasticsearch.rest.RestUtils;\n+import org.elasticsearch.xpack.idp.action.SamlValidateAuthnRequestResponse;\n+import org.elasticsearch.xpack.idp.saml.idp.SamlIdentityProvider;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProvider;\n+import org.elasticsearch.xpack.idp.saml.support.SamlUtils;\n+import org.opensaml.saml.saml2.core.AuthnRequest;\n+import org.opensaml.saml.saml2.core.Issuer;\n+import org.opensaml.saml.saml2.core.NameIDPolicy;\n+import org.opensaml.security.x509.X509Credential;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Signature;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import static org.opensaml.saml.saml2.core.NameIDType.UNSPECIFIED;\n+\n+\n+/*\n+ * Processes a SAML AuthnRequest, validates it and extracts necessary information\n+ */\n+public class SamlAuthnRequestValidator {\n+\n+    private final SamlIdentityProvider idp;\n+    private final Logger logger = LogManager.getLogger(SamlAuthnRequestValidator.class);\n+    private static final String[] XSD_FILES = new String[]{\"/org/elasticsearch/xpack/idp/saml/support/saml-schema-protocol-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/saml-schema-assertion-2.0.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xenc-schema.xsd\",\n+        \"/org/elasticsearch/xpack/idp/saml/support/xmldsig-core-schema.xsd\"};\n+\n+    private static final ThreadLocal<DocumentBuilder> THREAD_LOCAL_DOCUMENT_BUILDER = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SamlUtils.getHardenedBuilder(XSD_FILES);\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Could not load XSD schema file\", e);\n+        }\n+    });\n+\n+    public SamlAuthnRequestValidator(SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n+        this.idp = idp;\n+    }\n+\n+    public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+        try {\n+            final Map<String, String> parameters = new HashMap<>();\n+            RestUtils.decodeQueryString(queryString, 0, parameters);\n+            if (parameters.isEmpty()) {\n+                logAndRespond(\"Invalid Authentication Request query string\", listener);\n+            }\n+            logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+            final String samlRequest = parameters.get(\"SAMLRequest\");\n+            final String relayState = parameters.get(\"RelayState\");\n+            final String sigAlg = parameters.get(\"SigAlg\");\n+            final String signature = parameters.get(\"Signature\");\n+            if (null == samlRequest) {\n+                logAndRespond(new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString),\n+                    listener);\n+                return;\n+            }\n+            // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n+            // verify if we know of this SP and get its credentials for signature verification\n+            final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+            if (SamlUtils.elementNameMatches(root, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\") == false) {\n+                logAndRespond(new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", SamlUtils.text(root, 128)), listener);\n+                return;\n+            }\n+            final AuthnRequest authnRequest = SamlUtils.buildXmlObject(root, AuthnRequest.class);\n+            final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n+            // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n+            if (sp.shouldSignAuthnRequests()) {\n+                if (Strings.hasText(signature)) {\n+                    if (Strings.hasText(sigAlg) == false) {\n+                        logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                            queryString), listener);\n+                        return;\n+                    }\n+                    final X509Credential spSigningCredential = sp.getSigningCredential();\n+                    if (spSigningCredential == null) {\n+                        logAndRespond(\n+                            \"Unable to validate signature of authentication request, \" +\n+                                \"Service Provider hasn't registered signing credentials\",\n+                            listener);\n+                        return;\n+                    }\n+                    if (validateSignature(samlRequest, sigAlg, signature, sp.getSigningCredential(), relayState) == false) {\n+                        logAndRespond(\n+                            new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n+                            queryString, SamlUtils.describeCredentials(Collections.singletonList(sp.getSigningCredential()))), listener);\n+                        return;\n+                    }\n+                } else if (Strings.hasText(sigAlg)) {\n+                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n+                        queryString), listener);\n+                    return;\n+                } else {\n+                    logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n+                    return;\n+                }\n+            }\n+            validateAuthnRequest(authnRequest, sp);\n+            Map<String, Object> authnState = buildAuthnState(authnRequest, sp);\n+            final SamlValidateAuthnRequestResponse response = new SamlValidateAuthnRequestResponse(sp.getEntityId(),\n+                authnRequest.isForceAuthn(), authnState);\n+            logger.trace(new ParameterizedMessage(\"Validated AuthnResponse from queryString [{}] and extracted [{}]\",\n+                queryString, response));\n+            listener.onResponse(response);\n+        } catch (ElasticsearchSecurityException e) {\n+            listener.onFailure(e);\n+        } catch (Exception e) {\n+            logAndRespond(\"Could not process and validate AuthnRequest\", e, listener);\n+        }\n+    }\n+\n+    private Map<String, Object> buildAuthnState(AuthnRequest request, SamlServiceProvider sp) {\n+        Map<String, Object> authnState = new HashMap<>();\n+        final NameIDPolicy nameIDPolicy = request.getNameIDPolicy();\n+        if (null != nameIDPolicy) {\n+            final String requestedFormat = request.getNameIDPolicy().getFormat();\n+            if (Strings.hasText(requestedFormat)) {\n+                authnState.put(\"nameid_format\", requestedFormat);\n+                // we should not throw an error. Pass this as additional data so that the /saml/init API can\n+                // return a SAML response with the appropriate status (3.4.1.1 in the core spec)\n+                if (requestedFormat.equals(UNSPECIFIED) == false &&\n+                    requestedFormat.equals(sp.getNameIDPolicyFormat()) == false) {\n+                    logger.warn(() ->\n+                        new ParameterizedMessage(\"The requested NameID format [{}] doesn't match the allowed NameID format\" +\n+                            \"for this Service Provider is [{}]\", requestedFormat, sp.getNameIDPolicyFormat()));\n+                    authnState.put(\"error\", \"invalid_nameid_policy\");\n+                }\n+            }\n+        }\n+        return authnState;\n+    }\n+\n+    private void validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp) {\n+        checkDestination(authnRequest);\n+        checkAcs(authnRequest, sp);\n+    }\n+\n+    private boolean validateSignature(String samlRequest, String sigAlg, String signature, X509Credential credential,\n+                                      @Nullable String relayState) {\n+        try {\n+            final String queryParam = relayState == null ?\n+                \"SAMLRequest=\" + urlEncode(samlRequest) + \"&SigAlg=\" + urlEncode(sigAlg) :\n+                \"SAMLRequest=\" + urlEncode(samlRequest) + \"&RelayState=\" + urlEncode(relayState) + \"&SigAlg=\" + urlEncode(sigAlg);\n+            Signature sig = Signature.getInstance(getJavaAlorithmNameFromUri(sigAlg));\n+            sig.initVerify(credential.getEntityCertificate().getPublicKey());\n+            sig.update(queryParam.getBytes(StandardCharsets.UTF_8));\n+            return sig.verify(Base64.getDecoder().decode(signature));\n+        } catch (Exception e) {\n+            throw new ElasticsearchSecurityException(\"Unable to validate signature of authentication request using credentials [{}]\",\n+                SamlUtils.describeCredentials(Collections.singletonList(credential)), e);\n+        }\n+    }\n+\n+    private SamlServiceProvider getSpFromIssuer(Issuer issuer) {\n+        if (issuer == null || issuer.getValue() == null) {\n+            throw new ElasticsearchSecurityException(\"SAML authentication request has no issuer\");\n+        }\n+        final String issuerString = issuer.getValue();\n+        final SamlServiceProvider serviceProvider = idp.getRegisteredServiceProvider(issuerString);\n+        if (null == serviceProvider) {\n+            throw new ElasticsearchSecurityException(\"Service Provider with Entity ID [{}] is not registered with this Identity Provider\",\n+                issuerString);\n+        }\n+        return serviceProvider;\n+    }\n+\n+    private void checkDestination(AuthnRequest request) {\n+        final String url = idp.getSingleSignOnEndpoint(\"redirect\");", "originalCommit": "80b074540293413fe226b06f355d9bd5ff1a63ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzMjM2OA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r382032368", "bodyText": "Yes, I've already changed it in #52415 to use org.opensaml.saml.common.xml.SAMLConstants.SAML2_REDIRECT_BINDING_URI instead of simple strings, will adjust it here too", "author": "jkakavas", "createdAt": "2020-02-20T14:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk2ODk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk3NzYxOA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r381977618", "bodyText": "What's the reason for dropping the SamlFactory ?", "author": "tvernum", "createdAt": "2020-02-20T12:48:45Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SuccessfulAuthenticationResponseMessageBuilder.java", "diffHunk": "@@ -45,32 +49,33 @@\n  */\n public class SuccessfulAuthenticationResponseMessageBuilder {\n \n-    private final SamlFactory samlFactory;\n     private final Clock clock;\n     private final SamlIdentityProvider idp;\n+    private final XMLObjectBuilderFactory builderFactory;\n \n-    public SuccessfulAuthenticationResponseMessageBuilder(SamlFactory samlFactory, Clock clock, SamlIdentityProvider idp) {\n-        this.samlFactory = samlFactory;\n+    public SuccessfulAuthenticationResponseMessageBuilder(Clock clock, SamlIdentityProvider idp) {\n+        SamlUtils.initialize();\n         this.clock = clock;\n         this.idp = idp;\n+        this.builderFactory = XMLObjectProviderRegistrySupport.getBuilderFactory();", "originalCommit": "80b074540293413fe226b06f355d9bd5ff1a63ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzNzA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r382037064", "bodyText": "I thought that SamlUtils covers the functionality and purpose so there was no reason to have both and I moved relevant parts from SamlFactory to SamlUtils ( this is more or less what we do in the saml realm implementation ).\nIf you feel that we should split somehow ( Instance with initialization for loggers in Factory and all static methods in Utils for instance ) I'm happy to discuss or just do it. I have no strong preference", "author": "jkakavas", "createdAt": "2020-02-20T14:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk3NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzOTI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r382339270", "bodyText": "I found SamlUtils in security to have been a bit overloaded, and was hoping to avoid replicating it here. I'm not stuck on it, I just have an aversion to catch-all utility classes.", "author": "tvernum", "createdAt": "2020-02-21T00:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk3NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1MDk3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r382450974", "bodyText": "Thinking this through again and seeing that I've made all methods in SamlUtils static already, I'm not sure what distinction would make sense. As in what should be in Utils and what should be in the Factory class. At 300 loc, SamlUtils doesn't seem too bloated atm.\nI'm open to suggestions on what should be split away and back to a Factory class, or we could merge as is and spit these somehow once/if SamlUtils gets too bloated/overloaded", "author": "jkakavas", "createdAt": "2020-02-21T08:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk3NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2MzcwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r383063709", "bodyText": "This is definitely a personal preference thing, so I'm OK with merging as-is (though, in terms of preferences, I preferred the existing code).\nIssues with Utility classes:\n\nThey become a catch-all dumping ground that becomes a cheap answer when something is needed, and avoids doing the harder design thinking. A good chunk of Utility class methods are working around broken class design that ideally would be fixed up front (but sometimes you have to because the broken class is in the JDK).\nRelated to the above, they often end up with a weird mix of responsibilities/behaviours. Because they're just chunks of code that \"do something, that someone thought was useful\", they typically don't go through the process of Is this the right behaviour for this method?.\nRelated to that, they can be hard to test well, unless they've got a clear interface & a single purpose (those are the best kind of utility method).\nMore importantly, it becomes hard to test code the uses utility methods. They can't be mocked (because they're static), and it's often hard to trigger some of the behaviours that you need. As an example, while writing tests for SSL error messages, it was almost impossible to force PemUtils to throw certain exceptions so that I could verify they were handled neatly.\nIt can be hard to find the right method, because of the dumping ground problem. Ever tried to find the right helper method in amongst XContentUtils, XContentParserUtils, XContentHelper, XContentTestUtils ?\n\nNow, you're probably thinking Wait, SamlUtils and SamlFactory makes problem 5 worse. And that's true, but SamlInit and SamlFactory were clear. It's when we decide to take the easy option and just have a Utils class that we lose clarity about what we each class is supposed to do.\nHowever, as I said, personal preference. This definitely isn't a hill I'd die on. But those are the sorts of reasons why I tried to start with SamlInit and SamlFactory for this project.", "author": "tvernum", "createdAt": "2020-02-24T01:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk3NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA5NDYwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r383094603", "bodyText": "No need for anyone to die on this hill :) Given we've put in the time to climb it already though, I'll try and come up with something that you feel better with. I'll put the initialization logic in SamlInit to we can call initialize() on it and then move things back to a SamlFactory class which we can instantiate and call methods on.", "author": "jkakavas", "createdAt": "2020-02-24T05:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk3NzYxOA=="}], "type": "inlineReview"}, {"oid": "76c45efb32f18a78b4e92bf6d26dfa003d7d7224", "url": "https://github.com/elastic/elasticsearch/commit/76c45efb32f18a78b4e92bf6d26dfa003d7d7224", "message": "address feedback", "committedDate": "2020-02-20T15:37:19Z", "type": "commit"}, {"oid": "16826b2f39b30a1311beed3303a87c103ecc032b", "url": "https://github.com/elastic/elasticsearch/commit/16826b2f39b30a1311beed3303a87c103ecc032b", "message": "Merge remote-tracking branch 'origin/feature-internal-idp' into idp-sp-init-handlers", "committedDate": "2020-02-20T16:44:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2Mzk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r383063991", "bodyText": "Putting aside the SamlUtils vs SamlFactory question, why move these methods here?\nSurely we'll need them again when handling logout requests/response & authn failures.", "author": "tvernum", "createdAt": "2020-02-24T01:59:57Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SuccessfulAuthenticationResponseMessageBuilder.java", "diffHunk": "@@ -184,31 +189,50 @@ private Attribute buildAttribute(String formalName, String friendlyName, Collect\n         if (values.isEmpty()) {\n             return null;\n         }\n-        final Attribute attribute = samlFactory.object(Attribute.class, Attribute.DEFAULT_ELEMENT_NAME);\n+        final Attribute attribute = object(Attribute.class, Attribute.DEFAULT_ELEMENT_NAME);\n         attribute.setName(formalName);\n         attribute.setFriendlyName(friendlyName);\n         attribute.setNameFormat(Attribute.URI_REFERENCE);\n         for (String val : values) {\n-            final XSString string = samlFactory.object(XSString.class, AttributeValue.DEFAULT_ELEMENT_NAME, XSString.TYPE_NAME);\n+            final XSString string = object(XSString.class, AttributeValue.DEFAULT_ELEMENT_NAME, XSString.TYPE_NAME);\n             string.setValue(val);\n             attribute.getAttributeValues().add(string);\n         }\n         return attribute;\n     }\n \n     private Issuer buildIssuer() {\n-        final Issuer issuer = samlFactory.object(Issuer.class, Issuer.DEFAULT_ELEMENT_NAME);\n+        final Issuer issuer = object(Issuer.class, Issuer.DEFAULT_ELEMENT_NAME);\n         issuer.setValue(this.idp.getEntityId());\n         return issuer;\n     }\n \n     private Status buildStatus() {\n-        final StatusCode code = samlFactory.object(StatusCode.class, StatusCode.DEFAULT_ELEMENT_NAME);\n+        final StatusCode code = object(StatusCode.class, StatusCode.DEFAULT_ELEMENT_NAME);\n         code.setValue(StatusCode.SUCCESS);\n \n-        final Status status = samlFactory.object(Status.class, Status.DEFAULT_ELEMENT_NAME);\n+        final Status status = object(Status.class, Status.DEFAULT_ELEMENT_NAME);\n         status.setStatusCode(code);\n \n         return status;\n     }\n+\n+    public <T extends XMLObject> T object(Class<T> type, QName elementName) {\n+        final XMLObject obj = builderFactory.getBuilder(elementName).buildObject(elementName);\n+        return cast(type, elementName, obj);\n+    }", "originalCommit": "16826b2f39b30a1311beed3303a87c103ecc032b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2NTU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r383065599", "bodyText": "I still feel like this should be a URI. It is a URI and I think we should consistently treat it like one.", "author": "tvernum", "createdAt": "2020-02-24T02:14:23Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/CloudServiceProvider.java", "diffHunk": "@@ -6,30 +6,40 @@\n \n package org.elasticsearch.xpack.idp.saml.sp;\n \n+import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.xpack.idp.privileges.ServiceProviderPrivileges;\n import org.joda.time.Duration;\n import org.joda.time.ReadableDuration;\n+import org.opensaml.security.x509.X509Credential;\n \n-import java.net.URI;\n-import java.net.URISyntaxException;\n \n public class CloudServiceProvider implements SamlServiceProvider {\n \n     private final String entityid;\n-    private final URI assertionConsumerService;\n+    private final String assertionConsumerService;\n     private final ReadableDuration authnExpiry;\n+    private final String nameIdPolicyFormat;\n+    private final X509Credential signingCredential;\n+    private final ServiceProviderPrivileges privileges;\n+    private final boolean signAuthnRequests;\n+    private final boolean signLogoutRequests;\n \n-    public CloudServiceProvider(String entityId, String assertionConsumerService) {\n+    public CloudServiceProvider(String entityId, String assertionConsumerService, String nameIdPolicyFormat,\n+                                ServiceProviderPrivileges privileges, boolean signAuthnRequests, boolean signLogoutRequests,\n+                                @Nullable X509Credential signingCredential) {\n         if (Strings.isNullOrEmpty(entityId)) {\n             throw new IllegalArgumentException(\"Service Provider Entity ID cannot be null or empty\");\n         }\n         this.entityid = entityId;\n-        try {\n-            this.assertionConsumerService = new URI(assertionConsumerService);\n-        } catch (URISyntaxException e) {\n-            throw new IllegalArgumentException(\"Invalid URI for Assertion Consumer Service\", e);\n-        }\n+        this.assertionConsumerService = assertionConsumerService;", "originalCommit": "16826b2f39b30a1311beed3303a87c103ecc032b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI5NDc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r383294753", "bodyText": "I don't necessarily agree that this is important.\nI reverted the change as you requested. There is value in validating that it is a URL (it's a URI but we should not be validating for a URI, as it can't be a URN ) and we will be doing this in the Registration API , no harm in doing it here too. Again, I think that for all intents and purposes when it comes to SAML, handling this as a URL in code - after validation - is unnecessary and it can potentially  introduce subtle bugs.\nFor instance we need to take care so that when comparing ACS values , we are comparing string representations of the URLs and i.e. not URL.equals which does something different.\nI didn't change the IDP configuration settings to be Setting<URL> too because of the arguments here, the fact that we already validate them and finally that we have no good existing way to parse and handle Setting<URL> with optional values in a way that makes sense to me ( I can further elaborate if needed )", "author": "jkakavas", "createdAt": "2020-02-24T14:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2NTU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzMzE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r384133145", "bodyText": "I'm moving these to Setting in the IDP metadata PR", "author": "jkakavas", "createdAt": "2020-02-25T21:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2NTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2NTY1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52018#discussion_r383065652", "bodyText": "Can we make this a Set since we've done that with the index?", "author": "tvernum", "createdAt": "2020-02-24T02:15:03Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/CloudServiceProvider.java", "diffHunk": "@@ -38,7 +48,12 @@ public String getEntityId() {\n     }\n \n     @Override\n-    public URI getAssertionConsumerService() {\n+    public String getNameIDPolicyFormat() {\n+        return nameIdPolicyFormat;", "originalCommit": "16826b2f39b30a1311beed3303a87c103ecc032b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e3d379d73e73b9b74a9875b3298d854fd2c2299e", "url": "https://github.com/elastic/elasticsearch/commit/e3d379d73e73b9b74a9875b3298d854fd2c2299e", "message": "Split Utils to Factory and Init, treat URLs as URLs", "committedDate": "2020-02-24T14:05:56Z", "type": "commit"}, {"oid": "03eba44834bca6b6b56e725a4c52c1ebe55156e5", "url": "https://github.com/elastic/elasticsearch/commit/03eba44834bca6b6b56e725a4c52c1ebe55156e5", "message": "Merge remote-tracking branch 'origin/feature-internal-idp' into idp-sp-init-handlers", "committedDate": "2020-02-24T14:34:30Z", "type": "commit"}, {"oid": "eef3dd60f0f93aac4ebf5cd57dc5ed04a44def5e", "url": "https://github.com/elastic/elasticsearch/commit/eef3dd60f0f93aac4ebf5cd57dc5ed04a44def5e", "message": "Support multiple allowed NameID formats per SP", "committedDate": "2020-02-25T11:26:53Z", "type": "commit"}]}