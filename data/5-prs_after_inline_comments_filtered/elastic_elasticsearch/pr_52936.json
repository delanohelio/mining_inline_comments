{"pr_number": 52936, "pr_title": "Add REST endpoint to register a new SAML SP", "pr_createdAt": "2020-02-28T05:49:49Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52936", "timeline": [{"oid": "00012579b70493b849fba0db6a09b98bedbff662", "url": "https://github.com/elastic/elasticsearch/commit/00012579b70493b849fba0db6a09b98bedbff662", "message": "Add REST endpoint to register a new SAML SP\n\nThis change adds a new PUT /_idp/saml/sp/{entity_id} endpoint that\nregisters (or updates) a Service Provider in the IDP.", "committedDate": "2020-02-28T05:48:35Z", "type": "commit"}, {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "url": "https://github.com/elastic/elasticsearch/commit/aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "message": "Merge branch 'feature-internal-idp' into idp/sp-registration", "committedDate": "2020-02-28T06:09:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNDIyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385604223", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);\n          \n          \n            \n                                    \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be an [https] URL\", validationException);", "author": "jkakavas", "createdAt": "2020-02-28T09:58:19Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        final ValidationException docException = document.validate();\n+        ActionRequestValidationException validationException = null;\n+        if (docException != null) {\n+            validationException = new ActionRequestValidationException();\n+            validationException.addValidationErrors(docException.validationErrors());\n+        }\n+\n+        if (Strings.hasText(document.acs)) { // if this is blank the document validation will fail\n+            try {\n+                final URL url = new URL(document.acs);\n+                if (url.getProtocol().equals(\"https\") == false) {\n+                    validationException = addValidationError(\n+                        \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDI0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385660247", "bodyText": "Given that we do not have a consensus on which component of the IDP will be generating the IDP signing certificates and the fact that the caller of this API will in principal be only an IDP administrator, why do we disallow this up front ?", "author": "jkakavas", "createdAt": "2020-02-28T12:05:55Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        final ValidationException docException = document.validate();\n+        ActionRequestValidationException validationException = null;\n+        if (docException != null) {\n+            validationException = new ActionRequestValidationException();\n+            validationException.addValidationErrors(docException.validationErrors());\n+        }\n+\n+        if (Strings.hasText(document.acs)) { // if this is blank the document validation will fail\n+            try {\n+                final URL url = new URL(document.acs);\n+                if (url.getProtocol().equals(\"https\") == false) {\n+                    validationException = addValidationError(\n+                        \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);\n+                }\n+            } catch (MalformedURLException e) {\n+                String error = \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a valid URL\";\n+                if (e.getMessage() != null) {\n+                    error += \" - \" + e.getMessage();\n+                }\n+                validationException = addValidationError(error, validationException);\n+            }\n+        }\n+\n+        if (document.certificates.identityProviderSigning.isEmpty() == false) {", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2MDc1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386160751", "bodyText": "Because we have no other way to validate that correct data is sent here.\nI could accept it but enforce that it can only be the same certificate that is configured for the IDP, but that seems worse to me. I'm happy to discuss that option if you prefer it, but to my thinking \"you can provide this field, but only with this value that is pre-configured in the YML and you don't have access to\" is a pretty weird API.\nAnd it forces us to continue to support that field in the API even if we decide that we want a different approach (like implicit generation of signing certs) down the track.\nI can't accept any other certificates, because we wont have the keys for them, so it would be allowing the creation of a broken SP.\nActually my preference would be for this field to go away entirely, because we don't know how to support it yet, and I feel like I made the wrong choice by supporting it in the index document before we really know how it will be handled. But I took the less invasive approach and just decided that we don't support it for SP registration yet.", "author": "tvernum", "createdAt": "2020-03-02T00:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNzQxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386817411", "bodyText": "What I was thinking about wouldn't need to do validation, but it would need the private keys to be passed in the API request and stored somewhere and we don't have this yet.\nThis is the second time I make a similar comment without taking the private keys into consideration \ud83e\udd26\u200d\u2642\ufe0f .\nGiven that we will not store these in the same index ever ,I'm ok with leaving this as is here - if we were writing this now from scratch I'd remove this altogether as you say and handle it only as yml settings until we have a better story for per SP signing credentials", "author": "jkakavas", "createdAt": "2020-03-03T06:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTQwNw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385661407", "bodyText": "nit: use getPreferredName() for consistency. Or. given that toString() actually calls  getPreferredName() maybe remove the getPreferredName() from other places i.e. like SamlServiceProviderDocument#validate ?", "author": "jkakavas", "createdAt": "2020-02-28T12:09:07Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        final ValidationException docException = document.validate();\n+        ActionRequestValidationException validationException = null;\n+        if (docException != null) {\n+            validationException = new ActionRequestValidationException();\n+            validationException.addValidationErrors(docException.validationErrors());\n+        }\n+\n+        if (Strings.hasText(document.acs)) { // if this is blank the document validation will fail\n+            try {\n+                final URL url = new URL(document.acs);\n+                if (url.getProtocol().equals(\"https\") == false) {\n+                    validationException = addValidationError(\n+                        \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2MTEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386161103", "bodyText": "The API for ParseField annoys me. Actually the API for ToXContentBuilder annoys me because it doesn't support ParseField for field names (or any interface that ParseField could implement), so we have to use getPreferredName there.\nBut overall I prefer not having to call getPreferredName and just treat the object as the field.\nI can fix the other other uses.", "author": "tvernum", "createdAt": "2020-03-02T01:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNjI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386816296", "bodyText": "SGTM", "author": "jkakavas", "createdAt": "2020-03-03T06:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MzMwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385663301", "bodyText": "it reads slightly strange that we split the validation in 3 parts ( PutSamlServiceProviderRequest#fromXContent, PutSamlServiceProviderRequest#validate and SamlServiceProviderDocument#validate ) but the semantics of the validation in each step and the fact that we reuse SamlServiceProviderDocument#fromXContent  probably leaves no other choice.  Could maybe a fromSource and fromRequest split where both call fromXContent but do different validation depending on the context make this clearer ? Just a thought", "author": "jkakavas", "createdAt": "2020-02-28T12:14:11Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2NDYxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386164610", "bodyText": "The fromXContent split was my first consideration as well, but it's hard to do nicely with ObjectParser. It's possible, but none of the options felt like they were an overall improvement.\nWe can pass a \"mode\" (probably just Boolean) as the \"context\" to a parser, but we already use the context, so we'd need to pass some sort of tuple of SamlServiceProviderDocument and Boolean.\nOr (and this was my preferred option) we could have 2 parsers, one of which registers the right fields for the Document and another registers the fields for the Request.\nThat's not too bad, but it kind of pushes the validation logic into the parser building (indirectly) so the logic is still split & it's harder to follow (because you need to understand that there are 2 parsers with different fields to enforce that the request doesn't permit certain fields from being set).\nTo be honest, we always do some validation during XContent parsing. At the very least it's enforcing field names/types, but often it's more than that. This code does that more obviously than most, so it feels extra strange.\nTo my thinking, the root of the issue is that the Request lifecycle expects validation to happen separately to parsing, and that can be an artificial separation. It's a by-product of transport client (because you could have Requests that didn't come from XContent), but it's sometimes a weird fit.\nI could approach this differently, and embrace that separation - which would mean if a field is not supposed to be set on the request, it should be null during validate. That is, don't treat it as a parsing issue, but as a request issue.\nThen I'd need to add some conditional logic in doc.validate() (or maybe duplicate the logic into the request) so that fields which are supposed to be null in the request but cannot be null in the index are validated correctly.\nI think that would work, but it has the slightly weird behaviour that we accept certain fields during parsing that really shouldn't be part of the API (but would be validated when the request is processed).", "author": "tvernum", "createdAt": "2020-03-02T01:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MzMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2NDc1MA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386164750", "bodyText": "Let's chat. I think we can do better than what I've put here, but it might be worth making it a new PR so that we can debate possible options.", "author": "tvernum", "createdAt": "2020-03-02T01:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MzMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMDUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r387600525", "bodyText": "We discussed this, and I will raise a separate PR for it so that we can move forward with this change, and then iterate on that.", "author": "tvernum", "createdAt": "2020-03-04T11:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NDcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385664727", "bodyText": "Make these private final and add getters ?", "author": "jkakavas", "createdAt": "2020-02-28T12:17:58Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderResponse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class PutSamlServiceProviderResponse extends ActionResponse implements ToXContentObject {\n+\n+    public String docId;", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4NzM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385687350", "bodyText": "\ud83d\udc4d", "author": "jkakavas", "createdAt": "2020-02-28T13:12:40Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {\n+            if (matchingDocuments.isEmpty()) {\n+                // derive a document id from the entity id so that don't accidentally create duplicate entities due to a race condition\n+                document.docId = deriveDocumentId(document);\n+                // force a create in case there are concurrent requests\n+                writeDocument(document, DocWriteRequest.OpType.CREATE, listener);\n+            } else if (matchingDocuments.size() == 1) {\n+                SamlServiceProviderDocument existingDoc = Iterables.get(matchingDocuments, 0);\n+                assert existingDoc.docId != null : \"Loaded document with no doc id\";\n+                assert existingDoc.entityId.equals(document.entityId) : \"Loaded document with non-matching entity-id\";\n+                document.setDocId(existingDoc.docId);\n+                document.setCreated(existingDoc.created);\n+                writeDocument(document, DocWriteRequest.OpType.INDEX, listener);\n+            } else {\n+                logger.warn(\"Found multiple existing service providers in [{}] with entity id [{}] - [{}]\",\n+                    index, document.entityId, matchingDocuments.stream().map(d -> d.docId).collect(Collectors.joining(\",\")));\n+                listener.onFailure(new IllegalStateException(\n+                    \"Multiple service providers already exist with entity id [\" + document.entityId + \"]\"));\n+            }\n+        }, listener::onFailure));\n+    }\n+\n+    private void writeDocument(SamlServiceProviderDocument document, DocWriteRequest.OpType opType,\n+                               ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final Instant now = clock.instant();\n+        if (document.created == null || opType == DocWriteRequest.OpType.CREATE) {\n+            document.created = now;\n+        }\n+        document.lastModified = now;\n+        final ValidationException validationException = document.validate();\n+        if (validationException != null) {\n+            listener.onFailure(validationException);\n+            return;\n+        }\n+        logger.debug(\"[{}] service provider [{}] in document [{}] of [{}]\", opType, document.entityId, document.docId, index);\n+        index.writeDocument(document, opType, ActionListener.wrap(\n+            response -> listener.onResponse(new PutSamlServiceProviderResponse(\n+                response.getId(),\n+                response.getResult() == DocWriteResponse.Result.CREATED,\n+                response.getSeqNo(),\n+                response.getPrimaryTerm(),\n+                document.entityId,\n+                document.enabled)),\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private String deriveDocumentId(SamlServiceProviderDocument document) {\n+        final byte[] sha256 = MessageDigests.sha256().digest(document.entityId.getBytes(StandardCharsets.UTF_8));\n+        return Base64.getUrlEncoder().withoutPadding().encodeToString(sha256);", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4OTMzNA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385689334", "bodyText": "we could export document.entityId in a local var here and call deriveDocumentId with that too below as this is the only field we use from the document", "author": "jkakavas", "createdAt": "2020-02-28T13:17:27Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2NTAzOA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386165038", "bodyText": "Sorry, I don't follow. I think you're implying that if I set the entityId into a local that will allow me to achieve something else that's benefitial, but I'm not sure what that something else is.", "author": "tvernum", "createdAt": "2020-03-02T01:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4OTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxOTQ2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386819469", "bodyText": "yeah that was badly written. I actually mixed up document.entityId and document.docId` here and my thinking was that since you :\n\nuse document.entityId a few times already and\nyou pass document in deriveDocumentId() but only use the docId in there\n\nDo a\nfinal String someName = document.entityId ;\nand use someName instead of document.entityId in all cases below and to pass to deriveDocumentId\nIt was a nit, I thought it reads better (in a similar manner to #52886 (review)) , feel free to disregard if you don't agree that it does - I really do not hold strong opinions over these.", "author": "jkakavas", "createdAt": "2020-03-03T06:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4OTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMjEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r387602131", "bodyText": "I personally perfer not assigning it to a local because I find it easier to read the code if it's clear that a particular value always comes from the object.\nThat is, I see document.entityId and, so long as I know what document is, I know that we're talking about the entityId of the document.\nHowever, if I assigned it to docEntityId I'm left wondering why it's a local and if it's assigned from multiple places, etc, and need to navigate to where it's assigned to work out what it really is.\nBut I'm very interested in why you find the reverse to be true. But perhaps that's a conversation for another time.", "author": "tvernum", "createdAt": "2020-03-04T11:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4OTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MDk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385690963", "bodyText": "Question : Why is this a check we fail specifically upon as opposed to just an assertion like the null Id or entityIds not matching ? Isn't this equally improbable ?", "author": "jkakavas", "createdAt": "2020-02-28T13:20:57Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {\n+            if (matchingDocuments.isEmpty()) {\n+                // derive a document id from the entity id so that don't accidentally create duplicate entities due to a race condition\n+                document.docId = deriveDocumentId(document);\n+                // force a create in case there are concurrent requests\n+                writeDocument(document, DocWriteRequest.OpType.CREATE, listener);\n+            } else if (matchingDocuments.size() == 1) {\n+                SamlServiceProviderDocument existingDoc = Iterables.get(matchingDocuments, 0);\n+                assert existingDoc.docId != null : \"Loaded document with no doc id\";\n+                assert existingDoc.entityId.equals(document.entityId) : \"Loaded document with non-matching entity-id\";\n+                document.setDocId(existingDoc.docId);\n+                document.setCreated(existingDoc.created);\n+                writeDocument(document, DocWriteRequest.OpType.INDEX, listener);\n+            } else {", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2NzI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386167255", "bodyText": "No, I don't think it's equally improbable.\nThe other assert checks are supposed to be guaranteed by the index contract. You can't get a doc without an ID from an index, it's impossible unless either:\n\nThe SamlServiceProviderIndex is horribly broken (unlikely)\nIt's a test with bogus data (much more likely).\n\nSimilarly for the entityId since the method returns matching docs, it can only represent a completely broken Index class, or badly set up mock data.\nHowever, this case is a more realistic scenario that represents some failure to correctly write documents to the index (I don't see how it would happen, but I'm not perfectly confident that we couldn't have such bugs, now or in the future), or it's the result of manual updates of the index (which someone might do, even though they shouldn't).\nWhat should we do in such a case? Since assertions are off in production, if we rely exclusively on assert statements, we have no checks in production, so we could either:\n\nTreat it like a single element result, and just operate on the first doc. That's not completely terrible, but it's defintely not good. I'd much rather we fail and make the admin fix the broken data\nUpdate all the matching docs, which seems even worse.\nDo nothing, which is clearly much worse.", "author": "tvernum", "createdAt": "2020-03-02T01:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MDk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxOTgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386819831", "bodyText": "Thanks for going through your reasoning, makes sense to me too", "author": "jkakavas", "createdAt": "2020-03-03T06:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MDk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTIxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385691213", "bodyText": "Can you elaborate on this comment?", "author": "jkakavas", "createdAt": "2020-02-28T13:21:24Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {\n+            if (matchingDocuments.isEmpty()) {\n+                // derive a document id from the entity id so that don't accidentally create duplicate entities due to a race condition\n+                document.docId = deriveDocumentId(document);\n+                // force a create in case there are concurrent requests", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2NjA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386166047", "bodyText": "If two threads (or 2 nodes) are trying to create the same SP at the same time, then it's possible for them both to write to the index. That is - it's possible for two threads to be in this block simultaneously.\nThis path assumes that the doc doesn't exist. For now that assumption is weak - all it means is that the creation time is lost. But in the future it might mean more - e.g. If we automatically generate IDP signing credentials on first registration, then have 2 threads thinking they're creating a new SP would do the wrong thing.\nIf we're in a block that is based on the premise that we are creating the SP for the first time, letting the index enforce that seems helpful.\nI could also do the same on the 2nd block - enforce the seqNo/primTerm so that we're only overwriting the doc we expect to. I haven't, but maybe I should?\nThere's also the theoretical risk of a SHA256 collision. While highly unlikely, it would be an almost impossible issue to diagnose and debug if it did happen. If we do a INDEX here, it's possible to overwrite a doc with a matching hash (doc-id) but different entity-id. This way it will fail instead, which is not great, but better than silently overwriting data.", "author": "tvernum", "createdAt": "2020-03-02T01:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDQzNg==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386820436", "bodyText": "Makes sense, the\n\nThis way it will fail instead, which is not great, but better than silently overwriting data.\n\npart is the reasoning I was missing for\n\n             // force a create in case there are concurrent requests \n\n\nall clear now", "author": "jkakavas", "createdAt": "2020-03-03T06:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk4MDcxOA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386980718", "bodyText": "I'll update the code comment, to make the \"fail\" rather than silently overwrite bit explicit.", "author": "tvernum", "createdAt": "2020-03-03T12:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5Mzc3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385693771", "bodyText": "You either rename this to sp_entity_id or we rename the parameter in the get metadata API to entity_id, for consistency", "author": "jkakavas", "createdAt": "2020-02-28T13:26:43Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/rest/action/RestPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.rest.action;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestRequest.Method;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestBuilderListener;\n+import org.elasticsearch.xpack.idp.action.PutSamlServiceProviderAction;\n+import org.elasticsearch.xpack.idp.action.PutSamlServiceProviderRequest;\n+import org.elasticsearch.xpack.idp.action.PutSamlServiceProviderResponse;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class RestPutSamlServiceProviderAction extends BaseRestHandler {\n+\n+    @Override\n+    public String getName() {\n+        return \"idp_put_saml_sp_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(Method.PUT, \"/_idp/saml/sp/{entity_id}\"),\n+            new Route(Method.POST, \"/_idp/saml/sp/{entity_id}\")\n+        );\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest restRequest, NodeClient client) throws IOException {\n+        final String entityId = restRequest.param(\"entity_id\");", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2ODQ3MA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386168470", "bodyText": "I can rename this, but I don't feel it's truly necessary.\nThe fact that this is a SP entity id is obvious from the URL, that's not true for the metadata API where there could be some confusion since it's an API that is seemingly related to the IdP, but needs to know the SP's id.", "author": "tvernum", "createdAt": "2020-03-02T01:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5Mzc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386820991", "bodyText": "I still think it makes sense to keep the same parameter name for the same thing in those closely related APIs", "author": "jkakavas", "createdAt": "2020-03-03T06:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5Mzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NTM1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385695353", "bodyText": "Good chance to create StreamOutput#writeOptionalVLong ,StreamInput#readOptionalVLong this could be used in ~15 places in our codebase", "author": "jkakavas", "createdAt": "2020-02-28T13:30:13Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -247,6 +250,68 @@ public int hashCode() {\n     public final AttributeNames attributeNames = new AttributeNames();\n     public final Certificates certificates = new Certificates();\n \n+    public SamlServiceProviderDocument() {\n+    }\n+\n+    public SamlServiceProviderDocument(StreamInput in) throws IOException {\n+        docId = in.readOptionalString();\n+        name = in.readString();\n+        entityId = in.readString();\n+        acs = in.readString();\n+        enabled = in.readBoolean();\n+        created = in.readInstant();\n+        lastModified = in.readInstant();\n+        nameIdFormats = in.readSet(StreamInput::readString);\n+        authenticationExpiryMillis = in.readBoolean() ? in.readVLong() : null;\n+\n+        privileges.application = in.readOptionalString();\n+        privileges.resource = in.readString();\n+        privileges.loginAction = in.readOptionalString();\n+        privileges.groupActions = in.readMap(StreamInput::readString, StreamInput::readString);\n+\n+        attributeNames.principal = in.readString();\n+        attributeNames.email = in.readOptionalString();\n+        attributeNames.name = in.readOptionalString();\n+        attributeNames.groups = in.readOptionalString();\n+\n+        certificates.serviceProviderSigning = in.readStringList();\n+        certificates.identityProviderSigning = in.readStringList();\n+        certificates.identityProviderMetadataSigning = in.readStringList();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeOptionalString(docId);\n+        out.writeString(name);\n+        out.writeString(entityId);\n+        out.writeString(acs);\n+        out.writeBoolean(enabled);\n+        out.writeInstant(created);\n+        out.writeInstant(lastModified);\n+        out.writeCollection(nameIdFormats, StreamOutput::writeString);\n+        if (authenticationExpiryMillis == null) {", "originalCommit": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2ODY4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386168682", "bodyText": "Do you mind if I do it in a separate PR? I'm worried about adding it on a feature branch and it being harder to merge down the track.\nI'd prefer to just raise it against master directly.", "author": "tvernum", "createdAt": "2020-03-02T01:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMTA0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r386821043", "bodyText": "sure thing", "author": "jkakavas", "createdAt": "2020-03-03T06:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyNTA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r388025098", "bodyText": "#53145", "author": "tvernum", "createdAt": "2020-03-05T01:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NTM1Mw=="}], "type": "inlineReview"}, {"oid": "b012d29ae51369ed3de5be4a3e957fc125949acf", "url": "https://github.com/elastic/elasticsearch/commit/b012d29ae51369ed3de5be4a3e957fc125949acf", "message": "Merge branch 'feature-internal-idp' into idp/sp-registration\n\n# Conflicts:\n#\tx-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/IdentityProviderPlugin.java", "committedDate": "2020-03-02T03:18:43Z", "type": "commit"}, {"oid": "7d62ef488316b5ecccd60bbe16bc145ca7f3fe0c", "url": "https://github.com/elastic/elasticsearch/commit/7d62ef488316b5ecccd60bbe16bc145ca7f3fe0c", "message": "Address feedback", "committedDate": "2020-03-02T03:23:07Z", "type": "commit"}, {"oid": "3d57ca5f9a4a10c0d4aac9c217ac3033c85b5f70", "url": "https://github.com/elastic/elasticsearch/commit/3d57ca5f9a4a10c0d4aac9c217ac3033c85b5f70", "message": "Merge branch 'idp/sp-registration' of github.com:tvernum/elasticsearch into idp/sp-registration", "committedDate": "2020-03-02T03:24:00Z", "type": "commit"}, {"oid": "b7dc2663f731b7748a7cd302e10669e8c637cffc", "url": "https://github.com/elastic/elasticsearch/commit/b7dc2663f731b7748a7cd302e10669e8c637cffc", "message": "Fix test compilation", "committedDate": "2020-03-02T04:46:37Z", "type": "commit"}, {"oid": "0a955b5d3141b15028ff5496340cf59d3fe4b7c6", "url": "https://github.com/elastic/elasticsearch/commit/0a955b5d3141b15028ff5496340cf59d3fe4b7c6", "message": "Update comment", "committedDate": "2020-03-04T11:20:26Z", "type": "commit"}, {"oid": "01705397bf06f28dad0342e4b34939700d897f35", "url": "https://github.com/elastic/elasticsearch/commit/01705397bf06f28dad0342e4b34939700d897f35", "message": "Merge branch 'feature-internal-idp' into idp/sp-registration", "committedDate": "2020-03-05T00:18:06Z", "type": "commit"}]}