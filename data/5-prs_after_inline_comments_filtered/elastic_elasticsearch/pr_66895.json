{"pr_number": 66895, "pr_title": "Lower contention on requests with many aggs", "pr_createdAt": "2020-12-30T17:25:58Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66895", "timeline": [{"oid": "2c8890d19624283068b0f03932568fd0a79e0c0a", "url": "https://github.com/elastic/elasticsearch/commit/2c8890d19624283068b0f03932568fd0a79e0c0a", "message": "WIP", "committedDate": "2020-12-08T17:27:05Z", "type": "commit"}, {"oid": "85dacd4d2c32521704f29f6526a5de06572982c2", "url": "https://github.com/elastic/elasticsearch/commit/85dacd4d2c32521704f29f6526a5de06572982c2", "message": "WIP", "committedDate": "2020-12-08T17:27:05Z", "type": "commit"}, {"oid": "26d980950837547668229391291ca901294fb220", "url": "https://github.com/elastic/elasticsearch/commit/26d980950837547668229391291ca901294fb220", "message": "Sixty sums", "committedDate": "2020-12-08T17:27:05Z", "type": "commit"}, {"oid": "9166f271f0f1719ce40626bfc5e95ce71f3cad4b", "url": "https://github.com/elastic/elasticsearch/commit/9166f271f0f1719ce40626bfc5e95ce71f3cad4b", "message": "Doc", "committedDate": "2020-12-08T17:27:05Z", "type": "commit"}, {"oid": "46a229549b4a00b314c30f3894b1910a738d8d32", "url": "https://github.com/elastic/elasticsearch/commit/46a229549b4a00b314c30f3894b1910a738d8d32", "message": "Test preallocation pattern", "committedDate": "2020-12-08T17:27:05Z", "type": "commit"}, {"oid": "bb0ddcc18d1eac0381ec49693966516554ce5069", "url": "https://github.com/elastic/elasticsearch/commit/bb0ddcc18d1eac0381ec49693966516554ce5069", "message": "Merge branch 'master' into agg_construction_contention", "committedDate": "2020-12-29T22:48:56Z", "type": "commit"}, {"oid": "385607d74629b3b822254449429bef4b7d130c4a", "url": "https://github.com/elastic/elasticsearch/commit/385607d74629b3b822254449429bef4b7d130c4a", "message": "Compile plz", "committedDate": "2020-12-30T13:37:01Z", "type": "commit"}, {"oid": "795c89a068bd453e717ac67f4d5d15cca48751d2", "url": "https://github.com/elastic/elasticsearch/commit/795c89a068bd453e717ac67f4d5d15cca48751d2", "message": "Working?", "committedDate": "2020-12-30T15:38:55Z", "type": "commit"}, {"oid": "ff4835345d6ee3ce3e99aa22f599f9f00f974565", "url": "https://github.com/elastic/elasticsearch/commit/ff4835345d6ee3ce3e99aa22f599f9f00f974565", "message": "Drop .new", "committedDate": "2020-12-30T15:40:08Z", "type": "commit"}, {"oid": "d3f04a44ddfb0cdcb30c60c466b2ad11acbc88af", "url": "https://github.com/elastic/elasticsearch/commit/d3f04a44ddfb0cdcb30c60c466b2ad11acbc88af", "message": "Release properly", "committedDate": "2020-12-30T16:13:11Z", "type": "commit"}, {"oid": "2c8aeb513bc0b82334ba93405e9728107ea445f8", "url": "https://github.com/elastic/elasticsearch/commit/2c8aeb513bc0b82334ba93405e9728107ea445f8", "message": "Drop benchmark we don't need", "committedDate": "2020-12-30T16:21:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI2OTc1MA==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550269750", "bodyText": "Making AggregationContext Releasable lets us free the preallocated breaker after freeing all of the aggs without adding complexity to SearchContext.", "author": "nik9000", "createdAt": "2020-12-30T17:27:52Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -63,7 +66,7 @@\n  * this is {@code abstract} so that tests can build it without creating the\n  * massing {@link QueryShardContext}.\n  */\n-public abstract class AggregationContext {\n+public abstract class AggregationContext implements Releasable {", "originalCommit": "ff4835345d6ee3ce3e99aa22f599f9f00f974565", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24addcf3dd8d8b11f1fc3efa71f0632fc8fd8d0c", "url": "https://github.com/elastic/elasticsearch/commit/24addcf3dd8d8b11f1fc3efa71f0632fc8fd8d0c", "message": "tests", "committedDate": "2020-12-30T18:57:49Z", "type": "commit"}, {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582", "url": "https://github.com/elastic/elasticsearch/commit/e7a64a8cbaed18d45f2f55c0a347001aa5292582", "message": "Test", "committedDate": "2020-12-30T19:11:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwODA5NA==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550308094", "bodyText": "this ternary shouldn't be necessary, right?", "author": "DJRickyB", "createdAt": "2020-12-30T19:46:57Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -277,12 +277,25 @@ public ProductionAggregationContext(\n             Supplier<Boolean> isCancelled\n         ) {\n             this.context = context;\n-            this.breakerService = new PreallocatedCircuitBreakerService(\n-                context.bigArrays().breakerService(),\n-                CircuitBreaker.REQUEST,\n-                bytesToPreallocate\n-            );\n-            this.bigArrays = context.bigArrays().withBreakerService(breakerService).withCircuitBreaking();\n+            if (bytesToPreallocate == 0) {\n+                /*\n+                 * Its possible if a bit strange for the aggregations to ask\n+                 * to preallocate 0 bytes. Mostly this is for testing other\n+                 * things, but we should honor it and just not preallocate\n+                 * anything. Setting the breakerService reference to null will\n+                 * cause us to skip it when we close this context.\n+                 */\n+                this.breakerService = null;\n+                this.bigArrays = context.bigArrays().withCircuitBreaking();\n+            } else {\n+                this.breakerService = bytesToPreallocate == 0 ? null : new PreallocatedCircuitBreakerService(", "originalCommit": "e7a64a8cbaed18d45f2f55c0a347001aa5292582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwODE5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550308197", "bodyText": "Correct! A leftover.", "author": "nik9000", "createdAt": "2020-12-30T19:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwODA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwODIyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550308229", "bodyText": "I'll zap it.", "author": "nik9000", "createdAt": "2020-12-30T19:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwODA5NA=="}], "type": "inlineReview"}, {"oid": "0bd4bc56c468c56b54c565113151226bf09f88b1", "url": "https://github.com/elastic/elasticsearch/commit/0bd4bc56c468c56b54c565113151226bf09f88b1", "message": "zap", "committedDate": "2020-12-30T19:51:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwMTgxMA==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550301810", "bodyText": "Why do we change this to a null here?", "author": "not-napoleon", "createdAt": "2020-12-30T19:23:42Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/action/search/TransportSearchIT.java", "diffHunk": "@@ -567,13 +572,13 @@ public Aggregator subAggregator(String name) {\n         @Override\n         public InternalAggregation[] buildAggregations(long[] owningBucketOrds) throws IOException {\n             return new InternalAggregation[] {\n-                new InternalMax(name(), Double.NaN, DocValueFormat.RAW, Collections.emptyMap())\n+                buildEmptyAggregation()\n             };\n         }\n \n         @Override\n         public InternalAggregation buildEmptyAggregation() {\n-            return new InternalMax(name(), Double.NaN, DocValueFormat.RAW, Collections.emptyMap());\n+            return new InternalMax(name(), Double.NaN, DocValueFormat.RAW, null);", "originalCommit": "e7a64a8cbaed18d45f2f55c0a347001aa5292582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMzMjE1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r551332151", "bodyText": "I don't think I had to and on reflection I'll change it back. null here is actually more like what we do in production. emptyMap is more like when I user sends an empty meta.", "author": "nik9000", "createdAt": "2021-01-04T13:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwMTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwMjE0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550302142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Use this when you know you'll be allocating many small\n          \n          \n            \n             * Use this when you know you'll be allocating many small bits of memory.\n          \n      \n    \n    \n  \n\nor something like that.  Just a dangling sentence fragment right now.", "author": "not-napoleon", "createdAt": "2020-12-30T19:24:54Z", "path": "server/src/main/java/org/elasticsearch/common/breaker/PreallocatedCircuitBreakerService.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.breaker;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.indices.breaker.AllCircuitBreakerStats;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerStats;\n+\n+/**\n+ * {@link CircuitBreakerService} that preallocates some bytes on construction.\n+ * Use this when you know you'll be allocating many small", "originalCommit": "e7a64a8cbaed18d45f2f55c0a347001aa5292582", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNDg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550304842", "bodyText": "Isn't this always going to be true, since three lines previous, we checked that newUsed > preallocated?  Nothing involved is volatile, right?", "author": "not-napoleon", "createdAt": "2020-12-30T19:34:46Z", "path": "server/src/main/java/org/elasticsearch/common/breaker/PreallocatedCircuitBreakerService.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.breaker;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.indices.breaker.AllCircuitBreakerStats;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerStats;\n+\n+/**\n+ * {@link CircuitBreakerService} that preallocates some bytes on construction.\n+ * Use this when you know you'll be allocating many small\n+ */\n+public class PreallocatedCircuitBreakerService extends CircuitBreakerService implements Releasable {\n+    private final CircuitBreakerService next;\n+    private final PreallocedCircuitBreaker preallocated;\n+\n+    public PreallocatedCircuitBreakerService(\n+        CircuitBreakerService next,\n+        String breakerToPreallocate,\n+        long bytesToPreallocate,\n+        String label\n+    ) {\n+        if (bytesToPreallocate <= 0) {\n+            throw new IllegalArgumentException(\"can't preallocate negative or zero bytes but got [\" + bytesToPreallocate + \"]\");\n+        }\n+        CircuitBreaker nextBreaker = next.getBreaker(breakerToPreallocate);\n+        nextBreaker.addEstimateBytesAndMaybeBreak(bytesToPreallocate, \"preallocate[\" + label + \"]\");\n+        this.next = next;\n+        this.preallocated = new PreallocedCircuitBreaker(nextBreaker, bytesToPreallocate);\n+    }\n+\n+    @Override\n+    public CircuitBreaker getBreaker(String name) {\n+        if (name.equals(preallocated.getName())) {\n+            return preallocated;\n+        }\n+        return next.getBreaker(name);\n+    }\n+\n+    @Override\n+    public AllCircuitBreakerStats stats() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public CircuitBreakerStats stats(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void close() {\n+        preallocated.close();\n+    }\n+\n+    /**\n+     * The preallocated breaker.\n+     * <p>\n+     * This breaker operates in two states:\n+     * <ol>\n+     * <li>We've used fewer bytes than we've preallocated.\n+     * <li>We've used all of the preallocated bytes.\n+     * </ol>\n+     * <p>\n+     * If we're in the \"used fewer bytes\" state than we've allocated then\n+     * allocating new bytes just adds to\n+     * {@link PreallocedCircuitBreaker#preallocationUsed}, maxing out at\n+     * {@link PreallocedCircuitBreaker#preallocated}. If we max\n+     * out we irreversibly switch to \"used all\" state. In that state any\n+     * additional allocations are passed directly to the underlying breaker.\n+     * <p>\n+     * De-allocating is just allocating a negative number of bytes. De-allocating\n+     * can not transition us from the \"used all\" state back into the\n+     * \"used fewer bytes\" state. It is a one way trip. Once we're in the\n+     * \"used all\" state all de-allocates are done directly on the underlying\n+     * breaker. So well behaved callers will naturally de-allocate everything.\n+     * <p>\n+     * {@link PreallocedCircuitBreaker#close()} is only used to de-allocate\n+     * bytes from the underlying breaker if we're still in the \"used fewer bytes\"\n+     * state. There is nothing to de-allocate if we are in the \"used all\" state. \n+     */\n+    private static class PreallocedCircuitBreaker implements CircuitBreaker, Releasable {\n+        private final CircuitBreaker next;\n+        private final long preallocated;\n+        private long preallocationUsed;\n+        private boolean closed;\n+\n+        PreallocedCircuitBreaker(CircuitBreaker next, long preallocated) {\n+            this.next = next;\n+            this.preallocated = preallocated;\n+        }\n+\n+        @Override\n+        public void circuitBreak(String fieldName, long bytesNeeded) {\n+            next.circuitBreak(fieldName, bytesNeeded);\n+        }\n+\n+        @Override\n+        public double addEstimateBytesAndMaybeBreak(long bytes, String label) throws CircuitBreakingException {\n+            if (closed) {\n+                throw new IllegalStateException(\"already closed\");\n+            }\n+            if (preallocationUsed == preallocated) {\n+                return next.addEstimateBytesAndMaybeBreak(bytes, label);\n+            }\n+            long newUsed = preallocationUsed + bytes;\n+            if (newUsed > preallocated) {\n+                preallocationUsed = preallocated;\n+                long toAllocate = newUsed - preallocated;\n+                if (toAllocate > 0) {", "originalCommit": "e7a64a8cbaed18d45f2f55c0a347001aa5292582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMzMzgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r551333831", "bodyText": "Why did I have this........ Now I've got to reread and see what I was thinking.", "author": "nik9000", "createdAt": "2021-01-04T14:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNDg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM0MzI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r551343263", "bodyText": "Yeah. When I remove the if > 0 everything just works too. I imagine this is a left over from weird thinking. I mean, math works the way we think it does.", "author": "nik9000", "createdAt": "2021-01-04T14:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNDg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjMxOA==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550306318", "bodyText": "...That is a terrifying comment.  Maybe let's open an issue to drop the return value from this method?", "author": "not-napoleon", "createdAt": "2020-12-30T19:40:14Z", "path": "server/src/main/java/org/elasticsearch/common/breaker/PreallocatedCircuitBreakerService.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.breaker;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.indices.breaker.AllCircuitBreakerStats;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerStats;\n+\n+/**\n+ * {@link CircuitBreakerService} that preallocates some bytes on construction.\n+ * Use this when you know you'll be allocating many small\n+ */\n+public class PreallocatedCircuitBreakerService extends CircuitBreakerService implements Releasable {\n+    private final CircuitBreakerService next;\n+    private final PreallocedCircuitBreaker preallocated;\n+\n+    public PreallocatedCircuitBreakerService(\n+        CircuitBreakerService next,\n+        String breakerToPreallocate,\n+        long bytesToPreallocate,\n+        String label\n+    ) {\n+        if (bytesToPreallocate <= 0) {\n+            throw new IllegalArgumentException(\"can't preallocate negative or zero bytes but got [\" + bytesToPreallocate + \"]\");\n+        }\n+        CircuitBreaker nextBreaker = next.getBreaker(breakerToPreallocate);\n+        nextBreaker.addEstimateBytesAndMaybeBreak(bytesToPreallocate, \"preallocate[\" + label + \"]\");\n+        this.next = next;\n+        this.preallocated = new PreallocedCircuitBreaker(nextBreaker, bytesToPreallocate);\n+    }\n+\n+    @Override\n+    public CircuitBreaker getBreaker(String name) {\n+        if (name.equals(preallocated.getName())) {\n+            return preallocated;\n+        }\n+        return next.getBreaker(name);\n+    }\n+\n+    @Override\n+    public AllCircuitBreakerStats stats() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public CircuitBreakerStats stats(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void close() {\n+        preallocated.close();\n+    }\n+\n+    /**\n+     * The preallocated breaker.\n+     * <p>\n+     * This breaker operates in two states:\n+     * <ol>\n+     * <li>We've used fewer bytes than we've preallocated.\n+     * <li>We've used all of the preallocated bytes.\n+     * </ol>\n+     * <p>\n+     * If we're in the \"used fewer bytes\" state than we've allocated then\n+     * allocating new bytes just adds to\n+     * {@link PreallocedCircuitBreaker#preallocationUsed}, maxing out at\n+     * {@link PreallocedCircuitBreaker#preallocated}. If we max\n+     * out we irreversibly switch to \"used all\" state. In that state any\n+     * additional allocations are passed directly to the underlying breaker.\n+     * <p>\n+     * De-allocating is just allocating a negative number of bytes. De-allocating\n+     * can not transition us from the \"used all\" state back into the\n+     * \"used fewer bytes\" state. It is a one way trip. Once we're in the\n+     * \"used all\" state all de-allocates are done directly on the underlying\n+     * breaker. So well behaved callers will naturally de-allocate everything.\n+     * <p>\n+     * {@link PreallocedCircuitBreaker#close()} is only used to de-allocate\n+     * bytes from the underlying breaker if we're still in the \"used fewer bytes\"\n+     * state. There is nothing to de-allocate if we are in the \"used all\" state. \n+     */\n+    private static class PreallocedCircuitBreaker implements CircuitBreaker, Releasable {\n+        private final CircuitBreaker next;\n+        private final long preallocated;\n+        private long preallocationUsed;\n+        private boolean closed;\n+\n+        PreallocedCircuitBreaker(CircuitBreaker next, long preallocated) {\n+            this.next = next;\n+            this.preallocated = preallocated;\n+        }\n+\n+        @Override\n+        public void circuitBreak(String fieldName, long bytesNeeded) {\n+            next.circuitBreak(fieldName, bytesNeeded);\n+        }\n+\n+        @Override\n+        public double addEstimateBytesAndMaybeBreak(long bytes, String label) throws CircuitBreakingException {\n+            if (closed) {\n+                throw new IllegalStateException(\"already closed\");\n+            }\n+            if (preallocationUsed == preallocated) {\n+                return next.addEstimateBytesAndMaybeBreak(bytes, label);\n+            }\n+            long newUsed = preallocationUsed + bytes;\n+            if (newUsed > preallocated) {\n+                preallocationUsed = preallocated;\n+                long toAllocate = newUsed - preallocated;\n+                if (toAllocate > 0) {\n+                    return next.addEstimateBytesAndMaybeBreak(toAllocate, label);\n+                }\n+                return 0;\n+            }\n+            // This is the fast case. No volatile reads or writes here, ma!\n+            preallocationUsed = newUsed;\n+            // We return garbage here but callers never use the result for anything interesting", "originalCommit": "e7a64a8cbaed18d45f2f55c0a347001aa5292582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxNDY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550314690", "bodyText": "Yeah. I feel like there are several \"perspectives\" on CircuitBreaker which might be useful to split up. The \"I'm allocating and deallocating stuff\" one. The \"how much is used and how many times has this tripped?\" one. There is kind of also a \"testing\" one. And that one is where the caller uses the result here. Maybe tests could just read the result rather than look at the percent. I'll take another look.", "author": "nik9000", "createdAt": "2020-12-30T20:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxMTU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550311577", "bodyText": "This is a great comment.  I was literally about to ask why it would ever be 0.", "author": "not-napoleon", "createdAt": "2020-12-30T20:00:44Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -243,36 +251,55 @@ public final AggregationUsageService getUsageService() {\n      */\n     public static class ProductionAggregationContext extends AggregationContext {\n         private final QueryShardContext context;\n+        private final PreallocatedCircuitBreakerService breakerService;\n         private final BigArrays bigArrays;\n         private final Query topLevelQuery;\n         private final AggregationProfiler profiler;\n         private final MultiBucketConsumer multiBucketConsumer;\n         private final Supplier<SubSearchContext> subSearchContextBuilder;\n-        private final Consumer<Aggregator> addReleasable;\n         private final BitsetFilterCache bitsetFilterCache;\n         private final int randomSeed;\n         private final LongSupplier relativeTimeInMillis;\n         private final Supplier<Boolean> isCancelled;\n \n+        private final List<Aggregator> releaseMe = new ArrayList<>();\n+\n         public ProductionAggregationContext(\n             QueryShardContext context,\n+            long bytesToPreallocate,\n             Query topLevelQuery,\n             @Nullable AggregationProfiler profiler,\n             MultiBucketConsumer multiBucketConsumer,\n             Supplier<SubSearchContext> subSearchContextBuilder,\n-            Consumer<Aggregator> addReleasable,\n             BitsetFilterCache bitsetFilterCache,\n             int randomSeed,\n             LongSupplier relativeTimeInMillis,\n             Supplier<Boolean> isCancelled\n         ) {\n             this.context = context;\n-            this.bigArrays = context.bigArrays().withCircuitBreaking();  // We can break in searches.\n+            if (bytesToPreallocate == 0) {\n+                /*\n+                 * Its possible if a bit strange for the aggregations to ask\n+                 * to preallocate 0 bytes. Mostly this is for testing other\n+                 * things, but we should honor it and just not preallocate\n+                 * anything. Setting the breakerService reference to null will\n+                 * cause us to skip it when we close this context.", "originalCommit": "0bd4bc56c468c56b54c565113151226bf09f88b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e01f0e27393cd1f19747c2a695a03eada1e1f69", "url": "https://github.com/elastic/elasticsearch/commit/4e01f0e27393cd1f19747c2a695a03eada1e1f69", "message": "Merge branch 'master' into agg_construction_contention", "committedDate": "2021-01-04T14:07:52Z", "type": "commit"}, {"oid": "2d42334873d2c9bee3e0a66a747700eb25b758f8", "url": "https://github.com/elastic/elasticsearch/commit/2d42334873d2c9bee3e0a66a747700eb25b758f8", "message": "Clean up", "committedDate": "2021-01-04T14:27:55Z", "type": "commit"}, {"oid": "90026745c168608dbdffd254776f5f49d2f866f6", "url": "https://github.com/elastic/elasticsearch/commit/90026745c168608dbdffd254776f5f49d2f866f6", "message": "Moar words!", "committedDate": "2021-01-04T15:03:02Z", "type": "commit"}]}