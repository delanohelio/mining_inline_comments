{"pr_number": 60931, "pr_title": "Run core's integration tests with runtime fields", "pr_createdAt": "2020-08-10T19:05:54Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60931", "timeline": [{"oid": "44aa6e7d141f014e2494455b4cfbd910703d90f6", "url": "https://github.com/elastic/elasticsearch/commit/44aa6e7d141f014e2494455b4cfbd910703d90f6", "message": "Run core's integration tests with runtime fields\n\nAdds the `x-pack/plugin/runtime-fields/qa/rest` project to run core's\nintegration tests against an index with `runtime_scipt` fields. This\nworks by modifying the test configuration on load to replace supported\nfield types with `runtime_script`.\n\nRelates to #59332", "committedDate": "2020-08-10T19:03:24Z", "type": "commit"}, {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389", "url": "https://github.com/elastic/elasticsearch/commit/fb8402f6ca5839d6118f10f3df224803ee3f8389", "message": "Newline", "committedDate": "2020-08-10T19:04:41Z", "type": "commit"}, {"oid": "b392332ced3a2f896b962453b45600c397ef7602", "url": "https://github.com/elastic/elasticsearch/commit/b392332ced3a2f896b962453b45600c397ef7602", "message": "New way", "committedDate": "2020-08-10T20:18:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468179123", "bodyText": "Is there ever a time when the rest of the Object array is relevant (beyond the first element)? Maybe we could replace orig[0] and still return orig, or simply assert orig.length == 1 ?", "author": "jtibshirani", "createdAt": "2020-08-10T20:52:37Z", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];", "originalCommit": "b392332ced3a2f896b962453b45600c397ef7602", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5ODQ0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468598441", "bodyText": "The array only ever has a single entry, but I'll add an assert just to make sure it stays that way. The funny shape of the return here comes from the method being used primarily for junit's parameterized tests.", "author": "nik9000", "createdAt": "2020-08-11T13:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mjg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468182868", "bodyText": "I find the formatting hard to follow, does it work to just do return settings.containsKey(\"sort.field\"); ? Also maybe we could use the phrase 'index sort' to clarify what this setting refers to.", "author": "jtibshirani", "createdAt": "2020-08-10T20:59:59Z", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return", "originalCommit": "b392332ced3a2f896b962453b45600c397ef7602", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5NjE1OA==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468596158", "bodyText": "I super thought there'd be other things to add here. But it turned out this was it. I'll remove the method and move the check into the caller.", "author": "nik9000", "createdAt": "2020-08-11T13:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mjg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468192396", "bodyText": "This seems like the best approach for now but feels a bit fragile -- we're essentially duplicating the source parsing logic, which can be pretty nuanced. For example, for boolean fields, the value \"\" is interpreted as false. We also don't cover cases where the value is malformed or missing from _source.\nTo make this more robust, I guess we could switch to 'source-only fields' when those are available?  That way we could reuse the logic from fields retrieval for parsing values from source. Or we could consider adding a way to access nicely-formatted source fields from painless?", "author": "jtibshirani", "createdAt": "2020-08-10T21:20:10Z", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return\n+        /*\n+         * You can't sort on a runtime_keyword and it is hard to figure out\n+         * if the sort was a runtime_keyword so lets just skip this test.\n+         */\n+        settings.containsKey(\"sort.field\");\n+    }\n+\n+    private static String painlessToLoadFromSource(String name, String type) {\n+        String emit = PAINLESS_TO_EMIT.get(type);\n+        if (emit == null) {\n+            return null;\n+        }\n+        StringBuilder b = new StringBuilder();\n+        b.append(\"def v = source['\").append(name).append(\"'];\\n\");\n+        b.append(\"if (v instanceof Iterable) {\\n\");\n+        b.append(\"  for (def vv : ((Iterable) v)) {\\n\");\n+        b.append(\"    if (vv != null) {\\n\");\n+        b.append(\"      def value = vv;\\n\");\n+        b.append(\"      \").append(emit).append(\"\\n\");\n+        b.append(\"    }\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"} else {\\n\");\n+        b.append(\"  if (v != null) {\\n\");\n+        b.append(\"    def value = v;\\n\");\n+        b.append(\"    \").append(emit).append(\"\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"}\\n\");\n+        return b.toString();\n+    }\n+\n+    private static final Map<String, String> PAINLESS_TO_EMIT = Map.ofEntries(\n+        // TODO implement dates against the parser\n+        Map.entry(", "originalCommit": "b392332ced3a2f896b962453b45600c397ef7602", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5NTcyMg==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468595722", "bodyText": "It really is pretty fragile. I was thinking of something similar to what you said - steal the source parsing and expose it to the script. That wouldn't be a \"painless feature\" so much as a feature of the script context of the runtime field. The advantage of this is that I know exactly which runtime field I'm running against so, for example, dates could use the the field's date parsing logic.", "author": "nik9000", "createdAt": "2020-08-11T13:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MTA4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468691081", "bodyText": "That makes sense. I think this is the right way to go for this feature branch, but it'd be good to follow-up on source parsing improvements at a later point.", "author": "jtibshirani", "createdAt": "2020-08-11T15:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng=="}], "type": "inlineReview"}, {"oid": "ac330ec82f95b716987d6ca7488fec962af380f9", "url": "https://github.com/elastic/elasticsearch/commit/ac330ec82f95b716987d6ca7488fec962af380f9", "message": "Just search", "committedDate": "2020-08-11T13:43:20Z", "type": "commit"}, {"oid": "5eccfcdbc357f72044d8724bdd7e73c9904b8b0c", "url": "https://github.com/elastic/elasticsearch/commit/5eccfcdbc357f72044d8724bdd7e73c9904b8b0c", "message": "Merge branch 'feature/runtime_fields' into runtime_fields_tests", "committedDate": "2020-08-11T14:06:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTE2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468689162", "bodyText": "Small comment, we could say 'index sort' for clarity?", "author": "jtibshirani", "createdAt": "2020-08-11T15:56:39Z", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            assert orig.length == 1;\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && ((Map<?, ?>) settings).containsKey(\"sort.field\")) {\n+                    /*\n+                     * You can't sort on a runtime_keyword and it is hard to figure out", "originalCommit": "5eccfcdbc357f72044d8724bdd7e73c9904b8b0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5OTY2NA==", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468699664", "bodyText": "++", "author": "nik9000", "createdAt": "2020-08-11T16:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTE2Mg=="}], "type": "inlineReview"}, {"oid": "ac5e2e1c52860b4b4ad7cf2f886afb765817a315", "url": "https://github.com/elastic/elasticsearch/commit/ac5e2e1c52860b4b4ad7cf2f886afb765817a315", "message": "Words", "committedDate": "2020-08-11T16:17:21Z", "type": "commit"}]}