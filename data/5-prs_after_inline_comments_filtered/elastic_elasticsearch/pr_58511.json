{"pr_number": 58511, "pr_title": "Fix Memory Leak From Master Failover During Snapshot", "pr_createdAt": "2020-06-24T17:55:41Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58511", "timeline": [{"oid": "5a9813941d3ad07499f825c961038e1550144217", "url": "https://github.com/elastic/elasticsearch/commit/5a9813941d3ad07499f825c961038e1550144217", "message": "Fix Memory Leak From Master Failover During Snapshot\n\nIf we failed over while the data nodes were doing their work\nwe would never resolve the listener and leak it.\nThis change fails all listeners if master fails over.", "committedDate": "2020-06-24T17:52:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3MjAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/58511#discussion_r445072020", "bodyText": "These tests should have access to the utilities from abstract snapshot tests.", "author": "original-brownbear", "createdAt": "2020-06-24T17:56:49Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/discovery/SnapshotDisruptionIT.java", "diffHunk": "@@ -65,7 +66,7 @@\n  * Tests snapshot operations during disruptions.\n  */\n @ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n-public class SnapshotDisruptionIT extends ESIntegTestCase {\n+public class SnapshotDisruptionIT extends AbstractSnapshotIntegTestCase {", "originalCommit": "5a9813941d3ad07499f825c961038e1550144217", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3MjM2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58511#discussion_r445072362", "bodyText": "Had to add this to force a cleanup run so the repo consistency check doesn't start complaining about leaked files from the broken snapshot run in this test.", "author": "original-brownbear", "createdAt": "2020-06-24T17:57:26Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/discovery/SnapshotDisruptionIT.java", "diffHunk": "@@ -228,6 +229,48 @@ public void testDisruptionAfterShardFinalization() throws Exception {\n                 client(masterNode).admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\").setWaitForCompletion(true).get();\n         final SnapshotInfo successfulSnapshotInfo = successfulSnapshot.getSnapshotInfo();\n         assertThat(successfulSnapshotInfo.state(), is(SnapshotState.SUCCESS));\n+\n+        logger.info(\"--> making sure snapshot delete works out cleanly\");\n+        assertAcked(client().admin().cluster().prepareDeleteSnapshot(repoName, \"snapshot-2\").get());", "originalCommit": "5a9813941d3ad07499f825c961038e1550144217", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3Mjc3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58511#discussion_r445072772", "bodyText": "Gotta copy the keyset because failSnapshotCompletionListeners modifies the map", "author": "original-brownbear", "createdAt": "2020-06-24T17:58:07Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -453,6 +453,15 @@ public void applyClusterState(ClusterChangedEvent event) {\n                 if (newMaster) {\n                     finalizeSnapshotDeletionFromPreviousMaster(event.state());\n                 }\n+            } else if (snapshotCompletionListeners.isEmpty() == false) {\n+                // We have snapshot listeners but are not the master any more. Fail all waiting listeners except for those that already\n+                // have their snapshots finalizing (those that are already finalizing will fail on their own from to update the cluster\n+                // state).\n+                for (Snapshot snapshot : Set.copyOf(snapshotCompletionListeners.keySet())) {", "originalCommit": "5a9813941d3ad07499f825c961038e1550144217", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxMDEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/58511#discussion_r445410133", "bodyText": "Just to be sure, do we already assert somewhere else that there are not listeners leaking after any cluster state update?", "author": "tlrx", "createdAt": "2020-06-25T08:57:25Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1330,6 +1339,20 @@ protected void doClose() {\n         clusterService.removeApplier(this);\n     }\n \n+    /**\n+     * Assert that no in-memory state for any running snapshot operation exists in this instance.\n+     */\n+    public boolean assertAllListenersResolved() {", "originalCommit": "5a9813941d3ad07499f825c961038e1550144217", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5MTk2NA==", "url": "https://github.com/elastic/elasticsearch/pull/58511#discussion_r445491964", "bodyText": "Replying to myself: we do, in SnapshotsService.assertConsistentWithClusterState()", "author": "tlrx", "createdAt": "2020-06-25T11:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxMDEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3MzA5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58511#discussion_r445673099", "bodyText": "Yea sadly that assertion (and the way it works in general) can only make sure that we are not failing to resolve a listener during an action (i.e. updating the state because of some other state change or shard update message). It unfortunately couldn't detect that the final state of things is what we want.", "author": "original-brownbear", "createdAt": "2020-06-25T16:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxMDEzMw=="}], "type": "inlineReview"}]}