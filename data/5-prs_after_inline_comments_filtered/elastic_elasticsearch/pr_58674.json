{"pr_number": 58674, "pr_title": "Enhance real memory circuit breaker with G1 GC", "pr_createdAt": "2020-06-29T14:08:15Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58674", "timeline": [{"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595", "url": "https://github.com/elastic/elasticsearch/commit/05ec98a32ac3e5dfb516726bf4904f412fc62595", "message": "Enhance real memory circuit breaker with G1 GC\n\nUsing G1 GC, Elasticsearch can rarely trigger that heap usage goes above\nthe real memory circuit breaker limit and stays there for an extended\nperiod. This situation will persist until the next young GC. The circuit\nbreaking itself hinders that from occurring in a timely manner since it\nbreaks all request before real work is done.\n\nThis commit gently nudges G1 to do a young GC and then double checks\nthat heap usage is still above the real memory circuit breaker limit\nbefore throwing the circuit breaker exception.\n\nRelated to #57202", "committedDate": "2020-06-29T14:06:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMjgxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447902815", "bodyText": "Maybe name it OverLimitStrategy?", "author": "jaymode", "createdAt": "2020-06-30T18:43:59Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {", "originalCommit": "05ec98a32ac3e5dfb516726bf4904f412fc62595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NTQxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448585419", "bodyText": "++, see 1d007ca", "author": "henningandersen", "createdAt": "2020-07-01T19:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMjgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzE1NA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447903154", "bodyText": "can you add a link or reference to this calculation?", "author": "jaymode", "createdAt": "2020-06-30T18:44:36Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation", "originalCommit": "05ec98a32ac3e5dfb516726bf4904f412fc62595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NTEwNA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448585104", "bodyText": "Added in c8ac1af", "author": "henningandersen", "createdAt": "2020-07-01T19:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwODU2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447908565", "bodyText": "unfortunately neither System.currentTimeMillis() nor System.nanoTime() are always monotonic so now could be less than the last checked time so I do not believe that this assert should be here", "author": "jaymode", "createdAt": "2020-06-30T18:53:42Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();\n+                    }\n+\n+                    blackHole += localBlackHole;\n+                    logger.trace(\"black hole [{}]\", blackHole);\n+                    long now = timeSupplier.getAsLong();\n+                    assert now > this.lastCheckTime;", "originalCommit": "05ec98a32ac3e5dfb516726bf4904f412fc62595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NDkwNw==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448584907", "bodyText": "Thanks, removed in b6b565a", "author": "henningandersen", "createdAt": "2020-07-01T19:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwODU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Nzg2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447977867", "bodyText": "is it possible for this to trigger an OOM?", "author": "jaymode", "createdAt": "2020-06-30T21:04:04Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();", "originalCommit": "05ec98a32ac3e5dfb516726bf4904f412fc62595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3NDQyNg==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448574426", "bodyText": "Yes and no.\nIn theory yes, if there is really no collectible heap left.\nBut if that was the case, just creating the CircuitBreakingException poses the same risk. And if we are that close, we are doomed anyway I think. The chances of us having a workload at exactly 99.95 percent heap  (corresponding to approximately 2000 regions) and surviving is so small that even if it was the case, the next time round we enter the same workload it would fall over.\nNotice that we only need 1 region of space free or collectible space for this to succeed.", "author": "henningandersen", "createdAt": "2020-07-01T19:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Nzg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448388167", "bodyText": "Any reason to use lock over this?", "author": "jaymode", "createdAt": "2020-07-01T14:07:02Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {", "originalCommit": "05ec98a32ac3e5dfb516726bf4904f412fc62595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MjA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448572096", "bodyText": "Given the locality of the usage, not really, it is just a personal preference since it avoids thinking about external synchronization on this. I am OK turning it into this if you prefer?", "author": "henningandersen", "createdAt": "2020-07-01T19:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTk1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450359956", "bodyText": "I'm fine with it; just curious.", "author": "jaymode", "createdAt": "2020-07-06T17:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw=="}], "type": "inlineReview"}, {"oid": "b6b565aee012e8bb5ca204b832a4995a3144475d", "url": "https://github.com/elastic/elasticsearch/commit/b6b565aee012e8bb5ca204b832a4995a3144475d", "message": "Time not monotonic.", "committedDate": "2020-07-01T19:34:59Z", "type": "commit"}, {"oid": "c8ac1af58e5edc9d2f718070e8da846912d0010f", "url": "https://github.com/elastic/elasticsearch/commit/c8ac1af58e5edc9d2f718070e8da846912d0010f", "message": "Add link to JDK G1 region size calculation.", "committedDate": "2020-07-01T19:45:21Z", "type": "commit"}, {"oid": "1d007ca5fbd148887449a9c794d37eb46c57184f", "url": "https://github.com/elastic/elasticsearch/commit/1d007ca5fbd148887449a9c794d37eb46c57184f", "message": "Rename to \"over limit\" rather than \"double check\"", "committedDate": "2020-07-01T19:53:47Z", "type": "commit"}, {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "url": "https://github.com/elastic/elasticsearch/commit/66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "message": "Merge remote-tracking branch 'origin/master' into enhance_g1_circuit_breaking", "committedDate": "2020-07-01T20:59:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTYxMA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450359610", "bodyText": "Since this appears to be a consistent value, maybe we just keep it as a final long that is a class member.", "author": "jaymode", "createdAt": "2020-07-06T17:00:41Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1OverLimitStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface OverLimitStrategy {\n+        MemoryUsage overLimit(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1OverLimitStrategy implements OverLimitStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1OverLimitStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                            LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation based on JDK 14 source:\n+            // https://hg.openjdk.java.net/jdk/jdk14/file/6c954123ee8d/src/hotspot/share/gc/g1/heapRegion.cpp#l65\n+            // notice that newer JDKs will have a slight variant only considering max-heap:\n+            // https://hg.openjdk.java.net/jdk/jdk/file/e7d0ec2d06e8/src/hotspot/share/gc/g1/heapRegion.cpp#l67\n+            // based on this JDK \"bug\":\n+            // https://bugs.openjdk.java.net/browse/JDK-8241670\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage overLimit(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();", "originalCommit": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEzOTk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451139948", "bodyText": "Fixed in 3eacf32", "author": "henningandersen", "createdAt": "2020-07-07T20:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTYxMA=="}], "type": "inlineReview"}, {"oid": "3eacf32b9ad90fa5029ca55c31b8e90a233d389e", "url": "https://github.com/elastic/elasticsearch/commit/3eacf32b9ad90fa5029ca55c31b8e90a233d389e", "message": "Keep maxHeap in field.", "committedDate": "2020-07-07T13:47:48Z", "type": "commit"}, {"oid": "addeede803b72a12f01a5218b48838a75e763b3e", "url": "https://github.com/elastic/elasticsearch/commit/addeede803b72a12f01a5218b48838a75e763b3e", "message": "Improved logging.", "committedDate": "2020-07-07T14:00:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NDU0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450974547", "bodyText": "Maybe the method call can be replaced with overLimitStrategy.apply(memoryUsed) and the construction of the OverLimitStrategy will be responsible for handling the behavior of what to do?", "author": "jaymode", "createdAt": "2020-07-07T16:00:22Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -290,7 +308,7 @@ public long getParentLimit() {\n     public void checkParentLimit(long newBytesReserved, String label) throws CircuitBreakingException {\n         final MemoryUsage memoryUsed = memoryUsed(newBytesReserved);\n         long parentLimit = this.parentSettings.getLimit();\n-        if (memoryUsed.totalUsage > parentLimit) {\n+        if (memoryUsed.totalUsage > parentLimit && doubleCheckMemoryUsed(memoryUsed).totalUsage > parentLimit) {", "originalCommit": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451140394", "bodyText": "Good idea, done in 3f61f93", "author": "henningandersen", "createdAt": "2020-07-07T21:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NDU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NTI5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450985291", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n          \n          \n            \n                private static OverLimitStrategy createOverLimitStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,", "author": "jaymode", "createdAt": "2020-07-07T16:16:47Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,", "originalCommit": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NzIxNA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450987214", "bodyText": "In line with an earlier comment, we could pass in trackRealMemoryUsage to this method and add it to this check.", "author": "jaymode", "createdAt": "2020-07-07T16:19:58Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")", "originalCommit": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDc3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451140776", "bodyText": "Also part of 3f61f93", "author": "henningandersen", "createdAt": "2020-07-07T21:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NzIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4ODM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450988354", "bodyText": "Do you mind using Booleans.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\"), true)? The java Boolean parsing is pretty lenient and I thought it was a forbidden api at some point :|", "author": "jaymode", "createdAt": "2020-07-07T16:21:43Z", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {", "originalCommit": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDk3NA==", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451140974", "bodyText": "Thanks, fixed in 845dc10", "author": "henningandersen", "createdAt": "2020-07-07T21:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4ODM1NA=="}], "type": "inlineReview"}, {"oid": "110925d155e95eefce529507d8540d24da90c996", "url": "https://github.com/elastic/elasticsearch/commit/110925d155e95eefce529507d8540d24da90c996", "message": "Also check young GC counts.", "committedDate": "2020-07-07T19:04:52Z", "type": "commit"}, {"oid": "cfde2a7a4bfd26de50a0f189fff2038af82598ce", "url": "https://github.com/elastic/elasticsearch/commit/cfde2a7a4bfd26de50a0f189fff2038af82598ce", "message": "Move wiring into createDoubleCheckStrategy.", "committedDate": "2020-07-07T19:08:49Z", "type": "commit"}, {"oid": "fea2ddc674d6d7234fc80767c3a2473e0410bc8d", "url": "https://github.com/elastic/elasticsearch/commit/fea2ddc674d6d7234fc80767c3a2473e0410bc8d", "message": "createOverLimitStrategy naming", "committedDate": "2020-07-07T19:14:01Z", "type": "commit"}, {"oid": "845dc109955ad5dd2b60f247541de9c0fc328225", "url": "https://github.com/elastic/elasticsearch/commit/845dc109955ad5dd2b60f247541de9c0fc328225", "message": "Use Booleans.parseBoolean", "committedDate": "2020-07-07T19:15:14Z", "type": "commit"}, {"oid": "3f61f93f6660b32153047b7fb0393b314510d238", "url": "https://github.com/elastic/elasticsearch/commit/3f61f93f6660b32153047b7fb0393b314510d238", "message": "Always call the over limit strategy\n\nNow determine strategy based on whether real memory usage is\ntracked.", "committedDate": "2020-07-07T20:57:38Z", "type": "commit"}, {"oid": "55a17746c7efd04978dbf6fe1fbb5ded7fbbdc25", "url": "https://github.com/elastic/elasticsearch/commit/55a17746c7efd04978dbf6fe1fbb5ded7fbbdc25", "message": "Fix test stability\n\nTest would not always trigger the over limit check twice, fixed.", "committedDate": "2020-07-07T21:14:47Z", "type": "commit"}, {"oid": "ed460f9e9cbb0b23158c6e731664d109aeb8c548", "url": "https://github.com/elastic/elasticsearch/commit/ed460f9e9cbb0b23158c6e731664d109aeb8c548", "message": "Improved code formatting", "committedDate": "2020-07-07T21:22:07Z", "type": "commit"}, {"oid": "7d148d0374d16f2011e4e44afcccef1b1cc67c6e", "url": "https://github.com/elastic/elasticsearch/commit/7d148d0374d16f2011e4e44afcccef1b1cc67c6e", "message": "Better field order.", "committedDate": "2020-07-07T21:23:36Z", "type": "commit"}, {"oid": "263f474dc279149e746b7e264c8fd790efc23baf", "url": "https://github.com/elastic/elasticsearch/commit/263f474dc279149e746b7e264c8fd790efc23baf", "message": "Few line reorderings", "committedDate": "2020-07-07T21:25:50Z", "type": "commit"}, {"oid": "79bd399eceef4a2766e703d496716d96eddaf790", "url": "https://github.com/elastic/elasticsearch/commit/79bd399eceef4a2766e703d496716d96eddaf790", "message": "Merge remote-tracking branch 'origin/master' into enhance_g1_circuit_breaking", "committedDate": "2020-07-08T04:54:16Z", "type": "commit"}, {"oid": "facd321c5a4114d8a5425a5d278faa02bfa1b584", "url": "https://github.com/elastic/elasticsearch/commit/facd321c5a4114d8a5425a5d278faa02bfa1b584", "message": "Added lock timeout.", "committedDate": "2020-07-08T06:34:35Z", "type": "commit"}, {"oid": "14e574cb0e061f9e5e367ab6aaac98c4f9624039", "url": "https://github.com/elastic/elasticsearch/commit/14e574cb0e061f9e5e367ab6aaac98c4f9624039", "message": "Merge branch 'master' into enhance_g1_circuit_breaking", "committedDate": "2020-07-13T09:23:02Z", "type": "commit"}]}