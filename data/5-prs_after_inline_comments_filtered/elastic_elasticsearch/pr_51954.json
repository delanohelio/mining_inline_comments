{"pr_number": 51954, "pr_title": "Move specialized execute method code into an external phase", "pr_createdAt": "2020-02-05T17:18:37Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51954", "timeline": [{"oid": "6e6aa320a4e86fc61f97c3f68828b69886662415", "url": "https://github.com/elastic/elasticsearch/commit/6e6aa320a4e86fc61f97c3f68828b69886662415", "message": "removed scopes for functions to see used variables", "committedDate": "2020-02-04T23:17:45Z", "type": "commit"}, {"oid": "0f8f2db1681620b7a4ff8b4fb6f1a5c85cde3c7b", "url": "https://github.com/elastic/elasticsearch/commit/0f8f2db1681620b7a4ff8b4fb6f1a5c85cde3c7b", "message": "change scoping to track variables in all scopes", "committedDate": "2020-02-04T23:40:15Z", "type": "commit"}, {"oid": "92281afdd77398b9928520621d4410a1cc0d0c92", "url": "https://github.com/elastic/elasticsearch/commit/92281afdd77398b9928520621d4410a1cc0d0c92", "message": "partially removed execute method exceptino customization", "committedDate": "2020-02-04T23:43:52Z", "type": "commit"}, {"oid": "d1dfeda725afc5bc5e615d9aa0d99492923f929b", "url": "https://github.com/elastic/elasticsearch/commit/d1dfeda725afc5bc5e615d9aa0d99492923f929b", "message": "move autoreturn out of ir nodes", "committedDate": "2020-02-05T00:11:35Z", "type": "commit"}, {"oid": "65147708c75fc0c16023c7576b2aa9ba52b1980a", "url": "https://github.com/elastic/elasticsearch/commit/65147708c75fc0c16023c7576b2aa9ba52b1980a", "message": "add es specific exceptions in decorate execute phase", "committedDate": "2020-02-05T16:56:42Z", "type": "commit"}, {"oid": "6115179c2b5b9bb6ab690212f35babfb7ed6103f", "url": "https://github.com/elastic/elasticsearch/commit/6115179c2b5b9bb6ab690212f35babfb7ed6103f", "message": "remove commented out code", "committedDate": "2020-02-05T17:09:10Z", "type": "commit"}, {"oid": "57feda775fd8e006aa5d29f6a6494e75449d3f2d", "url": "https://github.com/elastic/elasticsearch/commit/57feda775fd8e006aa5d29f6a6494e75449d3f2d", "message": "Merge branch 'master' into trees6", "committedDate": "2020-02-05T22:34:25Z", "type": "commit"}, {"oid": "84f5754ffb2b867554eea9ae42d116231e67555c", "url": "https://github.com/elastic/elasticsearch/commit/84f5754ffb2b867554eea9ae42d116231e67555c", "message": "Merge branch 'master' into trees6", "committedDate": "2020-02-10T22:09:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTMyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377391321", "bodyText": "typo: to for -> for", "author": "rjernst", "createdAt": "2020-02-11T00:11:26Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for", "originalCommit": "84f5754ffb2b867554eea9ae42d116231e67555c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczMzMxMg==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377733312", "bodyText": "Fixed.", "author": "jdconrad", "createdAt": "2020-02-11T16:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NTk0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377395942", "bodyText": "this could be a class constant, like ERRORS_TO_CATCH?", "author": "rjernst", "createdAt": "2020-02-11T00:28:26Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {\n+\n+    public static void phase(ScriptRoot scriptRoot, ClassNode classNode) {\n+        FunctionNode executeFunctionNode = null;\n+\n+        // look up the execute method for decoration\n+        for (FunctionNode functionNode : classNode.getFunctionsNodes()) {\n+            if (\"execute\".equals(functionNode.getName())) {\n+                executeFunctionNode = functionNode;\n+                break;\n+            }\n+        }\n+\n+        BlockNode blockNode = executeFunctionNode.getBlockNode();\n+\n+        // convert gets methods to a new set of inserted ir nodes as necessary -\n+        // requires the gets method name be modified from \"getExample\" to \"example\"\n+        // if a get method variable isn't used it's declaration node is removed from\n+        // the ir tree permanently so there is no frivolous variable slotting\n+        int statementIndex = 0;\n+\n+        while (statementIndex < blockNode.getStatementsNodes().size()) {\n+            StatementNode statementNode = blockNode.getStatementsNodes().get(statementIndex);\n+\n+            if (statementNode instanceof DeclarationNode) {\n+                DeclarationNode declarationNode = (DeclarationNode)statementNode;\n+                boolean isRemoved = false;\n+\n+                for (int getIndex = 0; getIndex < scriptRoot.getScriptClassInfo().getGetMethods().size(); ++getIndex) {\n+                    Class<?> returnType = scriptRoot.getScriptClassInfo().getGetReturns().get(getIndex);\n+                    Method getMethod = scriptRoot.getScriptClassInfo().getGetMethods().get(getIndex);\n+                    String name = getMethod.getName().substring(3);\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                    if (name.equals(declarationNode.getName())) {\n+                        if (scriptRoot.getUsedVariables().contains(name)) {\n+                                UnboundCallNode unboundCallNode = new UnboundCallNode();\n+                                unboundCallNode.setLocation(declarationNode.getLocation());\n+                                unboundCallNode.setExpressionType(declarationNode.getDeclarationType());\n+                                unboundCallNode.setLocalFunction(new LocalFunction(\n+                                        getMethod.getName(), returnType, Collections.emptyList(), true, false));\n+                                declarationNode.setExpressionNode(unboundCallNode);\n+                        } else {\n+                            blockNode.getStatementsNodes().remove(statementIndex);\n+                            isRemoved = true;\n+                        }\n+\n+                        break;\n+                    }\n+                }\n+\n+                if (isRemoved == false) {\n+                    ++statementIndex;\n+                }\n+            } else {\n+                ++statementIndex;\n+            }\n+        }\n+\n+        // decorate the execute method with nodes to wrap the user statements with\n+        // the sandboxed errors as follows:\n+        // } catch (PainlessExplainError e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders($DEFINITION))\n+        // }\n+        // and\n+        // } catch (PainlessError | BootstrapMethodError | OutOfMemoryError | StackOverflowError | Exception e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders())\n+        // }\n+        try {\n+            Location internalLocation = new Location(\"<internal>\", 0);\n+\n+            TryNode tryNode = new TryNode();\n+            tryNode.setLocation(internalLocation);\n+            tryNode.setBlockNode(blockNode);\n+\n+            CatchNode catchNode = new CatchNode();\n+            catchNode.setLocation(internalLocation);\n+\n+            tryNode.addCatchNode(catchNode);\n+\n+            DeclarationNode declarationNode = new DeclarationNode();\n+            declarationNode.setLocation(internalLocation);\n+            declarationNode.setDeclarationType(PainlessExplainError.class);\n+            declarationNode.setName(\"#painlessExplainError\");\n+            declarationNode.setRequiresDefault(false);\n+\n+            catchNode.setDeclarationNode(declarationNode);\n+\n+            BlockNode catchBlockNode = new BlockNode();\n+            catchBlockNode.setLocation(internalLocation);\n+            catchBlockNode.setAllEscape(true);\n+            catchBlockNode.setStatementCount(1);\n+\n+            catchNode.setBlockNode(catchBlockNode);\n+\n+            ThrowNode throwNode = new ThrowNode();\n+            throwNode.setLocation(internalLocation);\n+\n+            catchBlockNode.addStatementNode(throwNode);\n+\n+            UnboundCallNode unboundCallNode = new UnboundCallNode();\n+            unboundCallNode.setLocation(internalLocation);\n+            unboundCallNode.setExpressionType(ScriptException.class);\n+            unboundCallNode.setLocalFunction(new LocalFunction(\n+                            \"convertToScriptException\",\n+                            ScriptException.class,\n+                            Arrays.asList(Throwable.class, Map.class),\n+                            true,\n+                            false\n+                    )\n+            );\n+\n+            throwNode.setExpressionNode(unboundCallNode);\n+\n+            VariableNode variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(ScriptException.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            unboundCallNode.addArgumentNode(variableNode);\n+\n+            CallNode callNode = new CallNode();\n+            callNode.setLocation(internalLocation);\n+            callNode.setExpressionType(Map.class);\n+\n+            unboundCallNode.addArgumentNode(callNode);\n+\n+            variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(PainlessExplainError.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            callNode.setLeftNode(variableNode);\n+\n+            CallSubNode callSubNode = new CallSubNode();\n+            callSubNode.setLocation(internalLocation);\n+            callSubNode.setExpressionType(Map.class);\n+            callSubNode.setBox(PainlessExplainError.class);\n+            callSubNode.setMethod(new PainlessMethod(\n+                    PainlessExplainError.class.getMethod(\n+                            \"getHeaders\",\n+                            PainlessLookup.class),\n+                    PainlessExplainError.class,\n+                    null,\n+                    Collections.emptyList(),\n+                    null,\n+                    null,\n+                    null\n+            ));\n+\n+            callNode.setRightNode(callSubNode);\n+\n+            UnboundFieldNode unboundFieldNode = new UnboundFieldNode();\n+            unboundFieldNode.setLocation(internalLocation);\n+            unboundFieldNode.setExpressionType(PainlessLookup.class);\n+            unboundFieldNode.setName(\"$DEFINITION\");\n+            unboundFieldNode.setStatic(true);\n+\n+            callSubNode.addArgumentNode(unboundFieldNode);\n+\n+            for (Class<?> throwable : new Class<?>[] {\n+                    PainlessError.class, BootstrapMethodError.class, OutOfMemoryError.class, StackOverflowError.class, Exception.class}) {", "originalCommit": "84f5754ffb2b867554eea9ae42d116231e67555c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MTYwNA==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377741604", "bodyText": "This is going to change in future PRs so I would prefer to leave this for now.", "author": "jdconrad", "createdAt": "2020-02-11T16:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NjA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377396065", "bodyText": "this can be private, no need to construct right?", "author": "rjernst", "createdAt": "2020-02-11T00:28:54Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {\n+\n+    public static void phase(ScriptRoot scriptRoot, ClassNode classNode) {\n+        FunctionNode executeFunctionNode = null;\n+\n+        // look up the execute method for decoration\n+        for (FunctionNode functionNode : classNode.getFunctionsNodes()) {\n+            if (\"execute\".equals(functionNode.getName())) {\n+                executeFunctionNode = functionNode;\n+                break;\n+            }\n+        }\n+\n+        BlockNode blockNode = executeFunctionNode.getBlockNode();\n+\n+        // convert gets methods to a new set of inserted ir nodes as necessary -\n+        // requires the gets method name be modified from \"getExample\" to \"example\"\n+        // if a get method variable isn't used it's declaration node is removed from\n+        // the ir tree permanently so there is no frivolous variable slotting\n+        int statementIndex = 0;\n+\n+        while (statementIndex < blockNode.getStatementsNodes().size()) {\n+            StatementNode statementNode = blockNode.getStatementsNodes().get(statementIndex);\n+\n+            if (statementNode instanceof DeclarationNode) {\n+                DeclarationNode declarationNode = (DeclarationNode)statementNode;\n+                boolean isRemoved = false;\n+\n+                for (int getIndex = 0; getIndex < scriptRoot.getScriptClassInfo().getGetMethods().size(); ++getIndex) {\n+                    Class<?> returnType = scriptRoot.getScriptClassInfo().getGetReturns().get(getIndex);\n+                    Method getMethod = scriptRoot.getScriptClassInfo().getGetMethods().get(getIndex);\n+                    String name = getMethod.getName().substring(3);\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                    if (name.equals(declarationNode.getName())) {\n+                        if (scriptRoot.getUsedVariables().contains(name)) {\n+                                UnboundCallNode unboundCallNode = new UnboundCallNode();\n+                                unboundCallNode.setLocation(declarationNode.getLocation());\n+                                unboundCallNode.setExpressionType(declarationNode.getDeclarationType());\n+                                unboundCallNode.setLocalFunction(new LocalFunction(\n+                                        getMethod.getName(), returnType, Collections.emptyList(), true, false));\n+                                declarationNode.setExpressionNode(unboundCallNode);\n+                        } else {\n+                            blockNode.getStatementsNodes().remove(statementIndex);\n+                            isRemoved = true;\n+                        }\n+\n+                        break;\n+                    }\n+                }\n+\n+                if (isRemoved == false) {\n+                    ++statementIndex;\n+                }\n+            } else {\n+                ++statementIndex;\n+            }\n+        }\n+\n+        // decorate the execute method with nodes to wrap the user statements with\n+        // the sandboxed errors as follows:\n+        // } catch (PainlessExplainError e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders($DEFINITION))\n+        // }\n+        // and\n+        // } catch (PainlessError | BootstrapMethodError | OutOfMemoryError | StackOverflowError | Exception e) {\n+        //     throw this.convertToScriptException(e, e.getHeaders())\n+        // }\n+        try {\n+            Location internalLocation = new Location(\"<internal>\", 0);\n+\n+            TryNode tryNode = new TryNode();\n+            tryNode.setLocation(internalLocation);\n+            tryNode.setBlockNode(blockNode);\n+\n+            CatchNode catchNode = new CatchNode();\n+            catchNode.setLocation(internalLocation);\n+\n+            tryNode.addCatchNode(catchNode);\n+\n+            DeclarationNode declarationNode = new DeclarationNode();\n+            declarationNode.setLocation(internalLocation);\n+            declarationNode.setDeclarationType(PainlessExplainError.class);\n+            declarationNode.setName(\"#painlessExplainError\");\n+            declarationNode.setRequiresDefault(false);\n+\n+            catchNode.setDeclarationNode(declarationNode);\n+\n+            BlockNode catchBlockNode = new BlockNode();\n+            catchBlockNode.setLocation(internalLocation);\n+            catchBlockNode.setAllEscape(true);\n+            catchBlockNode.setStatementCount(1);\n+\n+            catchNode.setBlockNode(catchBlockNode);\n+\n+            ThrowNode throwNode = new ThrowNode();\n+            throwNode.setLocation(internalLocation);\n+\n+            catchBlockNode.addStatementNode(throwNode);\n+\n+            UnboundCallNode unboundCallNode = new UnboundCallNode();\n+            unboundCallNode.setLocation(internalLocation);\n+            unboundCallNode.setExpressionType(ScriptException.class);\n+            unboundCallNode.setLocalFunction(new LocalFunction(\n+                            \"convertToScriptException\",\n+                            ScriptException.class,\n+                            Arrays.asList(Throwable.class, Map.class),\n+                            true,\n+                            false\n+                    )\n+            );\n+\n+            throwNode.setExpressionNode(unboundCallNode);\n+\n+            VariableNode variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(ScriptException.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            unboundCallNode.addArgumentNode(variableNode);\n+\n+            CallNode callNode = new CallNode();\n+            callNode.setLocation(internalLocation);\n+            callNode.setExpressionType(Map.class);\n+\n+            unboundCallNode.addArgumentNode(callNode);\n+\n+            variableNode = new VariableNode();\n+            variableNode.setLocation(internalLocation);\n+            variableNode.setExpressionType(PainlessExplainError.class);\n+            variableNode.setName(\"#painlessExplainError\");\n+\n+            callNode.setLeftNode(variableNode);\n+\n+            CallSubNode callSubNode = new CallSubNode();\n+            callSubNode.setLocation(internalLocation);\n+            callSubNode.setExpressionType(Map.class);\n+            callSubNode.setBox(PainlessExplainError.class);\n+            callSubNode.setMethod(new PainlessMethod(\n+                    PainlessExplainError.class.getMethod(\n+                            \"getHeaders\",\n+                            PainlessLookup.class),\n+                    PainlessExplainError.class,\n+                    null,\n+                    Collections.emptyList(),\n+                    null,\n+                    null,\n+                    null\n+            ));\n+\n+            callNode.setRightNode(callSubNode);\n+\n+            UnboundFieldNode unboundFieldNode = new UnboundFieldNode();\n+            unboundFieldNode.setLocation(internalLocation);\n+            unboundFieldNode.setExpressionType(PainlessLookup.class);\n+            unboundFieldNode.setName(\"$DEFINITION\");\n+            unboundFieldNode.setStatic(true);\n+\n+            callSubNode.addArgumentNode(unboundFieldNode);\n+\n+            for (Class<?> throwable : new Class<?>[] {\n+                    PainlessError.class, BootstrapMethodError.class, OutOfMemoryError.class, StackOverflowError.class, Exception.class}) {\n+\n+                String name = throwable.getSimpleName();\n+                name = \"#\" + Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                catchNode = new CatchNode();\n+                catchNode.setLocation(internalLocation);\n+\n+                tryNode.addCatchNode(catchNode);\n+\n+                declarationNode = new DeclarationNode();\n+                declarationNode.setLocation(internalLocation);\n+                declarationNode.setDeclarationType(throwable);\n+                declarationNode.setName(name);\n+                declarationNode.setRequiresDefault(false);\n+\n+                catchNode.setDeclarationNode(declarationNode);\n+\n+                catchBlockNode = new BlockNode();\n+                catchBlockNode.setLocation(internalLocation);\n+                catchBlockNode.setAllEscape(true);\n+                catchBlockNode.setStatementCount(1);\n+\n+                catchNode.setBlockNode(catchBlockNode);\n+\n+                throwNode = new ThrowNode();\n+                throwNode.setLocation(internalLocation);\n+\n+                catchBlockNode.addStatementNode(throwNode);\n+\n+                unboundCallNode = new UnboundCallNode();\n+                unboundCallNode.setLocation(internalLocation);\n+                unboundCallNode.setExpressionType(ScriptException.class);\n+                unboundCallNode.setLocalFunction(new LocalFunction(\n+                                \"convertToScriptException\",\n+                                ScriptException.class,\n+                                Arrays.asList(Throwable.class, Map.class),\n+                                true,\n+                                false\n+                        )\n+                );\n+\n+                throwNode.setExpressionNode(unboundCallNode);\n+\n+                variableNode = new VariableNode();\n+                variableNode.setLocation(internalLocation);\n+                variableNode.setExpressionType(ScriptException.class);\n+                variableNode.setName(name);\n+\n+                unboundCallNode.addArgumentNode(variableNode);\n+\n+                callNode = new CallNode();\n+                callNode.setLocation(internalLocation);\n+                callNode.setExpressionType(Map.class);\n+\n+                unboundCallNode.addArgumentNode(callNode);\n+\n+                StaticNode staticNode = new StaticNode();\n+                staticNode.setLocation(internalLocation);\n+                staticNode.setExpressionType(Collections.class);\n+\n+                callNode.setLeftNode(staticNode);\n+\n+                callSubNode = new CallSubNode();\n+                callSubNode.setLocation(internalLocation);\n+                callSubNode.setExpressionType(Map.class);\n+                callSubNode.setBox(Collections.class);\n+                callSubNode.setMethod(new PainlessMethod(\n+                        Collections.class.getMethod(\"emptyMap\"),\n+                        Collections.class,\n+                        null,\n+                        Collections.emptyList(),\n+                        null,\n+                        null,\n+                        null\n+                ));\n+\n+                callNode.setRightNode(callSubNode);\n+            }\n+\n+            blockNode = new BlockNode();\n+            blockNode.setLocation(blockNode.getLocation());\n+            blockNode.setAllEscape(blockNode.doAllEscape());\n+            blockNode.setStatementCount(blockNode.getStatementCount());\n+            blockNode.addStatementNode(tryNode);\n+\n+            executeFunctionNode.setBlockNode(blockNode);\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    protected DecorateExecutePhase() {", "originalCommit": "84f5754ffb2b867554eea9ae42d116231e67555c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNDM1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377734351", "bodyText": "Fixed.", "author": "jdconrad", "createdAt": "2020-02-11T16:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5NjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5OTE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377399175", "bodyText": "Would MemberFieldNode be a better name here?", "author": "rjernst", "createdAt": "2020-02-11T00:40:04Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/UnboundFieldNode.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.ir;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.Globals;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.symbol.ScopeTable;\n+\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+\n+public class UnboundFieldNode extends ExpressionNode {", "originalCommit": "84f5754ffb2b867554eea9ae42d116231e67555c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNDIxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377734211", "bodyText": "Yes, and fixed.", "author": "jdconrad", "createdAt": "2020-02-11T16:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5OTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5OTQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377399478", "bodyText": "Maybe we should rename this to MemberCallNode? The meaning of unbound is unclear", "author": "rjernst", "createdAt": "2020-02-11T00:41:15Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {\n+\n+    public static void phase(ScriptRoot scriptRoot, ClassNode classNode) {\n+        FunctionNode executeFunctionNode = null;\n+\n+        // look up the execute method for decoration\n+        for (FunctionNode functionNode : classNode.getFunctionsNodes()) {\n+            if (\"execute\".equals(functionNode.getName())) {\n+                executeFunctionNode = functionNode;\n+                break;\n+            }\n+        }\n+\n+        BlockNode blockNode = executeFunctionNode.getBlockNode();\n+\n+        // convert gets methods to a new set of inserted ir nodes as necessary -\n+        // requires the gets method name be modified from \"getExample\" to \"example\"\n+        // if a get method variable isn't used it's declaration node is removed from\n+        // the ir tree permanently so there is no frivolous variable slotting\n+        int statementIndex = 0;\n+\n+        while (statementIndex < blockNode.getStatementsNodes().size()) {\n+            StatementNode statementNode = blockNode.getStatementsNodes().get(statementIndex);\n+\n+            if (statementNode instanceof DeclarationNode) {\n+                DeclarationNode declarationNode = (DeclarationNode)statementNode;\n+                boolean isRemoved = false;\n+\n+                for (int getIndex = 0; getIndex < scriptRoot.getScriptClassInfo().getGetMethods().size(); ++getIndex) {\n+                    Class<?> returnType = scriptRoot.getScriptClassInfo().getGetReturns().get(getIndex);\n+                    Method getMethod = scriptRoot.getScriptClassInfo().getGetMethods().get(getIndex);\n+                    String name = getMethod.getName().substring(3);\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+\n+                    if (name.equals(declarationNode.getName())) {\n+                        if (scriptRoot.getUsedVariables().contains(name)) {\n+                                UnboundCallNode unboundCallNode = new UnboundCallNode();", "originalCommit": "84f5754ffb2b867554eea9ae42d116231e67555c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNDI4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377734283", "bodyText": "Yes, and fixed.", "author": "jdconrad", "createdAt": "2020-02-11T16:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5OTQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwMTM4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377401380", "bodyText": "This isn't really decorating execute (well the try/catch is, but it's still not decorating, it's wrapping in that case?). In the other case we have variables being converted to this.getXXX() calls...they seem unrelated, maybe they should be separate classes? In both these cases these seem to be things we need for correctness in the IR tree, so to me should be part of the creation of the IR tree, rather than phases operating on it. But I also appreciate this is just a step towards the overarching refactor, so if this frees up space to move towards that future, I'm fine with this as is for now.", "author": "rjernst", "createdAt": "2020-02-11T00:48:38Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/DecorateExecutePhase.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.UnboundCallNode;\n+import org.elasticsearch.painless.ir.UnboundFieldNode;\n+import org.elasticsearch.painless.ir.VariableNode;\n+import org.elasticsearch.painless.lookup.PainlessLookup;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+import org.elasticsearch.script.ScriptException;\n+import org.objectweb.asm.commons.Method;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * This injects additional ir nodes required to for\n+ * the \"execute\" method. This includes injection of ir nodes\n+ * to convert get methods into local variables for those\n+ * that are used and adds additional sandboxing by wrapping\n+ * the main \"execute\" block with several exceptions.\n+ */\n+public class DecorateExecutePhase {", "originalCommit": "84f5754ffb2b867554eea9ae42d116231e67555c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MTEwNA==", "url": "https://github.com/elastic/elasticsearch/pull/51954#discussion_r377741104", "bodyText": "I renamed this ScriptInjectionPhase for now. But as we discussed this will change significantly, and I agree with your assessments of correctness. I would like to note that my line of thought was the user tree is what requires semantic checking and the ir tree is semantically correct (always other than bugs). I will also consider correctness moving forward in that the ir tree should always be in a state that can be written to ASM as any given time. We will get there, but there's a bunch more work in between to clean up enough to make those changes.", "author": "jdconrad", "createdAt": "2020-02-11T16:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwMTM4MA=="}], "type": "inlineReview"}, {"oid": "bb4e48c3e0c301a294151a92dcaf69672801dd0c", "url": "https://github.com/elastic/elasticsearch/commit/bb4e48c3e0c301a294151a92dcaf69672801dd0c", "message": "Merge branch 'master' into trees6", "committedDate": "2020-02-11T16:02:33Z", "type": "commit"}, {"oid": "10d8757a1ae0e457251ebc4bc5ae9056c7126971", "url": "https://github.com/elastic/elasticsearch/commit/10d8757a1ae0e457251ebc4bc5ae9056c7126971", "message": "response to PR comments", "committedDate": "2020-02-11T16:37:08Z", "type": "commit"}]}