{"pr_number": 51123, "pr_title": "Password-protected Keystore Feature Branch PR", "pr_createdAt": "2020-01-16T19:07:43Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51123", "timeline": [{"oid": "b0be1805671569489d9340f7faeeafe67ebadbbd", "url": "https://github.com/elastic/elasticsearch/commit/b0be1805671569489d9340f7faeeafe67ebadbbd", "message": "Password Protected Keystore (Feature Branch) (cleaned up) (#49268)\n\n* Reload secure settings with password (#43197)\r\n\r\nIf a password is not set, we assume an empty string to be\r\ncompatible with previous behavior.\r\nOnly allow the reload to be broadcast to other nodes if TLS is\r\nenabled for the transport layer.\r\n\r\n* Add passphrase support to elasticsearch-keystore (#38498)\r\n\r\nThis change adds support for keystore passphrases to all subcommands\r\nof the elasticsearch-keystore cli tool and adds a subcommand for\r\nchanging the passphrase of an existing keystore.\r\nThe work to read the passphrase in Elasticsearch when\r\nloading, which will be addressed in a different PR.\r\n\r\nSubcommands of elasticsearch-keystore can handle (open and create)\r\npassphrase protected keystores\r\n\r\nWhen reading a keystore, a user is only prompted for a passphrase\r\nonly if the keystore is passphrase protected.\r\n\r\nWhen creating a keystore, a user is allowed (default behavior) to create one with an\r\nempty passphrase\r\n\r\nPassphrase can be set to be empty when changing/setting it for an\r\nexisting keystore\r\n\r\nRelates to: #32691\r\nSupersedes: #37472\r\n\r\n* Restore behavior for force parameter (#44847)\r\n\r\nTurns out that the behavior of `-f` for the add and add-file sub\r\ncommands where it would also forcibly create the keystore if it\r\ndidn't exist, was by design - although undocumented.\r\nThis change restores that behavior auto-creating a keystore that\r\nis not password protected if the force flag is used. The force\r\nOptionSpec is moved to the BaseKeyStoreCommand as we will presumably\r\nwant to maintain the same behavior in any other command that takes\r\na force option.\r\n\r\n*  Handle pwd protected keystores in all CLI tools  (#45289)\r\n\r\nThis change ensures that `elasticsearch-setup-passwords` and\r\n`elasticsearch-saml-metadata` can handle a password protected\r\nelasticsearch.keystore.\r\nFor setup passwords the user would be prompted to add the\r\nelasticsearch keystore password upon running the tool. There is no\r\noption to pass the password as a parameter as we assume the user is\r\npresent in order to enter the desired passwords for the built-in\r\nusers.\r\nFor saml-metadata, we prompt for the keystore password at all times\r\neven though we'd only need to read something from the keystore when\r\nthere is a signing or encryption configuration.\r\n\r\n* Modify docs for setup passwords and saml metadata cli (#45797)\r\n\r\nAdds a sentence in the documentation of `elasticsearch-setup-passwords`\r\nand `elasticsearch-saml-metadata` to describe that users would be\r\nprompted for the keystore's password when running these CLI tools,\r\nwhen the keystore is password protected.\r\n\r\nCo-Authored-By: Lisa Cawley <lcawley@elastic.co>\r\n\r\n* Elasticsearch keystore passphrase for startup scripts (#44775)\r\n\r\nThis commit allows a user to provide a keystore password on Elasticsearch\r\nstartup, but only prompts when the keystore exists and is encrypted.\r\n\r\nThe entrypoint in Java code is standard input. When the Bootstrap class is\r\nchecking for secure keystore settings, it checks whether or not the keystore\r\nis encrypted. If so, we read one line from standard input and use this as the\r\npassword. For simplicity's sake, we allow a maximum passphrase length of 128\r\ncharacters. (This is an arbitrary limit and could be increased or eliminated.\r\nIt is also enforced in the keystore tools, so that a user can't create a\r\npassword that's too long to enter at startup.)\r\n\r\nIn order to provide a password on standard input, we have to account for four\r\ndifferent ways of starting Elasticsearch: the bash startup script, the Windows\r\nbatch startup script, systemd startup, and docker startup. We use wrapper\r\nscripts to reduce systemd and docker to the bash case: in both cases, a\r\nwrapper script can read a passphrase from the filesystem and pass it to the\r\nbash script.\r\n\r\nIn order to simplify testing the need for a passphrase, I have added a\r\nhas-passwd command to the keystore tool. This command can run silently, and\r\nexit with status 0 when the keystore has a password. It exits with status 1 if\r\nthe keystore doesn't exist or exists and is unencrypted.\r\n\r\nA good deal of the code-change in this commit has to do with refactoring\r\npackaging tests to cleanly use the same tests for both the \"archive\" and the\r\n\"package\" cases. This required not only moving tests around, but also adding\r\nsome convenience methods for an abstraction layer over distribution-specific\r\ncommands.\r\n\r\nI will write some user-facing documentation for these changes in a follow-up\r\ncommit.\r\n\r\n* Adjust docs for password protected keystore (#45054)\r\n\r\nThis commit adds relevant parts in the elasticsearch-keystore\r\nsub-commands reference docs and in the reload secure settings API\r\ndoc.\r\n\r\n* Cleanup after feature branch reconstruction\r\n\r\nThe feature branch for the password-protected keystore, due to an\r\naccident, contains a large number of unrelated commits. In order to get\r\na cleaner merge, I've cherry-picked the main commits that went into the\r\nfeature branch against a branch derived from master \u2014 essentially, a\r\nrebase onto master. We've ignored some tests that will addressed in\r\nfollow-up PRs to the feature branch.", "committedDate": "2019-12-11T22:05:57Z", "type": "commit"}, {"oid": "fab3d56f87df74cf44f32348c5a3528dc4fb92cb", "url": "https://github.com/elastic/elasticsearch/commit/fab3d56f87df74cf44f32348c5a3528dc4fb92cb", "message": "Merging master to feature branch", "committedDate": "2019-12-12T21:20:51Z", "type": "commit"}, {"oid": "d64ab04143212d2d0b9a4fd061ce9e06b5a09ab4", "url": "https://github.com/elastic/elasticsearch/commit/d64ab04143212d2d0b9a4fd061ce9e06b5a09ab4", "message": "Merge branch 'master' into feature-pwd-protected-keystore-2", "committedDate": "2019-12-13T20:31:19Z", "type": "commit"}, {"oid": "35b4f5287df7a8910c7c58f0f744b77317fdb18b", "url": "https://github.com/elastic/elasticsearch/commit/35b4f5287df7a8910c7c58f0f744b77317fdb18b", "message": "Fix failing Keystore Passphrase test for feature branch (#50154)\n\nOne problem with the passphrase-from-file tests, as written, is that\r\nthey would leave a SystemD environment variable set when they failed,\r\nand this setting would cause elasticsearch startup to fail for other\r\ntests as well. By using a try-finally, I hope that these tests will fail\r\nmore gracefully.\r\n\r\nIt appears that our Fedora and Ubuntu environments may be configured to\r\nstore journald information under /var rather than under /run, so that it\r\nwill persist between boots. Our destructive tests that read from the\r\njournal need to account for this in order to avoid trying to limit the\r\noutput we check in tests.", "committedDate": "2019-12-13T21:55:10Z", "type": "commit"}, {"oid": "6695e5366b38666c1f5365c2f234641731724b37", "url": "https://github.com/elastic/elasticsearch/commit/6695e5366b38666c1f5365c2f234641731724b37", "message": "Merge master into feature branch", "committedDate": "2020-01-02T20:59:13Z", "type": "commit"}, {"oid": "1284eccf5d49c107e8df99e68910d25f90c42ed7", "url": "https://github.com/elastic/elasticsearch/commit/1284eccf5d49c107e8df99e68910d25f90c42ed7", "message": "Run keystore management tests on docker distros (#50610)\n\n* Add Docker handling to PackagingTestCase\r\n\r\nKeystore tests need to be able to run in the Docker case. We can do this\r\nby using a DockerShell instead of a plain Shell when Docker is running.\r\n\r\n* Improve ES startup check for docker\r\n\r\nPreviously we were checking truncated output for the packaged JDK as\r\nan indication that Elasticsearch had started. With new preliminary\r\npassword checks, we might get a false positive from ES keystore\r\ncommands, so we have to check specifically that the Elasticsearch\r\nclass from the Bootstrap package is what's running.", "committedDate": "2020-01-08T14:22:00Z", "type": "commit"}, {"oid": "1c656f2477b9f9e226ff521c9affcaffe2b9150f", "url": "https://github.com/elastic/elasticsearch/commit/1c656f2477b9f9e226ff521c9affcaffe2b9150f", "message": "Merging master into feature branch", "committedDate": "2020-01-08T14:49:38Z", "type": "commit"}, {"oid": "3d7cf1f4bccfeaa30cb11ad96e9fa291d0a36276", "url": "https://github.com/elastic/elasticsearch/commit/3d7cf1f4bccfeaa30cb11ad96e9fa291d0a36276", "message": "Test password-protected keystore with Docker (#50803)\n\nThis commit adds two tests for the case where we mount a\r\npassword-protected keystore into a Docker container and provide a\r\npassword via a Docker environment variable.\r\n\r\nWe also fix a logging bug where we were logging the identifier for an\r\narray of strings rather than the contents of that array.", "committedDate": "2020-01-10T16:30:13Z", "type": "commit"}, {"oid": "93ca7e6ab6b3b63bab584faad8fc3b663ff146db", "url": "https://github.com/elastic/elasticsearch/commit/93ca7e6ab6b3b63bab584faad8fc3b663ff146db", "message": "Merging changes from master", "committedDate": "2020-01-13T22:52:24Z", "type": "commit"}, {"oid": "663fc0b94dc04d4177dfef0d1e337d4190f102ca", "url": "https://github.com/elastic/elasticsearch/commit/663fc0b94dc04d4177dfef0d1e337d4190f102ca", "message": "Add documentation for keystore startup prompting (#50821)\n\nWhen a keystore is password-protected, Elasticsearch will prompt at\r\nstartup. This commit adds documentation for this prompt for the archive,\r\nsystemd, and Docker cases.\r\n\r\nCo-authored-by: Lisa Cawley <lcawley@elastic.co>", "committedDate": "2020-01-14T20:14:31Z", "type": "commit"}, {"oid": "91cb2c95b46bd67b9bc883f3a356dd086078f490", "url": "https://github.com/elastic/elasticsearch/commit/91cb2c95b46bd67b9bc883f3a356dd086078f490", "message": "Merge branch 'master' into feature-pwd-protected-keystore-2", "committedDate": "2020-01-15T13:43:00Z", "type": "commit"}, {"oid": "6238d854a2f95ee47fcf5b74ceec09c420658d90", "url": "https://github.com/elastic/elasticsearch/commit/6238d854a2f95ee47fcf5b74ceec09c420658d90", "message": "Warn when unable to upgrade keystore on debian (#51011)\n\nFor Red Hat RPM upgrades, we warn if we can't upgrade the keystore. This\r\ncommit brings the same logic to the code for Debian packages. See the\r\nposttrans file for gets executed for RPMs.", "committedDate": "2020-01-15T21:15:35Z", "type": "commit"}, {"oid": "75bdbdd95f9b6bfdbf60c9b72768fcf19d08e60e", "url": "https://github.com/elastic/elasticsearch/commit/75bdbdd95f9b6bfdbf60c9b72768fcf19d08e60e", "message": "Merge master into feature branch", "committedDate": "2020-01-16T17:35:16Z", "type": "commit"}, {"oid": "0b2d5d1eec153689786a0733c1240e2ec5e78056", "url": "https://github.com/elastic/elasticsearch/commit/0b2d5d1eec153689786a0733c1240e2ec5e78056", "message": "Merge branch 'feature-pwd-protected-keystore-2' of github.com:elastic/elasticsearch into feature-pwd-protected-keystore-2", "committedDate": "2020-01-16T17:36:12Z", "type": "commit"}, {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "url": "https://github.com/elastic/elasticsearch/commit/81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "message": "Increase Docker startup wait time for tests", "committedDate": "2020-01-16T21:44:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2OTQwNg==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r367969406", "bodyText": "Should be we capitalizing \"elasticsearch\" here, and elsewhere?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {\n          \n          \n            \n                            if (terminal.promptYesNo(\"An Elasticsearch keystore already exists. Overwrite?\", false) == false) {", "author": "pugnascotia", "createdAt": "2020-01-17T14:42:50Z", "path": "distribution/tools/keystore-cli/src/main/java/org/elasticsearch/common/settings/CreateKeyStoreCommand.java", "diffHunk": "@@ -21,41 +21,44 @@\n \n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.Arrays;\n \n import joptsimple.OptionSet;\n-import org.elasticsearch.cli.EnvironmentAwareCommand;\n+import joptsimple.OptionSpec;\n+import org.elasticsearch.cli.ExitCodes;\n+import org.elasticsearch.cli.KeyStoreAwareCommand;\n import org.elasticsearch.cli.Terminal;\n+import org.elasticsearch.cli.UserException;\n import org.elasticsearch.env.Environment;\n \n /**\n- * A subcommand for the keystore cli to create a new keystore.\n+ * A sub-command for the keystore cli to create a new keystore.\n  */\n-class CreateKeyStoreCommand extends EnvironmentAwareCommand {\n+class CreateKeyStoreCommand extends KeyStoreAwareCommand {\n+\n+    private final OptionSpec<Void> passwordOption;\n \n     CreateKeyStoreCommand() {\n         super(\"Creates a new elasticsearch keystore\");\n+        this.passwordOption = parser.acceptsAll(Arrays.asList(\"p\", \"password\"), \"Prompt for password to encrypt the keystore\");\n     }\n \n     @Override\n     protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {\n-        Path keystoreFile = KeyStoreWrapper.keystorePath(env.configFile());\n-        if (Files.exists(keystoreFile)) {\n-            if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {\n-                terminal.println(\"Exiting without creating keystore.\");\n-                return;\n+        try (SecureString password = options.has(passwordOption) ?\n+            readPassword(terminal, true) : new SecureString(new char[0])) {\n+            Path keystoreFile = KeyStoreWrapper.keystorePath(env.configFile());\n+            if (Files.exists(keystoreFile)) {\n+                if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1MDE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369450191", "bodyText": "I think we use non-capitalized elasticsearch everywhere else in our logs, prompts ,etc.", "author": "jkakavas", "createdAt": "2020-01-22T09:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2OTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNzg0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368017849", "bodyText": "Nit-pick - I first read this test name as meaning that the file being added doesn't exist. Could we tweak it, e.g.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testForceNonExistent() throws Exception {\n          \n          \n            \n                public void testForceDoesNotAlreadyExist() throws Exception {\n          \n      \n    \n    \n  \n\nMore generally, it'd be great if these tests had Javadoc comments that briefly explained each scenario / expectation, but I'll leave that up to you.", "author": "pugnascotia", "createdAt": "2020-01-17T16:15:56Z", "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddFileKeyStoreCommandTests.java", "diffHunk": "@@ -53,110 +53,156 @@ private Path createRandomFile() throws IOException {\n         return file;\n     }\n \n-    private void addFile(KeyStoreWrapper keystore, String setting, Path file) throws Exception {\n+    private void addFile(KeyStoreWrapper keystore, String setting, Path file, String password) throws Exception {\n         keystore.setFile(setting, Files.readAllBytes(file));\n-        keystore.save(env.configFile(), new char[0]);\n+        keystore.save(env.configFile(), password.toCharArray());\n     }\n \n-    public void testMissingPromptCreate() throws Exception {\n+    public void testMissingCreateWithEmptyPasswordWhenPrompted() throws Exception {\n+        String password = \"\";\n         Path file1 = createRandomFile();\n         terminal.addTextInput(\"y\");\n         execute(\"foo\", file1.toString());\n-        assertSecureFile(\"foo\", file1);\n+        assertSecureFile(\"foo\", file1, password);\n     }\n \n-    public void testMissingForceCreate() throws Exception {\n+    public void testMissingCreateWithEmptyPasswordWithoutPromptIfForced() throws Exception {\n+        String password = \"\";\n         Path file1 = createRandomFile();\n-        terminal.addSecretInput(\"bar\");\n         execute(\"-f\", \"foo\", file1.toString());\n-        assertSecureFile(\"foo\", file1);\n+        assertSecureFile(\"foo\", file1, password);\n     }\n \n     public void testMissingNoCreate() throws Exception {\n+        terminal.addSecretInput(randomFrom(\"\", \"keystorepassword\"));\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\");\n         assertNull(KeyStoreWrapper.load(env.configFile()));\n     }\n \n     public void testOverwritePromptDefault() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file, password);\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"\");\n         execute(\"foo\", \"path/dne\");\n-        assertSecureFile(\"foo\", file);\n+        assertSecureFile(\"foo\", file, password);\n     }\n \n     public void testOverwritePromptExplicitNo() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file, password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\", \"path/dne\");\n-        assertSecureFile(\"foo\", file);\n+        assertSecureFile(\"foo\", file, password);\n     }\n \n     public void testOverwritePromptExplicitYes() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"y\");\n         Path file2 = createRandomFile();\n         execute(\"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testOverwriteForceShort() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n         Path file2 = createRandomFile();\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         execute(\"-f\", \"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testOverwriteForceLong() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n         Path file2 = createRandomFile();\n+        terminal.addSecretInput(password);\n         execute(\"--force\", \"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testForceNonExistent() throws Exception {", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1NTQ5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369455493", "bodyText": "I think this is a generic problem for a lot of our tests. It's not quite obvious all the time what the test does and the method name can only have so many words in it. However, very few of our tests have javadocs.\nIn this case I think we can get away with editing the method names but feel free to argue against it", "author": "jkakavas", "createdAt": "2020-01-22T09:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNzg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTA1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368021053", "bodyText": "What happened to these tests?", "author": "pugnascotia", "createdAt": "2020-01-17T16:22:39Z", "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddStringKeyStoreCommandTests.java", "diffHunk": "@@ -70,105 +80,92 @@ public void testMissingNoCreate() throws Exception {\n     }\n \n     public void testOverwritePromptDefault() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitNo() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitYes() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n         terminal.addTextInput(\"y\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceShort() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"-f\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceLong() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"and yet another secret value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"and yet another secret value\");\n+        assertSecureString(\"foo\", \"and yet another secret value\", password);\n     }\n \n     public void testForceNonExistent() throws Exception {\n-        createKeystore(\"\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password);\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"value\");\n+        assertSecureString(\"foo\", \"value\", password);\n     }\n \n     public void testPromptForValue() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"secret value\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"secret value\");\n+        assertSecureString(\"foo\", \"secret value\", password);\n     }\n \n     public void testStdinShort() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 1\");\n         execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 1\");\n+        assertSecureString(\"foo\", \"secret value 1\", password);\n     }\n \n     public void testStdinLong() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 2\");\n         execute(\"--stdin\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 2\");\n-    }\n-\n-    public void testStdinNoInput() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"\");\n-    }\n-\n-    public void testStdinInputWithLineBreaks() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\n\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testStdinInputWithCarriageReturn() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\r\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testAddUtf8String() throws Exception {", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxODczMg==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369418732", "bodyText": "These were removed in #38498 but apparently by mistake, I don't remember removing them for a reason. I'll push them back in", "author": "jkakavas", "createdAt": "2020-01-22T08:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQzNDY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369434673", "bodyText": "Good catch @pugnascotia ! Not only these were removed by mistake, but the removal was hiding a bug \ud83d\ude4f", "author": "jkakavas", "createdAt": "2020-01-22T08:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNjIyMg==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368026222", "bodyText": "Maybe not hard-code the expected exit code in the message? Very nit-picky, I realise.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(\"Exit code should be 1\", HasPasswordKeyStoreCommand.NO_PASSWORD_EXIT_CODE, e.exitCode);\n          \n          \n            \n                    assertEquals(\"Unexpected exit code\", HasPasswordKeyStoreCommand.NO_PASSWORD_EXIT_CODE, e.exitCode);", "author": "pugnascotia", "createdAt": "2020-01-17T16:32:54Z", "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/HasPasswordKeyStoreCommandTests.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.settings;\n+\n+import org.elasticsearch.cli.Command;\n+import org.elasticsearch.cli.UserException;\n+import org.elasticsearch.env.Environment;\n+\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.emptyString;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class HasPasswordKeyStoreCommandTests extends KeyStoreCommandTestCase {\n+    @Override\n+    protected Command newCommand() {\n+        return new HasPasswordKeyStoreCommand() {\n+            @Override\n+            protected Environment createEnv(Map<String, String> settings) throws UserException {\n+                return env;\n+            }\n+        };\n+    }\n+\n+    public void testFailsWithNoKeystore() throws Exception {\n+        UserException e = expectThrows(UserException.class, this::execute);\n+        assertEquals(\"Exit code should be 1\", HasPasswordKeyStoreCommand.NO_PASSWORD_EXIT_CODE, e.exitCode);", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzOTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368039147", "bodyText": "Should we extract some of the other standard error messages too?", "author": "pugnascotia", "createdAt": "2020-01-17T16:59:38Z", "path": "qa/os/src/test/java/org/elasticsearch/packaging/test/KeystoreManagementTests.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.packaging.test;\n+\n+import org.elasticsearch.packaging.util.Distribution;\n+import org.elasticsearch.packaging.util.Docker;\n+import org.elasticsearch.packaging.util.FileUtils;\n+import org.elasticsearch.packaging.util.Installation;\n+import org.elasticsearch.packaging.util.Platforms;\n+import org.elasticsearch.packaging.util.ServerUtils;\n+import org.elasticsearch.packaging.util.Shell;\n+import org.junit.Ignore;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Map;\n+\n+import static org.elasticsearch.packaging.util.Archives.ARCHIVE_OWNER;\n+import static org.elasticsearch.packaging.util.Archives.installArchive;\n+import static org.elasticsearch.packaging.util.Archives.verifyArchiveInstallation;\n+import static org.elasticsearch.packaging.util.Docker.assertPermissionsAndOwnership;\n+import static org.elasticsearch.packaging.util.Docker.runContainer;\n+import static org.elasticsearch.packaging.util.Docker.runContainerExpectingFailure;\n+import static org.elasticsearch.packaging.util.Docker.waitForElasticsearch;\n+import static org.elasticsearch.packaging.util.Docker.waitForPathToExist;\n+import static org.elasticsearch.packaging.util.FileMatcher.Fileness.File;\n+import static org.elasticsearch.packaging.util.FileMatcher.file;\n+import static org.elasticsearch.packaging.util.FileMatcher.p660;\n+import static org.elasticsearch.packaging.util.FileUtils.getTempDir;\n+import static org.elasticsearch.packaging.util.FileUtils.rm;\n+import static org.elasticsearch.packaging.util.Packages.assertInstalled;\n+import static org.elasticsearch.packaging.util.Packages.assertRemoved;\n+import static org.elasticsearch.packaging.util.Packages.installPackage;\n+import static org.elasticsearch.packaging.util.Packages.verifyPackageInstallation;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;\n+\n+public class KeystoreManagementTests extends PackagingTestCase {\n+\n+    private static final String PASSWORD_ERROR_MESSAGE = \"Provided keystore password was incorrect\";", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0Mjk4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368042987", "bodyText": "Is it not sufficient to just ensure that Elasticsearch has started? Do we need to also run the tests?", "author": "pugnascotia", "createdAt": "2020-01-17T17:08:21Z", "path": "qa/os/src/test/java/org/elasticsearch/packaging/test/KeystoreManagementTests.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.packaging.test;\n+\n+import org.elasticsearch.packaging.util.Distribution;\n+import org.elasticsearch.packaging.util.Docker;\n+import org.elasticsearch.packaging.util.FileUtils;\n+import org.elasticsearch.packaging.util.Installation;\n+import org.elasticsearch.packaging.util.Platforms;\n+import org.elasticsearch.packaging.util.ServerUtils;\n+import org.elasticsearch.packaging.util.Shell;\n+import org.junit.Ignore;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Map;\n+\n+import static org.elasticsearch.packaging.util.Archives.ARCHIVE_OWNER;\n+import static org.elasticsearch.packaging.util.Archives.installArchive;\n+import static org.elasticsearch.packaging.util.Archives.verifyArchiveInstallation;\n+import static org.elasticsearch.packaging.util.Docker.assertPermissionsAndOwnership;\n+import static org.elasticsearch.packaging.util.Docker.runContainer;\n+import static org.elasticsearch.packaging.util.Docker.runContainerExpectingFailure;\n+import static org.elasticsearch.packaging.util.Docker.waitForElasticsearch;\n+import static org.elasticsearch.packaging.util.Docker.waitForPathToExist;\n+import static org.elasticsearch.packaging.util.FileMatcher.Fileness.File;\n+import static org.elasticsearch.packaging.util.FileMatcher.file;\n+import static org.elasticsearch.packaging.util.FileMatcher.p660;\n+import static org.elasticsearch.packaging.util.FileUtils.getTempDir;\n+import static org.elasticsearch.packaging.util.FileUtils.rm;\n+import static org.elasticsearch.packaging.util.Packages.assertInstalled;\n+import static org.elasticsearch.packaging.util.Packages.assertRemoved;\n+import static org.elasticsearch.packaging.util.Packages.installPackage;\n+import static org.elasticsearch.packaging.util.Packages.verifyPackageInstallation;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;\n+\n+public class KeystoreManagementTests extends PackagingTestCase {\n+\n+    private static final String PASSWORD_ERROR_MESSAGE = \"Provided keystore password was incorrect\";\n+\n+    /** Test initial archive state */\n+    public void test10InstallArchiveDistribution() throws Exception {\n+        assumeTrue(distribution().isArchive());\n+\n+        installation = installArchive(sh, distribution);\n+        verifyArchiveInstallation(installation, distribution());\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate missing keystore\",\n+            r.stderr, containsString(\"ERROR: Elasticsearch keystore not found\"));\n+    }\n+\n+    /** Test initial package state */\n+    public void test11InstallPackageDistribution() throws Exception {\n+        assumeTrue(distribution().isPackage());\n+\n+        assertRemoved(distribution);\n+        installation = installPackage(sh, distribution);\n+        assertInstalled(distribution);\n+        verifyPackageInstallation(installation, distribution, sh);\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate unprotected keystore\",\n+            r.stderr, containsString(\"ERROR: Keystore is not password-protected\"));\n+        Shell.Result r2 = bin.keystoreTool.run(\"list\");\n+        assertThat(r2.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    /** Test initial Docker state */\n+    public void test12InstallDockerDistribution() throws Exception {\n+        assumeTrue(distribution().isDocker());\n+\n+        installation = Docker.runContainer(distribution());\n+\n+        try {\n+            waitForPathToExist(installation.config(\"elasticsearch.keystore\"));\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate unprotected keystore\",\n+            r.stdout, containsString(\"ERROR: Keystore is not password-protected\"));\n+        Shell.Result r2 = bin.keystoreTool.run(\"list\");\n+        assertThat(r2.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test20CreateKeystoreManually() throws Exception {\n+        rmKeystoreIfExists();\n+        createKeystore();\n+\n+        final Installation.Executables bin = installation.executables();\n+        verifyKeystorePermissions();\n+\n+        Shell.Result r = bin.keystoreTool.run(\"list\");\n+        assertThat(r.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test30AutoCreateKeystore() throws Exception {\n+        assumeTrue(\"Packages and docker are installed with a keystore file\", distribution.isArchive());\n+        rmKeystoreIfExists();\n+\n+        startElasticsearch();\n+        stopElasticsearch();\n+\n+        Platforms.onWindows(() -> sh.chown(installation.config(\"elasticsearch.keystore\")));\n+\n+        verifyKeystorePermissions();\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = bin.keystoreTool.run(\"list\");\n+        assertThat(r.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test40KeystorePasswordOnStandardInput() throws Exception {\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        String password = \"^|<>\\\\&exit\"; // code insertion on Windows if special characters are not escaped\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        awaitElasticsearchStartup(startElasticsearchStandardInputPassword(password));\n+        ServerUtils.runElasticsearchTests();\n+        stopElasticsearch();\n+    }\n+\n+    public void test41WrongKeystorePasswordOnStandardInput() {\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        assertPasswordProtectedKeystore();\n+\n+        Shell.Result result = startElasticsearchStandardInputPassword(\"wrong\");\n+        assertElasticsearchFailure(result, PASSWORD_ERROR_MESSAGE);\n+    }\n+\n+    @Ignore /* Ignored for feature branch, awaits fix: https://github.com/elastic/elasticsearch/issues/49340 */\n+    public void test42KeystorePasswordOnTty() throws Exception {\n+        assumeTrue(\"expect command isn't on Windows\",\n+            distribution.platform != Distribution.Platform.WINDOWS);\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        String password = \"keystorepass\";\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        awaitElasticsearchStartup(startElasticsearchTtyPassword(password));\n+        ServerUtils.runElasticsearchTests();\n+        stopElasticsearch();\n+    }\n+\n+    @Ignore /* Ignored for feature branch, awaits fix: https://github.com/elastic/elasticsearch/issues/49340 */\n+    public void test43WrongKeystorePasswordOnTty() throws Exception {\n+        assumeTrue(\"expect command isn't on Windows\",\n+            distribution.platform != Distribution.Platform.WINDOWS);\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        assertPasswordProtectedKeystore();\n+\n+        Shell.Result result = startElasticsearchTtyPassword(\"wrong\");\n+        // error will be on stdout for \"expect\"\n+        assertThat(result.stdout, containsString(PASSWORD_ERROR_MESSAGE));\n+    }\n+\n+    public void test50KeystorePasswordFromFile() throws Exception {\n+        assumeTrue(\"only for systemd\", Platforms.isSystemd() && distribution().isPackage());\n+        String password = \"!@#$%^&*()|\\\\<>/?\";\n+        Path esKeystorePassphraseFile = installation.config.resolve(\"eks\");\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        try {\n+            sh.run(\"sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=\" + esKeystorePassphraseFile);\n+\n+            Files.createFile(esKeystorePassphraseFile);\n+            Files.write(esKeystorePassphraseFile,\n+                (password + System.lineSeparator()).getBytes(StandardCharsets.UTF_8),\n+                StandardOpenOption.WRITE);\n+\n+            startElasticsearch();\n+            ServerUtils.runElasticsearchTests();\n+            stopElasticsearch();\n+        } finally {\n+            sh.run(\"sudo systemctl unset-environment ES_KEYSTORE_PASSPHRASE_FILE\");\n+        }\n+    }\n+\n+    public void test51WrongKeystorePasswordFromFile() throws Exception {\n+        assumeTrue(\"only for systemd\", Platforms.isSystemd() && distribution().isPackage());\n+        Path esKeystorePassphraseFile = installation.config.resolve(\"eks\");\n+\n+        assertPasswordProtectedKeystore();\n+\n+        try {\n+            sh.run(\"sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=\" + esKeystorePassphraseFile);\n+\n+            if (Files.exists(esKeystorePassphraseFile)) {\n+                rm(esKeystorePassphraseFile);\n+            }\n+\n+            Files.createFile(esKeystorePassphraseFile);\n+            Files.write(esKeystorePassphraseFile,\n+                (\"wrongpassword\" + System.lineSeparator()).getBytes(StandardCharsets.UTF_8),\n+                StandardOpenOption.WRITE);\n+\n+            Shell.Result result = runElasticsearchStartCommand();\n+            assertElasticsearchFailure(result, PASSWORD_ERROR_MESSAGE);\n+        } finally {\n+            sh.run(\"sudo systemctl unset-environment ES_KEYSTORE_PASSPHRASE_FILE\");\n+        }\n+    }\n+\n+    /**\n+     * Check that we can mount a password-protected keystore to a docker image\n+     * and provide a password via an environment variable.\n+     */\n+    public void test60DockerEnvironmentVariablePassword() throws Exception {\n+        assumeTrue(distribution().isDocker());\n+        String password = \"password\";\n+        Path dockerKeystore = installation.config(\"elasticsearch.keystore\");\n+\n+        Path localKeystoreFile = getKeystoreFileFromDockerContainer(password, dockerKeystore);\n+\n+        // restart ES with password and mounted keystore\n+        Map<Path, Path> volumes = Map.of(localKeystoreFile, dockerKeystore);\n+        Map<String, String> envVars = Map.of(\"KEYSTORE_PASSWORD\", password);\n+        runContainer(distribution(), volumes, envVars);\n+        waitForElasticsearch(installation);\n+        ServerUtils.runElasticsearchTests();", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgwNzk3MA==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369807970", "bodyText": "I don't see the downside in checking that Elasticsearch is not just running but minimally functional as well.", "author": "williamrandolph", "createdAt": "2020-01-22T21:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0Mjk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxOTY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368219692", "bodyText": "Any particular reason we're not using '\\0' here, like we do in other places that we zero out an array?", "author": "pugnascotia", "createdAt": "2020-01-18T10:26:08Z", "path": "server/src/main/java/org/elasticsearch/cli/KeyStoreAwareCommand.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cli;\n+\n+import joptsimple.OptionSet;\n+import org.elasticsearch.common.settings.KeyStoreWrapper;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.env.Environment;\n+\n+import javax.crypto.AEADBadTagException;\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+import java.util.Arrays;\n+\n+/**\n+ * An {@link org.elasticsearch.cli.EnvironmentAwareCommand} that needs to access the elasticsearch keystore, possibly\n+ * decrypting it if it is password protected.\n+ */\n+public abstract class KeyStoreAwareCommand extends EnvironmentAwareCommand {\n+    public KeyStoreAwareCommand(String description) {\n+        super(description);\n+    }\n+\n+    /** Arbitrarily chosen maximum passphrase length */\n+    public static final int MAX_PASSPHRASE_LENGTH = 128;\n+\n+    /**\n+     * Reads the keystore password from the {@link Terminal}, prompting for verification where applicable and returns it as a\n+     * {@link SecureString}.\n+     *\n+     * @param terminal         the terminal to use for user inputs\n+     * @param withVerification whether the user should be prompted for password verification\n+     * @return a SecureString with the password the user entered\n+     * @throws UserException If the user is prompted for verification and enters a different password\n+     */\n+    protected static SecureString readPassword(Terminal terminal, boolean withVerification) throws UserException {\n+        final char[] passwordArray;\n+        if (withVerification) {\n+            passwordArray = terminal.readSecret(\"Enter new password for the elasticsearch keystore (empty for no password): \",\n+                MAX_PASSPHRASE_LENGTH);\n+            char[] passwordVerification = terminal.readSecret(\"Enter same password again: \",\n+                MAX_PASSPHRASE_LENGTH);\n+            if (Arrays.equals(passwordArray, passwordVerification) == false) {\n+                throw new UserException(ExitCodes.DATA_ERROR, \"Passwords are not equal, exiting.\");\n+            }\n+            Arrays.fill(passwordVerification, '\\u0000');", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMzU1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369413553", "bodyText": "No reason, both are the null character denoted as a decimal or a hexadecimal. I think I have introduced all the \\u0000 instances as this is a convention I had been using", "author": "jkakavas", "createdAt": "2020-01-22T08:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxOTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMDM1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368220357", "bodyText": "Tiny nit: you can use hasSize.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    assertThat(nodesMap.size(), equalTo(1));\n          \n          \n            \n                                    assertThat(nodesMap, hasSize(1));", "author": "pugnascotia", "createdAt": "2020-01-18T10:45:31Z", "path": "server/src/test/java/org/elasticsearch/action/admin/ReloadSecureSettingsIT.java", "diffHunk": "@@ -109,83 +115,213 @@ public void testInvalidKeystoreFile() throws Exception {\n             Files.copy(keystore, KeyStoreWrapper.keystorePath(environment.configFile()), StandardCopyOption.REPLACE_EXISTING);\n         }\n         final CountDownLatch latch = new CountDownLatch(1);\n-        client().admin().cluster().prepareReloadSecureSettings().execute(\n-                new ActionListener<NodesReloadSecureSettingsResponse>() {\n-                    @Override\n-                    public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n-                        try {\n-                            assertThat(nodesReloadResponse, notNullValue());\n-                            final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n-                            assertThat(nodesMap.size(), equalTo(cluster().size()));\n-                            for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n-                                assertThat(nodeResponse.reloadException(), notNullValue());\n-                            }\n-                        } catch (final AssertionError e) {\n-                            reloadSettingsError.set(e);\n-                        } finally {\n-                            latch.countDown();\n+        final SecureString emptyPassword = randomBoolean() ? new SecureString(new char[0]) : null;\n+        client().admin().cluster().prepareReloadSecureSettings().setSecureStorePassword(emptyPassword)\n+            .setNodesIds(Strings.EMPTY_ARRAY).execute(\n+            new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(cluster().size()));\n+                        for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n+                            assertThat(nodeResponse.reloadException(), notNullValue());\n                         }\n+                    } catch (final AssertionError e) {\n+                        reloadSettingsError.set(e);\n+                    } finally {\n+                        latch.countDown();\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request failed\", e));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        // in the invalid keystore format case no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadAllNodesWithPasswordWithoutTLSFails() throws Exception {\n+        final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class);\n+        final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class)\n+            .stream().findFirst().get();\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final int initialReloadCount = mockReloadablePlugin.getReloadCount();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            // No filter should try to hit all nodes\n+            .setNodesIds(Strings.EMPTY_ARRAY)\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request succeeded when it should have failed\", null));\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(ElasticsearchException.class));\n+                    assertThat(e.getMessage(),\n+                        containsString(\"Secure settings cannot be updated cluster wide when TLS for the transport layer is not enabled\"));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        //no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadLocalNodeWithPasswordWithoutTLSSucceeds() throws Exception {\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            .setNodesIds(\"_local\")\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(1));", "originalCommit": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NjI3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369466277", "bodyText": "Actually there is no hasSize for  Matcher<java.util.Map<? extends K,? extends V>>", "author": "jkakavas", "createdAt": "2020-01-22T10:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMDM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzQ0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369473445", "bodyText": "Ah, there's aMapWithSize(). Don't know if that's an improvement \ud83e\udd37\u200d\u2642", "author": "pugnascotia", "createdAt": "2020-01-22T10:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMDM1Nw=="}], "type": "inlineReview"}, {"oid": "377506137e865a26dcfc05e14beea8aa36a29cd0", "url": "https://github.com/elastic/elasticsearch/commit/377506137e865a26dcfc05e14beea8aa36a29cd0", "message": "Restore handling of string input\n\nAdds tests that were mistakenly removed. One of these tests proved\nwe were not handling the the stdin (-x) option correctly when no\ninput was added. This commit restores the original approach of\nreading stdin one char at a time until there is no more (-1, \\r, \\n)\ninstead of using readline() that might return null", "committedDate": "2020-01-22T08:34:06Z", "type": "commit"}, {"oid": "bf27d31ae4bf4e10dee0998ef581b2803d167b55", "url": "https://github.com/elastic/elasticsearch/commit/bf27d31ae4bf4e10dee0998ef581b2803d167b55", "message": "address feedback", "committedDate": "2020-01-22T10:03:38Z", "type": "commit"}, {"oid": "ba7434fb699f49128e41990d5d4920e0962033e0", "url": "https://github.com/elastic/elasticsearch/commit/ba7434fb699f49128e41990d5d4920e0962033e0", "message": "Apply spotless reformatting", "committedDate": "2020-01-22T17:09:54Z", "type": "commit"}, {"oid": "bd9465d30a9039d2e6f52a34a6e4dd4cc7befbec", "url": "https://github.com/elastic/elasticsearch/commit/bd9465d30a9039d2e6f52a34a6e4dd4cc7befbec", "message": "Merging changes from master", "committedDate": "2020-01-22T17:14:25Z", "type": "commit"}, {"oid": "e6156ef478bbaf278ffe1cee9df6a36c03e4f56b", "url": "https://github.com/elastic/elasticsearch/commit/e6156ef478bbaf278ffe1cee9df6a36c03e4f56b", "message": "Reformat after merge from master", "committedDate": "2020-01-22T17:43:51Z", "type": "commit"}, {"oid": "f88837b7b616f6b245db7d8cd0bfda95998bb3b1", "url": "https://github.com/elastic/elasticsearch/commit/f88837b7b616f6b245db7d8cd0bfda95998bb3b1", "message": "Back out merge commit errors", "committedDate": "2020-01-22T20:21:24Z", "type": "commit"}, {"oid": "f61d75662d560606c4e82a2886ebac24cf09ba66", "url": "https://github.com/elastic/elasticsearch/commit/f61d75662d560606c4e82a2886ebac24cf09ba66", "message": "Respond to PR comments", "committedDate": "2020-01-22T21:31:16Z", "type": "commit"}, {"oid": "95087330a4521510c1d74ebf0f9aa1bb66c7a6b4", "url": "https://github.com/elastic/elasticsearch/commit/95087330a4521510c1d74ebf0f9aa1bb66c7a6b4", "message": "Stop journald before trying to delete its files", "committedDate": "2020-01-22T23:27:56Z", "type": "commit"}, {"oid": "936ba917be88750fef115204406e67dfa28cfe9b", "url": "https://github.com/elastic/elasticsearch/commit/936ba917be88750fef115204406e67dfa28cfe9b", "message": "Adjust clearing the journalctl logs", "committedDate": "2020-01-23T14:59:20Z", "type": "commit"}, {"oid": "8ede6265ee1826e6332e3c23ddda73b0b1dab0dd", "url": "https://github.com/elastic/elasticsearch/commit/8ede6265ee1826e6332e3c23ddda73b0b1dab0dd", "message": "Merging changes from master", "committedDate": "2020-01-23T15:36:18Z", "type": "commit"}, {"oid": "8389ea02ec3494bd4a8272673188c4a8dc3a375b", "url": "https://github.com/elastic/elasticsearch/commit/8389ea02ec3494bd4a8272673188c4a8dc3a375b", "message": "Use '--since' flag to get recent journal messages\n\nWhen we get Elasticsearch logs from journald, we want to fetch only log\nmessages from the last run. There are two reasons for this. First, if\nthere are many logs, we might get a string that's too large for our\nutility methods. Second, when we're looking for a specific message or\nerror, we almost certainly want to look only at messages from the last\nexecution.\n\nPreviously, we've been trying to do this by clearing out the physical\nfiles under the journald process. But there seems to be some contention\nover these directories: if journald writes a log file in between when\nour deletion command deletes the file and when it deletes the log\ndirectory, the deletion will fail.\n\nIt seems to me that we might be able to use journald's \"--since\" flag to\nretrieve only log messages from the last run, and that this might be\nless likely to fail due to race conditions in file deletion.\n\nUnfortunately, it looks as if the \"--since\" flag has a granularity of\none-second. I've added a two-second sleep to make sure that there's a\nsufficient gap between the test that will read from journald and the\ntest before it.", "committedDate": "2020-01-23T19:23:51Z", "type": "commit"}, {"oid": "2f8228401fd6f3c9a3da113e8f4751559ea19170", "url": "https://github.com/elastic/elasticsearch/commit/2f8228401fd6f3c9a3da113e8f4751559ea19170", "message": "Use --since when reading journal", "committedDate": "2020-01-23T20:19:18Z", "type": "commit"}, {"oid": "675778572ecb6cd3be9ecf0f061b26ca5ecff4ec", "url": "https://github.com/elastic/elasticsearch/commit/675778572ecb6cd3be9ecf0f061b26ca5ecff4ec", "message": "Merging changes from master", "committedDate": "2020-01-24T20:26:37Z", "type": "commit"}, {"oid": "f93ab59c2eb9cecb7fa43b793aafcc24420c196f", "url": "https://github.com/elastic/elasticsearch/commit/f93ab59c2eb9cecb7fa43b793aafcc24420c196f", "message": "Use new journald wrapper pattern", "committedDate": "2020-01-24T20:52:55Z", "type": "commit"}, {"oid": "a8103a66adfc35e47a0e4ddb3aebfd6d6b458c1e", "url": "https://github.com/elastic/elasticsearch/commit/a8103a66adfc35e47a0e4ddb3aebfd6d6b458c1e", "message": "Update version added in secure settings request", "committedDate": "2020-01-27T22:10:27Z", "type": "commit"}]}