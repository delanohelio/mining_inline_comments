{"pr_number": 60121, "pr_title": "Make MlDailyMaintenanceService delete jobs that are in deleting state anyway", "pr_createdAt": "2020-07-23T13:44:44Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60121", "timeline": [{"oid": "d341cd7fd639e6a0a9f8d740752131d1648bcf91", "url": "https://github.com/elastic/elasticsearch/commit/d341cd7fd639e6a0a9f8d740752131d1648bcf91", "message": "Make MlDailyMaintenanceService delete jobs that are in deleting state anyway", "committedDate": "2020-07-27T10:05:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxODI4MA==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460818280", "bodyText": "why was this changed to just 10 seconds into the future?", "author": "benwtrent", "createdAt": "2020-07-27T11:15:36Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -88,11 +102,7 @@ private static TimeValue delayToNextTime(ClusterName clusterName) {\n         int minutesOffset = random.ints(0, MAX_TIME_OFFSET_MINUTES).findFirst().getAsInt();\n \n         ZonedDateTime now = ZonedDateTime.now(Clock.systemDefaultZone());\n-        ZonedDateTime next = now.plusDays(1)\n-            .toLocalDate()\n-            .atStartOfDay(now.getZone())\n-            .plusMinutes(30)\n-            .plusMinutes(minutesOffset);\n+        ZonedDateTime next = now.plusSeconds(10);", "originalCommit": "d341cd7fd639e6a0a9f8d740752131d1648bcf91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNTMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460825323", "bodyText": "Ooops, for debugging of course.\nFixed.", "author": "przemekwitek", "createdAt": "2020-07-27T11:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxODI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzMjI1MA==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460832250", "bodyText": "This type of action should be rare, so an info log here would be good. This way we know when ALL longer running maintenance tasks are complete since now we have two that run concurrently.\nsince you are using an AcknowledgedResponse, a predicate on acknowledged would work.", "author": "benwtrent", "createdAt": "2020-07-27T11:44:55Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +150,107 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n+            triggerDeleteExpiredDataTask();\n+            triggerDeleteJobsInStateDeletingWithoutDeletionTask(\n                 ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+                    response -> {},", "originalCommit": "8018e0bb5823ba1ec95b785142f1c6f450efac88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMzc2OA==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461413768", "bodyText": "Done.\nI've put the log message in triggerDeleteJobsInStateDeletingWithoutDeletionTask method, depending on the value of isAcknowledged.", "author": "przemekwitek", "createdAt": "2020-07-28T08:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzMjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460837145", "bodyText": "\ud83d\udc4d", "author": "davidkyle", "createdAt": "2020-07-27T11:55:09Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/action/DeleteDataFrameAnalyticsAction.java", "diffHunk": "@@ -77,6 +78,11 @@ public ActionRequestValidationException validate() {\n             return null;\n         }\n \n+        @Override\n+        public String getDescription() {\n+            return DELETION_TASK_DESCRIPTION_PREFIX + id;", "originalCommit": "8018e0bb5823ba1ec95b785142f1c6f450efac88", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0MDE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460840147", "bodyText": "I'm not sure this will fail the test as the response does not come on the main test thread it will cause the assertion failure on a different thread. I could be wrong can you check please.\nCompare with https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/MlSingleNodeTestCase.java#L121", "author": "davidkyle", "createdAt": "2020-07-27T12:01:29Z", "path": "x-pack/plugin/ml/qa/native-multi-node-tests/src/test/java/org/elasticsearch/xpack/ml/integration/MlDailyMaintenanceServiceIT.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.integration;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.job.config.AnalysisConfig;\n+import org.elasticsearch.xpack.core.ml.job.config.DataDescription;\n+import org.elasticsearch.xpack.core.ml.job.config.Detector;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.ml.MlAssignmentNotifier;\n+import org.elasticsearch.xpack.ml.MlDailyMaintenanceService;\n+import org.elasticsearch.xpack.ml.job.persistence.JobConfigProvider;\n+import org.junit.Before;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class MlDailyMaintenanceServiceIT extends MlNativeAutodetectIntegTestCase {\n+\n+    private JobConfigProvider jobConfigProvider;\n+    private ThreadPool threadPool;\n+\n+    @Before\n+    public void setUpMocks() {\n+        jobConfigProvider = new JobConfigProvider(client(), xContentRegistry());\n+        threadPool = mock(ThreadPool.class);\n+        ExecutorService directExecutorService = EsExecutors.newDirectExecutorService();\n+        when(threadPool.generic()).thenReturn(directExecutorService);\n+    }\n+\n+    public void testTriggerDeleteJobsInStateDeletingWithoutDeletionTask() throws InterruptedException {\n+        MlDailyMaintenanceService maintenanceService =\n+            new MlDailyMaintenanceService(\n+                settings(Version.CURRENT).build(),\n+                ClusterName.DEFAULT,\n+                threadPool,\n+                client(),\n+                mock(ClusterService.class),\n+                mock(MlAssignmentNotifier.class));\n+\n+        putJob(\"maintenance-test-1\");\n+        putJob(\"maintenance-test-2\");\n+        putJob(\"maintenance-test-3\");\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+\n+        blockingCall(maintenanceService::triggerDeleteJobsInStateDeletingWithoutDeletionTask);\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+\n+        this.<Boolean>blockingCall(listener -> jobConfigProvider.markJobAsDeleting(\"maintenance-test-2\", listener));\n+        this.<Boolean>blockingCall(listener -> jobConfigProvider.markJobAsDeleting(\"maintenance-test-3\", listener));\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+        assertThat(getJob(\"maintenance-test-1\").get(0).isDeleting(), is(false));\n+        assertThat(getJob(\"maintenance-test-2\").get(0).isDeleting(), is(true));\n+        assertThat(getJob(\"maintenance-test-3\").get(0).isDeleting(), is(true));\n+\n+        blockingCall(maintenanceService::triggerDeleteJobsInStateDeletingWithoutDeletionTask);\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\"));\n+    }\n+\n+    private <T> void blockingCall(Consumer<ActionListener<T>> function) throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<T> listener = ActionListener.wrap(\n+            r -> {\n+                latch.countDown();\n+            },\n+            e -> {\n+                latch.countDown();\n+                fail(e.getMessage());", "originalCommit": "8018e0bb5823ba1ec95b785142f1c6f450efac88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzODIzNg==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461438236", "bodyText": "I agree it's safer to assert on the main test thread so I changed it the way you suggested.\nNow the code is very similar between my blockingCall and MlSingleNodeTestCase::blockingCall. Do you think it's worth extracting this method to some common place between single-node and multi-node tests?", "author": "przemekwitek", "createdAt": "2020-07-28T09:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0MDE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ2OTUzMg==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461469532", "bodyText": "It is a simple method there is no harm in duplicating it.", "author": "davidkyle", "createdAt": "2020-07-28T10:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0MDE0Nw=="}], "type": "inlineReview"}, {"oid": "8cb8b50068fa283f17f992856d747bda1d130ab0", "url": "https://github.com/elastic/elasticsearch/commit/8cb8b50068fa283f17f992856d747bda1d130ab0", "message": "Apply review comments", "committedDate": "2020-07-28T09:29:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzOTQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461539405", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)\n          \n          \n            \n                            e -> LOGGER.error(\"An error occurred during [ML] maintenance tasks execution\", e)", "author": "droberts195", "createdAt": "2020-07-28T12:26:57Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,122 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),\n+                e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)", "originalCommit": "8cb8b50068fa283f17f992856d747bda1d130ab0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU4NjY4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461586689", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-07-28T13:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzOTQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0MzUyNg==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461543526", "bodyText": "If we ever see this in a log it will frustrate us.  We will want to know which ones failed.  The low level error logging for the failure might be on a different node in the cluster that we haven't been sent the logs for.  So this should list the job IDs that failed to be deleted.", "author": "droberts195", "createdAt": "2020-07-28T12:33:47Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,127 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),\n+                e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)\n+            );\n+\n+            // Step 2: Delete expired data\n+            ActionListener<AcknowledgedResponse> deleteJobsListener = ActionListener.wrap(\n+                unused -> triggerDeleteExpiredDataTask(finalListener),\n+                e -> {\n+                    LOGGER.info(\"[ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask failed\", e);\n+                    // Note: Steps 1 and 2 are independent of each other and step 2 is executed even if step 1 failed.\n+                    triggerDeleteExpiredDataTask(finalListener);\n+                }\n+            );\n+\n+            // Step 1: Delete jobs that are in deleting state\n+            triggerDeleteJobsInStateDeletingWithoutDeletionTask(deleteJobsListener);\n+\n+            auditUnassignedMlTasks();\n         } finally {\n             scheduleNext();\n         }\n     }\n \n+    private void triggerDeleteExpiredDataTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        ActionListener<DeleteExpiredDataAction.Response> deleteExpiredDataActionListener = ActionListener.wrap(\n+            deleteExpiredDataResponse -> {\n+                if (deleteExpiredDataResponse.isDeleted()) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteExpiredDataTask\");\n+                } else {\n+                    LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n+                }\n+                finalListener.onResponse(new AcknowledgedResponse(true));\n+            },\n+            finalListener::onFailure\n+        );\n+\n+        executeAsyncWithOrigin(\n+            client,\n+            ML_ORIGIN,\n+            DeleteExpiredDataAction.INSTANCE,\n+            new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n+            deleteExpiredDataActionListener);\n+    }\n+\n+    // Visible for testing\n+    public void triggerDeleteJobsInStateDeletingWithoutDeletionTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        SetOnce<Set<String>> jobsInStateDeletingHolder = new SetOnce<>();\n+\n+        ActionListener<List<AcknowledgedResponse>> deleteJobsActionListener = ActionListener.wrap(\n+            deleteJobsResponses -> {\n+                if (deleteJobsResponses.stream().allMatch(AcknowledgedResponse::isAcknowledged)) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask\");\n+                } else {\n+                    LOGGER.info(\"At least one of the ML jobs could not be deleted\");", "originalCommit": "4f4dcd60f9af1836be0d4ad720e7a526da5fe001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYwMTg3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461601875", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-07-28T13:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0MzUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0Njg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461546880", "bodyText": "I wonder if it's best to remove this line and leave the success logging to the individual steps.  This will get logged when the last step succeeds, even if earlier steps failed.  As long as every other step logs successful completion this doesn't really add anything.", "author": "droberts195", "createdAt": "2020-07-28T12:39:30Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,127 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),", "originalCommit": "4f4dcd60f9af1836be0d4ad720e7a526da5fe001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU4NTk2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461585962", "bodyText": "Done.", "author": "przemekwitek", "createdAt": "2020-07-28T13:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0Njg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU1MDcwOA==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461550708", "bodyText": "This will get logged in the case where jobs are being deleted when the daily maintenance runs, but all of them already had deletion tasks.  I think it should only be logged when a job had lost its original deletion task.", "author": "droberts195", "createdAt": "2020-07-28T12:45:41Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,127 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),\n+                e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)\n+            );\n+\n+            // Step 2: Delete expired data\n+            ActionListener<AcknowledgedResponse> deleteJobsListener = ActionListener.wrap(\n+                unused -> triggerDeleteExpiredDataTask(finalListener),\n+                e -> {\n+                    LOGGER.info(\"[ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask failed\", e);\n+                    // Note: Steps 1 and 2 are independent of each other and step 2 is executed even if step 1 failed.\n+                    triggerDeleteExpiredDataTask(finalListener);\n+                }\n+            );\n+\n+            // Step 1: Delete jobs that are in deleting state\n+            triggerDeleteJobsInStateDeletingWithoutDeletionTask(deleteJobsListener);\n+\n+            auditUnassignedMlTasks();\n         } finally {\n             scheduleNext();\n         }\n     }\n \n+    private void triggerDeleteExpiredDataTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        ActionListener<DeleteExpiredDataAction.Response> deleteExpiredDataActionListener = ActionListener.wrap(\n+            deleteExpiredDataResponse -> {\n+                if (deleteExpiredDataResponse.isDeleted()) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteExpiredDataTask\");\n+                } else {\n+                    LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n+                }\n+                finalListener.onResponse(new AcknowledgedResponse(true));\n+            },\n+            finalListener::onFailure\n+        );\n+\n+        executeAsyncWithOrigin(\n+            client,\n+            ML_ORIGIN,\n+            DeleteExpiredDataAction.INSTANCE,\n+            new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n+            deleteExpiredDataActionListener);\n+    }\n+\n+    // Visible for testing\n+    public void triggerDeleteJobsInStateDeletingWithoutDeletionTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        SetOnce<Set<String>> jobsInStateDeletingHolder = new SetOnce<>();\n+\n+        ActionListener<List<AcknowledgedResponse>> deleteJobsActionListener = ActionListener.wrap(\n+            deleteJobsResponses -> {\n+                if (deleteJobsResponses.stream().allMatch(AcknowledgedResponse::isAcknowledged)) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask\");", "originalCommit": "4f4dcd60f9af1836be0d4ad720e7a526da5fe001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExMjAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r462112008", "bodyText": "Done.\ndeleteJobsActionListener is now bypassed when there are no jobs to delete. finalListener is called directly in such situation.", "author": "przemekwitek", "createdAt": "2020-07-29T08:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU1MDcwOA=="}], "type": "inlineReview"}, {"oid": "0a9caaa703a107f9c08d62c6653a79c35d894faf", "url": "https://github.com/elastic/elasticsearch/commit/0a9caaa703a107f9c08d62c6653a79c35d894faf", "message": "Make MlDailyMaintenanceService delete jobs that are in deleting state anyway", "committedDate": "2020-07-29T09:46:04Z", "type": "commit"}, {"oid": "2d09e6ec1652edc7c7aa35da3d8debcb445b6707", "url": "https://github.com/elastic/elasticsearch/commit/2d09e6ec1652edc7c7aa35da3d8debcb445b6707", "message": "Apply review comment", "committedDate": "2020-07-29T09:46:04Z", "type": "commit"}, {"oid": "45eb59135921766542fdf0c428de2554bd475105", "url": "https://github.com/elastic/elasticsearch/commit/45eb59135921766542fdf0c428de2554bd475105", "message": "Revert debug-related change", "committedDate": "2020-07-29T09:46:04Z", "type": "commit"}, {"oid": "aa0d7898b15dafdd536d85495a2d6d3387086ad7", "url": "https://github.com/elastic/elasticsearch/commit/aa0d7898b15dafdd536d85495a2d6d3387086ad7", "message": "Apply review comments", "committedDate": "2020-07-29T09:46:04Z", "type": "commit"}, {"oid": "4dc1a5ccacc17bac5b92a43f7d4885327b04dab0", "url": "https://github.com/elastic/elasticsearch/commit/4dc1a5ccacc17bac5b92a43f7d4885327b04dab0", "message": "Swap the order of execution of tasks", "committedDate": "2020-07-29T09:46:04Z", "type": "commit"}, {"oid": "e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "url": "https://github.com/elastic/elasticsearch/commit/e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "message": "Apply review comments", "committedDate": "2020-07-29T09:46:04Z", "type": "commit"}, {"oid": "e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "url": "https://github.com/elastic/elasticsearch/commit/e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "message": "Apply review comments", "committedDate": "2020-07-29T09:46:04Z", "type": "forcePushed"}]}