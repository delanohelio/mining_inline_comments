{"pr_number": 53429, "pr_title": "[ML] Start gathering and storing inference stats", "pr_createdAt": "2020-03-11T19:00:29Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53429", "timeline": [{"oid": "ee4868652ec579425ff84d2efa0c77ed1521608d", "url": "https://github.com/elastic/elasticsearch/commit/ee4868652ec579425ff84d2efa0c77ed1521608d", "message": "[ML] Gathering inference stats in localModel and loading service", "committedDate": "2020-03-11T18:46:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMDYwNw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r391200607", "bodyText": "We might actually want to fail completely if the unwrapped error is anything other than a ResourceNotFound. If .ml-stats-* exists but has unallocated primary shards, we may want to bail.", "author": "benwtrent", "createdAt": "2020-03-11T19:09:05Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java", "diffHunk": "@@ -336,11 +351,22 @@ private void loadModels(Set<String> modelIds) {\n         threadPool.executor(MachineLearning.UTILITY_THREAD_POOL_NAME).execute(() -> {\n             for (String modelId : modelIds) {\n                 auditNewReferencedModel(modelId);\n-                this.loadModel(modelId);\n+                loadStatsAndModel(modelId);\n             }\n         });\n     }\n \n+    private void loadStatsAndModel(String modelId) {\n+        this.provider.getInferenceStats(modelId,\n+            localNode,\n+            ActionListener.wrap(\n+                r -> this.loadModel(modelId, r),\n+                e -> {\n+                    logger.error(\"[{}] failed to get previous model stats\", modelId);", "originalCommit": "ee4868652ec579425ff84d2efa0c77ed1521608d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "01127055d1d33db45fe467849481eadb22f207a5", "url": "https://github.com/elastic/elasticsearch/commit/01127055d1d33db45fe467849481eadb22f207a5", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-03-12T12:03:04Z", "type": "commit"}, {"oid": "6b45143212bae53972160f5c7bbb4ba873a0006a", "url": "https://github.com/elastic/elasticsearch/commit/6b45143212bae53972160f5c7bbb4ba873a0006a", "message": "making stats loading failure fail the listeners", "committedDate": "2020-03-12T12:09:38Z", "type": "commit"}, {"oid": "3afa69e437ac93478e5e15aa178c9a4c2d4cb5f8", "url": "https://github.com/elastic/elasticsearch/commit/3afa69e437ac93478e5e15aa178c9a4c2d4cb5f8", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-03-12T17:16:09Z", "type": "commit"}, {"oid": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "url": "https://github.com/elastic/elasticsearch/commit/c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "message": "allowing missing stats index", "committedDate": "2020-03-12T17:54:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNzU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r394917543", "bodyText": "Typo Inferece in function name and param", "author": "davidkyle", "createdAt": "2020-03-19T10:12:09Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/action/GetTrainedModelsStatsAction.java", "diffHunk": "@@ -191,13 +209,23 @@ public Builder setIngestStatsByModelId(Map<String, IngestStats> ingestStatsByMod\n                 return this;\n             }\n \n+            public Builder setInfereceStatsByModelId(Map<String, InferenceStats> infereceStatsByModelId) {", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxOTg2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r394919867", "bodyText": "Just this one is private? I'd make it public just so the fields line up", "author": "davidkyle", "createdAt": "2020-03-19T10:16:05Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+public class InferenceStats implements ToXContentObject, Writeable {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    public static final ParseField NODE_ID = new ParseField(\"node_id\");\n+    public static final ParseField TOTAL_TIME_SPENT_MILLIS = new ParseField(\"total_time_spent_millis\");\n+    private static final ParseField TOTAL_TIME_SPENT = new ParseField(\"total_time_spent\");", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMTI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395021252", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        instant == null ? Instant.now() : Instant.ofEpochMilli(instant.toEpochMilli()));\n          \n          \n            \n                        instant);\n          \n      \n    \n    \n  \n\nThe public ctor has the null check", "author": "davidkyle", "createdAt": "2020-03-19T13:24:29Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+public class InferenceStats implements ToXContentObject, Writeable {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    public static final ParseField NODE_ID = new ParseField(\"node_id\");\n+    public static final ParseField TOTAL_TIME_SPENT_MILLIS = new ParseField(\"total_time_spent_millis\");\n+    private static final ParseField TOTAL_TIME_SPENT = new ParseField(\"total_time_spent\");\n+    public static final ParseField FAILURE_COUNT = new ParseField(\"failure_count\");\n+    public static final ParseField TYPE = new ParseField(\"type\");\n+    public static final ParseField TIMESTAMP = new ParseField(\"time_stamp\");\n+\n+    public static final ConstructingObjectParser<InferenceStats, Void> PARSER = new ConstructingObjectParser<>(\n+        NAME,\n+        true,\n+        a -> new InferenceStats((Long)a[0], (Long)a[1], (Long)a[2], (Long)a[3], (String)a[4], (String)a[5], (Instant) a[6])\n+    );\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), MISSING_ALL_FIELDS_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), INFERENCE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), TOTAL_TIME_SPENT_MILLIS);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), FAILURE_COUNT);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), MODEL_ID);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), NODE_ID);\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP.getPreferredName()),\n+            TIMESTAMP,\n+            ObjectParser.ValueType.VALUE);\n+    }\n+    public static InferenceStats emptyStats(String modelId, String nodeId) {\n+        return new InferenceStats(0L, 0L, 0L, 0L, modelId, nodeId, Instant.now());\n+    }\n+\n+    public static String docId(String modelId, String nodeId) {\n+        return NAME + \"-\" + modelId + \"-\" + nodeId;\n+    }\n+\n+    private final long missingAllFieldsCount;\n+    private final long inferenceCount;\n+    private final long totalTimeSpent;\n+    private final long failureCount;\n+    private final String modelId;\n+    private final String nodeId;\n+    private final Instant timeStamp;\n+\n+    private InferenceStats(Long missingAllFieldsCount,\n+                           Long inferenceCount,\n+                           Long totalTimeSpent,\n+                           Long failureCount,\n+                           String modelId,\n+                           String nodeId,\n+                           Instant instant) {\n+        this(unbox(missingAllFieldsCount),\n+            unbox(inferenceCount),\n+            unbox(totalTimeSpent),\n+            unbox(failureCount),\n+            modelId,\n+            nodeId,\n+            instant == null ? Instant.now() : Instant.ofEpochMilli(instant.toEpochMilli()));", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMzc2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395023766", "bodyText": "Does converting to epoch then back to Instant serve a purpose?", "author": "davidkyle", "createdAt": "2020-03-19T13:28:24Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+public class InferenceStats implements ToXContentObject, Writeable {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    public static final ParseField NODE_ID = new ParseField(\"node_id\");\n+    public static final ParseField TOTAL_TIME_SPENT_MILLIS = new ParseField(\"total_time_spent_millis\");\n+    private static final ParseField TOTAL_TIME_SPENT = new ParseField(\"total_time_spent\");\n+    public static final ParseField FAILURE_COUNT = new ParseField(\"failure_count\");\n+    public static final ParseField TYPE = new ParseField(\"type\");\n+    public static final ParseField TIMESTAMP = new ParseField(\"time_stamp\");\n+\n+    public static final ConstructingObjectParser<InferenceStats, Void> PARSER = new ConstructingObjectParser<>(\n+        NAME,\n+        true,\n+        a -> new InferenceStats((Long)a[0], (Long)a[1], (Long)a[2], (Long)a[3], (String)a[4], (String)a[5], (Instant) a[6])\n+    );\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), MISSING_ALL_FIELDS_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), INFERENCE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), TOTAL_TIME_SPENT_MILLIS);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), FAILURE_COUNT);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), MODEL_ID);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), NODE_ID);\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP.getPreferredName()),\n+            TIMESTAMP,\n+            ObjectParser.ValueType.VALUE);\n+    }\n+    public static InferenceStats emptyStats(String modelId, String nodeId) {\n+        return new InferenceStats(0L, 0L, 0L, 0L, modelId, nodeId, Instant.now());\n+    }\n+\n+    public static String docId(String modelId, String nodeId) {\n+        return NAME + \"-\" + modelId + \"-\" + nodeId;\n+    }\n+\n+    private final long missingAllFieldsCount;\n+    private final long inferenceCount;\n+    private final long totalTimeSpent;\n+    private final long failureCount;\n+    private final String modelId;\n+    private final String nodeId;\n+    private final Instant timeStamp;\n+\n+    private InferenceStats(Long missingAllFieldsCount,\n+                           Long inferenceCount,\n+                           Long totalTimeSpent,\n+                           Long failureCount,\n+                           String modelId,\n+                           String nodeId,\n+                           Instant instant) {\n+        this(unbox(missingAllFieldsCount),\n+            unbox(inferenceCount),\n+            unbox(totalTimeSpent),\n+            unbox(failureCount),\n+            modelId,\n+            nodeId,\n+            instant == null ? Instant.now() : Instant.ofEpochMilli(instant.toEpochMilli()));\n+    }\n+\n+\n+    public InferenceStats(long missingAllFieldsCount,\n+                          long inferenceCount,\n+                          long totalTimeSpent,\n+                          long failureCount,\n+                          String modelId,\n+                          String nodeId,\n+                          Instant timeStamp) {\n+        this.missingAllFieldsCount = missingAllFieldsCount;\n+        this.inferenceCount = inferenceCount;\n+        this.totalTimeSpent = totalTimeSpent;\n+        this.failureCount = failureCount;\n+        this.modelId = modelId;\n+        this.nodeId = nodeId;\n+        this.timeStamp = timeStamp == null ?\n+            Instant.ofEpochMilli(Instant.now().toEpochMilli()) :\n+            Instant.ofEpochMilli(timeStamp.toEpochMilli());", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzc4MA==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395227780", "bodyText": "It's because the convention is for the XContent representation to be at millisecond accuracy and it's painful if the internal representation is more accurate.  As I said in #52778 (comment) I think it's worth adding a comment to say this.  We used to have about 3 different ways of solving this problem but now we're standardising on rounding in the constructor.", "author": "droberts195", "createdAt": "2020-03-19T18:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMzc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3ODY3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395678677", "bodyText": "Rounding in the ctor is the standard way. I will remove the rounding from the stream input :)", "author": "benwtrent", "createdAt": "2020-03-20T14:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyNzQxNw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395027417", "bodyText": "Oh is it to trim the nanoseconds? Is that because of a failing equality check?", "author": "davidkyle", "createdAt": "2020-03-19T13:33:55Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+public class InferenceStats implements ToXContentObject, Writeable {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    public static final ParseField NODE_ID = new ParseField(\"node_id\");\n+    public static final ParseField TOTAL_TIME_SPENT_MILLIS = new ParseField(\"total_time_spent_millis\");\n+    private static final ParseField TOTAL_TIME_SPENT = new ParseField(\"total_time_spent\");\n+    public static final ParseField FAILURE_COUNT = new ParseField(\"failure_count\");\n+    public static final ParseField TYPE = new ParseField(\"type\");\n+    public static final ParseField TIMESTAMP = new ParseField(\"time_stamp\");\n+\n+    public static final ConstructingObjectParser<InferenceStats, Void> PARSER = new ConstructingObjectParser<>(\n+        NAME,\n+        true,\n+        a -> new InferenceStats((Long)a[0], (Long)a[1], (Long)a[2], (Long)a[3], (String)a[4], (String)a[5], (Instant) a[6])\n+    );\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), MISSING_ALL_FIELDS_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), INFERENCE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), TOTAL_TIME_SPENT_MILLIS);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), FAILURE_COUNT);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), MODEL_ID);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), NODE_ID);\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP.getPreferredName()),\n+            TIMESTAMP,\n+            ObjectParser.ValueType.VALUE);\n+    }\n+    public static InferenceStats emptyStats(String modelId, String nodeId) {\n+        return new InferenceStats(0L, 0L, 0L, 0L, modelId, nodeId, Instant.now());\n+    }\n+\n+    public static String docId(String modelId, String nodeId) {\n+        return NAME + \"-\" + modelId + \"-\" + nodeId;\n+    }\n+\n+    private final long missingAllFieldsCount;\n+    private final long inferenceCount;\n+    private final long totalTimeSpent;\n+    private final long failureCount;\n+    private final String modelId;\n+    private final String nodeId;\n+    private final Instant timeStamp;\n+\n+    private InferenceStats(Long missingAllFieldsCount,\n+                           Long inferenceCount,\n+                           Long totalTimeSpent,\n+                           Long failureCount,\n+                           String modelId,\n+                           String nodeId,\n+                           Instant instant) {\n+        this(unbox(missingAllFieldsCount),\n+            unbox(inferenceCount),\n+            unbox(totalTimeSpent),\n+            unbox(failureCount),\n+            modelId,\n+            nodeId,\n+            instant == null ? Instant.now() : Instant.ofEpochMilli(instant.toEpochMilli()));\n+    }\n+\n+\n+    public InferenceStats(long missingAllFieldsCount,\n+                          long inferenceCount,\n+                          long totalTimeSpent,\n+                          long failureCount,\n+                          String modelId,\n+                          String nodeId,\n+                          Instant timeStamp) {\n+        this.missingAllFieldsCount = missingAllFieldsCount;\n+        this.inferenceCount = inferenceCount;\n+        this.totalTimeSpent = totalTimeSpent;\n+        this.failureCount = failureCount;\n+        this.modelId = modelId;\n+        this.nodeId = nodeId;\n+        this.timeStamp = timeStamp == null ?\n+            Instant.ofEpochMilli(Instant.now().toEpochMilli()) :\n+            Instant.ofEpochMilli(timeStamp.toEpochMilli());\n+    }\n+\n+    public InferenceStats(StreamInput in) throws IOException {\n+        this.missingAllFieldsCount = in.readVLong();\n+        this.inferenceCount = in.readVLong();\n+        this.totalTimeSpent = in.readVLong();\n+        this.failureCount = in.readVLong();\n+        this.modelId = in.readOptionalString();\n+        this.nodeId = in.readOptionalString();\n+        this.timeStamp = Instant.ofEpochMilli(in.readInstant().toEpochMilli());", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyODgzOA==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395228838", "bodyText": "We haven't rounded when receiving off the wire in other places, for example https://github.com/elastic/elasticsearch/pull/52778/files#diff-e7461e3bf8c7e61722aecccd3d4c3a99R65.  There shouldn't be any need if we've always rounded in the other constructors.", "author": "droberts195", "createdAt": "2020-03-19T18:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyNzQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3ODkyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395678926", "bodyText": "This isn't necessary. I will remove this since I am rounding in the ctor", "author": "benwtrent", "createdAt": "2020-03-20T14:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyNzQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAzMjgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395032831", "bodyText": "Are node_id and model_id not of interest", "author": "davidkyle", "createdAt": "2020-03-19T13:41:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+public class InferenceStats implements ToXContentObject, Writeable {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    public static final ParseField NODE_ID = new ParseField(\"node_id\");\n+    public static final ParseField TOTAL_TIME_SPENT_MILLIS = new ParseField(\"total_time_spent_millis\");\n+    private static final ParseField TOTAL_TIME_SPENT = new ParseField(\"total_time_spent\");\n+    public static final ParseField FAILURE_COUNT = new ParseField(\"failure_count\");\n+    public static final ParseField TYPE = new ParseField(\"type\");\n+    public static final ParseField TIMESTAMP = new ParseField(\"time_stamp\");\n+\n+    public static final ConstructingObjectParser<InferenceStats, Void> PARSER = new ConstructingObjectParser<>(\n+        NAME,\n+        true,\n+        a -> new InferenceStats((Long)a[0], (Long)a[1], (Long)a[2], (Long)a[3], (String)a[4], (String)a[5], (Instant) a[6])\n+    );\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), MISSING_ALL_FIELDS_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), INFERENCE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), TOTAL_TIME_SPENT_MILLIS);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), FAILURE_COUNT);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), MODEL_ID);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), NODE_ID);\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP.getPreferredName()),\n+            TIMESTAMP,\n+            ObjectParser.ValueType.VALUE);\n+    }\n+    public static InferenceStats emptyStats(String modelId, String nodeId) {\n+        return new InferenceStats(0L, 0L, 0L, 0L, modelId, nodeId, Instant.now());\n+    }\n+\n+    public static String docId(String modelId, String nodeId) {\n+        return NAME + \"-\" + modelId + \"-\" + nodeId;\n+    }\n+\n+    private final long missingAllFieldsCount;\n+    private final long inferenceCount;\n+    private final long totalTimeSpent;\n+    private final long failureCount;\n+    private final String modelId;\n+    private final String nodeId;\n+    private final Instant timeStamp;\n+\n+    private InferenceStats(Long missingAllFieldsCount,\n+                           Long inferenceCount,\n+                           Long totalTimeSpent,\n+                           Long failureCount,\n+                           String modelId,\n+                           String nodeId,\n+                           Instant instant) {\n+        this(unbox(missingAllFieldsCount),\n+            unbox(inferenceCount),\n+            unbox(totalTimeSpent),\n+            unbox(failureCount),\n+            modelId,\n+            nodeId,\n+            instant == null ? Instant.now() : Instant.ofEpochMilli(instant.toEpochMilli()));\n+    }\n+\n+\n+    public InferenceStats(long missingAllFieldsCount,\n+                          long inferenceCount,\n+                          long totalTimeSpent,\n+                          long failureCount,\n+                          String modelId,\n+                          String nodeId,\n+                          Instant timeStamp) {\n+        this.missingAllFieldsCount = missingAllFieldsCount;\n+        this.inferenceCount = inferenceCount;\n+        this.totalTimeSpent = totalTimeSpent;\n+        this.failureCount = failureCount;\n+        this.modelId = modelId;\n+        this.nodeId = nodeId;\n+        this.timeStamp = timeStamp == null ?\n+            Instant.ofEpochMilli(Instant.now().toEpochMilli()) :\n+            Instant.ofEpochMilli(timeStamp.toEpochMilli());\n+    }\n+\n+    public InferenceStats(StreamInput in) throws IOException {\n+        this.missingAllFieldsCount = in.readVLong();\n+        this.inferenceCount = in.readVLong();\n+        this.totalTimeSpent = in.readVLong();\n+        this.failureCount = in.readVLong();\n+        this.modelId = in.readOptionalString();\n+        this.nodeId = in.readOptionalString();\n+        this.timeStamp = Instant.ofEpochMilli(in.readInstant().toEpochMilli());\n+    }\n+\n+    public long getMissingAllFieldsCount() {\n+        return missingAllFieldsCount;\n+    }\n+\n+    public long getInferenceCount() {\n+        return inferenceCount;\n+    }\n+\n+    public long getTotalTimeSpent() {\n+        return totalTimeSpent;\n+    }\n+\n+    public long getFailureCount() {\n+        return failureCount;\n+    }\n+\n+    public String getModelId() {\n+        return modelId;\n+    }\n+\n+    public String getNodeId() {\n+        return nodeId;\n+    }\n+\n+    public Instant getTimeStamp() {\n+        return timeStamp;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+            assert modelId != null : \"model_id cannot be null when storing inference stats\";\n+            assert nodeId != null : \"node_id cannot be null when storing inference stats\";\n+            builder.field(TYPE.getPreferredName(), NAME);\n+            builder.field(MODEL_ID.getPreferredName(), modelId);\n+            builder.field(NODE_ID.getPreferredName(), nodeId);", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3OTcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395679723", "bodyText": "strictly speaking, no. They are only interesting in that the caller needs them when gathering the stats from the index.\nDocs are collapsed together before being sent back to the user and the overall object keeps tabs on the model_id.", "author": "benwtrent", "createdAt": "2020-03-20T14:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAzMjgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1ODU1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395158559", "bodyText": "maybe addTimeSpent", "author": "davidkyle", "createdAt": "2020-03-19T16:30:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+public class InferenceStats implements ToXContentObject, Writeable {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    public static final ParseField NODE_ID = new ParseField(\"node_id\");\n+    public static final ParseField TOTAL_TIME_SPENT_MILLIS = new ParseField(\"total_time_spent_millis\");\n+    private static final ParseField TOTAL_TIME_SPENT = new ParseField(\"total_time_spent\");\n+    public static final ParseField FAILURE_COUNT = new ParseField(\"failure_count\");\n+    public static final ParseField TYPE = new ParseField(\"type\");\n+    public static final ParseField TIMESTAMP = new ParseField(\"time_stamp\");\n+\n+    public static final ConstructingObjectParser<InferenceStats, Void> PARSER = new ConstructingObjectParser<>(\n+        NAME,\n+        true,\n+        a -> new InferenceStats((Long)a[0], (Long)a[1], (Long)a[2], (Long)a[3], (String)a[4], (String)a[5], (Instant) a[6])\n+    );\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), MISSING_ALL_FIELDS_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), INFERENCE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), TOTAL_TIME_SPENT_MILLIS);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), FAILURE_COUNT);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), MODEL_ID);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), NODE_ID);\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP.getPreferredName()),\n+            TIMESTAMP,\n+            ObjectParser.ValueType.VALUE);\n+    }\n+    public static InferenceStats emptyStats(String modelId, String nodeId) {\n+        return new InferenceStats(0L, 0L, 0L, 0L, modelId, nodeId, Instant.now());\n+    }\n+\n+    public static String docId(String modelId, String nodeId) {\n+        return NAME + \"-\" + modelId + \"-\" + nodeId;\n+    }\n+\n+    private final long missingAllFieldsCount;\n+    private final long inferenceCount;\n+    private final long totalTimeSpent;\n+    private final long failureCount;\n+    private final String modelId;\n+    private final String nodeId;\n+    private final Instant timeStamp;\n+\n+    private InferenceStats(Long missingAllFieldsCount,\n+                           Long inferenceCount,\n+                           Long totalTimeSpent,\n+                           Long failureCount,\n+                           String modelId,\n+                           String nodeId,\n+                           Instant instant) {\n+        this(unbox(missingAllFieldsCount),\n+            unbox(inferenceCount),\n+            unbox(totalTimeSpent),\n+            unbox(failureCount),\n+            modelId,\n+            nodeId,\n+            instant == null ? Instant.now() : Instant.ofEpochMilli(instant.toEpochMilli()));\n+    }\n+\n+\n+    public InferenceStats(long missingAllFieldsCount,\n+                          long inferenceCount,\n+                          long totalTimeSpent,\n+                          long failureCount,\n+                          String modelId,\n+                          String nodeId,\n+                          Instant timeStamp) {\n+        this.missingAllFieldsCount = missingAllFieldsCount;\n+        this.inferenceCount = inferenceCount;\n+        this.totalTimeSpent = totalTimeSpent;\n+        this.failureCount = failureCount;\n+        this.modelId = modelId;\n+        this.nodeId = nodeId;\n+        this.timeStamp = timeStamp == null ?\n+            Instant.ofEpochMilli(Instant.now().toEpochMilli()) :\n+            Instant.ofEpochMilli(timeStamp.toEpochMilli());\n+    }\n+\n+    public InferenceStats(StreamInput in) throws IOException {\n+        this.missingAllFieldsCount = in.readVLong();\n+        this.inferenceCount = in.readVLong();\n+        this.totalTimeSpent = in.readVLong();\n+        this.failureCount = in.readVLong();\n+        this.modelId = in.readOptionalString();\n+        this.nodeId = in.readOptionalString();\n+        this.timeStamp = Instant.ofEpochMilli(in.readInstant().toEpochMilli());\n+    }\n+\n+    public long getMissingAllFieldsCount() {\n+        return missingAllFieldsCount;\n+    }\n+\n+    public long getInferenceCount() {\n+        return inferenceCount;\n+    }\n+\n+    public long getTotalTimeSpent() {\n+        return totalTimeSpent;\n+    }\n+\n+    public long getFailureCount() {\n+        return failureCount;\n+    }\n+\n+    public String getModelId() {\n+        return modelId;\n+    }\n+\n+    public String getNodeId() {\n+        return nodeId;\n+    }\n+\n+    public Instant getTimeStamp() {\n+        return timeStamp;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+            assert modelId != null : \"model_id cannot be null when storing inference stats\";\n+            assert nodeId != null : \"node_id cannot be null when storing inference stats\";\n+            builder.field(TYPE.getPreferredName(), NAME);\n+            builder.field(MODEL_ID.getPreferredName(), modelId);\n+            builder.field(NODE_ID.getPreferredName(), nodeId);\n+        }\n+        builder.field(FAILURE_COUNT.getPreferredName(), failureCount);\n+        builder.timeField(TOTAL_TIME_SPENT_MILLIS.getPreferredName(), TOTAL_TIME_SPENT.getPreferredName(), totalTimeSpent);\n+        builder.field(INFERENCE_COUNT.getPreferredName(), inferenceCount);\n+        builder.field(MISSING_ALL_FIELDS_COUNT.getPreferredName(), missingAllFieldsCount);\n+        builder.timeField(TIMESTAMP.getPreferredName(), TIMESTAMP.getPreferredName() + \"_string\", timeStamp.toEpochMilli());\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        InferenceStats that = (InferenceStats) o;\n+        return missingAllFieldsCount == that.missingAllFieldsCount\n+            && inferenceCount == that.inferenceCount\n+            && totalTimeSpent == that.totalTimeSpent\n+            && failureCount == that.failureCount\n+            && Objects.equals(modelId, that.modelId)\n+            && Objects.equals(nodeId, that.nodeId)\n+            && Objects.equals(timeStamp, that.timeStamp);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(missingAllFieldsCount, inferenceCount, totalTimeSpent, failureCount, modelId, nodeId, timeStamp);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    private static long unbox(@Nullable Long value) {\n+        return value == null ? 0L : value;\n+    }\n+\n+    public static Accumulator accumulator(String modelId, String nodeId) {\n+        return new Accumulator(modelId, nodeId);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeVLong(this.missingAllFieldsCount);\n+        out.writeVLong(this.inferenceCount);\n+        out.writeVLong(this.totalTimeSpent);\n+        out.writeVLong(this.failureCount);\n+        out.writeOptionalString(this.modelId);\n+        out.writeOptionalString(this.nodeId);\n+        out.writeInstant(timeStamp);\n+    }\n+\n+    public static class Accumulator {\n+\n+        private final LongAdder missingFieldsAccumulator = new LongAdder();\n+        private final LongAdder inferenceAccumulator = new LongAdder();\n+        private final LongAdder totalTimeSpentAccumulator = new LongAdder();\n+        private final LongAdder failureCountAccumulator = new LongAdder();\n+        private final String modelId;\n+        private final String nodeId;\n+\n+        public Accumulator(String modelId, String nodeId) {\n+            this.modelId = modelId;\n+            this.nodeId = nodeId;\n+        }\n+\n+        public Accumulator(InferenceStats previousStats) {\n+            this.modelId = previousStats.modelId;\n+            this.nodeId = previousStats.nodeId;\n+            this.missingFieldsAccumulator.add(previousStats.missingAllFieldsCount);\n+            this.inferenceAccumulator.add(previousStats.inferenceCount);\n+            this.totalTimeSpentAccumulator.add(TimeValue.timeValueMillis(previousStats.totalTimeSpent).nanos());\n+            this.failureCountAccumulator.add(previousStats.failureCount);\n+        }\n+\n+        public void merge(InferenceStats otherStats) {\n+            this.missingFieldsAccumulator.add(otherStats.missingAllFieldsCount);\n+            this.inferenceAccumulator.add(otherStats.inferenceCount);\n+            this.totalTimeSpentAccumulator.add(TimeValue.timeValueMillis(otherStats.totalTimeSpent).nanos());\n+            this.failureCountAccumulator.add(otherStats.failureCount);\n+        }\n+\n+        public void incMissingFields() {\n+            this.missingFieldsAccumulator.increment();\n+        }\n+\n+        public void incInference() {\n+            this.inferenceAccumulator.increment();\n+        }\n+\n+        public void incFailure() {\n+            this.failureCountAccumulator.increment();\n+        }\n+\n+        public void timeSpent(long value) {", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3Mjc1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395172751", "bodyText": "\ud83d\udc4d", "author": "davidkyle", "createdAt": "2020-03-19T16:50:26Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportGetTrainedModelsStatsAction.java", "diffHunk": "@@ -102,8 +111,8 @@ protected void doExecute(Task task,\n             idsListener);\n     }\n \n-    static Map<String, IngestStats> inferenceIngestStatsByPipelineId(NodesStatsResponse response,\n-                                                                     Map<String, Set<String>> modelIdToPipelineId) {\n+    static Map<String, IngestStats> inferenceIngestStatsByModelId(NodesStatsResponse response,", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NTMxMg==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395175312", "bodyText": "I'm not sure about using the GENERIC threadpool \ud83e\udd14", "author": "davidkyle", "createdAt": "2020-03-19T16:54:05Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.component.LifecycleListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.MlStatsIndex;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceStats;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+\n+public class TrainedModelStatsService {\n+\n+    private static final Logger logger = LogManager.getLogger(TrainedModelStatsService.class);\n+\n+    // Script to only update if stats have increased since last persistence\n+    private static final String STATS_UPDATE_SCRIPT = \"\" +\n+        \"if (ctx._source.missing_all_fields_count >= params.missing_all_fields_count\\n\" +\n+        \"     && ctx._source.inference_count >= params.inference_count\\n\" +\n+        \"     && ctx._source.total_time_spent_millis >= params.total_time_spent_millis\\n\" +\n+        \"     && ctx._source.failure_count >= params.failure_count) {\\n\" +\n+        \"      ctx.op = 'none';\\n\" +\n+        \"      return;\\n\" +\n+        \"    }\\n\" +\n+        \"    ctx._source.missing_all_fields_count = params.missing_all_fields_count;\\n\" +\n+        \"    ctx._source.inference_count = params.inference_count;\\n\" +\n+        \"    ctx._source.total_time_spent_millis = params.total_time_spent_millis;\\n\" +\n+        \"    ctx._source.failure_count = params.failure_count;\\n\" +\n+        \"    ctx._source.time_stamp = params.time_stamp;\";\n+    private static final ToXContent.Params FOR_INTERNAL_STORAGE_PARAMS =\n+        new ToXContent.MapParams(Collections.singletonMap(ToXContentParams.FOR_INTERNAL_STORAGE, \"true\"));\n+\n+    private final Map<String, InferenceStats> statsQueue;\n+    private final ResultsPersisterService resultsPersisterService;\n+    private final OriginSettingClient client;\n+    private final IndexNameExpressionResolver indexNameExpressionResolver;\n+    private final ThreadPool threadPool;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile boolean verifiedStatsIndexCreated;\n+    private volatile boolean stopped;\n+    private volatile ClusterState clusterState;\n+\n+    public TrainedModelStatsService(ResultsPersisterService resultsPersisterService,\n+                                    OriginSettingClient client,\n+                                    IndexNameExpressionResolver indexNameExpressionResolver,\n+                                    ClusterService clusterService,\n+                                    ThreadPool threadPool) {\n+        this.resultsPersisterService = resultsPersisterService;\n+        this.client = client;\n+        this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        this.threadPool = threadPool;\n+        this.statsQueue = new ConcurrentHashMap<>();\n+\n+        clusterService.addLifecycleListener(new LifecycleListener() {\n+            @Override\n+            public void beforeStart() {\n+                start();\n+            }\n+\n+            @Override\n+            public void beforeStop() {\n+                stop();\n+            }\n+        });\n+        clusterService.addListener((event) -> this.clusterState = event.state());\n+    }\n+\n+    public void queueStats(InferenceStats stats) {\n+        statsQueue.put(InferenceStats.docId(stats.getModelId(), stats.getNodeId()), stats);\n+    }\n+\n+    void stop() {\n+        stopped = true;\n+        statsQueue.clear();\n+\n+        ThreadPool.Cancellable cancellable = this.scheduledFuture;\n+        if (cancellable != null) {\n+            cancellable.cancel();\n+        }\n+    }\n+\n+    void start() {\n+        stopped = false;\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(this::persistStats, TimeValue.timeValueSeconds(1), ThreadPool.Names.GENERIC);", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI0MDExMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395240113", "bodyText": "We could use the ML utility one?", "author": "benwtrent", "createdAt": "2020-03-19T18:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NTMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395182285", "bodyText": "\"failure creating ml stats index\"", "author": "davidkyle", "createdAt": "2020-03-19T17:04:16Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.component.LifecycleListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.MlStatsIndex;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceStats;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+\n+public class TrainedModelStatsService {\n+\n+    private static final Logger logger = LogManager.getLogger(TrainedModelStatsService.class);\n+\n+    // Script to only update if stats have increased since last persistence\n+    private static final String STATS_UPDATE_SCRIPT = \"\" +\n+        \"if (ctx._source.missing_all_fields_count >= params.missing_all_fields_count\\n\" +\n+        \"     && ctx._source.inference_count >= params.inference_count\\n\" +\n+        \"     && ctx._source.total_time_spent_millis >= params.total_time_spent_millis\\n\" +\n+        \"     && ctx._source.failure_count >= params.failure_count) {\\n\" +\n+        \"      ctx.op = 'none';\\n\" +\n+        \"      return;\\n\" +\n+        \"    }\\n\" +\n+        \"    ctx._source.missing_all_fields_count = params.missing_all_fields_count;\\n\" +\n+        \"    ctx._source.inference_count = params.inference_count;\\n\" +\n+        \"    ctx._source.total_time_spent_millis = params.total_time_spent_millis;\\n\" +\n+        \"    ctx._source.failure_count = params.failure_count;\\n\" +\n+        \"    ctx._source.time_stamp = params.time_stamp;\";\n+    private static final ToXContent.Params FOR_INTERNAL_STORAGE_PARAMS =\n+        new ToXContent.MapParams(Collections.singletonMap(ToXContentParams.FOR_INTERNAL_STORAGE, \"true\"));\n+\n+    private final Map<String, InferenceStats> statsQueue;\n+    private final ResultsPersisterService resultsPersisterService;\n+    private final OriginSettingClient client;\n+    private final IndexNameExpressionResolver indexNameExpressionResolver;\n+    private final ThreadPool threadPool;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile boolean verifiedStatsIndexCreated;\n+    private volatile boolean stopped;\n+    private volatile ClusterState clusterState;\n+\n+    public TrainedModelStatsService(ResultsPersisterService resultsPersisterService,\n+                                    OriginSettingClient client,\n+                                    IndexNameExpressionResolver indexNameExpressionResolver,\n+                                    ClusterService clusterService,\n+                                    ThreadPool threadPool) {\n+        this.resultsPersisterService = resultsPersisterService;\n+        this.client = client;\n+        this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        this.threadPool = threadPool;\n+        this.statsQueue = new ConcurrentHashMap<>();\n+\n+        clusterService.addLifecycleListener(new LifecycleListener() {\n+            @Override\n+            public void beforeStart() {\n+                start();\n+            }\n+\n+            @Override\n+            public void beforeStop() {\n+                stop();\n+            }\n+        });\n+        clusterService.addListener((event) -> this.clusterState = event.state());\n+    }\n+\n+    public void queueStats(InferenceStats stats) {\n+        statsQueue.put(InferenceStats.docId(stats.getModelId(), stats.getNodeId()), stats);\n+    }\n+\n+    void stop() {\n+        stopped = true;\n+        statsQueue.clear();\n+\n+        ThreadPool.Cancellable cancellable = this.scheduledFuture;\n+        if (cancellable != null) {\n+            cancellable.cancel();\n+        }\n+    }\n+\n+    void start() {\n+        stopped = false;\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(this::persistStats, TimeValue.timeValueSeconds(1), ThreadPool.Names.GENERIC);\n+    }\n+\n+    void persistStats() {\n+        if (clusterState == null || statsQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        List<InferenceStats> stats = new ArrayList<>(statsQueue.size());\n+        for(String k : statsQueue.keySet()) {\n+            InferenceStats inferenceStats = statsQueue.remove(k);\n+            if (inferenceStats != null) {\n+                stats.add(inferenceStats);\n+            }\n+        }\n+        if (stats.isEmpty()) {\n+            return;\n+        }\n+        if (verifiedStatsIndexCreated == false) {\n+            try {\n+                PlainActionFuture<Boolean> listener = new PlainActionFuture<>();\n+                MlStatsIndex.createStatsIndexAndAliasIfNecessary(client, clusterState, indexNameExpressionResolver, listener);\n+                listener.actionGet();\n+                verifiedStatsIndexCreated = true;\n+            } catch (Exception e) {\n+                logger.error(\n+                    new ParameterizedMessage(\"failure updating stats for models {}\",", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MzgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395183823", "bodyText": "Will this be printed properly, what is toString() on a stream?", "author": "davidkyle", "createdAt": "2020-03-19T17:06:36Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.component.LifecycleListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.MlStatsIndex;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceStats;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+\n+public class TrainedModelStatsService {\n+\n+    private static final Logger logger = LogManager.getLogger(TrainedModelStatsService.class);\n+\n+    // Script to only update if stats have increased since last persistence\n+    private static final String STATS_UPDATE_SCRIPT = \"\" +\n+        \"if (ctx._source.missing_all_fields_count >= params.missing_all_fields_count\\n\" +\n+        \"     && ctx._source.inference_count >= params.inference_count\\n\" +\n+        \"     && ctx._source.total_time_spent_millis >= params.total_time_spent_millis\\n\" +\n+        \"     && ctx._source.failure_count >= params.failure_count) {\\n\" +\n+        \"      ctx.op = 'none';\\n\" +\n+        \"      return;\\n\" +\n+        \"    }\\n\" +\n+        \"    ctx._source.missing_all_fields_count = params.missing_all_fields_count;\\n\" +\n+        \"    ctx._source.inference_count = params.inference_count;\\n\" +\n+        \"    ctx._source.total_time_spent_millis = params.total_time_spent_millis;\\n\" +\n+        \"    ctx._source.failure_count = params.failure_count;\\n\" +\n+        \"    ctx._source.time_stamp = params.time_stamp;\";\n+    private static final ToXContent.Params FOR_INTERNAL_STORAGE_PARAMS =\n+        new ToXContent.MapParams(Collections.singletonMap(ToXContentParams.FOR_INTERNAL_STORAGE, \"true\"));\n+\n+    private final Map<String, InferenceStats> statsQueue;\n+    private final ResultsPersisterService resultsPersisterService;\n+    private final OriginSettingClient client;\n+    private final IndexNameExpressionResolver indexNameExpressionResolver;\n+    private final ThreadPool threadPool;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile boolean verifiedStatsIndexCreated;\n+    private volatile boolean stopped;\n+    private volatile ClusterState clusterState;\n+\n+    public TrainedModelStatsService(ResultsPersisterService resultsPersisterService,\n+                                    OriginSettingClient client,\n+                                    IndexNameExpressionResolver indexNameExpressionResolver,\n+                                    ClusterService clusterService,\n+                                    ThreadPool threadPool) {\n+        this.resultsPersisterService = resultsPersisterService;\n+        this.client = client;\n+        this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        this.threadPool = threadPool;\n+        this.statsQueue = new ConcurrentHashMap<>();\n+\n+        clusterService.addLifecycleListener(new LifecycleListener() {\n+            @Override\n+            public void beforeStart() {\n+                start();\n+            }\n+\n+            @Override\n+            public void beforeStop() {\n+                stop();\n+            }\n+        });\n+        clusterService.addListener((event) -> this.clusterState = event.state());\n+    }\n+\n+    public void queueStats(InferenceStats stats) {\n+        statsQueue.put(InferenceStats.docId(stats.getModelId(), stats.getNodeId()), stats);\n+    }\n+\n+    void stop() {\n+        stopped = true;\n+        statsQueue.clear();\n+\n+        ThreadPool.Cancellable cancellable = this.scheduledFuture;\n+        if (cancellable != null) {\n+            cancellable.cancel();\n+        }\n+    }\n+\n+    void start() {\n+        stopped = false;\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(this::persistStats, TimeValue.timeValueSeconds(1), ThreadPool.Names.GENERIC);\n+    }\n+\n+    void persistStats() {\n+        if (clusterState == null || statsQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        List<InferenceStats> stats = new ArrayList<>(statsQueue.size());\n+        for(String k : statsQueue.keySet()) {\n+            InferenceStats inferenceStats = statsQueue.remove(k);\n+            if (inferenceStats != null) {\n+                stats.add(inferenceStats);\n+            }\n+        }\n+        if (stats.isEmpty()) {\n+            return;\n+        }\n+        if (verifiedStatsIndexCreated == false) {\n+            try {\n+                PlainActionFuture<Boolean> listener = new PlainActionFuture<>();\n+                MlStatsIndex.createStatsIndexAndAliasIfNecessary(client, clusterState, indexNameExpressionResolver, listener);\n+                listener.actionGet();\n+                verifiedStatsIndexCreated = true;\n+            } catch (Exception e) {\n+                logger.error(\n+                    new ParameterizedMessage(\"failure updating stats for models {}\",\n+                        stats.stream().map(InferenceStats::getModelId)),", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4MzE4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395683187", "bodyText": "Nope, it won't, I am added a collector.", "author": "benwtrent", "createdAt": "2020-03-20T14:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MzgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzYzNw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395197637", "bodyText": "I thought the string replacement in the message parameter only occurred if trace is enabled", "author": "davidkyle", "createdAt": "2020-03-19T17:27:15Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java", "diffHunk": "@@ -130,24 +141,26 @@ public void getModel(String modelId, ActionListener<Model> modelActionListener)\n         LocalModel cachedModel = localModelCache.get(modelId);\n         if (cachedModel != null) {\n             modelActionListener.onResponse(cachedModel);\n-            logger.trace(\"[{}] loaded from cache\", modelId);\n+            logger.trace(() -> new ParameterizedMessage(\"[{}] loaded from cache\", modelId));", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTAyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395685025", "bodyText": "I don't know. I do know that using a message supplier is common in other logging code.", "author": "benwtrent", "createdAt": "2020-03-20T14:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4OTg0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395689846", "bodyText": "OK, looking at https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/Logger.html\nIt seems the parameters are for sure read, no matter the level (unless a supplier is used).\nThis seems to indicate that the string is formatted eagerly unless parameters are suppliers or a message supplier is passed.", "author": "benwtrent", "createdAt": "2020-03-20T14:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIwMjQyNA==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395202424", "bodyText": "This is a tricky one. When the model is done with how do we ensure it persists the latest stats. Could this implement closable and persist on close when the model is evicted from the cache?", "author": "davidkyle", "createdAt": "2020-03-19T17:34:29Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -64,17 +100,45 @@ public String getResultsType() {\n         }\n     }\n \n+    void persistStats() {\n+        trainedModelStatsService.queueStats(getLatestStats());\n+        lastStatsQueue = nanoTimeSupplier.get();\n+        if (persistenceQuotient < 1000 && currentInferenceCount.sum() > 1000) {\n+            persistenceQuotient = 1000;\n+        }\n+        if (persistenceQuotient < 10_000 && currentInferenceCount.sum() > 10_000) {\n+            persistenceQuotient = 10_000;\n+        }\n+    }\n+\n     @Override\n     public void infer(Map<String, Object> fields, InferenceConfig config, ActionListener<InferenceResults> listener) {\n         try {\n+            statsAccumulator.incInference();\n+            currentInferenceCount.increment();\n+\n             Model.mapFieldsIfNecessary(fields, defaultFieldMap);\n+\n+            long startTimeInNanos = nanoTimeSupplier.get();\n+            boolean shouldPersistStats =\n+                (TimeUnit.NANOSECONDS.toMillis(startTimeInNanos - lastStatsQueue) > MIN_PERSISTENCE_INTERVAL)\n+                || ((currentInferenceCount.sum() + 1) % persistenceQuotient == 0);", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NDA0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395684049", "bodyText": "Potentially, but what catastrophic events?\nThe reason for this is so we periodically update stats and if the node crashes, we have some stored.", "author": "benwtrent", "createdAt": "2020-03-20T14:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIwMjQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MTY1OA==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395691658", "bodyText": "I think it is inevitable to lose some stats on a node failure. But I try my best to lose as little as possible while keeping performance in mind.\nI am sure there is a better solution. I welcome better suggestions on how to handle this.", "author": "benwtrent", "createdAt": "2020-03-20T14:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIwMjQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxMzQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395213439", "bodyText": "\"search failed for model stats\"\nMaybe construct the string and use the same one for the logger and exception message", "author": "davidkyle", "createdAt": "2020-03-19T17:51:45Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/persistence/TrainedModelProvider.java", "diffHunk": "@@ -453,6 +459,155 @@ public void expandIds(String idExpression,\n             client::search);\n     }\n \n+    public void getInferenceStats(String[] modelIds, ActionListener<List<InferenceStats>> listener) {\n+        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\n+        Arrays.stream(modelIds).map(this::buildStatsSearchRequest).forEach(multiSearchRequest::add);\n+        if (multiSearchRequest.requests().isEmpty()) {\n+            listener.onResponse(Collections.emptyList());\n+            return;\n+        }\n+        executeAsyncWithOrigin(client.threadPool().getThreadContext(),\n+            ML_ORIGIN,\n+            multiSearchRequest,\n+            ActionListener.<MultiSearchResponse>wrap(\n+                responses -> {\n+                    List<InferenceStats> allStats = new ArrayList<>(modelIds.length);\n+                    int modelIndex = 0;\n+                    assert responses.getResponses().length == modelIds.length :\n+                        \"mismatch between search response size and models requested\";\n+                    for (MultiSearchResponse.Item response : responses.getResponses()) {\n+                        if (response.isFailure()) {\n+                            if (ExceptionsHelper.unwrapCause(response.getFailure()) instanceof ResourceNotFoundException) {\n+                                continue;\n+                            }\n+                            logger.error(new ParameterizedMessage(\"search failed for models [{}]\",", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxNDMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395214307", "bodyText": "modelIndex++;", "author": "davidkyle", "createdAt": "2020-03-19T17:53:12Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/persistence/TrainedModelProvider.java", "diffHunk": "@@ -453,6 +459,155 @@ public void expandIds(String idExpression,\n             client::search);\n     }\n \n+    public void getInferenceStats(String[] modelIds, ActionListener<List<InferenceStats>> listener) {\n+        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\n+        Arrays.stream(modelIds).map(this::buildStatsSearchRequest).forEach(multiSearchRequest::add);\n+        if (multiSearchRequest.requests().isEmpty()) {\n+            listener.onResponse(Collections.emptyList());\n+            return;\n+        }\n+        executeAsyncWithOrigin(client.threadPool().getThreadContext(),\n+            ML_ORIGIN,\n+            multiSearchRequest,\n+            ActionListener.<MultiSearchResponse>wrap(\n+                responses -> {\n+                    List<InferenceStats> allStats = new ArrayList<>(modelIds.length);\n+                    int modelIndex = 0;\n+                    assert responses.getResponses().length == modelIds.length :\n+                        \"mismatch between search response size and models requested\";\n+                    for (MultiSearchResponse.Item response : responses.getResponses()) {\n+                        if (response.isFailure()) {\n+                            if (ExceptionsHelper.unwrapCause(response.getFailure()) instanceof ResourceNotFoundException) {\n+                                continue;", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxNzY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395217651", "bodyText": "In theory the number of stats docs returned is the number of distinct count of nodes the model was ever open on? And there will be one document for every unique node/model id pair", "author": "davidkyle", "createdAt": "2020-03-19T17:58:34Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/persistence/TrainedModelProvider.java", "diffHunk": "@@ -453,6 +459,155 @@ public void expandIds(String idExpression,\n             client::search);\n     }\n \n+    public void getInferenceStats(String[] modelIds, ActionListener<List<InferenceStats>> listener) {\n+        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\n+        Arrays.stream(modelIds).map(this::buildStatsSearchRequest).forEach(multiSearchRequest::add);\n+        if (multiSearchRequest.requests().isEmpty()) {\n+            listener.onResponse(Collections.emptyList());\n+            return;\n+        }\n+        executeAsyncWithOrigin(client.threadPool().getThreadContext(),\n+            ML_ORIGIN,\n+            multiSearchRequest,\n+            ActionListener.<MultiSearchResponse>wrap(\n+                responses -> {\n+                    List<InferenceStats> allStats = new ArrayList<>(modelIds.length);\n+                    int modelIndex = 0;\n+                    assert responses.getResponses().length == modelIds.length :\n+                        \"mismatch between search response size and models requested\";\n+                    for (MultiSearchResponse.Item response : responses.getResponses()) {\n+                        if (response.isFailure()) {\n+                            if (ExceptionsHelper.unwrapCause(response.getFailure()) instanceof ResourceNotFoundException) {\n+                                continue;\n+                            }\n+                            logger.error(new ParameterizedMessage(\"search failed for models [{}]\",\n+                                    Strings.arrayToCommaDelimitedString(modelIds)),\n+                                response.getFailure());\n+                            listener.onFailure(ExceptionsHelper.serverError(\"Searching for stats for models [{}] failed\",\n+                                response.getFailure(),\n+                                Strings.arrayToCommaDelimitedString(modelIds)));\n+                            return;\n+                        }\n+                        try {\n+                            InferenceStats inferenceStats = handleMultiNodeStatsResponse(response.getResponse(), modelIds[modelIndex++]);\n+                            if (inferenceStats != null) {\n+                                allStats.add(inferenceStats);\n+                            }\n+                        } catch (Exception e) {\n+                            listener.onFailure(e);\n+                            return;\n+                        }\n+                    }\n+                    listener.onResponse(allStats);\n+                },\n+                e -> {\n+                    Throwable unwrapped = ExceptionsHelper.unwrapCause(e);\n+                    if (unwrapped instanceof ResourceNotFoundException) {\n+                        listener.onResponse(Collections.emptyList());\n+                        return;\n+                    }\n+                    listener.onFailure((Exception)unwrapped);\n+                }\n+            ),\n+            client::multiSearch);\n+    }\n+\n+    private SearchRequest buildStatsSearchRequest(String modelId) {\n+        BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery()\n+            .filter(QueryBuilders.termQuery(InferenceStats.MODEL_ID.getPreferredName(), modelId))\n+            .filter(QueryBuilders.termQuery(InferenceStats.TYPE.getPreferredName(), InferenceStats.NAME));\n+        return new SearchRequest(MlStatsIndex.indexPattern())\n+            .indicesOptions(IndicesOptions.lenientExpandOpen())\n+            .allowPartialSearchResults(false)\n+            .source(SearchSourceBuilder.searchSource()\n+                .size(MAX_NODE_STATS_SIZE)", "originalCommit": "c406e8e542dd6ad4e503c0cb4dd75ffdb5c4988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI0MTI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r395241255", "bodyText": "Correct, in theory. The issue comes down to how greedy ILM is + the scale of the deployment. If there are 10x previous indices and the model has been deployed on 1000x separate nodes, we would hit the limit.", "author": "benwtrent", "createdAt": "2020-03-19T18:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxNzY1MQ=="}], "type": "inlineReview"}, {"oid": "b7bda48eee739bb4f730a7be564aec530b3c6333", "url": "https://github.com/elastic/elasticsearch/commit/b7bda48eee739bb4f730a7be564aec530b3c6333", "message": "addressing pr comments", "committedDate": "2020-03-20T14:55:55Z", "type": "commit"}, {"oid": "6bf2263eaf42762dd92df701ee5a77ce099f6815", "url": "https://github.com/elastic/elasticsearch/commit/6bf2263eaf42762dd92df701ee5a77ce099f6815", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-03-20T14:57:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3OTgxOA==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r396679818", "bodyText": "I know we are using the utility threadpool but this should really be aysnc i think. Maybe use ThreadedActionListener to ensure the nexts steps are done on the ML utility thread pool", "author": "davidkyle", "createdAt": "2020-03-23T18:47:58Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.component.LifecycleListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.MlStatsIndex;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceStats;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+import org.elasticsearch.xpack.ml.MachineLearning;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+\n+public class TrainedModelStatsService {\n+\n+    private static final Logger logger = LogManager.getLogger(TrainedModelStatsService.class);\n+\n+    // Script to only update if stats have increased since last persistence\n+    private static final String STATS_UPDATE_SCRIPT = \"\" +\n+        \"if (ctx._source.missing_all_fields_count >= params.missing_all_fields_count\\n\" +\n+        \"     && ctx._source.inference_count >= params.inference_count\\n\" +\n+        \"     && ctx._source.total_time_spent_millis >= params.total_time_spent_millis\\n\" +\n+        \"     && ctx._source.failure_count >= params.failure_count) {\\n\" +\n+        \"      ctx.op = 'none';\\n\" +\n+        \"      return;\\n\" +\n+        \"    }\\n\" +\n+        \"    ctx._source.missing_all_fields_count = params.missing_all_fields_count;\\n\" +\n+        \"    ctx._source.inference_count = params.inference_count;\\n\" +\n+        \"    ctx._source.total_time_spent_millis = params.total_time_spent_millis;\\n\" +\n+        \"    ctx._source.failure_count = params.failure_count;\\n\" +\n+        \"    ctx._source.time_stamp = params.time_stamp;\";\n+    private static final ToXContent.Params FOR_INTERNAL_STORAGE_PARAMS =\n+        new ToXContent.MapParams(Collections.singletonMap(ToXContentParams.FOR_INTERNAL_STORAGE, \"true\"));\n+\n+    private final Map<String, InferenceStats> statsQueue;\n+    private final ResultsPersisterService resultsPersisterService;\n+    private final OriginSettingClient client;\n+    private final IndexNameExpressionResolver indexNameExpressionResolver;\n+    private final ThreadPool threadPool;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile boolean verifiedStatsIndexCreated;\n+    private volatile boolean stopped;\n+    private volatile ClusterState clusterState;\n+\n+    public TrainedModelStatsService(ResultsPersisterService resultsPersisterService,\n+                                    OriginSettingClient client,\n+                                    IndexNameExpressionResolver indexNameExpressionResolver,\n+                                    ClusterService clusterService,\n+                                    ThreadPool threadPool) {\n+        this.resultsPersisterService = resultsPersisterService;\n+        this.client = client;\n+        this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        this.threadPool = threadPool;\n+        this.statsQueue = new ConcurrentHashMap<>();\n+\n+        clusterService.addLifecycleListener(new LifecycleListener() {\n+            @Override\n+            public void beforeStart() {\n+                start();\n+            }\n+\n+            @Override\n+            public void beforeStop() {\n+                stop();\n+            }\n+        });\n+        clusterService.addListener((event) -> this.clusterState = event.state());\n+    }\n+\n+    public void queueStats(InferenceStats stats) {\n+        statsQueue.put(InferenceStats.docId(stats.getModelId(), stats.getNodeId()), stats);\n+    }\n+\n+    void stop() {\n+        stopped = true;\n+        statsQueue.clear();\n+\n+        ThreadPool.Cancellable cancellable = this.scheduledFuture;\n+        if (cancellable != null) {\n+            cancellable.cancel();\n+        }\n+    }\n+\n+    void start() {\n+        stopped = false;\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(this::persistStats,\n+            TimeValue.timeValueSeconds(1),\n+            MachineLearning.UTILITY_THREAD_POOL_NAME);\n+    }\n+\n+    void persistStats() {\n+        if (clusterState == null || statsQueue.isEmpty()) {\n+            return;\n+        }\n+\n+        List<InferenceStats> stats = new ArrayList<>(statsQueue.size());\n+        for(String k : statsQueue.keySet()) {\n+            InferenceStats inferenceStats = statsQueue.remove(k);\n+            if (inferenceStats != null) {\n+                stats.add(inferenceStats);\n+            }\n+        }\n+        if (stats.isEmpty()) {\n+            return;\n+        }\n+        if (verifiedStatsIndexCreated == false) {\n+            try {\n+                PlainActionFuture<Boolean> listener = new PlainActionFuture<>();\n+                MlStatsIndex.createStatsIndexAndAliasIfNecessary(client, clusterState, indexNameExpressionResolver, listener);\n+                listener.actionGet();", "originalCommit": "6bf2263eaf42762dd92df701ee5a77ce099f6815", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1NTA4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r400855082", "bodyText": "If this was async, the calling thread would exit before it finished. It could get triggered again before this update has completed.", "author": "benwtrent", "createdAt": "2020-03-31T11:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3OTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5MDYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r396690629", "bodyText": "Even if is replaced it is replaced by a model that read the old persisted stats. Should it not always persist so changes are captured.", "author": "davidkyle", "createdAt": "2020-03-23T19:06:37Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java", "diffHunk": "@@ -235,17 +250,20 @@ private void handleLoadFailure(String modelId, Exception failure) {\n \n     private void cacheEvictionListener(RemovalNotification<String, LocalModel> notification) {\n         if (notification.getRemovalReason() == RemovalNotification.RemovalReason.EVICTED) {\n-            String msg = new ParameterizedMessage(\n+            MessageSupplier msg = () -> new ParameterizedMessage(\n                 \"model cache entry evicted.\" +\n                     \"current cache [{}] current max [{}] model size [{}]. \" +\n                     \"If this is undesired, consider updating setting [{}] or [{}].\",\n                 new ByteSizeValue(localModelCache.weight()).getStringRep(),\n                 maxCacheSize.getStringRep(),\n                 new ByteSizeValue(notification.getValue().ramBytesUsed()).getStringRep(),\n                 INFERENCE_MODEL_CACHE_SIZE.getKey(),\n-                INFERENCE_MODEL_CACHE_TTL.getKey()).getFormattedMessage();\n+                INFERENCE_MODEL_CACHE_TTL.getKey());\n             auditIfNecessary(notification.getKey(), msg);\n         }\n+        if (notification.getRemovalReason() != RemovalNotification.RemovalReason.REPLACED) {", "originalCommit": "6bf2263eaf42762dd92df701ee5a77ce099f6815", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MjIwMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r400862203", "bodyText": "True.\nI also don't see where in the code a cache replace is even possible. But, persisting even on replace protects us some from losing stats.", "author": "benwtrent", "createdAt": "2020-03-31T12:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5MDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5MTkzMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r396691933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void persistStats() {\n          \n          \n            \n                void updateStats() {\n          \n      \n    \n    \n  \n\nTo me persistStats() makes me think they are being overwritten and update is clearer. That's how I see it anyway many people may disagree", "author": "davidkyle", "createdAt": "2020-03-23T19:08:56Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.component.LifecycleListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.MlStatsIndex;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceStats;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+import org.elasticsearch.xpack.ml.MachineLearning;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+\n+public class TrainedModelStatsService {\n+\n+    private static final Logger logger = LogManager.getLogger(TrainedModelStatsService.class);\n+\n+    // Script to only update if stats have increased since last persistence\n+    private static final String STATS_UPDATE_SCRIPT = \"\" +\n+        \"if (ctx._source.missing_all_fields_count >= params.missing_all_fields_count\\n\" +\n+        \"     && ctx._source.inference_count >= params.inference_count\\n\" +\n+        \"     && ctx._source.total_time_spent_millis >= params.total_time_spent_millis\\n\" +\n+        \"     && ctx._source.failure_count >= params.failure_count) {\\n\" +\n+        \"      ctx.op = 'none';\\n\" +\n+        \"      return;\\n\" +\n+        \"    }\\n\" +\n+        \"    ctx._source.missing_all_fields_count = params.missing_all_fields_count;\\n\" +\n+        \"    ctx._source.inference_count = params.inference_count;\\n\" +\n+        \"    ctx._source.total_time_spent_millis = params.total_time_spent_millis;\\n\" +\n+        \"    ctx._source.failure_count = params.failure_count;\\n\" +\n+        \"    ctx._source.time_stamp = params.time_stamp;\";\n+    private static final ToXContent.Params FOR_INTERNAL_STORAGE_PARAMS =\n+        new ToXContent.MapParams(Collections.singletonMap(ToXContentParams.FOR_INTERNAL_STORAGE, \"true\"));\n+\n+    private final Map<String, InferenceStats> statsQueue;\n+    private final ResultsPersisterService resultsPersisterService;\n+    private final OriginSettingClient client;\n+    private final IndexNameExpressionResolver indexNameExpressionResolver;\n+    private final ThreadPool threadPool;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile boolean verifiedStatsIndexCreated;\n+    private volatile boolean stopped;\n+    private volatile ClusterState clusterState;\n+\n+    public TrainedModelStatsService(ResultsPersisterService resultsPersisterService,\n+                                    OriginSettingClient client,\n+                                    IndexNameExpressionResolver indexNameExpressionResolver,\n+                                    ClusterService clusterService,\n+                                    ThreadPool threadPool) {\n+        this.resultsPersisterService = resultsPersisterService;\n+        this.client = client;\n+        this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        this.threadPool = threadPool;\n+        this.statsQueue = new ConcurrentHashMap<>();\n+\n+        clusterService.addLifecycleListener(new LifecycleListener() {\n+            @Override\n+            public void beforeStart() {\n+                start();\n+            }\n+\n+            @Override\n+            public void beforeStop() {\n+                stop();\n+            }\n+        });\n+        clusterService.addListener((event) -> this.clusterState = event.state());\n+    }\n+\n+    public void queueStats(InferenceStats stats) {\n+        statsQueue.put(InferenceStats.docId(stats.getModelId(), stats.getNodeId()), stats);\n+    }\n+\n+    void stop() {\n+        stopped = true;\n+        statsQueue.clear();\n+\n+        ThreadPool.Cancellable cancellable = this.scheduledFuture;\n+        if (cancellable != null) {\n+            cancellable.cancel();\n+        }\n+    }\n+\n+    void start() {\n+        stopped = false;\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(this::persistStats,\n+            TimeValue.timeValueSeconds(1),\n+            MachineLearning.UTILITY_THREAD_POOL_NAME);\n+    }\n+\n+    void persistStats() {", "originalCommit": "6bf2263eaf42762dd92df701ee5a77ce099f6815", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf4051a8a3d3a0537eba561997e22b448f623f31", "url": "https://github.com/elastic/elasticsearch/commit/bf4051a8a3d3a0537eba561997e22b448f623f31", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-03-31T11:45:42Z", "type": "commit"}, {"oid": "0d6ba92c884398d97d4c004c4a684221748fdc50", "url": "https://github.com/elastic/elasticsearch/commit/0d6ba92c884398d97d4c004c4a684221748fdc50", "message": "addressing pr comments", "committedDate": "2020-03-31T15:04:54Z", "type": "commit"}, {"oid": "d2aecfaeaab36b7f2eba610ebfa54465cb8a3b41", "url": "https://github.com/elastic/elasticsearch/commit/d2aecfaeaab36b7f2eba610ebfa54465cb8a3b41", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-03-31T18:04:29Z", "type": "commit"}, {"oid": "9faca62c3b6ffdf95106785b0568fe7c3f3efcb2", "url": "https://github.com/elastic/elasticsearch/commit/9faca62c3b6ffdf95106785b0568fe7c3f3efcb2", "message": "fixing style checks", "committedDate": "2020-03-31T18:18:59Z", "type": "commit"}, {"oid": "5b0cf39509e900762171fddb616fbc13a43d5492", "url": "https://github.com/elastic/elasticsearch/commit/5b0cf39509e900762171fddb616fbc13a43d5492", "message": "Merge branch 'feature/ml-inference-stats-collection' of github.com:benwtrent/elasticsearch into feature/ml-inference-stats-collection", "committedDate": "2020-03-31T18:19:06Z", "type": "commit"}, {"oid": "f5f2821b94dcc763fa884c11a127ecda82a3c885", "url": "https://github.com/elastic/elasticsearch/commit/f5f2821b94dcc763fa884c11a127ecda82a3c885", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-03-31T18:30:27Z", "type": "commit"}, {"oid": "fe444885b7f8b906f1c093d7888f324b52eb127a", "url": "https://github.com/elastic/elasticsearch/commit/fe444885b7f8b906f1c093d7888f324b52eb127a", "message": "Update InferenceIngestIT.java", "committedDate": "2020-04-01T12:27:51Z", "type": "commit"}, {"oid": "650947b4df331597595ce4ab1f553cd0e9ce484a", "url": "https://github.com/elastic/elasticsearch/commit/650947b4df331597595ce4ab1f553cd0e9ce484a", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-04-01T13:03:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3MTQxMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r402271413", "bodyText": "Can total_time_spent_millis be removed now?", "author": "davidkyle", "createdAt": "2020-04-02T12:24:07Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.component.LifecycleListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.MlStatsIndex;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceStats;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+import org.elasticsearch.xpack.ml.MachineLearning;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+\n+public class TrainedModelStatsService {\n+\n+    private static final Logger logger = LogManager.getLogger(TrainedModelStatsService.class);\n+\n+    // Script to only update if stats have increased since last persistence\n+    private static final String STATS_UPDATE_SCRIPT = \"\" +\n+        \"if (ctx._source.missing_all_fields_count >= params.missing_all_fields_count\\n\" +\n+        \"     && ctx._source.inference_count >= params.inference_count\\n\" +\n+        \"     && ctx._source.total_time_spent_millis >= params.total_time_spent_millis\\n\" +\n+        \"     && ctx._source.failure_count >= params.failure_count) {\\n\" +\n+        \"      ctx.op = 'none';\\n\" +\n+        \"      return;\\n\" +\n+        \"    }\\n\" +\n+        \"    ctx._source.missing_all_fields_count = params.missing_all_fields_count;\\n\" +\n+        \"    ctx._source.inference_count = params.inference_count;\\n\" +\n+        \"    ctx._source.total_time_spent_millis = params.total_time_spent_millis;\\n\" +", "originalCommit": "650947b4df331597595ce4ab1f553cd0e9ce484a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r402404439", "bodyText": "I don't see how an update could be queued with at least one field having changed am I missing something?", "author": "davidkyle", "createdAt": "2020-04-02T15:28:28Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.component.LifecycleListener;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.MlStatsIndex;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceStats;\n+import org.elasticsearch.xpack.core.ml.utils.ToXContentParams;\n+import org.elasticsearch.xpack.ml.MachineLearning;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+\n+public class TrainedModelStatsService {\n+\n+    private static final Logger logger = LogManager.getLogger(TrainedModelStatsService.class);\n+\n+    // Script to only update if stats have increased since last persistence\n+    private static final String STATS_UPDATE_SCRIPT = \"\" +\n+        \"if (ctx._source.missing_all_fields_count >= params.missing_all_fields_count\\n\" +", "originalCommit": "650947b4df331597595ce4ab1f553cd0e9ce484a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNjM2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r402506369", "bodyText": "This is to protect against non-monotonically increasing stats.\nThere is a pathological scenario where:\n\nmodel is loaded\nwrites stats\nunloaded\nreloaded before previous stats write occurs and starts at the previous values\nattempts to write stats again, but the new values could be lower than the previously written ones.\n\nScenarios like this one are where I wish I could use optimistic concurrency, but since the underlying indices are ILM managed, I don't know when an index switches out from under the process :/. This FEELS like a fundamental flaw with optimistic concurrency and ILM. I really wish there was a POST where it either HAS to match the seq_no and primary_term OR if the doc doesn't exist, create it.", "author": "benwtrent", "createdAt": "2020-04-02T17:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNjMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r402526326", "bodyText": "This complexity makes me think that one of the following might have to be done\n\n\nstats should be append only for inference some how (sum aggs to pull them together). This feels like we could have tons of docs being written to the .ml-stats index, but is the easiest solution for now...\n\n\nwe don't use the .ml-stats index and do something similar to transforms (keeping track of the original underlying index name). This adds complexity as we now have yet another index, alias woes, and we will have to add optimistic concurrency controls between the stats persister and the thing persisting the stats.", "author": "benwtrent", "createdAt": "2020-04-02T18:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0MTYzMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r402841633", "bodyText": "Silly question why can't you increment the fields in the upsert, that way it doesn't matter if the updates arrive out of order. The stats accumulator would have to change track only the changes since the last persist but that is simple enough\nctx._source.missing_all_fields_count += params.missing_all_fields_count;", "author": "davidkyle", "createdAt": "2020-04-03T08:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0MjYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r402942632", "bodyText": "\ud83e\udd14\nI will work on it. I think this SHOULD work, my original design was not assuming a single input queue. Here, we do have a single persistence queue that guarantees order.", "author": "benwtrent", "createdAt": "2020-04-03T11:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2OTYxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r402969619", "bodyText": "The counters are not thread safe when reset to 0\nThe way to address this would be to keep track of the inference stats in LocalModel with an atomic reference. Then when stats are persisted to swap it out with a new one. I am not 100% of the performance impact.\nRight now performance is not really measured. So \ud83e\udd37\u200d\u2642", "author": "benwtrent", "createdAt": "2020-04-03T12:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDQzOQ=="}], "type": "inlineReview"}, {"oid": "c2c1522c5c547cd080f1a9a72c3876ecff228661", "url": "https://github.com/elastic/elasticsearch/commit/c2c1522c5c547cd080f1a9a72c3876ecff228661", "message": "Merge branch 'master' into feature/ml-inference-stats-collection", "committedDate": "2020-04-02T17:21:46Z", "type": "commit"}, {"oid": "5f86f95ce011a667d509415a5fb3e5d3e627e698", "url": "https://github.com/elastic/elasticsearch/commit/5f86f95ce011a667d509415a5fb3e5d3e627e698", "message": "addressing PR comments", "committedDate": "2020-04-02T17:57:35Z", "type": "commit"}, {"oid": "0360c3b79da834b2ab01b3aff3cc3e2a4d38f812", "url": "https://github.com/elastic/elasticsearch/commit/0360c3b79da834b2ab01b3aff3cc3e2a4d38f812", "message": "incrementally updating stats instead of overwriting", "committedDate": "2020-04-03T14:00:51Z", "type": "commit"}, {"oid": "8802fc40b67ab7236fb6a0447fe10b1aaa6dfaf8", "url": "https://github.com/elastic/elasticsearch/commit/8802fc40b67ab7236fb6a0447fe10b1aaa6dfaf8", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-inference-stats-collection", "committedDate": "2020-04-03T14:02:40Z", "type": "commit"}, {"oid": "0cca932fa83619e0f9f63cb8997d850d3d303e49", "url": "https://github.com/elastic/elasticsearch/commit/0cca932fa83619e0f9f63cb8997d850d3d303e49", "message": "fixing bwc serialization versions", "committedDate": "2020-04-03T14:11:48Z", "type": "commit"}, {"oid": "ff15e9726afda212a3d0c934c4d1d0a406e57477", "url": "https://github.com/elastic/elasticsearch/commit/ff15e9726afda212a3d0c934c4d1d0a406e57477", "message": "minor fixes", "committedDate": "2020-04-03T14:17:30Z", "type": "commit"}, {"oid": "74b95d54c952f8adccb8c1d8e51b29b1bbe0f14b", "url": "https://github.com/elastic/elasticsearch/commit/74b95d54c952f8adccb8c1d8e51b29b1bbe0f14b", "message": "handling situation where aggs are null", "committedDate": "2020-04-03T14:54:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA3MzExMw==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r403073113", "bodyText": "Yikes! good catch", "author": "davidkyle", "createdAt": "2020-04-03T15:08:07Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/TrainedModelStatsService.java", "diffHunk": "@@ -97,7 +92,8 @@ public void beforeStop() {\n     }\n \n     public void queueStats(InferenceStats stats) {\n-        statsQueue.put(InferenceStats.docId(stats.getModelId(), stats.getNodeId()), stats);\n+        statsQueue.computeIfPresent(InferenceStats.docId(stats.getModelId(), stats.getNodeId()),", "originalCommit": "0360c3b79da834b2ab01b3aff3cc3e2a4d38f812", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA3ODQ0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53429#discussion_r403078445", "bodyText": "\ud83d\udc4d", "author": "davidkyle", "createdAt": "2020-04-03T15:16:15Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -67,8 +70,9 @@ public String getModelId() {\n     }\n \n     @Override\n-    public InferenceStats getLatestStats() {\n-        return statsAccumulator.currentStats();\n+    public InferenceStats getLatestStatsAndReset() {\n+        InferenceStats.Accumulator toPersist = statsAccumulator.getAndSet(new InferenceStats.Accumulator(modelId, nodeId));", "originalCommit": "0360c3b79da834b2ab01b3aff3cc3e2a4d38f812", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1d7abd570cf67a0832654fff080c217b2e55fc4f", "url": "https://github.com/elastic/elasticsearch/commit/1d7abd570cf67a0832654fff080c217b2e55fc4f", "message": "fixing stats queueing", "committedDate": "2020-04-03T15:53:48Z", "type": "commit"}]}