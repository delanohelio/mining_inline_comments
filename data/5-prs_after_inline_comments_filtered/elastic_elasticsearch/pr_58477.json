{"pr_number": 58477, "pr_title": "Allows SparseFileTracker to progressively execute listeners during Gap processing", "pr_createdAt": "2020-06-24T08:10:55Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58477", "timeline": [{"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "url": "https://github.com/elastic/elasticsearch/commit/3b3dc50fe019e272acb8953650e06a797ebdd0dd", "message": "Add ProgressListenableActionFuture", "committedDate": "2020-06-24T07:27:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjAyNw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444786027", "bodyText": "I think there might be an off-by-one error lurking here. IMO we should report progress of value when the range \u27e8start, value\u27e9 is available, noting that our ranges are inclusive at the start and exclusive at the end. This means I think we can start with progress == start (not null) indicating that the available range is empty, and require start < value below.\nProbably a good idea to document this here too.", "author": "DaveCTurner", "createdAt": "2020-06-24T10:04:33Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/ProgressListenableActionFuture.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ListenableActionFuture;\n+import org.elasticsearch.action.support.AdapterActionFuture;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An {@link ActionFuture} that listeners can be attached to. Listeners are executed when the future is completed\n+ * or when a given progress is reached. Progression is updated using the {@link #onProgress(long)} method.\n+ *\n+ * Listeners are executed within the thread that triggers the completion, the failure or the progress update and\n+ * the progress value passed to the listeners on execution is the last updated value.\n+ */\n+class ProgressListenableActionFuture extends AdapterActionFuture<Long, Long> implements ListenableActionFuture<Long> {\n+\n+    protected final long start;\n+    protected final long end;\n+\n+    // modified under 'this' mutex\n+    private volatile List<Tuple<Long, ActionListener<Long>>> listeners;\n+    protected volatile @Nullable Long progress; // null if never updated\n+    private volatile boolean completed;\n+\n+    /**\n+     * Creates a {@link ProgressListenableActionFuture} that accepts the progression\n+     * to be within {@code start} (inclusive) and {@code end} (exclusive) values.\n+     *\n+     * @param start the start (inclusive)\n+     * @param end   the end (exclusive)\n+     */\n+    ProgressListenableActionFuture(long start, long end) {\n+        super();\n+        this.start = start;\n+        this.end = end;\n+        this.completed = false;\n+        assert invariant();\n+    }\n+\n+    private boolean invariant() {\n+        assert start < end : start + \" < \" + end;\n+        synchronized (this) {\n+            assert completed == false || listeners == null;\n+            if (progress != null) {\n+                assert start <= progress : start + \" <= \" + progress;\n+                assert progress <= end : progress + \" <= \" + end;\n+                assert listeners == null || listeners.stream().allMatch(listener -> progress < listener.v1());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Updates the progress of the current {@link ActionFuture} with the given value. Calling this method\n+     * potentially triggers the execution of one or more listeners that are waiting for the progress\n+     * to reach a value lower than the one just updated.\n+     *\n+     * @param value the new progress value", "originalCommit": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5MDc5MA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445490790", "bodyText": "I agree; I've been a bit back and forth here.", "author": "tlrx", "createdAt": "2020-06-25T11:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445494079", "bodyText": "Should we rename the parameter progress to align it with the {@code progress} in the paragraph above?", "author": "DaveCTurner", "createdAt": "2020-06-25T11:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NzU0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444787545", "bodyText": "Let's require the subrange to be non-null, it's only null in tests AFAICT.", "author": "DaveCTurner", "createdAt": "2020-06-24T10:07:21Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -57,19 +57,50 @@ private long computeLengthOfRanges() {\n     }\n \n     /**\n-     * Called before reading a range from the file to ensure that this range is present. Returns a list of gaps for the caller to fill.\n+     * Called before reading a range from the file to ensure that this range is present. Returns a list of gaps for the caller to fill. The\n+     * range from the file is defined by {@code range} but the listener can be executed as soon as a smaller sub range {@code subRange}\n+     * becomes available. When no {@code subRange} is provided the listener is executed once the full range is available.\n      *\n-     * @param start    The (inclusive) start of the desired range\n-     * @param end      The (exclusive) end of the desired range\n-     * @param listener Listener for when this range is fully available\n+     * @param range    A tuple that contains the (inclusive) start and (exclusive) end of the desired range\n+     * @param subRange A tuple that contains the (inclusive) start and (exclusive) end of the listener's range\n+     * @param listener Listener for when the listening range is fully available\n      * @return A collection of gaps that the client should fill in to satisfy this range\n      * @throws IllegalArgumentException if invalid range is requested\n      */\n-    public List<Gap> waitForRange(final long start, final long end, final ActionListener<Void> listener) {\n+    public List<Gap> waitForRange(\n+        final Tuple<Long, Long> range,\n+        @Nullable final Tuple<Long, Long> subRange,", "originalCommit": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4ODg4OA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444788888", "bodyText": "I expected this constructor to make a completed range whereas in fact we use the other one and pass null as the listener. There's only a couple of call-sites, I'd prefer to inline this to avoid that confusion.", "author": "DaveCTurner", "createdAt": "2020-06-24T10:09:51Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -358,9 +432,13 @@ public String toString() {\n         long end;\n \n         @Nullable // if not pending\n-        final PlainListenableActionFuture<Void> completionListener;\n+        final ProgressListenableActionFuture completionListener;\n+\n+        Range(long start, long end) {", "originalCommit": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4OTcyNA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444789724", "bodyText": "I think this shouldn't happen, so should be an assertion. Maybe just remove it since we assert it in onGapProgress anyway.", "author": "DaveCTurner", "createdAt": "2020-06-24T10:11:31Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -330,12 +399,17 @@ public String toString() {\n             this.end = end;\n         }\n \n-        @Override\n-        public void onResponse(Void aVoid) {\n+        public void onCompletion() {\n             onGapSuccess(start, end);\n         }\n \n-        @Override\n+        public void onProgress(long value) {\n+            if (value < start || end < value) {\n+                throw new IllegalArgumentException(\"Cannot update progress [\" + value + \"] for gap [\" + start + '-' + end + ']');", "originalCommit": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MTM4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444791383", "bodyText": "Seems strange to have to look up the range corresponding with the gap here, maybe Gap should keep hold of the corresponding Range so it can call the listener directly.", "author": "DaveCTurner", "createdAt": "2020-06-24T10:14:52Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -249,11 +299,30 @@ private void onGapSuccess(final long start, final long end) {\n             assert invariant();\n         }\n \n-        completionListener.onResponse(null);\n+        completionListener.onResponse(end);\n+    }\n+\n+    private void onGapProgress(long start, long end, long value) {\n+        final ProgressListenableActionFuture completionListener;\n+\n+        synchronized (mutex) {\n+            assert invariant();\n+\n+            final Range range = new Range(start, end, null);\n+            final SortedSet<Range> existingRanges = ranges.tailSet(range);", "originalCommit": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5MDE3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445490177", "bodyText": "The onSuccess and onFailure methods would also benefit from keeping a reference to the range; the look up should not be necessary there too as a pending Range should not be completed or failed outside of the corresponding Gap. I'm tempted to address this in a follow up PR.", "author": "tlrx", "createdAt": "2020-06-25T11:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MTM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5MzUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445493509", "bodyText": "Sure, a followup is fine. The difference with onSuccess and onFailure is that they also adjust ranges, but they do indeed start with the same kind of lookup as we do here.", "author": "DaveCTurner", "createdAt": "2020-06-25T11:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MTM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwOTE3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r446109177", "bodyText": "I opened #58587 for this.", "author": "tlrx", "createdAt": "2020-06-26T10:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjQzOA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444792438", "bodyText": "Can we drop this (and the implements ListenableActionFuture<Long> that requires it)? I think callers should always specify their target endpoint.", "author": "DaveCTurner", "createdAt": "2020-06-24T10:16:55Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/ProgressListenableActionFuture.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ListenableActionFuture;\n+import org.elasticsearch.action.support.AdapterActionFuture;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An {@link ActionFuture} that listeners can be attached to. Listeners are executed when the future is completed\n+ * or when a given progress is reached. Progression is updated using the {@link #onProgress(long)} method.\n+ *\n+ * Listeners are executed within the thread that triggers the completion, the failure or the progress update and\n+ * the progress value passed to the listeners on execution is the last updated value.\n+ */\n+class ProgressListenableActionFuture extends AdapterActionFuture<Long, Long> implements ListenableActionFuture<Long> {\n+\n+    protected final long start;\n+    protected final long end;\n+\n+    // modified under 'this' mutex\n+    private volatile List<Tuple<Long, ActionListener<Long>>> listeners;\n+    protected volatile @Nullable Long progress; // null if never updated\n+    private volatile boolean completed;\n+\n+    /**\n+     * Creates a {@link ProgressListenableActionFuture} that accepts the progression\n+     * to be within {@code start} (inclusive) and {@code end} (exclusive) values.\n+     *\n+     * @param start the start (inclusive)\n+     * @param end   the end (exclusive)\n+     */\n+    ProgressListenableActionFuture(long start, long end) {\n+        super();\n+        this.start = start;\n+        this.end = end;\n+        this.completed = false;\n+        assert invariant();\n+    }\n+\n+    private boolean invariant() {\n+        assert start < end : start + \" < \" + end;\n+        synchronized (this) {\n+            assert completed == false || listeners == null;\n+            if (progress != null) {\n+                assert start <= progress : start + \" <= \" + progress;\n+                assert progress <= end : progress + \" <= \" + end;\n+                assert listeners == null || listeners.stream().allMatch(listener -> progress < listener.v1());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Updates the progress of the current {@link ActionFuture} with the given value. Calling this method\n+     * potentially triggers the execution of one or more listeners that are waiting for the progress\n+     * to reach a value lower than the one just updated.\n+     *\n+     * @param value the new progress value\n+     */\n+    public void onProgress(final long value) {\n+        ensureNotCompleted();\n+\n+        if (value < start) {\n+            assert false : value + \" < \" + start;\n+            throw new IllegalArgumentException(\"Cannot update progress with a value less than [start=\" + start + ']');\n+        }\n+        if (end < value) {\n+            assert false : end + \" < \" + value;\n+            throw new IllegalArgumentException(\"Cannot update progress with a value greater than [end=\" + end + ']');\n+        }\n+\n+        List<ActionListener<Long>> listenersToExecute = null;\n+        synchronized (this) {\n+            assert progress == null || progress < value : progress + \" < \" + value;\n+            this.progress = value;\n+\n+            final List<Tuple<Long, ActionListener<Long>>> listeners = this.listeners;\n+            if (listeners != null) {\n+                List<Tuple<Long, ActionListener<Long>>> listenersToKeep = null;\n+                for (Tuple<Long, ActionListener<Long>> listener : listeners) {\n+                    if (value < listener.v1()) {\n+                        if (listenersToKeep == null) {\n+                            listenersToKeep = new ArrayList<>();\n+                        }\n+                        listenersToKeep.add(listener);\n+                    } else {\n+                        if (listenersToExecute == null) {\n+                            listenersToExecute = new ArrayList<>();\n+                        }\n+                        listenersToExecute.add(listener.v2());\n+                    }\n+                }\n+                this.listeners = listenersToKeep;\n+            }\n+        }\n+        if (listenersToExecute != null) {\n+            listenersToExecute.forEach(listener -> executeListener(listener, () -> value));\n+        }\n+        assert invariant();\n+    }\n+\n+    @Override\n+    public void onResponse(Long result) {\n+        ensureNotCompleted();\n+        super.onResponse(result);\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        ensureNotCompleted();\n+        super.onFailure(e);\n+    }\n+\n+    private void ensureNotCompleted() {\n+        if (completed) {\n+            throw new IllegalStateException(\"Future is already completed\");\n+        }\n+    }\n+\n+    @Override\n+    protected void done() {\n+        super.done();\n+        final List<Tuple<Long, ActionListener<Long>>> listenersToExecute;\n+        synchronized (this) {\n+            completed = true;\n+            listenersToExecute = this.listeners;\n+            listeners = null;\n+        }\n+        if (listenersToExecute != null) {\n+            listenersToExecute.stream().map(Tuple::v2).forEach(listener -> executeListener(listener, () -> actionGet(0L)));\n+        }\n+        assert invariant();\n+    }\n+\n+    /**\n+     * Attach a {@link ActionListener} to the current future. The listener will be executed once the future is completed.\n+     *\n+     * @param listener the {@link ActionListener} to add\n+     */\n+    @Override\n+    public void addListener(final ActionListener<Long> listener) {", "originalCommit": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444795252", "bodyText": "Here's the off-by-one error: when fileContents[i] is available we should do this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                gap.onProgress(i);\n          \n          \n            \n                                gap.onProgress(i + 1);", "author": "DaveCTurner", "createdAt": "2020-06-24T10:22:08Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/SparseFileTrackerTests.java", "diffHunk": "@@ -111,15 +165,150 @@ public void testCallsListenerWhenWholeRangeIsAvailable() {\n                 if (gapIndex == gaps.size() - 1) {\n                     expectNotification.set(true);\n                 }\n-                gap.onResponse(null);\n+                gap.onCompletion();\n             }\n             assertTrue(wasNotified.get());\n         }\n \n         final AtomicBoolean wasNotified = new AtomicBoolean();\n         final List<SparseFileTracker.Gap> gaps = sparseFileTracker.waitForRange(\n-            start,\n-            end,\n+            range,\n+            subRange,\n+            ActionListener.wrap(ignored -> assertTrue(wasNotified.compareAndSet(false, true)), e -> { throw new AssertionError(e); })\n+        );\n+        assertThat(gaps, empty());\n+        assertTrue(wasNotified.get());\n+    }\n+\n+    public void testCallsListenerWhenRangeIsAvailable() {\n+        final byte[] fileContents = new byte[between(0, 1000)];\n+        final SparseFileTracker sparseFileTracker = new SparseFileTracker(\"test\", fileContents.length);\n+\n+        final Set<AtomicBoolean> listenersCalled = new HashSet<>();\n+        for (int i = between(0, 10); i > 0; i--) {\n+            waitForRandomRange(fileContents, sparseFileTracker, listenersCalled::add, gap -> processGap(fileContents, gap));\n+            assertTrue(listenersCalled.stream().allMatch(AtomicBoolean::get));\n+        }\n+\n+        final Tuple<Long, Long> range;\n+        {\n+            final long start = randomLongBetween(0L, Math.max(0L, fileContents.length - 1));\n+            range = Tuple.tuple(start, randomLongBetween(start, fileContents.length));\n+        }\n+\n+        final Tuple<Long, Long> subRange;\n+        {\n+            final long rangeLength = range.v2() - range.v1();\n+            if (rangeLength > 1L) {\n+                final long start = randomLongBetween(range.v1(), range.v2() - 1L);\n+                subRange = Tuple.tuple(start, randomLongBetween(start + 1L, range.v2()));\n+            } else {\n+                subRange = Tuple.tuple(range.v1(), range.v2());\n+            }\n+        }\n+\n+        boolean pending = false;\n+        for (long i = subRange.v1(); i < subRange.v2(); i++) {\n+            if (fileContents[Math.toIntExact(i)] == UNAVAILABLE) {\n+                pending = true;\n+            }\n+        }\n+\n+        if (pending == false) {\n+            final AtomicBoolean wasNotified = new AtomicBoolean();\n+            final List<SparseFileTracker.Gap> gaps = sparseFileTracker.waitForRange(\n+                range,\n+                subRange,\n+                ActionListener.wrap(ignored -> assertTrue(wasNotified.compareAndSet(false, true)), e -> { throw new AssertionError(e); })\n+            );\n+\n+            assertTrue(\n+                \"All bytes of the sub range \" + subRange + \" are available, listener must be executed immediately\",\n+                wasNotified.get()\n+            );\n+\n+            for (final SparseFileTracker.Gap gap : gaps) {\n+                assertThat(gap.start, greaterThanOrEqualTo(range.v1()));\n+                assertThat(gap.end, lessThanOrEqualTo(range.v2()));\n+\n+                for (long i = gap.start; i < gap.end; i++) {\n+                    assertThat(fileContents[Math.toIntExact(i)], equalTo(UNAVAILABLE));\n+                    fileContents[Math.toIntExact(i)] = AVAILABLE;\n+                    assertTrue(wasNotified.get());\n+                    gap.onProgress(i);", "originalCommit": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3NjAzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445476039", "bodyText": "Thanks David! It becomes a tradition (sadly)", "author": "tlrx", "createdAt": "2020-06-25T10:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTI1Mg=="}], "type": "inlineReview"}, {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac", "url": "https://github.com/elastic/elasticsearch/commit/e787d1cb3d882dc908b751efc2100d32b2595dac", "message": "apply feedback", "committedDate": "2020-06-25T11:29:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDU3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445494575", "bodyText": "Should we require completed == false || progress == end too?", "author": "DaveCTurner", "createdAt": "2020-06-25T11:38:58Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/ProgressListenableActionFuture.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.AdapterActionFuture;\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An {@link ActionFuture} that listeners can be attached to. Listeners are executed when the future is completed\n+ * or when a given progress is reached. Progression is updated using the {@link #onProgress(long)} method.\n+ *\n+ * Listeners are executed within the thread that triggers the completion, the failure or the progress update and\n+ * the progress value passed to the listeners on execution is the last updated value.\n+ */\n+class ProgressListenableActionFuture extends AdapterActionFuture<Long, Long> {\n+\n+    protected final long start;\n+    protected final long end;\n+\n+    // modified under 'this' mutex\n+    private volatile List<Tuple<Long, ActionListener<Long>>> listeners;\n+    protected volatile long progress;\n+    private volatile boolean completed;\n+\n+    /**\n+     * Creates a {@link ProgressListenableActionFuture} that accepts the progression\n+     * to be within {@code start} (inclusive) and {@code end} (exclusive) values.\n+     *\n+     * @param start the start (inclusive)\n+     * @param end   the end (exclusive)\n+     */\n+    ProgressListenableActionFuture(long start, long end) {\n+        super();\n+        this.start = start;\n+        this.end = end;\n+        this.progress = start;\n+        this.completed = false;\n+        assert invariant();\n+    }\n+\n+    private boolean invariant() {\n+        assert start < end : start + \" < \" + end;\n+        synchronized (this) {\n+            assert completed == false || listeners == null;\n+            assert start <= progress : start + \" <= \" + progress;\n+            assert progress <= end : progress + \" <= \" + end;\n+            assert listeners == null || listeners.stream().allMatch(listener -> progress < listener.v1());", "originalCommit": "e787d1cb3d882dc908b751efc2100d32b2595dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUxMzY1MA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445513650", "bodyText": "I don't think so: completed indicates that the future is done, either with success or failure. In case of failure it could be completed before the progress reached end.", "author": "tlrx", "createdAt": "2020-06-25T12:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUzMzYyOA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445533628", "bodyText": "Ah yes so it does. Can we assert that successful completion only happens with progress == end?", "author": "DaveCTurner", "createdAt": "2020-06-25T12:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3NDQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445674453", "bodyText": "Can we assert that successful completion only happens with progress == end?\n\nIt means to change the  done()  method to pass around the completion state (success or failure/cancel) of the future so that we can later compare the successful completion plus the progress/end values. It also means that the progress must be updated in a more strictly manner before completing the future. I gave it a try in a5b29d5, let me know what you think.", "author": "tlrx", "createdAt": "2020-06-25T16:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMTAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445501034", "bodyText": "Should we also have a test that partially completes and then fails and verify that some listeners completed successfully and others failed?", "author": "DaveCTurner", "createdAt": "2020-06-25T11:52:15Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {", "originalCommit": "e787d1cb3d882dc908b751efc2100d32b2595dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3MzA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445673098", "bodyText": "I added testPartialProgressionThenFailure", "author": "tlrx", "createdAt": "2020-06-25T16:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMjUwMA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445502500", "bodyText": "Maybe also a test that we call the listener immediately if its progress target is already reached?", "author": "DaveCTurner", "createdAt": "2020-06-25T11:55:02Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n+                    future.onProgress(progress);\n+                }\n+                future.onResponse(future.end);\n+            } catch (Throwable t) {\n+                logger.error(\"Failed to update progress\", t);\n+                if (future.isDone() == false) {\n+                    future.onFailure(new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\"));\n+                }\n+                throw new AssertionError(t);\n+            }\n+        });\n+        progressUpdaterThread.start();\n+\n+        startLatch.countDown();\n+\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        progressUpdaterThread.join();\n+        assertTrue(future.isDone());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterResponse() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+        future.onResponse(randomLongBetween(future.start, future.end));\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerResponse.get(), equalTo(future.get()));\n+        assertThat(listenerFailure.get(), nullValue());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterFailure() {", "originalCommit": "e787d1cb3d882dc908b751efc2100d32b2595dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3Mjg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445672857", "bodyText": "Sure, I added testListenerCalledImmediatelyWhenProgressReached", "author": "tlrx", "createdAt": "2020-06-25T16:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMjk3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445502971", "bodyText": "Perhaps simpler:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n          \n          \n            \n                                progress += randomLongBetween(progress + 1L, future.end));", "author": "DaveCTurner", "createdAt": "2020-06-25T11:55:54Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));", "originalCommit": "e787d1cb3d882dc908b751efc2100d32b2595dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUxNDQ4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445514487", "bodyText": "I'll go with progress = randomLongBetween(1L, Math.max(1L, future.end - progress); - thanks for the suggestion", "author": "tlrx", "createdAt": "2020-06-25T12:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMjk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzYwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445503601", "bodyText": "Don't think we need a random limit on the randomness here; also 1TB should be enough for anyone :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(randomIntBetween(1, 10)));\n          \n          \n            \n                    final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(1));", "author": "DaveCTurner", "createdAt": "2020-06-25T11:57:10Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n+                    future.onProgress(progress);\n+                }\n+                future.onResponse(future.end);\n+            } catch (Throwable t) {\n+                logger.error(\"Failed to update progress\", t);\n+                if (future.isDone() == false) {\n+                    future.onFailure(new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\"));\n+                }\n+                throw new AssertionError(t);\n+            }\n+        });\n+        progressUpdaterThread.start();\n+\n+        startLatch.countDown();\n+\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        progressUpdaterThread.join();\n+        assertTrue(future.isDone());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterResponse() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+        future.onResponse(randomLongBetween(future.start, future.end));\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerResponse.get(), equalTo(future.get()));\n+        assertThat(listenerFailure.get(), nullValue());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterFailure() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Exception failure = new ElasticsearchException(\"simulated\");\n+        future.onFailure(failure);\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerFailure.get(), sameInstance(failure));\n+        assertThat(listenerResponse.get(), nullValue());\n+    }\n+\n+    private static ProgressListenableActionFuture randomFuture() {\n+        final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(randomIntBetween(1, 10)));", "originalCommit": "e787d1cb3d882dc908b751efc2100d32b2595dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUxNDgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445514823", "bodyText": "Agreed :)", "author": "tlrx", "createdAt": "2020-06-25T12:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445503835", "bodyText": "Do we really want negative numbers here?", "author": "DaveCTurner", "createdAt": "2020-06-25T11:57:39Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n+                    future.onProgress(progress);\n+                }\n+                future.onResponse(future.end);\n+            } catch (Throwable t) {\n+                logger.error(\"Failed to update progress\", t);\n+                if (future.isDone() == false) {\n+                    future.onFailure(new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\"));\n+                }\n+                throw new AssertionError(t);\n+            }\n+        });\n+        progressUpdaterThread.start();\n+\n+        startLatch.countDown();\n+\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        progressUpdaterThread.join();\n+        assertTrue(future.isDone());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterResponse() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+        future.onResponse(randomLongBetween(future.start, future.end));\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerResponse.get(), equalTo(future.get()));\n+        assertThat(listenerFailure.get(), nullValue());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterFailure() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Exception failure = new ElasticsearchException(\"simulated\");\n+        future.onFailure(failure);\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerFailure.get(), sameInstance(failure));\n+        assertThat(listenerResponse.get(), nullValue());\n+    }\n+\n+    private static ProgressListenableActionFuture randomFuture() {\n+        final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(randomIntBetween(1, 10)));\n+        final long start = randomLongBetween(Long.MIN_VALUE, Long.MAX_VALUE - delta);", "originalCommit": "e787d1cb3d882dc908b751efc2100d32b2595dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUxNjczNg==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445516736", "bodyText": "It's not really important but I prefer to make sure that ProgressListenableActionFuture works fine whatever the long boundaries are", "author": "tlrx", "createdAt": "2020-06-25T12:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUyNjc5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445526799", "bodyText": "(Note: I can change this before merging if you really care about it)", "author": "tlrx", "createdAt": "2020-06-25T12:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUzNDcxOA==", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445534718", "bodyText": "No, I'm happy with it as it is too.", "author": "DaveCTurner", "createdAt": "2020-06-25T12:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzgzNQ=="}], "type": "inlineReview"}, {"oid": "45a9f058efd2b584cf9df8d163db9e0eceb21485", "url": "https://github.com/elastic/elasticsearch/commit/45a9f058efd2b584cf9df8d163db9e0eceb21485", "message": "apply feedback (bis)", "committedDate": "2020-06-25T15:43:00Z", "type": "commit"}, {"oid": "a5b29d5c1233e39e1d870f6dd58d6b844964772a", "url": "https://github.com/elastic/elasticsearch/commit/a5b29d5c1233e39e1d870f6dd58d6b844964772a", "message": "more strict on progress updates", "committedDate": "2020-06-25T16:07:51Z", "type": "commit"}, {"oid": "a3bac6ba2956eb989167f677a332be19eabd09a0", "url": "https://github.com/elastic/elasticsearch/commit/a3bac6ba2956eb989167f677a332be19eabd09a0", "message": "missing in last commit", "committedDate": "2020-06-26T08:52:34Z", "type": "commit"}]}