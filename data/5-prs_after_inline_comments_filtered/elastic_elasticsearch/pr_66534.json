{"pr_number": 66534, "pr_title": "Network community_id processor for ingest pipelines", "pr_createdAt": "2020-12-17T15:36:33Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66534", "timeline": [{"oid": "f91208b9d6cb4ccce49a38f44d5616c3eb7e003a", "url": "https://github.com/elastic/elasticsearch/commit/f91208b9d6cb4ccce49a38f44d5616c3eb7e003a", "message": "community_id processor for ingest pipelines", "committedDate": "2020-12-17T15:27:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMTY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/66534#discussion_r545431670", "bodyText": "I'm worried that this could potentially perform network calls to lookup IP addresses from names.\nLuckily we have a utility for this that's safe. Can you use that package here?\n\n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/common/network/InetAddresses.java\n    \n    \n         Line 340\n      in\n      feab123\n    \n    \n    \n    \n\n        \n          \n           public static InetAddress forString(String ipString) {", "author": "andrewkroh", "createdAt": "2020-12-17T22:01:37Z", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/CommunityIdProcessor.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.math.BigInteger;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.ingest.ConfigurationUtils.newConfigurationException;\n+import static org.elasticsearch.ingest.ConfigurationUtils.readBooleanProperty;\n+\n+public class CommunityIdProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"community_id\";\n+\n+    private final String sourceIpField;\n+    private final String sourcePortField;\n+    private final String destinationIpField;\n+    private final String destinationPortField;\n+    private final String ianaNumberField;\n+    private final String transportField;\n+    private final String icmpTypeField;\n+    private final String icmpCodeField;\n+    private final String targetField;\n+    private final MessageDigest messageDigest;\n+    private final byte[] seed;\n+    private final boolean ignoreMissing;\n+\n+    CommunityIdProcessor(\n+        String tag,\n+        String description,\n+        String sourceIpField,\n+        String sourcePortField,\n+        String destinationIpField,\n+        String destinationPortField,\n+        String ianaNumberField,\n+        String transportField,\n+        String icmpTypeField,\n+        String icmpCodeField,\n+        String targetField,\n+        MessageDigest messageDigest,\n+        byte[] seed,\n+        boolean ignoreMissing\n+    ) {\n+        super(tag, description);\n+        this.sourceIpField = sourceIpField;\n+        this.sourcePortField = sourcePortField;\n+        this.destinationIpField = destinationIpField;\n+        this.destinationPortField = destinationPortField;\n+        this.ianaNumberField = ianaNumberField;\n+        this.transportField = transportField;\n+        this.icmpTypeField = icmpTypeField;\n+        this.icmpCodeField = icmpCodeField;\n+        this.targetField = targetField;\n+        this.messageDigest = messageDigest;\n+        this.seed = seed;\n+        this.ignoreMissing = ignoreMissing;\n+    }\n+\n+    public String getSourceIpField() {\n+        return sourceIpField;\n+    }\n+\n+    public String getSourcePortField() {\n+        return sourcePortField;\n+    }\n+\n+    public String getDestinationIpField() {\n+        return destinationIpField;\n+    }\n+\n+    public String getDestinationPortField() {\n+        return destinationPortField;\n+    }\n+\n+    public String getIanaNumberField() {\n+        return ianaNumberField;\n+    }\n+\n+    public String getTransportField() {\n+        return transportField;\n+    }\n+\n+    public String getIcmpTypeField() {\n+        return icmpTypeField;\n+    }\n+\n+    public String getIcmpCodeField() {\n+        return icmpCodeField;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public MessageDigest getMessageDigest() {\n+        return messageDigest;\n+    }\n+\n+    public byte[] getSeed() {\n+        return seed;\n+    }\n+\n+    public boolean getIgnoreMissing() {\n+        return ignoreMissing;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        Flow flow = buildFlow(ingestDocument);\n+        if (flow == null) {\n+            if (ignoreMissing) {\n+                return ingestDocument;\n+            } else {\n+                throw new IllegalArgumentException(\"unable to construct flow from document\");\n+            }\n+        }\n+\n+        ingestDocument.setFieldValue(targetField, flow.toCommunityId(messageDigest, seed));\n+        return ingestDocument;\n+    }\n+\n+    private Flow buildFlow(IngestDocument d) {\n+        String sourceIpAddrString = d.getFieldValue(sourceIpField, String.class, ignoreMissing);\n+        if (sourceIpAddrString == null) {\n+            return null;\n+        }\n+\n+        String destIpAddrString = d.getFieldValue(destinationIpField, String.class, ignoreMissing);\n+        if (destIpAddrString == null) {\n+            return null;\n+        }\n+\n+        Flow flow = new Flow();\n+        try {\n+            flow.source = InetAddress.getByName(sourceIpAddrString);", "originalCommit": "f91208b9d6cb4ccce49a38f44d5616c3eb7e003a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzOTA5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66534#discussion_r545439092", "bodyText": "Not sure if this is a worth it, so feel free to ignore. To ensure that fromNumber stays up-to-date with all the enum transportNumbers it might be useful to have test that checks the all the Transport.values() work with fromNumber without exception.", "author": "andrewkroh", "createdAt": "2020-12-17T22:16:24Z", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/CommunityIdProcessor.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.math.BigInteger;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.ingest.ConfigurationUtils.newConfigurationException;\n+import static org.elasticsearch.ingest.ConfigurationUtils.readBooleanProperty;\n+\n+public class CommunityIdProcessor extends AbstractProcessor {\n+\n+    public static final String TYPE = \"community_id\";\n+\n+    private final String sourceIpField;\n+    private final String sourcePortField;\n+    private final String destinationIpField;\n+    private final String destinationPortField;\n+    private final String ianaNumberField;\n+    private final String transportField;\n+    private final String icmpTypeField;\n+    private final String icmpCodeField;\n+    private final String targetField;\n+    private final MessageDigest messageDigest;\n+    private final byte[] seed;\n+    private final boolean ignoreMissing;\n+\n+    CommunityIdProcessor(\n+        String tag,\n+        String description,\n+        String sourceIpField,\n+        String sourcePortField,\n+        String destinationIpField,\n+        String destinationPortField,\n+        String ianaNumberField,\n+        String transportField,\n+        String icmpTypeField,\n+        String icmpCodeField,\n+        String targetField,\n+        MessageDigest messageDigest,\n+        byte[] seed,\n+        boolean ignoreMissing\n+    ) {\n+        super(tag, description);\n+        this.sourceIpField = sourceIpField;\n+        this.sourcePortField = sourcePortField;\n+        this.destinationIpField = destinationIpField;\n+        this.destinationPortField = destinationPortField;\n+        this.ianaNumberField = ianaNumberField;\n+        this.transportField = transportField;\n+        this.icmpTypeField = icmpTypeField;\n+        this.icmpCodeField = icmpCodeField;\n+        this.targetField = targetField;\n+        this.messageDigest = messageDigest;\n+        this.seed = seed;\n+        this.ignoreMissing = ignoreMissing;\n+    }\n+\n+    public String getSourceIpField() {\n+        return sourceIpField;\n+    }\n+\n+    public String getSourcePortField() {\n+        return sourcePortField;\n+    }\n+\n+    public String getDestinationIpField() {\n+        return destinationIpField;\n+    }\n+\n+    public String getDestinationPortField() {\n+        return destinationPortField;\n+    }\n+\n+    public String getIanaNumberField() {\n+        return ianaNumberField;\n+    }\n+\n+    public String getTransportField() {\n+        return transportField;\n+    }\n+\n+    public String getIcmpTypeField() {\n+        return icmpTypeField;\n+    }\n+\n+    public String getIcmpCodeField() {\n+        return icmpCodeField;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public MessageDigest getMessageDigest() {\n+        return messageDigest;\n+    }\n+\n+    public byte[] getSeed() {\n+        return seed;\n+    }\n+\n+    public boolean getIgnoreMissing() {\n+        return ignoreMissing;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        Flow flow = buildFlow(ingestDocument);\n+        if (flow == null) {\n+            if (ignoreMissing) {\n+                return ingestDocument;\n+            } else {\n+                throw new IllegalArgumentException(\"unable to construct flow from document\");\n+            }\n+        }\n+\n+        ingestDocument.setFieldValue(targetField, flow.toCommunityId(messageDigest, seed));\n+        return ingestDocument;\n+    }\n+\n+    private Flow buildFlow(IngestDocument d) {\n+        String sourceIpAddrString = d.getFieldValue(sourceIpField, String.class, ignoreMissing);\n+        if (sourceIpAddrString == null) {\n+            return null;\n+        }\n+\n+        String destIpAddrString = d.getFieldValue(destinationIpField, String.class, ignoreMissing);\n+        if (destIpAddrString == null) {\n+            return null;\n+        }\n+\n+        Flow flow = new Flow();\n+        try {\n+            flow.source = InetAddress.getByName(sourceIpAddrString);\n+        } catch (UnknownHostException e) {\n+            throw new IllegalArgumentException(\"unable to parse source IP address [\" + sourceIpAddrString + \"]\");\n+        }\n+\n+        try {\n+            flow.destination = InetAddress.getByName(destIpAddrString);\n+        } catch (UnknownHostException e) {\n+            throw new IllegalArgumentException(\"unable to parse destination IP address [\" + destIpAddrString + \"]\");\n+        }\n+\n+        Object protocol = d.getFieldValue(ianaNumberField, Object.class, true);\n+        if (protocol == null) {\n+            protocol = d.getFieldValue(transportField, Object.class, ignoreMissing);\n+            if (protocol == null) {\n+                return null;\n+            }\n+        }\n+        flow.protocol = Transport.fromObject(protocol);\n+\n+        switch (flow.protocol) {\n+            case Tcp:\n+            case Udp:\n+            case Sctp:\n+                flow.sourcePort = parseIntFromObjectOrString(d.getFieldValue(sourcePortField, Object.class, ignoreMissing), \"source port\");\n+                if (flow.sourcePort == 0) {\n+                    throw new IllegalArgumentException(\"invalid source port [0]\");\n+                }\n+\n+                flow.destinationPort = parseIntFromObjectOrString(\n+                    d.getFieldValue(destinationPortField, Object.class, ignoreMissing),\n+                    \"destination port\"\n+                );\n+                if (flow.destinationPort == 0) {\n+                    throw new IllegalArgumentException(\"invalid destination port [0]\");\n+                }\n+                break;\n+            case Icmp:\n+            case IcmpIpV6:\n+                // tolerate missing or invalid ICMP types and codes\n+                flow.icmpType = parseIntFromObjectOrString(d.getFieldValue(icmpTypeField, Object.class, true), \"icmp type\");\n+                flow.icmpCode = parseIntFromObjectOrString(d.getFieldValue(icmpCodeField, Object.class, true), \"icmp code\");\n+                break;\n+        }\n+\n+        return flow;\n+    }\n+\n+    @Override\n+    public String getType() {\n+        return TYPE;\n+    }\n+\n+    /**\n+     * Converts an integer in the range of an unsigned 16-bit integer to a big-endian byte pair\n+     */\n+    static byte[] toUint16(int num) {\n+        if (num < 0 || num > 65535) {\n+            throw new IllegalStateException(\"number [\" + num + \"] must be a value between 0 and 65535\");\n+        }\n+        return new byte[] { (byte) (num >> 8), (byte) num };\n+    }\n+\n+    /**\n+     * Attempts to coerce an object to an integer\n+     */\n+    static int parseIntFromObjectOrString(Object o, String fieldName) {\n+        if (o == null) {\n+            return 0;\n+        } else if (o instanceof Number) {\n+            return (int) o;\n+        } else if (o instanceof String) {\n+            try {\n+                return Integer.parseInt((String) o);\n+            } catch (NumberFormatException e) {\n+                // fall through to IllegalArgumentException below\n+            }\n+        }\n+        throw new IllegalArgumentException(\"unable to parse \" + fieldName + \" [\" + o + \"]\");\n+    }\n+\n+    public static final class Factory implements Processor.Factory {\n+\n+        static final String DEFAULT_SOURCE_IP = \"source.ip\";\n+        static final String DEFAULT_SOURCE_PORT = \"source.port\";\n+        static final String DEFAULT_DEST_IP = \"destination.ip\";\n+        static final String DEFAULT_DEST_PORT = \"destination.port\";\n+        static final String DEFAULT_IANA_NUMBER = \"network.iana_number\";\n+        static final String DEFAULT_TRANSPORT = \"network.transport\";\n+        static final String DEFAULT_ICMP_TYPE = \"icmp.type\";\n+        static final String DEFAULT_ICMP_CODE = \"icmp.code\";\n+        static final String DEFAULT_TARGET = \"network.community_id\";\n+\n+        @Override\n+        public CommunityIdProcessor create(\n+            Map<String, Processor.Factory> registry,\n+            String processorTag,\n+            String description,\n+            Map<String, Object> config\n+        ) throws Exception {\n+            String sourceIpField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"source_ip\", DEFAULT_SOURCE_IP);\n+            String sourcePortField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"source_port\", DEFAULT_SOURCE_PORT);\n+            String destIpField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"destination_ip\", DEFAULT_DEST_IP);\n+            String destPortField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"destination_port\", DEFAULT_DEST_PORT);\n+            String ianaNumberField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"iana_number\", DEFAULT_IANA_NUMBER);\n+            String transportField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"transport\", DEFAULT_TRANSPORT);\n+            String icmpTypeField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"icmp_type\", DEFAULT_ICMP_TYPE);\n+            String icmpCodeField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"icmp_code\", DEFAULT_ICMP_CODE);\n+            String targetField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, \"target_field\", DEFAULT_TARGET);\n+            int seedInt = ConfigurationUtils.readIntProperty(TYPE, processorTag, config, \"seed\", 0);\n+            if (seedInt < 0 || seedInt > 65535) {\n+                throw newConfigurationException(TYPE, processorTag, \"seed\", \"must be a value between 0 and 65535\");\n+            }\n+            MessageDigest messageDigest;\n+            try {\n+                messageDigest = MessageDigest.getInstance(\"SHA-1\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new IllegalStateException(\"unable to obtain SHA-1 hasher\", e);\n+            }\n+\n+            boolean ignoreMissing = readBooleanProperty(TYPE, processorTag, config, \"ignore_missing\", true);\n+            return new CommunityIdProcessor(\n+                processorTag,\n+                description,\n+                sourceIpField,\n+                sourcePortField,\n+                destIpField,\n+                destPortField,\n+                ianaNumberField,\n+                transportField,\n+                icmpTypeField,\n+                icmpCodeField,\n+                targetField,\n+                messageDigest,\n+                toUint16(seedInt),\n+                ignoreMissing\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Represents flow data per https://github.com/corelight/community-id-spec\n+     */\n+    public static final class Flow {\n+\n+        private static final List<Transport> TRANSPORTS_WITH_PORTS = List.of(\n+            Transport.Tcp,\n+            Transport.Udp,\n+            Transport.Sctp,\n+            Transport.Icmp,\n+            Transport.IcmpIpV6\n+        );\n+\n+        InetAddress source;\n+        InetAddress destination;\n+        Transport protocol;\n+        int sourcePort;\n+        int destinationPort;\n+        int icmpType;\n+        int icmpCode;\n+\n+        /**\n+         * @return true iff the source address/port is numerically less than the destination address/port as described\n+         * at https://github.com/corelight/community-id-spec\n+         */\n+        boolean isOrdered() {\n+            int result = new BigInteger(1, source.getAddress()).compareTo(new BigInteger(1, destination.getAddress()));\n+            return result < 0 || (result == 0 && sourcePort < destinationPort);\n+        }\n+\n+        byte[] toBytes() {\n+            boolean hasPort = TRANSPORTS_WITH_PORTS.contains(protocol);\n+            int len = source.getAddress().length + destination.getAddress().length + 2 + (hasPort ? 4 : 0);\n+            ByteBuffer bb = ByteBuffer.allocate(len);\n+\n+            boolean isOneWay = false;\n+            if (protocol == Transport.Icmp || protocol == Transport.IcmpIpV6) {\n+                // ICMP protocols populate port fields with ICMP data\n+                Integer equivalent = IcmpType.codeEquivalent(icmpType, protocol == Transport.IcmpIpV6);\n+                isOneWay = equivalent == null;\n+                sourcePort = icmpType;\n+                destinationPort = equivalent == null ? icmpCode : equivalent;\n+            }\n+\n+            boolean keepOrder = isOrdered() || ((protocol == Transport.Icmp || protocol == Transport.IcmpIpV6) && isOneWay);\n+            bb.put(keepOrder ? source.getAddress() : destination.getAddress());\n+            bb.put(keepOrder ? destination.getAddress() : source.getAddress());\n+            bb.put(toUint16(protocol.getTransportNumber() << 8));\n+\n+            if (hasPort) {\n+                bb.put(keepOrder ? toUint16(sourcePort) : toUint16(destinationPort));\n+                bb.put(keepOrder ? toUint16(destinationPort) : toUint16(sourcePort));\n+            }\n+\n+            return bb.array();\n+        }\n+\n+        String toCommunityId(MessageDigest md, byte[] seed) {\n+            md.update(seed);\n+            byte[] encodedBytes = Base64.getEncoder().encode(md.digest(toBytes()));\n+            return \"1:\" + new String(encodedBytes, StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    public enum Transport {\n+        Icmp(1),\n+        Igmp(2),\n+        Tcp(6),\n+        Udp(17),\n+        Gre(47),\n+        IcmpIpV6(58),\n+        Eigrp(88),\n+        Ospf(89),\n+        Pim(103),\n+        Sctp(132);\n+\n+        private final int transportNumber;\n+\n+        private static final Map<String, Transport> TRANSPORT_NAMES;\n+\n+        static {\n+            TRANSPORT_NAMES = new HashMap<>();\n+            TRANSPORT_NAMES.put(\"icmp\", Icmp);\n+            TRANSPORT_NAMES.put(\"igmp\", Igmp);\n+            TRANSPORT_NAMES.put(\"tcp\", Tcp);\n+            TRANSPORT_NAMES.put(\"udp\", Udp);\n+            TRANSPORT_NAMES.put(\"gre\", Gre);\n+            TRANSPORT_NAMES.put(\"ipv6-icmp\", IcmpIpV6);\n+            TRANSPORT_NAMES.put(\"icmpv6\", IcmpIpV6);\n+            TRANSPORT_NAMES.put(\"eigrp\", Eigrp);\n+            TRANSPORT_NAMES.put(\"ospf\", Ospf);\n+            TRANSPORT_NAMES.put(\"pim\", Pim);\n+            TRANSPORT_NAMES.put(\"sctp\", Sctp);\n+        }\n+\n+        Transport(int transportNumber) {\n+            this.transportNumber = transportNumber;\n+        }\n+\n+        public int getTransportNumber() {\n+            return transportNumber;\n+        }\n+\n+        public static Transport fromNumber(int transportNumber) {", "originalCommit": "f91208b9d6cb4ccce49a38f44d5616c3eb7e003a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba62c8a5fbd19e6197f5374ed5d60220b7e6dc8e", "url": "https://github.com/elastic/elasticsearch/commit/ba62c8a5fbd19e6197f5374ed5d60220b7e6dc8e", "message": "review comments", "committedDate": "2020-12-18T16:32:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYxODE2MA==", "url": "https://github.com/elastic/elasticsearch/pull/66534#discussion_r555618160", "bodyText": "make class final?", "author": "martijnvg", "createdAt": "2021-01-12T09:15:43Z", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/CommunityIdProcessor.java", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.common.network.InetAddresses;\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+\n+import java.math.BigInteger;\n+import java.net.InetAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.ingest.ConfigurationUtils.newConfigurationException;\n+import static org.elasticsearch.ingest.ConfigurationUtils.readBooleanProperty;\n+\n+public class CommunityIdProcessor extends AbstractProcessor {", "originalCommit": "ba62c8a5fbd19e6197f5374ed5d60220b7e6dc8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ab7beba6ee47d635f86db550a99d95420b25c9bf", "url": "https://github.com/elastic/elasticsearch/commit/ab7beba6ee47d635f86db550a99d95420b25c9bf", "message": "review comments", "committedDate": "2021-01-13T14:23:38Z", "type": "commit"}, {"oid": "32b88e42645194447b3d777367b5107ed0d07a8c", "url": "https://github.com/elastic/elasticsearch/commit/32b88e42645194447b3d777367b5107ed0d07a8c", "message": "Merge branch 'master' into 55685_community_id_processor", "committedDate": "2021-01-13T14:40:10Z", "type": "commit"}]}