{"pr_number": 58252, "pr_title": "[ML] calculate cache misses for inference and return in stats", "pr_createdAt": "2020-06-17T12:54:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58252", "timeline": [{"oid": "352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "url": "https://github.com/elastic/elasticsearch/commit/352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "message": "[ML] calculate cache misses for inference and return in stats", "committedDate": "2020-06-17T14:16:53Z", "type": "commit"}, {"oid": "352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "url": "https://github.com/elastic/elasticsearch/commit/352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "message": "[ML] calculate cache misses for inference and return in stats", "committedDate": "2020-06-17T14:16:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMzg1NA==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442123854", "bodyText": "It would be better to call this something like unboxOrZero, as it doesn't simply unbox.", "author": "droberts195", "createdAt": "2020-06-18T10:20:50Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.client.common.TimeUtil;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class InferenceStats implements ToXContentObject {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField CACHE_MISS_COUNT = new ParseField(\"cache_miss_count\");\n+    public static final ParseField FAILURE_COUNT = new ParseField(\"failure_count\");\n+    public static final ParseField TIMESTAMP = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<InferenceStats, Void> PARSER = new ConstructingObjectParser<>(\n+        NAME,\n+        true,\n+        a -> new InferenceStats((Long)a[0], (Long)a[1], (Long)a[2], (Long)a[3], (Instant)a[4])\n+    );\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), MISSING_ALL_FIELDS_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), INFERENCE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), FAILURE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), CACHE_MISS_COUNT);\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            p -> TimeUtil.parseTimeFieldToInstant(p, TIMESTAMP.getPreferredName()),\n+            TIMESTAMP,\n+            ObjectParser.ValueType.VALUE);\n+    }\n+\n+    private final long missingAllFieldsCount;\n+    private final long inferenceCount;\n+    private final long failureCount;\n+    private final long cacheMissCount;\n+    private final Instant timeStamp;\n+\n+    private InferenceStats(Long missingAllFieldsCount,\n+                           Long inferenceCount,\n+                           Long failureCount,\n+                           Long cacheMissCount,\n+                           Instant instant) {\n+        this(unbox(missingAllFieldsCount),\n+            unbox(inferenceCount),\n+            unbox(failureCount),\n+            unbox(cacheMissCount),\n+            instant);\n+    }\n+\n+    public InferenceStats(long missingAllFieldsCount,\n+                          long inferenceCount,\n+                          long failureCount,\n+                          long cacheMissCount,\n+                          Instant timeStamp) {\n+        this.missingAllFieldsCount = missingAllFieldsCount;\n+        this.inferenceCount = inferenceCount;\n+        this.failureCount = failureCount;\n+        this.cacheMissCount = cacheMissCount;\n+        this.timeStamp = timeStamp == null ?\n+            Instant.ofEpochMilli(Instant.now().toEpochMilli()) :\n+            Instant.ofEpochMilli(timeStamp.toEpochMilli());\n+    }\n+\n+    /**\n+     * How many times this model attempted to infer with all its fields missing\n+     */\n+    public long getMissingAllFieldsCount() {\n+        return missingAllFieldsCount;\n+    }\n+\n+    /**\n+     * How many inference calls were made against this model\n+     */\n+    public long getInferenceCount() {\n+        return inferenceCount;\n+    }\n+\n+    /**\n+     * How many inference failures occurred.\n+     */\n+    public long getFailureCount() {\n+        return failureCount;\n+    }\n+\n+    /**\n+     * How many cache misses occurred when inferring this model\n+     */\n+    public long getCacheMissCount() {\n+        return cacheMissCount;\n+    }\n+\n+    /**\n+     * The timestamp of these statistics.\n+     */\n+    public Instant getTimeStamp() {\n+        return timeStamp;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(FAILURE_COUNT.getPreferredName(), failureCount);\n+        builder.field(INFERENCE_COUNT.getPreferredName(), inferenceCount);\n+        builder.field(CACHE_MISS_COUNT.getPreferredName(), cacheMissCount);\n+        builder.field(MISSING_ALL_FIELDS_COUNT.getPreferredName(), missingAllFieldsCount);\n+        builder.timeField(TIMESTAMP.getPreferredName(), TIMESTAMP.getPreferredName() + \"_string\", timeStamp.toEpochMilli());\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        InferenceStats that = (InferenceStats) o;\n+        return missingAllFieldsCount == that.missingAllFieldsCount\n+            && inferenceCount == that.inferenceCount\n+            && failureCount == that.failureCount\n+            && cacheMissCount == that.cacheMissCount\n+            && Objects.equals(timeStamp, that.timeStamp);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(missingAllFieldsCount, inferenceCount, failureCount, cacheMissCount, timeStamp);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"InferenceStats{\" +\n+            \"missingAllFieldsCount=\" + missingAllFieldsCount +\n+            \", inferenceCount=\" + inferenceCount +\n+            \", failureCount=\" + failureCount +\n+            \", cachMissCount=\" + cacheMissCount +\n+            \", timeStamp=\" + timeStamp +\n+            '}';\n+    }\n+\n+    private static long unbox(@Nullable Long value) {", "originalCommit": "352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyODc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442128753", "bodyText": "typo: cach -> cache", "author": "droberts195", "createdAt": "2020-06-18T10:30:10Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -175,6 +194,7 @@ public String toString() {\n             \"missingAllFieldsCount=\" + missingAllFieldsCount +\n             \", inferenceCount=\" + inferenceCount +\n             \", failureCount=\" + failureCount +\n+            \", cachMissCount=\" + cacheMissCount +", "originalCommit": "352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyOTgyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442129825", "bodyText": "typo: cach -> cache", "author": "droberts195", "createdAt": "2020-06-18T10:32:21Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.client.common.TimeUtil;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class InferenceStats implements ToXContentObject {\n+\n+    public static final String NAME = \"inference_stats\";\n+    public static final ParseField MISSING_ALL_FIELDS_COUNT = new ParseField(\"missing_all_fields_count\");\n+    public static final ParseField INFERENCE_COUNT = new ParseField(\"inference_count\");\n+    public static final ParseField CACHE_MISS_COUNT = new ParseField(\"cache_miss_count\");\n+    public static final ParseField FAILURE_COUNT = new ParseField(\"failure_count\");\n+    public static final ParseField TIMESTAMP = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<InferenceStats, Void> PARSER = new ConstructingObjectParser<>(\n+        NAME,\n+        true,\n+        a -> new InferenceStats((Long)a[0], (Long)a[1], (Long)a[2], (Long)a[3], (Instant)a[4])\n+    );\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), MISSING_ALL_FIELDS_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), INFERENCE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), FAILURE_COUNT);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), CACHE_MISS_COUNT);\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            p -> TimeUtil.parseTimeFieldToInstant(p, TIMESTAMP.getPreferredName()),\n+            TIMESTAMP,\n+            ObjectParser.ValueType.VALUE);\n+    }\n+\n+    private final long missingAllFieldsCount;\n+    private final long inferenceCount;\n+    private final long failureCount;\n+    private final long cacheMissCount;\n+    private final Instant timeStamp;\n+\n+    private InferenceStats(Long missingAllFieldsCount,\n+                           Long inferenceCount,\n+                           Long failureCount,\n+                           Long cacheMissCount,\n+                           Instant instant) {\n+        this(unbox(missingAllFieldsCount),\n+            unbox(inferenceCount),\n+            unbox(failureCount),\n+            unbox(cacheMissCount),\n+            instant);\n+    }\n+\n+    public InferenceStats(long missingAllFieldsCount,\n+                          long inferenceCount,\n+                          long failureCount,\n+                          long cacheMissCount,\n+                          Instant timeStamp) {\n+        this.missingAllFieldsCount = missingAllFieldsCount;\n+        this.inferenceCount = inferenceCount;\n+        this.failureCount = failureCount;\n+        this.cacheMissCount = cacheMissCount;\n+        this.timeStamp = timeStamp == null ?\n+            Instant.ofEpochMilli(Instant.now().toEpochMilli()) :\n+            Instant.ofEpochMilli(timeStamp.toEpochMilli());\n+    }\n+\n+    /**\n+     * How many times this model attempted to infer with all its fields missing\n+     */\n+    public long getMissingAllFieldsCount() {\n+        return missingAllFieldsCount;\n+    }\n+\n+    /**\n+     * How many inference calls were made against this model\n+     */\n+    public long getInferenceCount() {\n+        return inferenceCount;\n+    }\n+\n+    /**\n+     * How many inference failures occurred.\n+     */\n+    public long getFailureCount() {\n+        return failureCount;\n+    }\n+\n+    /**\n+     * How many cache misses occurred when inferring this model\n+     */\n+    public long getCacheMissCount() {\n+        return cacheMissCount;\n+    }\n+\n+    /**\n+     * The timestamp of these statistics.\n+     */\n+    public Instant getTimeStamp() {\n+        return timeStamp;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(FAILURE_COUNT.getPreferredName(), failureCount);\n+        builder.field(INFERENCE_COUNT.getPreferredName(), inferenceCount);\n+        builder.field(CACHE_MISS_COUNT.getPreferredName(), cacheMissCount);\n+        builder.field(MISSING_ALL_FIELDS_COUNT.getPreferredName(), missingAllFieldsCount);\n+        builder.timeField(TIMESTAMP.getPreferredName(), TIMESTAMP.getPreferredName() + \"_string\", timeStamp.toEpochMilli());\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        InferenceStats that = (InferenceStats) o;\n+        return missingAllFieldsCount == that.missingAllFieldsCount\n+            && inferenceCount == that.inferenceCount\n+            && failureCount == that.failureCount\n+            && cacheMissCount == that.cacheMissCount\n+            && Objects.equals(timeStamp, that.timeStamp);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(missingAllFieldsCount, inferenceCount, failureCount, cacheMissCount, timeStamp);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"InferenceStats{\" +\n+            \"missingAllFieldsCount=\" + missingAllFieldsCount +\n+            \", inferenceCount=\" + inferenceCount +\n+            \", failureCount=\" + failureCount +\n+            \", cachMissCount=\" + cacheMissCount +", "originalCommit": "352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEzMDEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442130101", "bodyText": "I know it was already in this file, but, as above, maybe unboxOrZero would be clearer.", "author": "droberts195", "createdAt": "2020-06-18T10:32:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -62,19 +65,22 @@ public static String docId(String modelId, String nodeId) {\n     private final long missingAllFieldsCount;\n     private final long inferenceCount;\n     private final long failureCount;\n+    private final long cacheMissCount;\n     private final String modelId;\n     private final String nodeId;\n     private final Instant timeStamp;\n \n     private InferenceStats(Long missingAllFieldsCount,\n                            Long inferenceCount,\n                            Long failureCount,\n+                           Long cacheMissCount,\n                            String modelId,\n                            String nodeId,\n                            Instant instant) {\n         this(unbox(missingAllFieldsCount),\n             unbox(inferenceCount),\n             unbox(failureCount),\n+            unbox(cacheMissCount),", "originalCommit": "352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEzODY5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442138695", "bodyText": "Not something for this PR, but I wonder if the read/write lock is over complication.  The things that are going on inside the locked sections of code are very simple operations.  In my experience you need to be doing a lot of stuff in the locked sections to make the cost of a read/write lock worthwhile.  The amount of work the lock is doing to ensure fairness probably dwarfs the amount of work in these methods.  Then each LongAdder is doing its own synchronization internally too.  It is probably the case that it would be more efficient to simply make all the methods that use the read/write lock synchronized, replace the LongAdders with simple longs, and just use ++ to increment them.", "author": "droberts195", "createdAt": "2020-06-18T10:49:46Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -263,6 +289,15 @@ public Accumulator incFailure() {\n             }\n         }\n \n+        public Accumulator incCacheMiss() {\n+            readWriteLock.readLock().lock();", "originalCommit": "352f3b2157cb8bf07211dc7d9147f3c09ff4ec7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE2NzExMA==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442167110", "bodyText": "I will do some measurements and see which is better :)", "author": "benwtrent", "createdAt": "2020-06-18T11:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEzODY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5OTk1MA==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442299950", "bodyText": "Yet again, it is better to measure before making a decision about \"what is faster\".\nHere are average microsecond timed benchmarks for 1 and 128 threads.\nexample code:\nfor (int i = 1; i < 100_001; ++i) {\n    bh.consume(accumulator.incMissingFields().incFailure().incInference());\n}\n\nThe scenario was the BEST cast scenario for the RW lock (only ever doing increments, and never resetting with a full write lock).\nBenchmark                                                   Mode  Cnt        Score        Error  Units\nMultiThreadedStatsAccumulatorBenchmark.rwAccumulator_1      avgt   20     5957.399 \u00b1    112.892  us/op\nMultiThreadedStatsAccumulatorBenchmark.rwAccumulator_128    avgt   20  7480921.908 \u00b1 255364.820  us/op\nMultiThreadedStatsAccumulatorBenchmark.syncAccumulator_1    avgt   20      421.662 \u00b1      2.616  us/op\nMultiThreadedStatsAccumulatorBenchmark.syncAccumulator_128  avgt   20   792910.927 \u00b1  52219.577  us/op\n\nfull benchmark code: https://gist.github.com/benwtrent/b74254bf64aba0c55d4b24a474f9eff1\n@droberts195 ^", "author": "benwtrent", "createdAt": "2020-06-18T15:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEzODY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMwMzUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442303516", "bodyText": "Yes, that tallies with what I've always seen in the past, which is that you have to do a lot of work in the locked sections for the benefit of an RW lock to outweigh the complexity of its internal code.\nUp to you if you want to change it in this PR or a different one though.", "author": "droberts195", "createdAt": "2020-06-18T15:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEzODY5NQ=="}], "type": "inlineReview"}, {"oid": "f94ca472877bc099f8f942363e49f77e5dc69d14", "url": "https://github.com/elastic/elasticsearch/commit/f94ca472877bc099f8f942363e49f77e5dc69d14", "message": "addressing pr comments", "committedDate": "2020-06-18T12:08:04Z", "type": "commit"}, {"oid": "fa74013e6360975b3e546c915d4cfad51411d173", "url": "https://github.com/elastic/elasticsearch/commit/fa74013e6360975b3e546c915d4cfad51411d173", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-inference-count-cache-misses", "committedDate": "2020-06-18T12:08:09Z", "type": "commit"}, {"oid": "f4d5ffb601f0f24f508ffa499a34d2d84c72fdf7", "url": "https://github.com/elastic/elasticsearch/commit/f4d5ffb601f0f24f508ffa499a34d2d84c72fdf7", "message": "addressing pr comments", "committedDate": "2020-06-18T16:34:41Z", "type": "commit"}, {"oid": "036246fac1e32de713f8db335c96f4f101b517a0", "url": "https://github.com/elastic/elasticsearch/commit/036246fac1e32de713f8db335c96f4f101b517a0", "message": "Update docs/reference/ml/df-analytics/apis/get-inference-trained-model-stats.asciidoc", "committedDate": "2020-06-18T16:40:32Z", "type": "commit"}, {"oid": "842331422c053584c0492306d7ddbc9138fec320", "url": "https://github.com/elastic/elasticsearch/commit/842331422c053584c0492306d7ddbc9138fec320", "message": "Update docs/reference/ml/df-analytics/apis/get-inference-trained-model-stats.asciidoc", "committedDate": "2020-06-18T16:41:48Z", "type": "commit"}, {"oid": "84a280455feb2aa0e6c7d1ed1b734ed388c3232b", "url": "https://github.com/elastic/elasticsearch/commit/84a280455feb2aa0e6c7d1ed1b734ed388c3232b", "message": "Update docs/reference/ml/df-analytics/apis/get-inference-trained-model-stats.asciidoc", "committedDate": "2020-06-18T16:43:18Z", "type": "commit"}, {"oid": "4eed10adf254fb582eeb7de6742518b962a8bdfc", "url": "https://github.com/elastic/elasticsearch/commit/4eed10adf254fb582eeb7de6742518b962a8bdfc", "message": "Update docs/reference/ml/df-analytics/apis/get-inference-trained-model-stats.asciidoc", "committedDate": "2020-06-18T16:43:57Z", "type": "commit"}, {"oid": "470574c2cc5b278c46be48c92e49ecd6e0c4514d", "url": "https://github.com/elastic/elasticsearch/commit/470574c2cc5b278c46be48c92e49ecd6e0c4514d", "message": "Update docs/reference/ml/df-analytics/apis/get-inference-trained-model-stats.asciidoc", "committedDate": "2020-06-18T16:45:04Z", "type": "commit"}, {"oid": "4a8429d8a3ae9c2c08051753ff76827b92d3dfe2", "url": "https://github.com/elastic/elasticsearch/commit/4a8429d8a3ae9c2c08051753ff76827b92d3dfe2", "message": "Update docs/reference/ml/df-analytics/apis/get-inference-trained-model-stats.asciidoc", "committedDate": "2020-06-18T16:45:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3MTc2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442371767", "bodyText": "I think this method needs to be synchronized too", "author": "droberts195", "createdAt": "2020-06-18T16:58:35Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceStats.java", "diffHunk": "@@ -194,73 +208,59 @@ public void writeTo(StreamOutput out) throws IOException {\n         out.writeVLong(this.missingAllFieldsCount);\n         out.writeVLong(this.inferenceCount);\n         out.writeVLong(this.failureCount);\n+        if (out.getVersion().onOrAfter(Version.V_7_9_0)) {\n+            out.writeVLong(this.cacheMissCount);\n+        }\n         out.writeOptionalString(this.modelId);\n         out.writeOptionalString(this.nodeId);\n         out.writeInstant(timeStamp);\n     }\n \n     public static class Accumulator {\n \n-        private final LongAdder missingFieldsAccumulator = new LongAdder();\n-        private final LongAdder inferenceAccumulator = new LongAdder();\n-        private final LongAdder failureCountAccumulator = new LongAdder();\n+        private long missingFieldsAccumulator = 0L;\n+        private long inferenceAccumulator = 0L;\n+        private long failureCountAccumulator = 0L;\n+        private long cacheMissAccumulator = 0L;\n         private final String modelId;\n         private final String nodeId;\n-        // curious reader\n-        // you may be wondering why the lock set to the fair.\n-        // When `currentStatsAndReset` is called, we want it guaranteed that it will eventually execute.\n-        // If a ReadWriteLock is unfair, there are no such guarantees.\n-        // A call for the `writelock::lock` could pause indefinitely.\n-        private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);\n-\n-        public Accumulator(String modelId, String nodeId) {\n+\n+        public Accumulator(String modelId, String nodeId, long cacheMisses) {\n             this.modelId = modelId;\n             this.nodeId = nodeId;\n+            this.cacheMissAccumulator = cacheMisses;\n         }\n \n-        public Accumulator(InferenceStats previousStats) {\n+        Accumulator(InferenceStats previousStats) {\n             this.modelId = previousStats.modelId;\n             this.nodeId = previousStats.nodeId;\n-            this.missingFieldsAccumulator.add(previousStats.missingAllFieldsCount);\n-            this.inferenceAccumulator.add(previousStats.inferenceCount);\n-            this.failureCountAccumulator.add(previousStats.failureCount);\n+            this.missingFieldsAccumulator += previousStats.missingAllFieldsCount;\n+            this.inferenceAccumulator += previousStats.inferenceCount;\n+            this.failureCountAccumulator += previousStats.failureCount;\n+            this.cacheMissAccumulator += previousStats.cacheMissCount;\n         }\n \n         public Accumulator merge(InferenceStats otherStats) {", "originalCommit": "4a8429d8a3ae9c2c08051753ff76827b92d3dfe2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3ODA1MA==", "url": "https://github.com/elastic/elasticsearch/pull/58252#discussion_r442478050", "bodyText": "It is only used within ConcurrentHashMap#compute\nSome docs\nThe entire method invocation is performed atomically. \nSome attempted update operations on this map by other threads\nmay be blocked while computation is in progress, so the\ncomputation should be short and simple, and must not attempt to\nupdate any other mappings of this Map.\n\nI will add a comment saying this method is not thread safe itself and should be used in a thread safe fashion.", "author": "benwtrent", "createdAt": "2020-06-18T20:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3MTc2Nw=="}], "type": "inlineReview"}, {"oid": "d88b537ad651e675e9e819d9a91ae091e48148fb", "url": "https://github.com/elastic/elasticsearch/commit/d88b537ad651e675e9e819d9a91ae091e48148fb", "message": "adding comment", "committedDate": "2020-06-18T20:15:28Z", "type": "commit"}, {"oid": "ab676fc33f9c52e09c33190d2ee237743366fc69", "url": "https://github.com/elastic/elasticsearch/commit/ab676fc33f9c52e09c33190d2ee237743366fc69", "message": "Merge branch 'feature/ml-inference-count-cache-misses' of github.com:benwtrent/elasticsearch into feature/ml-inference-count-cache-misses", "committedDate": "2020-06-18T20:17:01Z", "type": "commit"}]}