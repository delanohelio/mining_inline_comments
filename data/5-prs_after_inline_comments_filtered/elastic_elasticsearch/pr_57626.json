{"pr_number": 57626, "pr_title": "Resolve index API", "pr_createdAt": "2020-06-03T21:04:14Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57626", "timeline": [{"oid": "0e816773f719ad023e1e06ebb93b911bf0f7ec3b", "url": "https://github.com/elastic/elasticsearch/commit/0e816773f719ad023e1e06ebb93b911bf0f7ec3b", "message": "resolve index abstractions", "committedDate": "2020-06-03T20:09:28Z", "type": "commit"}, {"oid": "e477312f694648a37dc66c4fea83ab897bc4f070", "url": "https://github.com/elastic/elasticsearch/commit/e477312f694648a37dc66c4fea83ab897bc4f070", "message": "fix a couple spots that were missed in renaming the endpoint", "committedDate": "2020-06-03T21:18:14Z", "type": "commit"}, {"oid": "27fd218eee31d0feca6073faae76620ef0edefcd", "url": "https://github.com/elastic/elasticsearch/commit/27fd218eee31d0feca6073faae76620ef0edefcd", "message": "one more missed spot", "committedDate": "2020-06-03T21:19:48Z", "type": "commit"}, {"oid": "8d3e6b4cfcd027db4ab92ddfa36f2a875537806c", "url": "https://github.com/elastic/elasticsearch/commit/8d3e6b4cfcd027db4ab92ddfa36f2a875537806c", "message": "ActionRequest instead of MasterNodeReadRequest", "committedDate": "2020-06-04T11:14:35Z", "type": "commit"}, {"oid": "0c4ef6b01f6b66a83d85faef2d2155716c41b16d", "url": "https://github.com/elastic/elasticsearch/commit/0c4ef6b01f6b66a83d85faef2d2155716c41b16d", "message": "support remote clusters, properly serialize indicesOptions", "committedDate": "2020-06-04T13:36:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NTcyNg==", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r435265726", "bodyText": "This code is largely adapted from IndicesAndAliasesResolver::resolveIndicesAndAliases. I saw no clear way to share that code.", "author": "danhermann", "createdAt": "2020-06-04T13:43:47Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/resolve/ResolveIndexAction.java", "diffHunk": "@@ -0,0 +1,636 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.resolve;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.OriginalIndices;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.CountDown;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Spliterators;\n+import java.util.stream.StreamSupport;\n+\n+public class ResolveIndexAction extends ActionType<ResolveIndexAction.Response> {\n+\n+    public static final ResolveIndexAction INSTANCE = new ResolveIndexAction();\n+    public static final String NAME = \"indices:admin/resolve/index\";\n+\n+    private ResolveIndexAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements IndicesRequest.Replaceable {\n+\n+        public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandOpen();\n+\n+        private String[] names;\n+        private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\n+\n+        public Request(String[] names) {\n+            this.names = names;\n+        }\n+\n+        public Request(String[] names, IndicesOptions indicesOptions) {\n+            this.names = names;\n+            this.indicesOptions = indicesOptions;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readStringArray();\n+            this.indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringArray(names);\n+            indicesOptions.writeIndicesOptions(out);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            ResolveIndexAction.Request request = (ResolveIndexAction.Request) o;\n+            return Arrays.equals(names, request.names);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash((Object[]) names);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            return names;\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return indicesOptions;\n+        }\n+\n+        @Override\n+        public IndicesRequest indices(String... indices) {\n+            this.names = indices;\n+            return this;\n+        }\n+    }\n+\n+    public static class ResolvedIndexAbstraction {\n+\n+        protected static final ParseField NAME_FIELD = new ParseField(\"name\");\n+\n+        private String name;\n+\n+        ResolvedIndexAbstraction() {}\n+\n+        ResolvedIndexAbstraction(String name) {\n+            this.name = name;\n+        }\n+\n+        protected void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    public static class ResolvedIndex extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField ATTRIBUTES_FIELD = new ParseField(\"attributes\");\n+        private static final ParseField DATA_STREAM_FIELD = new ParseField(\"data_stream\");\n+\n+        private final String[] aliases;\n+        private final String[] attributes;\n+        private final String dataStream;\n+\n+        ResolvedIndex(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.aliases = in.readStringArray();\n+            this.attributes = in.readStringArray();\n+            this.dataStream = in.readOptionalString();\n+        }\n+\n+        ResolvedIndex(String name, String[] aliases, String[] attributes, @Nullable String dataStream) {\n+            super(name);\n+            this.aliases = aliases;\n+            this.attributes = attributes;\n+            this.dataStream = dataStream;\n+        }\n+\n+        public ResolvedIndex copy(String newName) {\n+            return new ResolvedIndex(newName, aliases, attributes, dataStream);\n+        }\n+\n+        public String[] getAliases() {\n+            return aliases;\n+        }\n+\n+        public String getDataStream() {\n+            return dataStream;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(aliases);\n+            out.writeStringArray(attributes);\n+            out.writeOptionalString(dataStream);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (aliases.length > 0) {\n+                builder.array(ALIASES_FIELD.getPreferredName(), aliases);\n+            }\n+            builder.array(ATTRIBUTES_FIELD.getPreferredName(), attributes);\n+            if (Strings.isNullOrEmpty(dataStream) == false) {\n+                builder.field(DATA_STREAM_FIELD.getPreferredName(), dataStream);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedAlias extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+\n+        private final String[] indices;\n+\n+        ResolvedAlias(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.indices = in.readStringArray();\n+        }\n+\n+        ResolvedAlias(String name, String[] indices) {\n+            super(name);\n+            this.indices = indices;\n+        }\n+\n+        public ResolvedAlias copy(String newName) {\n+            return new ResolvedAlias(newName, indices);\n+        }\n+\n+        public String[] getIndices() {\n+            return indices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(indices);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (indices.length > 0) {\n+                builder.array(INDICES_FIELD.getPreferredName(), indices);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedDataStream extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField BACKING_INDICES_FIELD = new ParseField(\"backing_indices\");\n+        private static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp_field\");\n+\n+        private final String[] backingIndices;\n+        private final String timestampField;\n+\n+        ResolvedDataStream(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.backingIndices = in.readStringArray();\n+            this.timestampField = in.readString();\n+        }\n+\n+        ResolvedDataStream(String name, String[] backingIndices, String timestampField) {\n+            super(name);\n+            this.backingIndices = backingIndices;\n+            this.timestampField = timestampField;\n+        }\n+\n+        public ResolvedDataStream copy(String newName) {\n+            return new ResolvedDataStream(newName, backingIndices, timestampField);\n+        }\n+\n+        public String[] getBackingIndices() {\n+            return backingIndices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(backingIndices);\n+            out.writeString(timestampField);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            builder.array(BACKING_INDICES_FIELD.getPreferredName(), backingIndices);\n+            builder.field(TIMESTAMP_FIELD.getPreferredName(), timestampField);\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse implements ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField DATA_STREAMS_FIELD = new ParseField(\"data_streams\");\n+\n+        private final List<ResolvedIndex> indices;\n+        private final List<ResolvedAlias> aliases;\n+        private final List<ResolvedDataStream> dataStreams;\n+\n+        public Response(List<ResolvedIndex> indices, List<ResolvedAlias> aliases, List<ResolvedDataStream> dataStreams) {\n+            this.indices = indices;\n+            this.aliases = aliases;\n+            this.dataStreams = dataStreams;\n+        }\n+\n+        public Response(StreamInput in) throws IOException {\n+            this.indices = new ArrayList<>();\n+            int count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                indices.add(new ResolvedIndex(in));\n+            }\n+            this.aliases = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                aliases.add(new ResolvedAlias(in));\n+            }\n+            this.dataStreams = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                dataStreams.add(new ResolvedDataStream(in));\n+            }\n+        }\n+\n+        public List<ResolvedIndex> getIndices() {\n+            return indices;\n+        }\n+\n+        public List<ResolvedAlias> getAliases() {\n+            return aliases;\n+        }\n+\n+        public List<ResolvedDataStream> getDataStreams() {\n+            return dataStreams;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeVInt(indices.size());\n+            for (ResolvedIndex index : indices) {\n+                index.writeTo(out);\n+            }\n+            out.writeVInt(aliases.size());\n+            for (ResolvedAlias alias : aliases) {\n+                alias.writeTo(out);\n+            }\n+            out.writeVInt(dataStreams.size());\n+            for (ResolvedDataStream dataStream : dataStreams) {\n+                dataStream.writeTo(out);\n+            }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(INDICES_FIELD.getPreferredName(), indices);\n+            builder.field(ALIASES_FIELD.getPreferredName(), aliases);\n+            builder.field(DATA_STREAMS_FIELD.getPreferredName(), dataStreams);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response response = (Response) o;\n+            return indices.equals(response.indices) && aliases.equals(response.aliases) && dataStreams.equals(response.dataStreams);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(indices, aliases, dataStreams);\n+        }\n+    }\n+\n+    public static class TransportAction extends HandledTransportAction<Request, Response> {\n+\n+        private final ThreadPool threadPool;\n+        private final ClusterService clusterService;\n+        private final RemoteClusterService remoteClusterService;\n+        private final IndexNameExpressionResolver indexNameExpressionResolver;\n+\n+        @Inject\n+        public TransportAction(TransportService transportService, Settings settings, ClusterService clusterService, ThreadPool threadPool,\n+                               NodeClient client, ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                               IndicesService indicesService) {\n+            super(NAME, transportService, actionFilters, ResolveIndexAction.Request::new);\n+            this.threadPool = threadPool;\n+            this.clusterService = clusterService;\n+            this.remoteClusterService = transportService.getRemoteClusterService();\n+            this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        }\n+\n+        @Override\n+        protected void doExecute(Task task, Request request, final ActionListener<Response> listener) {\n+            final ClusterState clusterState = clusterService.state();\n+            final Map<String, OriginalIndices> remoteClusterIndices = remoteClusterService.groupIndices(request.indicesOptions(),\n+                request.indices());\n+            final OriginalIndices localIndices = remoteClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n+            final Metadata metadata = clusterState.metadata();\n+            List<ResolvedIndex> indices = Collections.synchronizedList(new ArrayList<>());\n+            List<ResolvedAlias> aliases = Collections.synchronizedList(new ArrayList<>());\n+            List<ResolvedDataStream> dataStreams = Collections.synchronizedList(new ArrayList<>());\n+            if (localIndices != null) {\n+                List<String> resolvedIndexAbstractions = resolveIndexAbstractions(localIndices.indices(), request.indicesOptions, metadata);\n+                SortedMap<String, IndexAbstraction> lookup = metadata.getIndicesLookup();\n+                for (String s : resolvedIndexAbstractions) {\n+                    addIndexAbstraction(s, lookup, indices, aliases, dataStreams);\n+                }\n+            }\n+\n+            if (remoteClusterIndices.size() > 0) {\n+                final int remoteRequests = remoteClusterIndices.size();\n+                final CountDown completionCounter = new CountDown(remoteRequests);\n+                final Runnable terminalHandler = () -> {\n+                    if (completionCounter.countDown()) {\n+                        listener.onResponse(new Response(indices, aliases, dataStreams));\n+                    }\n+                };\n+\n+                // make the cross-cluster calls\n+                for (Map.Entry<String, OriginalIndices> remoteIndices : remoteClusterIndices.entrySet()) {\n+                    String clusterAlias = remoteIndices.getKey();\n+                    OriginalIndices originalIndices = remoteIndices.getValue();\n+                    Client remoteClusterClient = remoteClusterService.getRemoteClusterClient(threadPool, clusterAlias);\n+                    Request remoteRequest = new Request(originalIndices.indices(), originalIndices.indicesOptions());\n+                    remoteClusterClient.admin().indices().resolveIndex(remoteRequest, ActionListener.wrap(response -> {\n+                        for (ResolvedIndex index : response.indices) {\n+                            indices.add(index.copy(RemoteClusterAware.buildRemoteIndexName(clusterAlias, index.getName())));\n+                        }\n+                        for (ResolvedAlias alias : response.aliases) {\n+                            aliases.add(alias.copy(RemoteClusterAware.buildRemoteIndexName(clusterAlias, alias.getName())));\n+                        }\n+                        for (ResolvedDataStream dataStream : response.dataStreams) {\n+                            dataStreams.add(dataStream.copy(RemoteClusterAware.buildRemoteIndexName(clusterAlias, dataStream.getName())));\n+                        }\n+                        terminalHandler.run();\n+                    }, failure -> terminalHandler.run()));\n+                }\n+            } else {\n+                listener.onResponse(new Response(indices, aliases, dataStreams));\n+            }\n+        }\n+\n+        private List<String> resolveIndexAbstractions(String[] indices, IndicesOptions indicesOptions, Metadata metadata) {", "originalCommit": "0c4ef6b01f6b66a83d85faef2d2155716c41b16d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3ODEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r437878133", "bodyText": "Do you think that we can add the shared logic to IndexNameExpressionResolver and share it between here and IndicesAndAliasesResolver?", "author": "martijnvg", "createdAt": "2020-06-10T06:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NTcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzU1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r439237556", "bodyText": "I think that isn't straightforward as the replaceWildcardsWithAuthorizedIndices() in IndicesAndAliasesResolver does additional filter out non autorized indices and that doesn't happen here.", "author": "martijnvg", "createdAt": "2020-06-12T06:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NTcyNg=="}], "type": "inlineReview"}, {"oid": "ed222d8e5e525d63d042abb66f6e455945854d8c", "url": "https://github.com/elastic/elasticsearch/commit/ed222d8e5e525d63d042abb66f6e455945854d8c", "message": "sort response, minor cleanup", "committedDate": "2020-06-04T15:52:51Z", "type": "commit"}, {"oid": "6eb916cd2b15bafc138ffaa23abf0a3b91857583", "url": "https://github.com/elastic/elasticsearch/commit/6eb916cd2b15bafc138ffaa23abf0a3b91857583", "message": "fix test stub", "committedDate": "2020-06-07T21:37:11Z", "type": "commit"}, {"oid": "6c35fe8940f28f66efe3aa5f14aa3309076a522f", "url": "https://github.com/elastic/elasticsearch/commit/6c35fe8940f28f66efe3aa5f14aa3309076a522f", "message": "Merge branch 'master' into resolve_index_abstraction", "committedDate": "2020-06-07T21:51:37Z", "type": "commit"}, {"oid": "c68e24ef2ecd027dab39c1c2ad05d8f7594ce598", "url": "https://github.com/elastic/elasticsearch/commit/c68e24ef2ecd027dab39c1c2ad05d8f7594ce598", "message": "test wip", "committedDate": "2020-06-08T12:28:05Z", "type": "commit"}, {"oid": "4eb83c450f460057fe61333790e9f6d83a6f0f49", "url": "https://github.com/elastic/elasticsearch/commit/4eb83c450f460057fe61333790e9f6d83a6f0f49", "message": "Merge branch 'master' into resolve_index_abstraction", "committedDate": "2020-06-08T12:53:49Z", "type": "commit"}, {"oid": "7067ba4c5ffdfad2cd0a9f221bbf847b72097671", "url": "https://github.com/elastic/elasticsearch/commit/7067ba4c5ffdfad2cd0a9f221bbf847b72097671", "message": "Merge branch 'master' into resolve_index_abstraction", "committedDate": "2020-06-08T13:43:42Z", "type": "commit"}, {"oid": "828bdae85b8bf976dc40b8aa6c565a45c45bc182", "url": "https://github.com/elastic/elasticsearch/commit/828bdae85b8bf976dc40b8aa6c565a45c45bc182", "message": "completed REST test", "committedDate": "2020-06-08T13:59:10Z", "type": "commit"}, {"oid": "a2070e1c6a2503d809019d27b297e69efe4a70e7", "url": "https://github.com/elastic/elasticsearch/commit/a2070e1c6a2503d809019d27b297e69efe4a70e7", "message": "add remote cluster REST test", "committedDate": "2020-06-08T14:32:16Z", "type": "commit"}, {"oid": "c2e25ab55667eae7c06305c8117433fbe95db068", "url": "https://github.com/elastic/elasticsearch/commit/c2e25ab55667eae7c06305c8117433fbe95db068", "message": "remote cluster test work", "committedDate": "2020-06-08T16:07:29Z", "type": "commit"}, {"oid": "88321670293ad49e1cc9fd0bed808832c51c2d67", "url": "https://github.com/elastic/elasticsearch/commit/88321670293ad49e1cc9fd0bed808832c51c2d67", "message": "update remote cluster REST test", "committedDate": "2020-06-08T18:53:38Z", "type": "commit"}, {"oid": "7c10665993e26eca3a46558cdb1105ae50609899", "url": "https://github.com/elastic/elasticsearch/commit/7c10665993e26eca3a46558cdb1105ae50609899", "message": "test retrieval of remote items only", "committedDate": "2020-06-09T11:47:56Z", "type": "commit"}, {"oid": "102fd78ff00a23d726e9699482ef70d08a16437c", "url": "https://github.com/elastic/elasticsearch/commit/102fd78ff00a23d726e9699482ef70d08a16437c", "message": "Merge branch 'master' into resolve_index_abstraction", "committedDate": "2020-06-09T12:40:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTQzNw==", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r437881437", "bodyText": "maybe add a parsing unit test for the response class? (extending AbstractSerializingTestCase and defining a parser in the test)", "author": "martijnvg", "createdAt": "2020-06-10T06:11:47Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/resolve/ResolveIndexAction.java", "diffHunk": "@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.resolve;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.OriginalIndices;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.util.concurrent.CountDown;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Spliterators;\n+import java.util.TreeMap;\n+import java.util.stream.StreamSupport;\n+\n+public class ResolveIndexAction extends ActionType<ResolveIndexAction.Response> {\n+\n+    public static final ResolveIndexAction INSTANCE = new ResolveIndexAction();\n+    public static final String NAME = \"indices:admin/resolve/index\";\n+\n+    private ResolveIndexAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements IndicesRequest.Replaceable {\n+\n+        public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandOpen();\n+\n+        private String[] names;\n+        private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\n+\n+        public Request(String[] names) {\n+            this.names = names;\n+        }\n+\n+        public Request(String[] names, IndicesOptions indicesOptions) {\n+            this.names = names;\n+            this.indicesOptions = indicesOptions;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readStringArray();\n+            this.indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringArray(names);\n+            indicesOptions.writeIndicesOptions(out);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            ResolveIndexAction.Request request = (ResolveIndexAction.Request) o;\n+            return Arrays.equals(names, request.names);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash((Object[]) names);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            return names;\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return indicesOptions;\n+        }\n+\n+        @Override\n+        public IndicesRequest indices(String... indices) {\n+            this.names = indices;\n+            return this;\n+        }\n+    }\n+\n+    public static class ResolvedIndexAbstraction {\n+\n+        protected static final ParseField NAME_FIELD = new ParseField(\"name\");\n+\n+        private String name;\n+\n+        ResolvedIndexAbstraction() {}\n+\n+        ResolvedIndexAbstraction(String name) {\n+            this.name = name;\n+        }\n+\n+        protected void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    public static class ResolvedIndex extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField ATTRIBUTES_FIELD = new ParseField(\"attributes\");\n+        private static final ParseField DATA_STREAM_FIELD = new ParseField(\"data_stream\");\n+\n+        private final String[] aliases;\n+        private final String[] attributes;\n+        private final String dataStream;\n+\n+        ResolvedIndex(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.aliases = in.readStringArray();\n+            this.attributes = in.readStringArray();\n+            this.dataStream = in.readOptionalString();\n+        }\n+\n+        ResolvedIndex(String name, String[] aliases, String[] attributes, @Nullable String dataStream) {\n+            super(name);\n+            this.aliases = aliases;\n+            this.attributes = attributes;\n+            this.dataStream = dataStream;\n+        }\n+\n+        public ResolvedIndex copy(String newName) {\n+            return new ResolvedIndex(newName, aliases, attributes, dataStream);\n+        }\n+\n+        public String[] getAliases() {\n+            return aliases;\n+        }\n+\n+        public String getDataStream() {\n+            return dataStream;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(aliases);\n+            out.writeStringArray(attributes);\n+            out.writeOptionalString(dataStream);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (aliases.length > 0) {\n+                builder.array(ALIASES_FIELD.getPreferredName(), aliases);\n+            }\n+            builder.array(ATTRIBUTES_FIELD.getPreferredName(), attributes);\n+            if (Strings.isNullOrEmpty(dataStream) == false) {\n+                builder.field(DATA_STREAM_FIELD.getPreferredName(), dataStream);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedAlias extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+\n+        private final String[] indices;\n+\n+        ResolvedAlias(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.indices = in.readStringArray();\n+        }\n+\n+        ResolvedAlias(String name, String[] indices) {\n+            super(name);\n+            this.indices = indices;\n+        }\n+\n+        public ResolvedAlias copy(String newName) {\n+            return new ResolvedAlias(newName, indices);\n+        }\n+\n+        public String[] getIndices() {\n+            return indices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(indices);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (indices.length > 0) {\n+                builder.array(INDICES_FIELD.getPreferredName(), indices);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedDataStream extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField BACKING_INDICES_FIELD = new ParseField(\"backing_indices\");\n+        private static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp_field\");\n+\n+        private final String[] backingIndices;\n+        private final String timestampField;\n+\n+        ResolvedDataStream(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.backingIndices = in.readStringArray();\n+            this.timestampField = in.readString();\n+        }\n+\n+        ResolvedDataStream(String name, String[] backingIndices, String timestampField) {\n+            super(name);\n+            this.backingIndices = backingIndices;\n+            this.timestampField = timestampField;\n+        }\n+\n+        public ResolvedDataStream copy(String newName) {\n+            return new ResolvedDataStream(newName, backingIndices, timestampField);\n+        }\n+\n+        public String[] getBackingIndices() {\n+            return backingIndices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(backingIndices);\n+            out.writeString(timestampField);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            builder.array(BACKING_INDICES_FIELD.getPreferredName(), backingIndices);\n+            builder.field(TIMESTAMP_FIELD.getPreferredName(), timestampField);\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse implements ToXContentObject {", "originalCommit": "102fd78ff00a23d726e9699482ef70d08a16437c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTg0MA==", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r437881840", "bodyText": "Maybe extract the logic here in a static method, so that unit tests can be written?", "author": "martijnvg", "createdAt": "2020-06-10T06:12:59Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/resolve/ResolveIndexAction.java", "diffHunk": "@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.resolve;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.OriginalIndices;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.util.concurrent.CountDown;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Spliterators;\n+import java.util.TreeMap;\n+import java.util.stream.StreamSupport;\n+\n+public class ResolveIndexAction extends ActionType<ResolveIndexAction.Response> {\n+\n+    public static final ResolveIndexAction INSTANCE = new ResolveIndexAction();\n+    public static final String NAME = \"indices:admin/resolve/index\";\n+\n+    private ResolveIndexAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements IndicesRequest.Replaceable {\n+\n+        public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandOpen();\n+\n+        private String[] names;\n+        private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\n+\n+        public Request(String[] names) {\n+            this.names = names;\n+        }\n+\n+        public Request(String[] names, IndicesOptions indicesOptions) {\n+            this.names = names;\n+            this.indicesOptions = indicesOptions;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readStringArray();\n+            this.indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringArray(names);\n+            indicesOptions.writeIndicesOptions(out);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            ResolveIndexAction.Request request = (ResolveIndexAction.Request) o;\n+            return Arrays.equals(names, request.names);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash((Object[]) names);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            return names;\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return indicesOptions;\n+        }\n+\n+        @Override\n+        public IndicesRequest indices(String... indices) {\n+            this.names = indices;\n+            return this;\n+        }\n+    }\n+\n+    public static class ResolvedIndexAbstraction {\n+\n+        protected static final ParseField NAME_FIELD = new ParseField(\"name\");\n+\n+        private String name;\n+\n+        ResolvedIndexAbstraction() {}\n+\n+        ResolvedIndexAbstraction(String name) {\n+            this.name = name;\n+        }\n+\n+        protected void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    public static class ResolvedIndex extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField ATTRIBUTES_FIELD = new ParseField(\"attributes\");\n+        private static final ParseField DATA_STREAM_FIELD = new ParseField(\"data_stream\");\n+\n+        private final String[] aliases;\n+        private final String[] attributes;\n+        private final String dataStream;\n+\n+        ResolvedIndex(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.aliases = in.readStringArray();\n+            this.attributes = in.readStringArray();\n+            this.dataStream = in.readOptionalString();\n+        }\n+\n+        ResolvedIndex(String name, String[] aliases, String[] attributes, @Nullable String dataStream) {\n+            super(name);\n+            this.aliases = aliases;\n+            this.attributes = attributes;\n+            this.dataStream = dataStream;\n+        }\n+\n+        public ResolvedIndex copy(String newName) {\n+            return new ResolvedIndex(newName, aliases, attributes, dataStream);\n+        }\n+\n+        public String[] getAliases() {\n+            return aliases;\n+        }\n+\n+        public String getDataStream() {\n+            return dataStream;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(aliases);\n+            out.writeStringArray(attributes);\n+            out.writeOptionalString(dataStream);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (aliases.length > 0) {\n+                builder.array(ALIASES_FIELD.getPreferredName(), aliases);\n+            }\n+            builder.array(ATTRIBUTES_FIELD.getPreferredName(), attributes);\n+            if (Strings.isNullOrEmpty(dataStream) == false) {\n+                builder.field(DATA_STREAM_FIELD.getPreferredName(), dataStream);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedAlias extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+\n+        private final String[] indices;\n+\n+        ResolvedAlias(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.indices = in.readStringArray();\n+        }\n+\n+        ResolvedAlias(String name, String[] indices) {\n+            super(name);\n+            this.indices = indices;\n+        }\n+\n+        public ResolvedAlias copy(String newName) {\n+            return new ResolvedAlias(newName, indices);\n+        }\n+\n+        public String[] getIndices() {\n+            return indices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(indices);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (indices.length > 0) {\n+                builder.array(INDICES_FIELD.getPreferredName(), indices);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedDataStream extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField BACKING_INDICES_FIELD = new ParseField(\"backing_indices\");\n+        private static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp_field\");\n+\n+        private final String[] backingIndices;\n+        private final String timestampField;\n+\n+        ResolvedDataStream(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.backingIndices = in.readStringArray();\n+            this.timestampField = in.readString();\n+        }\n+\n+        ResolvedDataStream(String name, String[] backingIndices, String timestampField) {\n+            super(name);\n+            this.backingIndices = backingIndices;\n+            this.timestampField = timestampField;\n+        }\n+\n+        public ResolvedDataStream copy(String newName) {\n+            return new ResolvedDataStream(newName, backingIndices, timestampField);\n+        }\n+\n+        public String[] getBackingIndices() {\n+            return backingIndices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(backingIndices);\n+            out.writeString(timestampField);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            builder.array(BACKING_INDICES_FIELD.getPreferredName(), backingIndices);\n+            builder.field(TIMESTAMP_FIELD.getPreferredName(), timestampField);\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse implements ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField DATA_STREAMS_FIELD = new ParseField(\"data_streams\");\n+\n+        private final List<ResolvedIndex> indices;\n+        private final List<ResolvedAlias> aliases;\n+        private final List<ResolvedDataStream> dataStreams;\n+\n+        public Response(List<ResolvedIndex> indices, List<ResolvedAlias> aliases, List<ResolvedDataStream> dataStreams) {\n+            this.indices = indices;\n+            this.aliases = aliases;\n+            this.dataStreams = dataStreams;\n+        }\n+\n+        public Response(StreamInput in) throws IOException {\n+            this.indices = new ArrayList<>();\n+            int count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                indices.add(new ResolvedIndex(in));\n+            }\n+            this.aliases = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                aliases.add(new ResolvedAlias(in));\n+            }\n+            this.dataStreams = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                dataStreams.add(new ResolvedDataStream(in));\n+            }\n+        }\n+\n+        public List<ResolvedIndex> getIndices() {\n+            return indices;\n+        }\n+\n+        public List<ResolvedAlias> getAliases() {\n+            return aliases;\n+        }\n+\n+        public List<ResolvedDataStream> getDataStreams() {\n+            return dataStreams;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeVInt(indices.size());\n+            for (ResolvedIndex index : indices) {\n+                index.writeTo(out);\n+            }\n+            out.writeVInt(aliases.size());\n+            for (ResolvedAlias alias : aliases) {\n+                alias.writeTo(out);\n+            }\n+            out.writeVInt(dataStreams.size());\n+            for (ResolvedDataStream dataStream : dataStreams) {\n+                dataStream.writeTo(out);\n+            }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(INDICES_FIELD.getPreferredName(), indices);\n+            builder.field(ALIASES_FIELD.getPreferredName(), aliases);\n+            builder.field(DATA_STREAMS_FIELD.getPreferredName(), dataStreams);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response response = (Response) o;\n+            return indices.equals(response.indices) && aliases.equals(response.aliases) && dataStreams.equals(response.dataStreams);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(indices, aliases, dataStreams);\n+        }\n+    }\n+\n+    public static class TransportAction extends HandledTransportAction<Request, Response> {\n+\n+        private final ThreadPool threadPool;\n+        private final ClusterService clusterService;\n+        private final RemoteClusterService remoteClusterService;\n+        private final IndexNameExpressionResolver indexNameExpressionResolver;\n+\n+        @Inject\n+        public TransportAction(TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                               ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+            super(NAME, transportService, actionFilters, ResolveIndexAction.Request::new);\n+            this.threadPool = threadPool;\n+            this.clusterService = clusterService;\n+            this.remoteClusterService = transportService.getRemoteClusterService();\n+            this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        }\n+\n+        @Override\n+        protected void doExecute(Task task, Request request, final ActionListener<Response> listener) {\n+            final ClusterState clusterState = clusterService.state();", "originalCommit": "102fd78ff00a23d726e9699482ef70d08a16437c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2fc51f9d0be6ee2d0930d9c7ceb5d5999297ffcd", "url": "https://github.com/elastic/elasticsearch/commit/2fc51f9d0be6ee2d0930d9c7ceb5d5999297ffcd", "message": "add serialization test", "committedDate": "2020-06-11T11:34:11Z", "type": "commit"}, {"oid": "a5c5a90a6fe5d7efd7f50c2aa36de8a3a5fd6123", "url": "https://github.com/elastic/elasticsearch/commit/a5c5a90a6fe5d7efd7f50c2aa36de8a3a5fd6123", "message": "serialization test for request class", "committedDate": "2020-06-11T14:45:42Z", "type": "commit"}, {"oid": "3863d507ffc2edd471a169d1fbf811d99a7c6d01", "url": "https://github.com/elastic/elasticsearch/commit/3863d507ffc2edd471a169d1fbf811d99a7c6d01", "message": "finalize the unit tests", "committedDate": "2020-06-12T01:18:43Z", "type": "commit"}, {"oid": "15bc4547d8beba4a0b2a9489d95b5ec1534974c0", "url": "https://github.com/elastic/elasticsearch/commit/15bc4547d8beba4a0b2a9489d95b5ec1534974c0", "message": "Merge branch 'master' into resolve_index_abstraction", "committedDate": "2020-06-12T01:31:20Z", "type": "commit"}]}