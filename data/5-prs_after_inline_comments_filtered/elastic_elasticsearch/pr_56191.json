{"pr_number": 56191, "pr_title": "EQL: simplify equals/not-equals TRUE/FALSE expressions", "pr_createdAt": "2020-05-05T11:52:27Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56191", "timeline": [{"oid": "3be78787fd82197be327574245493444f3f5ebc2", "url": "https://github.com/elastic/elasticsearch/commit/3be78787fd82197be327574245493444f3f5ebc2", "message": "Simplify equals/not-equals TRUE/FALSE expressions, by transforming\nthem into an AND(TRUE, new-expression) where new-expression may be\nthe original expression or a negation of it.", "committedDate": "2020-05-05T11:42:53Z", "type": "commit"}, {"oid": "bc6eb4a7369dcfc649beae53b19c3346932da5ea", "url": "https://github.com/elastic/elasticsearch/commit/bc6eb4a7369dcfc649beae53b19c3346932da5ea", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into bool_optimizer_rule", "committedDate": "2020-05-05T11:54:01Z", "type": "commit"}, {"oid": "4bb5f1f332a78960e6950680a6aaf32c8faed585", "url": "https://github.com/elastic/elasticsearch/commit/4bb5f1f332a78960e6950680a6aaf32c8faed585", "message": "Fix errors after master merge", "committedDate": "2020-05-05T12:00:56Z", "type": "commit"}, {"oid": "dbf707a8922c20cec46b38da55730d4152e91f73", "url": "https://github.com/elastic/elasticsearch/commit/dbf707a8922c20cec46b38da55730d4152e91f73", "message": "Remove unused import", "committedDate": "2020-05-05T12:16:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzMzA3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56191#discussion_r420233076", "bodyText": "What's the purpose of the intermediate And node if it's always combined with TRUE?", "author": "rw-access", "createdAt": "2020-05-05T16:14:52Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -62,6 +62,57 @@ public Expression rule(Expression e) {\n             return e.foldable() ? Literal.of(e) : e;\n         }\n     }\n+\n+    public static final class BooleanEqualsSimplification extends OptimizerExpressionRule {\n+\n+        public BooleanEqualsSimplification() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Equals || e instanceof NotEquals) {\n+                Expression newLeft = null;\n+                Expression newRight = null;\n+\n+                // transform a \"==\" or \"!=\" TRUE/FALSE into an \"AND TRUE\" by negating (if necessary) the other side of the expression\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+                    // ex == TRUE -> AND(ex, TRUE)\n+                    if (TRUE.equals(eq.left()) || TRUE.equals(eq.right())) {\n+                        newLeft = eq.left();\n+                        newRight = eq.right();\n+                    }\n+                    // ex == FALSE -> AND(NOT(ex), TRUE)\n+                    if (FALSE.equals(eq.left()) || FALSE.equals(eq.right())) {\n+                        boolean isLeftFalse = FALSE.equals(eq.left());\n+                        newLeft = isLeftFalse ? TRUE : new Not(eq.left().source(), eq.left());\n+                        newRight = isLeftFalse ? new Not(eq.right().source(), eq.right()) : TRUE;\n+                    }\n+                } else {\n+                    NotEquals neq = (NotEquals) e;\n+                    // ex != TRUE -> AND(NOT(x), TRUE)\n+                    if (TRUE.equals(neq.left()) || TRUE.equals(neq.right())) {\n+                        boolean isLeftTrue = TRUE.equals(neq.left());\n+                        newLeft = isLeftTrue ? TRUE : new Not(neq.left().source(), neq.left());\n+                        newRight = isLeftTrue ? new Not(neq.right().source(), neq.right()) : TRUE;\n+                    }\n+                    // ex != FALSE -> AND(ex, TRUE)\n+                    if (FALSE.equals(neq.left()) || FALSE.equals(neq.right())) {\n+                        boolean isLeftFalse = FALSE.equals(neq.left());\n+                        newLeft = isLeftFalse ? TRUE : neq.left();\n+                        newRight = isLeftFalse ? neq.right() : TRUE;\n+                    }\n+                }\n+                \n+                if (newLeft != null) {\n+                    return new And(e.source(), newLeft, newRight);", "originalCommit": "dbf707a8922c20cec46b38da55730d4152e91f73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNTc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56191#discussion_r420235787", "bodyText": "I think it's okay to assume that TRUE is on the right,  since we've moved literals to the right.\nIf it's on the left, than both left and right must be literals and the expression will fold anyway.\nIf that's true, I think it'll simplify the logic a good bit:\nif (e instanceof Equals ) {\n    Equals eq = (Equals) e;\n    if (TRUE.equals(eq.right()) {\n        return eq.left()\n    }\n\n    if (FALSE.equals(eq.right()) {\n        return new Not(eq.source(), eq.left())\n    }\n}\n\nif (e instanceof NotEquals ) {\n    Equals eq = (NotEquals) e;\n    if (FALSE.equals(eq.right()) {\n        return eq.left()\n    }\n\n    if (TRUE.equals(eq.right()) {\n        return new Not(eq.source(), eq.left())\n    }\n}", "author": "rw-access", "createdAt": "2020-05-05T16:18:53Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -62,6 +62,57 @@ public Expression rule(Expression e) {\n             return e.foldable() ? Literal.of(e) : e;\n         }\n     }\n+\n+    public static final class BooleanEqualsSimplification extends OptimizerExpressionRule {\n+\n+        public BooleanEqualsSimplification() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {", "originalCommit": "dbf707a8922c20cec46b38da55730d4152e91f73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI1MTQ2MA==", "url": "https://github.com/elastic/elasticsearch/pull/56191#discussion_r420251460", "bodyText": "BooleanLiteralsOnTheRight is applied after this rule so assuming literals on the right doesn't always work at least for the first iteration - I think this is fine or we could rearrange the rules, either move this rule after bools on the right or move that ahead.\nI agree with Ross that the code is simplified this way and we could avoid the intermediate And as well (it would be simplified by another rule but there's no value in keeping it around).", "author": "costin", "createdAt": "2020-05-05T16:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNTc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI1OTM0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56191#discussion_r420259349", "bodyText": "Note you could compress the code even more though it impacts readability:\nif (e instanceof Equals || e instanceof NotEquals) {\n    BinaryComparison bc = (BinaryComparison) e;\n    Literal isTrue = e instanceof Equals ? TRUE : FALSE;\n    Literal isFalse = e instanceof NotEquals ? TRUE: FALSE;\n\n    // e == TRUE or e != FALSE\n    if (isTrue.equals(bc.right()) {\n        return bc.left();\n    }\n\n    //  e == FALSE or e != TRUE\n    if (isFalse.equals(bc.right()) {\n        return new Not(bc.source(), bc.left())\n    }\n}", "author": "costin", "createdAt": "2020-05-05T16:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNTc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwNzYxMg==", "url": "https://github.com/elastic/elasticsearch/pull/56191#discussion_r420607612", "bodyText": "I can change this.\nIn the way it is now, this is a \"standalone\" rule that can be applied no matter what rules are after or before it. Maybe it can be reused in the future in other languages. Changing it will assume that BooleanLiteralsOnTheRight must be always before this rule. And the rule will be much simplified, as you pointed out.\nAnd to this extent, one can argue that this rule can very well be integrated in BooleanLiteralsOnTheRight...", "author": "astefan", "createdAt": "2020-05-06T07:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNTc4Nw=="}], "type": "inlineReview"}, {"oid": "8024a1951f006b1df5289342cc6ec70c077cea2c", "url": "https://github.com/elastic/elasticsearch/commit/8024a1951f006b1df5289342cc6ec70c077cea2c", "message": "Address reviews", "committedDate": "2020-05-06T08:42:31Z", "type": "commit"}, {"oid": "7102b384e52f35f3f8e57a8cfc8424934f1382d2", "url": "https://github.com/elastic/elasticsearch/commit/7102b384e52f35f3f8e57a8cfc8424934f1382d2", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into bool_optimizer_rule", "committedDate": "2020-05-06T08:42:48Z", "type": "commit"}, {"oid": "993c3b65b25207f88dbf595088beeb80b366715b", "url": "https://github.com/elastic/elasticsearch/commit/993c3b65b25207f88dbf595088beeb80b366715b", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into bool_optimizer_rule", "committedDate": "2020-05-06T09:02:25Z", "type": "commit"}, {"oid": "cce385b40f04d0793ae11a1c6d9e42e8a602162d", "url": "https://github.com/elastic/elasticsearch/commit/cce385b40f04d0793ae11a1c6d9e42e8a602162d", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into bool_optimizer_rule", "committedDate": "2020-05-06T20:16:31Z", "type": "commit"}]}