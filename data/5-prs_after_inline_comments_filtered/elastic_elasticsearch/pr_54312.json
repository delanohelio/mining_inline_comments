{"pr_number": 54312, "pr_title": "Broadcast cancellation to only nodes have outstanding child tasks", "pr_createdAt": "2020-03-26T23:40:37Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54312", "timeline": [{"oid": "cd19eef0fbdc1eca9b828c1678de5dd4cc618a3f", "url": "https://github.com/elastic/elasticsearch/commit/cd19eef0fbdc1eca9b828c1678de5dd4cc618a3f", "message": "Propagate cancellation to nodes have outstanding child tasks", "committedDate": "2020-03-26T23:38:06Z", "type": "commit"}, {"oid": "23ddc8aa0b0845e54666e8941791589b69c2b08e", "url": "https://github.com/elastic/elasticsearch/commit/23ddc8aa0b0845e54666e8941791589b69c2b08e", "message": "register child node when execute task locally", "committedDate": "2020-03-27T16:23:23Z", "type": "commit"}, {"oid": "2136f26af6e9ae409e8baf182b9ff1afcfdc3369", "url": "https://github.com/elastic/elasticsearch/commit/2136f26af6e9ae409e8baf182b9ff1afcfdc3369", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-27T16:41:48Z", "type": "commit"}, {"oid": "dba2dbdc0a567cd12cd460c3a25e5472abdab898", "url": "https://github.com/elastic/elasticsearch/commit/dba2dbdc0a567cd12cd460c3a25e5472abdab898", "message": "only return when childTasks have completed", "committedDate": "2020-03-27T17:40:09Z", "type": "commit"}, {"oid": "a2286d1d0f86da3108c5ce27ccbc72fb9ad8043f", "url": "https://github.com/elastic/elasticsearch/commit/a2286d1d0f86da3108c5ce27ccbc72fb9ad8043f", "message": "remove unneed synchronized", "committedDate": "2020-03-27T17:40:59Z", "type": "commit"}, {"oid": "b14efd3131591ae9522e39eacd3a294f5ee679fe", "url": "https://github.com/elastic/elasticsearch/commit/b14efd3131591ae9522e39eacd3a294f5ee679fe", "message": "javadocs", "committedDate": "2020-03-27T18:32:35Z", "type": "commit"}, {"oid": "f5753dc2a4d879ff14b77c6f3a034b648cd2081f", "url": "https://github.com/elastic/elasticsearch/commit/f5753dc2a4d879ff14b77c6f3a034b648cd2081f", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-27T18:55:24Z", "type": "commit"}, {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d", "url": "https://github.com/elastic/elasticsearch/commit/0f51b4548ef55190e34a26a4309122cdc95df32d", "message": "remove assertion", "committedDate": "2020-03-27T19:47:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399953501", "bodyText": "should we check before the unblock that cancelFuture.isDone == false?", "author": "ywelsch", "createdAt": "2020-03-30T06:29:28Z", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -159,7 +162,9 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         logger.debug(\"unblocking the blocked update\");\n         ALLOWED_OPERATIONS.release(builder.request().getSlices());\n-\n+        ListTasksResponse cancelTasksResponse = cancelFuture.get();", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NDQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399954403", "bodyText": "Given the test change here, I wonder if there should be an option for task cancellation to say whether it should wait for its children to be cancelled / completed before returning. As soon as the parent is cancelled, we know that eventually the children will be cancelled (not yet guaranteed by the current implementation, but something we eventually want with the keepalive).", "author": "ywelsch", "createdAt": "2020-03-30T06:31:59Z", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -131,16 +132,18 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         // Cancel the request while the action is blocked by the indexing operation listeners.\n         // This will prevent further requests from being sent.\n-        ListTasksResponse cancelTasksResponse = client().admin().cluster().prepareCancelTasks().setTaskId(mainTask.getTaskId()).get();\n-        cancelTasksResponse.rethrowFailures(\"Cancel\");\n-        assertThat(cancelTasksResponse.getTasks(), hasSize(1));\n+        ActionFuture<CancelTasksResponse> cancelFuture = client().admin().cluster().prepareCancelTasks()\n+            .setTaskId(mainTask.getTaskId()).execute();", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NjM0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399956343", "bodyText": "In theory, we could coordinate the banning / unbanning on a per-node basis, i.e., as soon as the parent is cancelled, and all requests from a child node have completed, we can send an unban to that node. I don't think that this optimization is needed (as it might make the code unnecessarily more complex), just thought I should mention it.", "author": "ywelsch", "createdAt": "2020-03-30T06:37:15Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMDc3NA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400410774", "bodyText": "Ok, I will try to implement this in a follow-up if it's simple.", "author": "dnhatn", "createdAt": "2020-03-30T18:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NjM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzM3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399957376", "bodyText": "let's also log the childNodes here", "author": "ywelsch", "createdAt": "2020-03-30T06:39:51Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959123", "bodyText": "if (canceled == false) we're not calling groupedListener?", "author": "ywelsch", "createdAt": "2020-03-30T06:44:28Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);\n+                    listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n+                },\n+                e -> {\n+                    try {\n+                        removeBanOnNodes(cancellableTask, childNodes);\n+                    } catch (Exception inner) {\n+                        e.addSuppressed(inner);\n                     }\n+                    listener.onFailure(e);\n                 });\n+            canceled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (canceled) {", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxODczNg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400418736", "bodyText": "We throw exception at the end. Anyway, I moved up that statement right after we cancel (see a5af596).", "author": "dnhatn", "createdAt": "2020-03-30T18:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959420", "bodyText": "log at trace level", "author": "ywelsch", "createdAt": "2020-03-30T06:45:17Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());\n+        GroupedActionListener<Void> groupedListener =\n+            new GroupedActionListener<>(ActionListener.map(listener, r -> null), childNodes.size());\n+        final BanParentTaskRequest banRequest = BanParentTaskRequest.createSetBanParentTaskRequest(\n+            new TaskId(clusterService.localNode().getId(), task.getId()), reason);\n+        for (DiscoveryNode node : childNodes) {\n+            transportService.sendRequest(node, BAN_PARENT_ACTION_NAME, banRequest,\n                 new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {\n                     @Override\n                     public void handleResponse(TransportResponse.Empty response) {\n-                        listener.onResponse(null);\n+                        groupedListener.onResponse(null);\n                     }\n \n                     @Override\n                     public void handleException(TransportException exp) {\n-                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-                        listener.onFailure(exp);\n+                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", banRequest.parentTaskId, node);\n+                        groupedListener.onFailure(exp);\n                     }\n                 });\n         }\n     }\n \n-    private void sendRemoveBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request, EmptyTransportResponseHandler\n-                .INSTANCE_SAME);\n+    private void removeBanOnNodes(CancellableTask task, Collection<DiscoveryNode> childNodes) {\n+        final BanParentTaskRequest request =\n+            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()));\n+        for (DiscoveryNode node : childNodes) {\n+            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTgyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399961829", "bodyText": "I wonder if we should leave this optimization in (and add a comment as well). This avoids computing the hash of the task id in order to look it up in the map.", "author": "ywelsch", "createdAt": "2020-03-30T06:51:37Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -163,7 +178,7 @@ private void registerCancellableTask(Task task) {\n         CancellableTaskHolder oldHolder = cancellableTasks.put(task.getId(), holder);\n         assert oldHolder == null;\n         // Check if this task was banned before we start it\n-        if (task.getParentTaskId().isSet() && banedParents.isEmpty() == false) {", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMTEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400411133", "bodyText": "I restored and added a comment 297b787", "author": "dnhatn", "createdAt": "2020-03-30T18:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzM2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963368", "bodyText": "when do we expect this to happen?", "author": "ywelsch", "createdAt": "2020-03-30T06:55:15Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzUwMA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963500", "bodyText": "I'm not sure I understand this comment. Can you elaborate on this?", "author": "ywelsch", "createdAt": "2020-03-30T06:55:35Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n+            // We still need to set ban on local node for persistent tasks", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMjY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400412661", "bodyText": "I don't know either. It's from the draft version. Sorry.", "author": "dnhatn", "createdAt": "2020-03-30T18:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2Mzk0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963945", "bodyText": "perhaps call this onChildTasksCompleted?", "author": "ywelsch", "createdAt": "2020-03-30T06:56:38Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NDk3MA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399964970", "bodyText": "any child tasks", "author": "ywelsch", "createdAt": "2020-03-30T06:58:59Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NTY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399965692", "bodyText": "perhaps runnable = {}, which avoids the null check later down", "author": "ywelsch", "createdAt": "2020-03-30T07:00:43Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400415123", "bodyText": "onChildTasksCompleted is still null if we do not cancel the task.", "author": "dnhatn", "createdAt": "2020-03-30T18:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966298", "bodyText": "why does this deserve a warning?\nWhen do we expect this to happen?", "author": "ywelsch", "createdAt": "2020-03-30T07:02:04Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966679", "bodyText": "Why use empty set here and not the actual set? Will this not lead to incorrectness?", "author": "ywelsch", "createdAt": "2020-03-30T07:03:00Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());\n+                    pendingChildNodes = Collections.emptySet();", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTQ4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400415489", "bodyText": "Good catch. Fixed in 226a541", "author": "dnhatn", "createdAt": "2020-03-30T18:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971293", "bodyText": "I think that we need to actually capture the connection (not the DiscoveryNode object). The reason for this is cross-cluster connections. In the task cancellation action, we assume that the DiscoveryNode is sufficient to resolve the target of the cancellation. This only works for nodes in the same cluster, however.\nI don't think that we need to solve this all in this PR, but we need to capture the issue properly, and add an item to the planning.", "author": "ywelsch", "createdAt": "2020-03-30T07:12:55Z", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNzA1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400417053", "bodyText": "++ see 4f337de", "author": "dnhatn", "createdAt": "2020-03-30T18:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTcxMg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971712", "bodyText": "should we call this in a finally block?", "author": "ywelsch", "createdAt": "2020-03-30T07:13:43Z", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTc4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971785", "bodyText": "should we call this in a finally block?", "author": "ywelsch", "createdAt": "2020-03-30T07:13:53Z", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);\n+                    }\n+\n+                    @Override\n+                    public void handleException(TransportException exp) {\n+                        unregisterChildNode.close();\n+                        delegate.handleException(exp);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjY5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399972699", "bodyText": "assert that cancelFuture.isDone == false before disabling blocks?", "author": "ywelsch", "createdAt": "2020-03-30T07:15:45Z", "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java", "diffHunk": "@@ -151,8 +151,9 @@ public void testCancellationDuringQueryPhase() throws Exception {\n             .execute();\n \n         awaitForBlock(plugins);\n-        cancelSearch(SearchAction.NAME);\n+        ActionFuture<CancelTasksResponse> cancelFuture = cancelSearch(SearchAction.NAME);\n         disableBlocks(plugins);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MzczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399973735", "bodyText": "testBanOnly...", "author": "ywelsch", "createdAt": "2020-03-30T07:18:01Z", "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.cluster.node.tasks;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionRunnable;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksResponse;\n+import org.elasticsearch.action.admin.cluster.node.tasks.list.ListTasksResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.plugins.ActionPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.tasks.CancellableTask;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskCancelledException;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.tasks.TaskManager;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportResponse;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class CancellableTasksIT extends ESIntegTestCase {\n+    static final Map<ChildRequest, CountDownLatch> arrivedLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> beforeExecuteLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> completedLatches = ConcurrentCollections.newConcurrentMap();\n+\n+    @Before\n+    public void resetTestStates() {\n+        arrivedLatches.clear();\n+        beforeExecuteLatches.clear();\n+        completedLatches.clear();\n+    }\n+\n+    public void testBandOnlyNodesWithOutstandingChildTasks() throws Exception {", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de680fc95020558a8889ca59bc89dcd2ea6537cb", "url": "https://github.com/elastic/elasticsearch/commit/de680fc95020558a8889ca59bc89dcd2ea6537cb", "message": "fix tests", "committedDate": "2020-03-30T12:52:25Z", "type": "commit"}, {"oid": "03ce7a816e1b89712ebd4057d3550646c315af2e", "url": "https://github.com/elastic/elasticsearch/commit/03ce7a816e1b89712ebd4057d3550646c315af2e", "message": "fix logging", "committedDate": "2020-03-30T13:00:14Z", "type": "commit"}, {"oid": "297b78726aeb4c7cae96db54e98903174745fd0b", "url": "https://github.com/elastic/elasticsearch/commit/297b78726aeb4c7cae96db54e98903174745fd0b", "message": "restore optimization", "committedDate": "2020-03-30T14:12:49Z", "type": "commit"}, {"oid": "226a5414320e8e4f725a1762e2226af6731a906a", "url": "https://github.com/elastic/elasticsearch/commit/226a5414320e8e4f725a1762e2226af6731a906a", "message": "ban children", "committedDate": "2020-03-30T14:48:48Z", "type": "commit"}, {"oid": "a5af596d79d4c663cb711f60f0f1011ad22b32d0", "url": "https://github.com/elastic/elasticsearch/commit/a5af596d79d4c663cb711f60f0f1011ad22b32d0", "message": "add wait_for_completion", "committedDate": "2020-03-30T18:31:12Z", "type": "commit"}, {"oid": "ff31a93604b5fe267e04a1b3bda5f06223df755d", "url": "https://github.com/elastic/elasticsearch/commit/ff31a93604b5fe267e04a1b3bda5f06223df755d", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-30T18:36:21Z", "type": "commit"}, {"oid": "4f337decce08edd355621c9982559df34bc42ce6", "url": "https://github.com/elastic/elasticsearch/commit/4f337decce08edd355621c9982559df34bc42ce6", "message": "Add TODO", "committedDate": "2020-03-30T18:49:13Z", "type": "commit"}, {"oid": "627e6a498a25618ffd8e7d0bc534f2d4ff4cf8db", "url": "https://github.com/elastic/elasticsearch/commit/627e6a498a25618ffd8e7d0bc534f2d4ff4cf8db", "message": "format", "committedDate": "2020-03-30T18:55:44Z", "type": "commit"}, {"oid": "4abd0f54c7d799ce19b9ff9161fa664e1a176f8b", "url": "https://github.com/elastic/elasticsearch/commit/4abd0f54c7d799ce19b9ff9161fa664e1a176f8b", "message": "wait_for_completion -> wait_for_child_tasks", "committedDate": "2020-03-30T21:33:15Z", "type": "commit"}, {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "url": "https://github.com/elastic/elasticsearch/commit/e6a8b7c79b07cb841b041f2acae26df113e6c068", "message": "comment", "committedDate": "2020-03-30T21:35:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400715280", "bodyText": "I wonder if this message is misleading. The task could have been cancelled, but it could also have completed successfully before this request came in.", "author": "ywelsch", "createdAt": "2020-03-31T08:00:13Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716543", "bodyText": "Another issue I have with this is that this does not play nicely with wait_for_completion. Assume someone else has cancelled the task, and you now want to wait for completion. This gives you a hard exception instead of waiting for all child tasks to complete.", "author": "ywelsch", "createdAt": "2020-03-31T08:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg5NDQ3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400894473", "bodyText": "Another issue I have with this is that this does not play nicely with wait_for_completion. Assume someone else has cancelled the task, and you now want to wait for completion. This gives you a hard exception instead of waiting for all child tasks to complete.\n\nI thought about that scenario but decided not to implement it as I worried about its complexity (we need to keep track of a list of cancellation listeners and childTasksCompleted listeners). Anyway, I will work on it.", "author": "dnhatn", "createdAt": "2020-03-31T13:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkwMDA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400900079", "bodyText": "Let's add a TODO for that part, and consider it in a follow-up", "author": "ywelsch", "createdAt": "2020-03-31T13:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDgzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401184839", "bodyText": "The cancel() method is a bit trappy. I have removed the return value and made it idempotent in 9a55fe4.", "author": "dnhatn", "createdAt": "2020-03-31T20:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjk2MA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716960", "bodyText": "basis", "author": "ywelsch", "createdAt": "2020-03-31T08:03:02Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n             }\n-        }  else {\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(),\n+            StepListener<Void> banOnNodesListener = new StepListener<>();\n+            setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n+            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n+            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basic.", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401175629", "bodyText": "thanks, fixed in a01325e", "author": "dnhatn", "createdAt": "2020-03-31T19:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MTA4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400861083", "bodyText": "shouldn't we get the default value from the cancelTasksRequest so we don't duplicate it?", "author": "javanna", "createdAt": "2020-03-31T12:10:12Z", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,7 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForChildTasks(request.paramAsBoolean(\"wait_for_child_tasks\", true));", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401175991", "bodyText": "yes, fixed in 8cff3b0.", "author": "dnhatn", "createdAt": "2020-03-31T19:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MTA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2NDUyOA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400864528", "bodyText": "I am curious about this: the child tasks are already cancelled or banned before the delete async search call returns?", "author": "javanna", "createdAt": "2020-03-31T12:16:15Z", "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java", "diffHunk": "@@ -190,8 +193,11 @@ public void testDeleteCancelRunningTask() throws Exception {\n         SearchResponseIterator it =\n             assertBlockingIterator(indexName, new SearchSourceBuilder(), randomBoolean() ? 1 : 0, 2);\n         initial = it.next();\n-        deleteAsyncSearch(initial.getId());\n+        ActionFuture<AcknowledgedResponse> cancelFuture =\n+            client().execute(DeleteAsyncSearchAction.INSTANCE, new DeleteAsyncSearchAction.Request(initial.getId()));\n+        ensureChildTasksCancelledOrBanned(AsyncSearchId.decode(initial.getId()).getTaskId());", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401177133", "bodyText": "Yes, but this is an async call. Anyway, I've reverted this change as wait_for_completion now defaults to false.", "author": "dnhatn", "createdAt": "2020-03-31T19:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2NDUyOA=="}], "type": "inlineReview"}, {"oid": "9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "url": "https://github.com/elastic/elasticsearch/commit/9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "message": "Allow cancel multiple times", "committedDate": "2020-03-31T18:26:03Z", "type": "commit"}, {"oid": "a01325e069ff433165a0bdbc0da2854da8db729e", "url": "https://github.com/elastic/elasticsearch/commit/a01325e069ff433165a0bdbc0da2854da8db729e", "message": "wording", "committedDate": "2020-03-31T18:26:03Z", "type": "commit"}, {"oid": "8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "url": "https://github.com/elastic/elasticsearch/commit/8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "message": "wait_for_completion to false", "committedDate": "2020-03-31T19:44:28Z", "type": "commit"}, {"oid": "b07d962385bea4ab2acc0afa887e2952baf3e44d", "url": "https://github.com/elastic/elasticsearch/commit/b07d962385bea4ab2acc0afa887e2952baf3e44d", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-31T19:44:41Z", "type": "commit"}, {"oid": "76f8fd128407aee9e3d7d99eaf7e89c55646bb8d", "url": "https://github.com/elastic/elasticsearch/commit/76f8fd128407aee9e3d7d99eaf7e89c55646bb8d", "message": "allow mock", "committedDate": "2020-03-31T20:17:36Z", "type": "commit"}, {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "url": "https://github.com/elastic/elasticsearch/commit/4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "message": "fix docs", "committedDate": "2020-03-31T22:02:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401463562", "bodyText": "Use this in TasksRequestConvertersTests?", "author": "ywelsch", "createdAt": "2020-04-01T09:05:11Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/tasks/CancelTasksRequest.java", "diffHunk": "@@ -138,13 +150,21 @@ public Builder withNodesFiltered(List<String> nodes){\n             return this;\n         }\n \n+        public Builder withWaitForCompletion(boolean waitForCompletion) {", "originalCommit": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3OTU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401479596", "bodyText": "As well as in TasksClientDocumentationIT to document it there as well?", "author": "ywelsch", "createdAt": "2020-04-01T09:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465335", "bodyText": "call this getWaitForCompletion", "author": "ywelsch", "createdAt": "2020-04-01T09:08:11Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java", "diffHunk": "@@ -68,4 +77,16 @@ public CancelTasksRequest setReason(String reason) {\n     public String getReason() {\n         return reason;\n     }\n+\n+    /**\n+     * If {@code true}, the request blocks until the cancellation of the task and its child tasks is completed.\n+     * Otherwise, the request can return soon after the cancellation is started. Defaults to {@code false}.\n+     */\n+    public void setWaitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    public boolean waitForChildTasks() {", "originalCommit": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTQ2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465468", "bodyText": "instead of introducing this constant, just use cancelTasksRequest.getWaitForCompletion() here", "author": "ywelsch", "createdAt": "2020-04-01T09:08:26Z", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,8 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForCompletion(\n+            request.paramAsBoolean(\"wait_for_child_tasks\", CancelTasksRequest.DEFAULT_WAIT_FOR_COMPLETION));", "originalCommit": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "url": "https://github.com/elastic/elasticsearch/commit/2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "message": "nits", "committedDate": "2020-04-01T13:18:46Z", "type": "commit"}]}