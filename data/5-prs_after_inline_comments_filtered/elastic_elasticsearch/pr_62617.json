{"pr_number": 62617, "pr_title": "Prepare Snapshot Shard State Update Logic For Clone Logic", "pr_createdAt": "2020-09-18T10:22:32Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62617", "timeline": [{"oid": "555159f9a06a3a5e4ac7dc7ce23664cbaf58dabf", "url": "https://github.com/elastic/elasticsearch/commit/555159f9a06a3a5e4ac7dc7ce23664cbaf58dabf", "message": "Prepare Snapshot Shard State Update Logic For Clone Logic\n\nSmall refactoring to shorten the diff with the clone logic in #61839:\n\n* Since clones will create a different kind of shard state update that\nisn't the same request sent by the snapshot shards service (and cannot be\nthe same request because we have no `ShardId`) base the shard state updates\non a different class that can be extended to be general enough to accomodate\nshard clones as well.\n* Make the update executor a singleton (can't make it an inline lambda as that\nwould break CS update batching because the executor is used as a map key but\nthis change still makes it crystal clear that there's no internal state to the\nexecutor)\n* Make shard state update responses a singleton (can't use TransportResponse.Empty because\nwe need an action response but still it makes it clear that there's no actual\nresponse with content here)", "committedDate": "2020-09-18T10:14:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg1MDcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62617#discussion_r490850706", "bodyText": "Note for review: there's no logical changes here whatsoever, just indent changes and the type change for the tasks.", "author": "original-brownbear", "createdAt": "2020-09-18T10:23:24Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1909,101 +1908,130 @@ public boolean assertAllListenersResolved() {\n         return true;\n     }\n \n-    private static class SnapshotStateExecutor implements ClusterStateTaskExecutor<UpdateIndexShardSnapshotStatusRequest> {\n-\n-        @Override\n-        public ClusterTasksResult<UpdateIndexShardSnapshotStatusRequest>\n-                        execute(ClusterState currentState, List<UpdateIndexShardSnapshotStatusRequest> tasks) {\n-            int changedCount = 0;\n-            int startedCount = 0;\n-            final List<SnapshotsInProgress.Entry> entries = new ArrayList<>();\n-            // Tasks to check for updates for running snapshots.\n-            final List<UpdateIndexShardSnapshotStatusRequest> unconsumedTasks = new ArrayList<>(tasks);\n-            // Tasks that were used to complete an existing in-progress shard snapshot\n-            final Set<UpdateIndexShardSnapshotStatusRequest> executedTasks = new HashSet<>();\n-            for (SnapshotsInProgress.Entry entry : currentState.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries()) {\n-                if (entry.state().completed()) {\n-                    entries.add(entry);\n+    private static final ClusterStateTaskExecutor<ShardSnapshotUpdate> SHARD_STATE_EXECUTOR = (currentState, tasks) -> {\n+        int changedCount = 0;", "originalCommit": "555159f9a06a3a5e4ac7dc7ce23664cbaf58dabf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}