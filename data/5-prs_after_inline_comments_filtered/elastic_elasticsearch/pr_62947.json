{"pr_number": 62947, "pr_title": "Introduce async search status API", "pr_createdAt": "2020-09-28T11:14:52Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62947", "timeline": [{"oid": "5a9b42b0ed8f80ae37790b7cf7bcd9ccfd4ba9ea", "url": "https://github.com/elastic/elasticsearch/commit/5a9b42b0ed8f80ae37790b7cf7bcd9ccfd4ba9ea", "message": "Async search status\n\nIntroduce async search status API\n\nGET /_async_search/status/<id>\n\nThe API is restricted to the monitoring_user role.\n\nFor a running async search, the response is:\n\n```js\n{\n  \"id\" : <id>,\n  \"is_running\" : true,\n  \"start_time_in_millis\" : 1583945890986,\n  \"expiration_time_in_millis\" : 1584377890986,\n  \"_shards\" : {\n      \"total\" : 562,\n      \"successful\" : 188,\n      \"skipped\" : 0,\n      \"failed\" : 0\n  }\n}\n```\n\nFor a completed async search, the response is:\n\n```js\n{\n  \"id\" : <id>\n  \"is_running\" : false,\n  \"expiration_time_in_millis\" : 1584377890986\n}\n```\n\n----\nTechincal details:\nWe first try to retrieve the status of the async search from tasks.\nIf this doesn't succeed, we retrieve it from an index: .async-search.\nIn case of retrieving from the index, we assume that the async search is\ncompleted, and a shorter response for the status is returned.\n\nCloses #57537", "committedDate": "2020-09-28T14:23:56Z", "type": "forcePushed"}, {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682", "url": "https://github.com/elastic/elasticsearch/commit/faafd18b22a60bdd3d56a9c57dee464969d01682", "message": "Async search status\n\nIntroduce async search status API\n\nGET /_async_search/status/<id>\n\nThe API is restricted to the monitoring_user role.\n\nFor a running async search, the response is:\n\n```js\n{\n  \"id\" : <id>,\n  \"is_running\" : true,\n  \"start_time_in_millis\" : 1583945890986,\n  \"expiration_time_in_millis\" : 1584377890986,\n  \"_shards\" : {\n      \"total\" : 562,\n      \"successful\" : 188,\n      \"skipped\" : 0,\n      \"failed\" : 0\n  }\n}\n```\n\nFor a completed async search, the response is:\n\n```js\n{\n  \"id\" : <id>\n  \"is_running\" : false,\n  \"expiration_time_in_millis\" : 1584377890986\n}\n```\n\n----\nTechincal details:\nWe first try to retrieve the status of the async search from tasks.\nIf this doesn't succeed, we retrieve it from an index: .async-search.\nIn case of retrieving from the index, we assume that the async search is\ncompleted, and a shorter response for the status is returned.\n\nCloses #57537", "committedDate": "2020-09-28T15:49:55Z", "type": "commit"}, {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682", "url": "https://github.com/elastic/elasticsearch/commit/faafd18b22a60bdd3d56a9c57dee464969d01682", "message": "Async search status\n\nIntroduce async search status API\n\nGET /_async_search/status/<id>\n\nThe API is restricted to the monitoring_user role.\n\nFor a running async search, the response is:\n\n```js\n{\n  \"id\" : <id>,\n  \"is_running\" : true,\n  \"start_time_in_millis\" : 1583945890986,\n  \"expiration_time_in_millis\" : 1584377890986,\n  \"_shards\" : {\n      \"total\" : 562,\n      \"successful\" : 188,\n      \"skipped\" : 0,\n      \"failed\" : 0\n  }\n}\n```\n\nFor a completed async search, the response is:\n\n```js\n{\n  \"id\" : <id>\n  \"is_running\" : false,\n  \"expiration_time_in_millis\" : 1584377890986\n}\n```\n\n----\nTechincal details:\nWe first try to retrieve the status of the async search from tasks.\nIf this doesn't succeed, we retrieve it from an index: .async-search.\nIn case of retrieving from the index, we assume that the async search is\ncompleted, and a shorter response for the status is returned.\n\nCloses #57537", "committedDate": "2020-09-28T15:49:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508407609", "bodyText": "This method should be synchronized.", "author": "jimczi", "createdAt": "2020-10-20T11:00:59Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,32 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+    AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {", "originalCommit": "faafd18b22a60bdd3d56a9c57dee464969d01682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2ODc1OA==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512168758", "bodyText": "Thanks Jim, good comment. I have made some variables volatile and I believe it doesn't need synchronization any more.", "author": "mayya-sharipova", "createdAt": "2020-10-26T18:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzk4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508407981", "bodyText": "We still need the number of shards, start time, ... I don't understand why the status would be reseted to 0 when the search is done ?", "author": "jimczi", "createdAt": "2020-10-20T11:01:43Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,32 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+    AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {\n+        if (frozen == false) {\n+            return new AsyncStatusResponse(\n+                asyncExecutionId,\n+                startTime,\n+                expirationTime,\n+                finalResponse != null ? finalResponse.getTotalShards() : totalShards,\n+                finalResponse != null ? finalResponse.getSuccessfulShards() : successfulShards,\n+                finalResponse != null ? finalResponse.getSkippedShards() : skippedShards,\n+                finalResponse != null ? (finalResponse.getShardFailures() == null ? finalResponse.getShardFailures().length : 0) :\n+                    (queryFailures != null ? queryFailures.length() : 0)\n+            );\n+        } else {\n+            return getCompletedSearchStatusResponse(asyncExecutionId, expirationTime);", "originalCommit": "faafd18b22a60bdd3d56a9c57dee464969d01682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwODQ0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508408448", "bodyText": "So I think you don't need to check frozen and just build the status from the finalResponse if it's available and from the partial stats otherwise.", "author": "jimczi", "createdAt": "2020-10-20T11:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2OTIxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512169215", "bodyText": "addressed in 0775cf1 with the new format for a completed status.", "author": "mayya-sharipova", "createdAt": "2020-10-26T18:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwOTQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508409453", "bodyText": "Can you add an option on getTask instead to enable/disable the authentication  check ?", "author": "jimczi", "createdAt": "2020-10-20T11:04:21Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "diffHunk": "@@ -252,6 +253,23 @@ public void deleteResponse(AsyncExecutionId asyncExecutionId,\n         return asyncTask;\n     }\n \n+    /**\n+     * Returns the {@link AsyncTask} if the provided <code>asyncTaskId</code>\n+     * is registered in the task manager, <code>null</code> otherwise.\n+     *\n+     */\n+    <T extends AsyncTask> T getTaskStatus(TaskManager taskManager, AsyncExecutionId asyncExecutionId, Class<T> tClass) {", "originalCommit": "faafd18b22a60bdd3d56a9c57dee464969d01682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MTI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512171272", "bodyText": "Thanks for the comment, @jimczi .  I have talked to @albertzaharovits about this sometime ago, and he suggested me from a security point of view to use a separate method instead of adding a parameter to enable/disable authentication.\nI ended up  moving the logic of this method to TransportGetAsyncStatusAction in order to avoid parametrized function arguments.", "author": "mayya-sharipova", "createdAt": "2020-10-26T18:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwOTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMTk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508411966", "bodyText": "Can we reuse getEncodedResponse ? We'd need to disable the authentication check but that can be an option on the function directly ?", "author": "jimczi", "createdAt": "2020-10-20T11:08:41Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "diffHunk": "@@ -307,6 +325,35 @@ public void getResponse(AsyncExecutionId asyncExecutionId,\n         ));\n     }\n \n+\n+    /**\n+     * Gets the status response of the async search from the index.\n+     * This should be called after unsuccessful attempt to retrieve a status from the Task Manager.\n+     * As the corresponding task doest' exist, we assume that the async search request\n+     * has been completed, and for a status response we are only interested in its expiration time.\n+     * @param asyncExecutionId \u2013 id of the async search\n+     * @param completedStatusProducer \u2013 a producer of the status response of the completed async task,\n+     *   where necessary fields are only id and expiration time.\n+     * @param listener \u2013 listener to report result to\n+     */\n+    public void getStatusResponse(\n+        AsyncExecutionId asyncExecutionId, BiFunction<String, Long, R> completedStatusProducer, ActionListener<R> listener) {", "originalCommit": "faafd18b22a60bdd3d56a9c57dee464969d01682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MjI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512172296", "bodyText": "Similarly to a previous comment, I opted out to have a separate method for this .  Please let me know if we still want to have a single method.", "author": "mayya-sharipova", "createdAt": "2020-10-26T18:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMTk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMjU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508412543", "bodyText": "Why would we set the stats to 0 on a completed search ? That seems wrong to me.", "author": "jimczi", "createdAt": "2020-10-20T11:09:43Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+import org.elasticsearch.xpack.core.async.AsyncResponse;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject, AsyncResponse<AsyncStatusResponse> {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+\n+    private AsyncStatusResponse(String id,\n+            boolean isRunning,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards) {\n+        this.id = id;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+        this.totalShards = totalShards;\n+        this.successfulShards = successfulShards;\n+        this.skippedShards = skippedShards;\n+        this.failedShards = failedShards;\n+    }\n+\n+    /**\n+     * Creates a new {@link AsyncStatusResponse} for a running search.\n+     *\n+     * @param id The id of the async search.\n+     * @param startTimeMillis The start date of the search in milliseconds since epoch.\n+     * @param expirationTimeMillis The expiration date of the search in milliseconds since epoch.\n+     * @param totalShards The total number of shards the request search is executed on\n+     * @param successfulShards The number of shards the request is completed on\n+     * @param skippedShards The number of skipped shards\n+     * @param failedShards The number of shards that failed to executed the request\n+     */\n+    public AsyncStatusResponse(String id,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards) {\n+        this(id, true, startTimeMillis, expirationTimeMillis, totalShards, successfulShards, skippedShards, failedShards);\n+    }\n+\n+    /**\n+     * Creates a new {@link AsyncStatusResponse} for a completed search.\n+     *\n+     * @param id The id of the async search.\n+     * @param expirationTimeMillis \u2013 expiration time in milliseconds\n+     * @return status of the completed async search\n+     */\n+    public static AsyncStatusResponse getCompletedSearchStatusResponse(String id, long expirationTimeMillis) {\n+        return new AsyncStatusResponse(id, false, 0, expirationTimeMillis, 0, 0, 0, 0);", "originalCommit": "faafd18b22a60bdd3d56a9c57dee464969d01682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MjgxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512172815", "bodyText": "addressed in 0775cf1", "author": "mayya-sharipova", "createdAt": "2020-10-26T18:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMjU0Mw=="}], "type": "inlineReview"}, {"oid": "6e384274882d587f9751c499fc957288088a1a47", "url": "https://github.com/elastic/elasticsearch/commit/6e384274882d587f9751c499fc957288088a1a47", "message": "Merge remote-tracking branch 'upstream/master' into async-metadata", "committedDate": "2020-10-21T13:37:16Z", "type": "commit"}, {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19", "url": "https://github.com/elastic/elasticsearch/commit/0775cf12e54c2e97c263e051467a611c3188ea19", "message": "Address feedback", "committedDate": "2020-10-26T18:01:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2MjA2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513262062", "bodyText": "I still think that this method should be synchronized. We need to ensure that the stats (failures, ...) are correct since they are attached to the response. Adding volatile is ok but these variables are connected so have to synchronize the access to them.", "author": "jimczi", "createdAt": "2020-10-28T08:35:35Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,58 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+     AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {", "originalCommit": "0775cf12e54c2e97c263e051467a611c3188ea19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NjczNg==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513266736", "bodyText": "I think we can return the status for partial response too ?", "author": "jimczi", "createdAt": "2020-10-28T08:43:45Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+    private final RestStatus completionStatus;", "originalCommit": "0775cf12e54c2e97c263e051467a611c3188ea19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NzAwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513267005", "bodyText": "I'd prefer that we always return  a  status even for partial responses.", "author": "jimczi", "createdAt": "2020-10-28T08:44:10Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+    private final RestStatus completionStatus;\n+\n+    public AsyncStatusResponse(String id,\n+            boolean isRunning,\n+            boolean isPartial,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards,\n+            RestStatus completionStatus) {\n+        this.id = id;\n+        this.isRunning = isRunning;\n+        this.isPartial = isPartial;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+        this.totalShards = totalShards;\n+        this.successfulShards = successfulShards;\n+        this.skippedShards = skippedShards;\n+        this.failedShards = failedShards;\n+        this.completionStatus = completionStatus;\n+    }\n+\n+    public static AsyncStatusResponse getStatusFromAsyncSearchResponseWithExpirationTime(AsyncSearchResponse asyncSearchResponse,\n+            long expirationTimeMillis) {\n+        int totalShards = 0;\n+        int successfulShards = 0;\n+        int skippedShards = 0;\n+        int failedShards = 0;\n+        RestStatus completionStatus = null;\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        if (searchResponse != null) {\n+            totalShards = searchResponse.getTotalShards();\n+            successfulShards = searchResponse.getSuccessfulShards();\n+            skippedShards = searchResponse.getSkippedShards();\n+            failedShards = searchResponse.getFailedShards();\n+        }\n+        if (asyncSearchResponse.isRunning() == false) {\n+            if (searchResponse != null) {\n+                completionStatus = searchResponse.status();\n+            } else {\n+                Exception failure = asyncSearchResponse.getFailure();\n+                if (failure != null) {\n+                    completionStatus = ExceptionsHelper.status(ExceptionsHelper.unwrapCause(failure));\n+                }\n+            }\n+        }\n+        return new AsyncStatusResponse(\n+            asyncSearchResponse.getId(),\n+            asyncSearchResponse.isRunning(),\n+            asyncSearchResponse.isPartial(),\n+            asyncSearchResponse.getStartTime(),\n+            expirationTimeMillis,\n+            totalShards,\n+            successfulShards,\n+            skippedShards,\n+            failedShards,\n+            completionStatus\n+        );\n+    }\n+\n+    public AsyncStatusResponse(StreamInput in) throws IOException {\n+        this.id = in.readString();\n+        this.isRunning = in.readBoolean();\n+        this.isPartial = in.readBoolean();\n+        this.startTimeMillis = in.readLong();\n+        this.expirationTimeMillis = in.readLong();\n+        this.totalShards = in.readVInt();\n+        this.successfulShards = in.readVInt();\n+        this.skippedShards = in.readVInt();\n+        this.failedShards = in.readVInt();\n+        this.completionStatus = (this.isRunning == false) ? RestStatus.readFrom(in) : null;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(id);\n+        out.writeBoolean(isRunning);\n+        out.writeBoolean(isPartial);\n+        out.writeLong(startTimeMillis);\n+        out.writeLong(expirationTimeMillis);\n+        out.writeVInt(totalShards);\n+        out.writeVInt(successfulShards);\n+        out.writeVInt(skippedShards);\n+        out.writeVInt(failedShards);\n+        if (isRunning == false) {\n+            RestStatus.writeTo(out, completionStatus);\n+        }\n+    }\n+\n+    @Override\n+    public RestStatus status() {\n+        return OK;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(\"id\", id);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.timeField(\"start_time_in_millis\", \"start_time\", startTimeMillis);\n+        builder.timeField(\"expiration_time_in_millis\", \"expiration_time\", expirationTimeMillis);\n+        RestActions.buildBroadcastShardsHeader(builder, params, totalShards, successfulShards, skippedShards, failedShards, null);\n+        if (isRunning == false) { // completion status information is only available for a completed search", "originalCommit": "0775cf12e54c2e97c263e051467a611c3188ea19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMzY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513703667", "bodyText": "@jimczi Thanks for the comment. I am wondering how to define the status of a partial response?\nFor a completed response, we returned a failure status only if we end up with successfulShards = 0.\nFor a partial response we may  have successfulShards=0 simply because we haven't received yet a response from a successful shard.\nFor a partial response, we can have a different algorithm for deriving a status only looking at the presence or absence of failures, but this could be a different status response from a completed search.  For example, for a partial response we may have successfulShards=0, queryFailures.length>0 and return 400; but then when the search is completed we may have successfulShards=1, queryFailures.length>0  and based on completed response, return 200.\nThus, I would suggest not to return the status for a partial response. WDYT?", "author": "mayya-sharipova", "createdAt": "2020-10-28T19:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NzAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NDQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r515194479", "bodyText": "Yes the discrepancy would be weird and since we return 200 if there's at least one successful shards I agree that we should expose the status only when the search has completed.", "author": "jimczi", "createdAt": "2020-10-30T15:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NzAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2ODAzMA==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513268030", "bodyText": "I don't think we should check the cancellation here, if the task is present, we should return the status.", "author": "jimczi", "createdAt": "2020-10-28T08:45:56Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncStatusAction.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.search;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionListenerResponseHandler;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportRequestOptions;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.async.AsyncExecutionId;\n+import org.elasticsearch.xpack.core.async.AsyncTask;\n+import org.elasticsearch.xpack.core.async.AsyncTaskIndexService;\n+import org.elasticsearch.xpack.core.async.GetAsyncStatusRequest;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.AsyncStatusResponse;\n+import org.elasticsearch.xpack.core.search.action.GetAsyncStatusAction;\n+\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ClientHelper.ASYNC_SEARCH_ORIGIN;\n+\n+public class TransportGetAsyncStatusAction extends HandledTransportAction<GetAsyncStatusRequest, AsyncStatusResponse> {\n+    private final TransportService transportService;\n+    private final ClusterService clusterService;\n+    private final AsyncTaskIndexService<AsyncSearchResponse> store;\n+\n+    @Inject\n+    public TransportGetAsyncStatusAction(TransportService transportService,\n+             ActionFilters actionFilters,\n+             ClusterService clusterService,\n+             NamedWriteableRegistry registry,\n+             Client client,\n+             ThreadPool threadPool) {\n+        super(GetAsyncStatusAction.NAME, transportService, actionFilters, GetAsyncStatusRequest::new);\n+        this.transportService = transportService;\n+        this.clusterService = clusterService;\n+        this.store = new AsyncTaskIndexService<>(XPackPlugin.ASYNC_RESULTS_INDEX, clusterService,\n+            threadPool.getThreadContext(), client, ASYNC_SEARCH_ORIGIN, AsyncSearchResponse::new, registry);\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GetAsyncStatusRequest request, ActionListener<AsyncStatusResponse> listener) {\n+        AsyncExecutionId searchId = AsyncExecutionId.decode(request.getId());\n+        DiscoveryNode node = clusterService.state().nodes().get(searchId.getTaskId().getNodeId());\n+        if (node == null || Objects.equals(node, clusterService.localNode())) {\n+            retrieveStatus(request, listener);\n+        } else {\n+            TransportRequestOptions.Builder builder = TransportRequestOptions.builder();\n+            transportService.sendRequest(node, GetAsyncStatusAction.NAME, request, builder.build(),\n+                new ActionListenerResponseHandler<>(listener, AsyncStatusResponse::new, ThreadPool.Names.SAME));\n+        }\n+    }\n+\n+    private void retrieveStatus(GetAsyncStatusRequest request, ActionListener<AsyncStatusResponse> listener) {\n+        long nowInMillis = System.currentTimeMillis();\n+        AsyncExecutionId searchId = AsyncExecutionId.decode(request.getId());\n+        try {\n+            AsyncTask task = (AsyncTask) taskManager.getTask(searchId.getTaskId().getId());\n+            if ((task instanceof AsyncSearchTask) && (task.getExecutionId().equals(searchId))) {\n+                if (task.isCancelled()) {", "originalCommit": "0775cf12e54c2e97c263e051467a611c3188ea19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1e427d574946a87ee33391d6db830230df2a3b52", "url": "https://github.com/elastic/elasticsearch/commit/1e427d574946a87ee33391d6db830230df2a3b52", "message": "Address feedback 2", "committedDate": "2020-10-28T19:39:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NzMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r515197329", "bodyText": "nit:  you can do return queryFailures.asList().size() ?", "author": "jimczi", "createdAt": "2020-10-30T15:48:12Z", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -213,4 +268,17 @@ private void failIfFrozen() {\n         }\n         return failures.toArray(ShardSearchFailure[]::new);\n     }\n+\n+    private int getQueryFailuresCount() {\n+        if (queryFailures == null) {\n+            return 0;\n+        }\n+        int count = 0;", "originalCommit": "1e427d574946a87ee33391d6db830230df2a3b52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NjY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r516066694", "bodyText": "@jimczi Thanks for the suggestion. It seems that asList() method creates a additional list object. Instead, in 39dafa9, I've added AtomicArray::nonNullLength method.", "author": "mayya-sharipova", "createdAt": "2020-11-02T15:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NzMyOQ=="}], "type": "inlineReview"}, {"oid": "25c45234b503f33d6882bb4be3e2e932542ff998", "url": "https://github.com/elastic/elasticsearch/commit/25c45234b503f33d6882bb4be3e2e932542ff998", "message": "Merge remote-tracking branch 'upstream/master' into async-metadata", "committedDate": "2020-11-02T15:09:58Z", "type": "commit"}, {"oid": "39dafa9b57306b2bccf3667a4dd4cebdfbec539b", "url": "https://github.com/elastic/elasticsearch/commit/39dafa9b57306b2bccf3667a4dd4cebdfbec539b", "message": "Add nonNullLength to AtomicArray", "committedDate": "2020-11-02T15:44:31Z", "type": "commit"}]}