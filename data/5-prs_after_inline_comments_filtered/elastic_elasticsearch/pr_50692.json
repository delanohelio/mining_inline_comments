{"pr_number": 50692, "pr_title": "Fix Snapshot Repository Corruption in Downgrade Scenarios", "pr_createdAt": "2020-01-07T04:21:22Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50692", "timeline": [{"oid": "edbff0fd726bd18bb14f92c7b00a83a5ef6fb5f5", "url": "https://github.com/elastic/elasticsearch/commit/edbff0fd726bd18bb14f92c7b00a83a5ef6fb5f5", "message": "start", "committedDate": "2020-01-06T12:55:26Z", "type": "commit"}, {"oid": "81c2228dd800492478b77b1112b6f3d2fa651223", "url": "https://github.com/elastic/elasticsearch/commit/81c2228dd800492478b77b1112b6f3d2fa651223", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-06T16:01:34Z", "type": "commit"}, {"oid": "a7306db7049a2ecadce23c59cd51f945d587b13a", "url": "https://github.com/elastic/elasticsearch/commit/a7306db7049a2ecadce23c59cd51f945d587b13a", "message": "works", "committedDate": "2020-01-06T18:05:32Z", "type": "commit"}, {"oid": "78907a1688cebb9cb1cad40cd7b99cafb8befa3b", "url": "https://github.com/elastic/elasticsearch/commit/78907a1688cebb9cb1cad40cd7b99cafb8befa3b", "message": "works", "committedDate": "2020-01-06T23:46:07Z", "type": "commit"}, {"oid": "ea223c98659431942650dd7314cf1d96b42c8a70", "url": "https://github.com/elastic/elasticsearch/commit/ea223c98659431942650dd7314cf1d96b42c8a70", "message": "works", "committedDate": "2020-01-06T23:52:21Z", "type": "commit"}, {"oid": "e9832b04d3907326be5c4e6faa051bfe2763e55a", "url": "https://github.com/elastic/elasticsearch/commit/e9832b04d3907326be5c4e6faa051bfe2763e55a", "message": "reproduces at last", "committedDate": "2020-01-07T03:25:39Z", "type": "commit"}, {"oid": "74ce345182d07d01522b9835706b90676168c1b9", "url": "https://github.com/elastic/elasticsearch/commit/74ce345182d07d01522b9835706b90676168c1b9", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-07T03:26:07Z", "type": "commit"}, {"oid": "b3497874d745e6586fc3e6074c64e775bd3feeba", "url": "https://github.com/elastic/elasticsearch/commit/b3497874d745e6586fc3e6074c64e775bd3feeba", "message": "fixed", "committedDate": "2020-01-07T03:47:28Z", "type": "commit"}, {"oid": "b61b8e9a67947a59af36cdc45b342119cea9ba33", "url": "https://github.com/elastic/elasticsearch/commit/b61b8e9a67947a59af36cdc45b342119cea9ba33", "message": "nicer", "committedDate": "2020-01-07T04:01:21Z", "type": "commit"}, {"oid": "3dbe0c4a8f5ce92bb25ee5f8dda2e156af7a996e", "url": "https://github.com/elastic/elasticsearch/commit/3dbe0c4a8f5ce92bb25ee5f8dda2e156af7a996e", "message": "add assertion", "committedDate": "2020-01-07T04:14:26Z", "type": "commit"}, {"oid": "f9249816281b2640e0af2e5443427483375fd025", "url": "https://github.com/elastic/elasticsearch/commit/f9249816281b2640e0af2e5443427483375fd025", "message": "add min version", "committedDate": "2020-01-07T04:36:00Z", "type": "commit"}, {"oid": "93c57769c24ea2dc0e18268fc6ccb5561803e7d9", "url": "https://github.com/elastic/elasticsearch/commit/93c57769c24ea2dc0e18268fc6ccb5561803e7d9", "message": "bck", "committedDate": "2020-01-07T06:55:37Z", "type": "commit"}, {"oid": "13ce331bcc6860ea3185c173453c8eef883ddcf8", "url": "https://github.com/elastic/elasticsearch/commit/13ce331bcc6860ea3185c173453c8eef883ddcf8", "message": "fix compile", "committedDate": "2020-01-07T07:17:53Z", "type": "commit"}, {"oid": "04702eb2061c0cdf0b60ca48fcbfbd397802184c", "url": "https://github.com/elastic/elasticsearch/commit/04702eb2061c0cdf0b60ca48fcbfbd397802184c", "message": "better efficiency", "committedDate": "2020-01-07T07:28:45Z", "type": "commit"}, {"oid": "8de5cad79b7dc3ad1aadb5ff0405d444eecae884", "url": "https://github.com/elastic/elasticsearch/commit/8de5cad79b7dc3ad1aadb5ff0405d444eecae884", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-07T11:05:55Z", "type": "commit"}, {"oid": "15bbc0498de7a654a569bb7af5b2f71c7c48aa72", "url": "https://github.com/elastic/elasticsearch/commit/15bbc0498de7a654a569bb7af5b2f71c7c48aa72", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-07T14:53:36Z", "type": "commit"}, {"oid": "3e7fef0dc6b031ff3c809da51086c379a090902c", "url": "https://github.com/elastic/elasticsearch/commit/3e7fef0dc6b031ff3c809da51086c379a090902c", "message": "need 2 steps ...", "committedDate": "2020-01-07T15:55:29Z", "type": "commit"}, {"oid": "4c0499970647f6ce74c3458223b6daac4c29ac26", "url": "https://github.com/elastic/elasticsearch/commit/4c0499970647f6ce74c3458223b6daac4c29ac26", "message": "document test", "committedDate": "2020-01-07T15:59:28Z", "type": "commit"}, {"oid": "cb509701350eb36654a9dac16e7fb62b3a5eb021", "url": "https://github.com/elastic/elasticsearch/commit/cb509701350eb36654a9dac16e7fb62b3a5eb021", "message": "drier", "committedDate": "2020-01-07T16:07:23Z", "type": "commit"}, {"oid": "5004dda3a0daec9f2ce04df12b05feab04802f8d", "url": "https://github.com/elastic/elasticsearch/commit/5004dda3a0daec9f2ce04df12b05feab04802f8d", "message": "drier", "committedDate": "2020-01-07T20:05:19Z", "type": "commit"}, {"oid": "33a3acdcb81dc0b22e2a6f52daec3a8663ea2944", "url": "https://github.com/elastic/elasticsearch/commit/33a3acdcb81dc0b22e2a6f52daec3a8663ea2944", "message": "drier", "committedDate": "2020-01-07T20:38:54Z", "type": "commit"}, {"oid": "f77ccd28d6fecebe0ec68668a6a8682a67b5a5b0", "url": "https://github.com/elastic/elasticsearch/commit/f77ccd28d6fecebe0ec68668a6a8682a67b5a5b0", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-07T20:39:10Z", "type": "commit"}, {"oid": "f7e65fce3e4800cc9da74e13c6e97869173577ab", "url": "https://github.com/elastic/elasticsearch/commit/f7e65fce3e4800cc9da74e13c6e97869173577ab", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-08T09:10:59Z", "type": "commit"}, {"oid": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "url": "https://github.com/elastic/elasticsearch/commit/72cfb1b8dbe85afe4976311e6a4fc84994298532", "message": "nicer", "committedDate": "2020-01-08T09:21:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3MzU1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364173555", "bodyText": "I think we should avoid the \"downgrade\" terminology (i.e. needs changes across the whole PR). This is not a downgrade in the classical sense. It is more of a \"revert to a previously good state\" scenario where, after a cluster was upgraded, we revert it back to a last good known state based on a backup.\nPerhaps we could frame these tests under the context of \"multi-version access to repo\"\nWe would have an old version cluster and a new version cluster.\nThere would be no \"upgrade\" in the classical sense.\nI would do the following:\nStep1: Add and write to repo on old cluster, then remove rep\nStep2: We add and write to repo on new cluster, then remove repo\nStep3: We add repo again and restore snapshot from step 1 on old cluster. We write a new snapshot, then remove repo\nStep4:  We add repo again and restore snapshots from step 1, step2, step3 on new cluster. We write a new snapshots and check if it can be restored.\nHave another test that does something similar, but instead of removing repo at the end of each step, remounts it as read-only, and uses same read-only repo in step+2 to restore.\nHave another test that only works in step1 and step2 and deletes all old snapshots in step2 and checks that snapshotting works as desired.", "author": "ywelsch", "createdAt": "2020-01-08T10:56:03Z", "path": "qa/snapshot-repository-downgrade/src/test/java/org/elasticsearch/upgrades/ClusterDowngradeIT.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Downgrade tests that verify that a snapshot repository is not getting corrupted and continues to function properly during cluster\n+ * downgrades. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start from a cluster in an old version: {@link TestStep#OLD}</li>\n+ *     <li>Upgrade the cluster to the current version: {@link TestStep#UPGRADED}</li>\n+ *     <li>Downgrade the cluster back to the old version: {@link TestStep#DOWNGRADED}</li>", "originalCommit": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NTA4OA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364175088", "bodyText": "perhaps these steps should just be abstractly named \"STEP1_OLD_CLUSTER, STEP2_NEW_CLUSTER, STEP3_OLD_CLUSTER, STEP4_NEW_CLUSTER\"", "author": "ywelsch", "createdAt": "2020-01-08T10:59:56Z", "path": "qa/snapshot-repository-downgrade/src/test/java/org/elasticsearch/upgrades/ClusterDowngradeIT.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Downgrade tests that verify that a snapshot repository is not getting corrupted and continues to function properly during cluster\n+ * downgrades. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start from a cluster in an old version: {@link TestStep#OLD}</li>\n+ *     <li>Upgrade the cluster to the current version: {@link TestStep#UPGRADED}</li>\n+ *     <li>Downgrade the cluster back to the old version: {@link TestStep#DOWNGRADED}</li>\n+ *     <li>Once again upgrade the cluster to the current version: {@link TestStep#RE_UPGRADED}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class ClusterDowngradeIT extends ESRestTestCase {\n+\n+    protected enum TestStep {\n+        OLD,\n+        UPGRADED,\n+        DOWNGRADED,\n+        RE_UPGRADED;", "originalCommit": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIyODc2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364228769", "bodyText": "Yea that sounds nicer :)", "author": "original-brownbear", "createdAt": "2020-01-08T13:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NTQzNw==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364175437", "bodyText": "do we need this?", "author": "ywelsch", "createdAt": "2020-01-08T11:00:50Z", "path": "qa/snapshot-repository-downgrade/src/test/java/org/elasticsearch/upgrades/ClusterDowngradeIT.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Downgrade tests that verify that a snapshot repository is not getting corrupted and continues to function properly during cluster\n+ * downgrades. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start from a cluster in an old version: {@link TestStep#OLD}</li>\n+ *     <li>Upgrade the cluster to the current version: {@link TestStep#UPGRADED}</li>\n+ *     <li>Downgrade the cluster back to the old version: {@link TestStep#DOWNGRADED}</li>\n+ *     <li>Once again upgrade the cluster to the current version: {@link TestStep#RE_UPGRADED}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class ClusterDowngradeIT extends ESRestTestCase {\n+\n+    protected enum TestStep {\n+        OLD,\n+        UPGRADED,\n+        DOWNGRADED,\n+        RE_UPGRADED;\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"old_cluster\":\n+                    return OLD;\n+                case \"upgraded_cluster\":\n+                    return UPGRADED;\n+                case \"downgraded_cluster\":\n+                    return DOWNGRADED;\n+                case \"re_upgraded_cluster\":\n+                    return RE_UPGRADED;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveIndicesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveTemplatesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterSettings() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveRollupJobsUponCompletion() {\n+        return true;", "originalCommit": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NTQ5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364175491", "bodyText": "do we need this?", "author": "ywelsch", "createdAt": "2020-01-08T11:00:58Z", "path": "qa/snapshot-repository-downgrade/src/test/java/org/elasticsearch/upgrades/ClusterDowngradeIT.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Downgrade tests that verify that a snapshot repository is not getting corrupted and continues to function properly during cluster\n+ * downgrades. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start from a cluster in an old version: {@link TestStep#OLD}</li>\n+ *     <li>Upgrade the cluster to the current version: {@link TestStep#UPGRADED}</li>\n+ *     <li>Downgrade the cluster back to the old version: {@link TestStep#DOWNGRADED}</li>\n+ *     <li>Once again upgrade the cluster to the current version: {@link TestStep#RE_UPGRADED}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class ClusterDowngradeIT extends ESRestTestCase {\n+\n+    protected enum TestStep {\n+        OLD,\n+        UPGRADED,\n+        DOWNGRADED,\n+        RE_UPGRADED;\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"old_cluster\":\n+                    return OLD;\n+                case \"upgraded_cluster\":\n+                    return UPGRADED;\n+                case \"downgraded_cluster\":\n+                    return DOWNGRADED;\n+                case \"re_upgraded_cluster\":\n+                    return RE_UPGRADED;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveIndicesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveTemplatesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterSettings() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveRollupJobsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveILMPoliciesUponCompletion() {\n+        return true;", "originalCommit": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NTU0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364175546", "bodyText": "do we need this?", "author": "ywelsch", "createdAt": "2020-01-08T11:01:07Z", "path": "qa/snapshot-repository-downgrade/src/test/java/org/elasticsearch/upgrades/ClusterDowngradeIT.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Downgrade tests that verify that a snapshot repository is not getting corrupted and continues to function properly during cluster\n+ * downgrades. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start from a cluster in an old version: {@link TestStep#OLD}</li>\n+ *     <li>Upgrade the cluster to the current version: {@link TestStep#UPGRADED}</li>\n+ *     <li>Downgrade the cluster back to the old version: {@link TestStep#DOWNGRADED}</li>\n+ *     <li>Once again upgrade the cluster to the current version: {@link TestStep#RE_UPGRADED}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class ClusterDowngradeIT extends ESRestTestCase {\n+\n+    protected enum TestStep {\n+        OLD,\n+        UPGRADED,\n+        DOWNGRADED,\n+        RE_UPGRADED;\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"old_cluster\":\n+                    return OLD;\n+                case \"upgraded_cluster\":\n+                    return UPGRADED;\n+                case \"downgraded_cluster\":\n+                    return DOWNGRADED;\n+                case \"re_upgraded_cluster\":\n+                    return RE_UPGRADED;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveIndicesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveTemplatesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterSettings() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveRollupJobsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveILMPoliciesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveSLMPoliciesUponCompletion() {\n+        return true;", "originalCommit": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIyODY4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364228687", "bodyText": "Nah I just blindly copy and pasted these, removed all but the repo and snapshot preserving now :)", "author": "original-brownbear", "createdAt": "2020-01-08T13:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NTU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE4MTg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364181841", "bodyText": "good idea. In my steps above, account for this as well", "author": "ywelsch", "createdAt": "2020-01-08T11:18:25Z", "path": "qa/snapshot-repository-downgrade/src/test/java/org/elasticsearch/upgrades/ClusterDowngradeIT.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Downgrade tests that verify that a snapshot repository is not getting corrupted and continues to function properly during cluster\n+ * downgrades. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start from a cluster in an old version: {@link TestStep#OLD}</li>\n+ *     <li>Upgrade the cluster to the current version: {@link TestStep#UPGRADED}</li>\n+ *     <li>Downgrade the cluster back to the old version: {@link TestStep#DOWNGRADED}</li>\n+ *     <li>Once again upgrade the cluster to the current version: {@link TestStep#RE_UPGRADED}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class ClusterDowngradeIT extends ESRestTestCase {\n+\n+    protected enum TestStep {\n+        OLD,\n+        UPGRADED,\n+        DOWNGRADED,\n+        RE_UPGRADED;\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"old_cluster\":\n+                    return OLD;\n+                case \"upgraded_cluster\":\n+                    return UPGRADED;\n+                case \"downgraded_cluster\":\n+                    return DOWNGRADED;\n+                case \"re_upgraded_cluster\":\n+                    return RE_UPGRADED;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveIndicesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveTemplatesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterSettings() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveRollupJobsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveILMPoliciesUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveSLMPoliciesUponCompletion() {\n+        return true;\n+    }\n+\n+    public void testCreateSnapshot() throws IOException {\n+        final String repoName = \"repo\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            if (TEST_STEP == TestStep.OLD || TEST_STEP == TestStep.DOWNGRADED) {\n+                createIndex(client, \"test-index\", shards);\n+                assertThat(client.snapshot().createRepository(new PutRepositoryRequest(repoName).type(\"fs\").settings(\n+                    Settings.builder().put(\"location\", \".\")), RequestOptions.DEFAULT).isAcknowledged(), is(true));\n+            }\n+            createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP.toString().toLowerCase(Locale.ROOT));\n+            final String snapshotToDeleteName = \"snapshot-to-delete\";\n+            // Create a snapshot and delete it right away again to test the impact of each version's cleanup functionality that is run", "originalCommit": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE4MzcwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364183709", "bodyText": "why do we need to convert to a list here? Why is Collection not good enough=?", "author": "ywelsch", "createdAt": "2020-01-08T11:23:30Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -351,6 +353,26 @@ public TimeValue timeout() {\n         }, listener::onFailure);\n     }\n \n+    public boolean hasOldVersionSnapshots(String repositoryName, RepositoryData repositoryData, @Nullable SnapshotId excluded) {\n+        final List<SnapshotId> snapshotIds = List.copyOf(repositoryData.getSnapshotIds());", "originalCommit": "72cfb1b8dbe85afe4976311e6a4fc84994298532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MDMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364190323", "bodyText": "My bad, this was a left-over from when I used an API that needed a List to get all the snapshot versions before :)", "author": "original-brownbear", "createdAt": "2020-01-08T11:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE4MzcwOQ=="}], "type": "inlineReview"}, {"oid": "bbb2b3d8942b4768e583f0823bda7f69de863dd3", "url": "https://github.com/elastic/elasticsearch/commit/bbb2b3d8942b4768e583f0823bda7f69de863dd3", "message": "CR: rename qa project", "committedDate": "2020-01-08T11:33:31Z", "type": "commit"}, {"oid": "1321106bad5462b06b14019ba63e0c624d35e17a", "url": "https://github.com/elastic/elasticsearch/commit/1321106bad5462b06b14019ba63e0c624d35e17a", "message": "CR: remove dead code", "committedDate": "2020-01-08T11:46:26Z", "type": "commit"}, {"oid": "2637126b9f73fd5a806f2069604cffdddfa2ec6d", "url": "https://github.com/elastic/elasticsearch/commit/2637126b9f73fd5a806f2069604cffdddfa2ec6d", "message": "CR: more tests and renaming", "committedDate": "2020-01-08T13:14:53Z", "type": "commit"}, {"oid": "cfe7254c9fbb199ccedfe331fdd37cd10b86cf31", "url": "https://github.com/elastic/elasticsearch/commit/cfe7254c9fbb199ccedfe331fdd37cd10b86cf31", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-08T13:15:48Z", "type": "commit"}, {"oid": "5df61002ba5a7a031f4f2ccd535d55be0ad6a094", "url": "https://github.com/elastic/elasticsearch/commit/5df61002ba5a7a031f4f2ccd535d55be0ad6a094", "message": "rename qa projct", "committedDate": "2020-01-08T13:25:35Z", "type": "commit"}, {"oid": "38de2a738c6b867384f2e66990a96f87d61cc475", "url": "https://github.com/elastic/elasticsearch/commit/38de2a738c6b867384f2e66990a96f87d61cc475", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-08T16:03:14Z", "type": "commit"}, {"oid": "cecf2d088e5c3ac398054cc6c0bd25ad18cb829e", "url": "https://github.com/elastic/elasticsearch/commit/cecf2d088e5c3ac398054cc6c0bd25ad18cb829e", "message": "only use 2 clusters", "committedDate": "2020-01-08T16:19:29Z", "type": "commit"}, {"oid": "cc6740e999e6eadb94eb316778019fff3e07238c", "url": "https://github.com/elastic/elasticsearch/commit/cc6740e999e6eadb94eb316778019fff3e07238c", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-08T16:20:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1MjkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364352902", "bodyText": "I'm confused by the terminology here. We're not starting a cluster again in step 3?", "author": "ywelsch", "createdAt": "2020-01-08T17:30:55Z", "path": "qa/repository-multi-version/src/test/java/org/elasticsearch/upgrades/MultiVersionRepositoryAccessIT.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Tests that verify that a snapshot repository is not getting corrupted and continues to function properly when accessed by multiple\n+ * clusters of different versions. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start a cluster in an old version: {@link TestStep#STEP1_OLD_CLUSTER}</li>\n+ *     <li>Start a cluster running the current version: {@link TestStep#STEP2_NEW_CLUSTER}</li>\n+ *     <li>Again start a cluster in an old version: {@link TestStep#STEP3_OLD_CLUSTER}</li>", "originalCommit": "cc6740e999e6eadb94eb316778019fff3e07238c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQyMjkzMA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364422930", "bodyText": "Reworded it a little, hope it's better now :)", "author": "original-brownbear", "createdAt": "2020-01-08T20:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1MjkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1NDEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364354131", "bodyText": "why is it always taking the first node here?", "author": "ywelsch", "createdAt": "2020-01-08T17:33:46Z", "path": "qa/repository-multi-version/src/test/java/org/elasticsearch/upgrades/MultiVersionRepositoryAccessIT.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Tests that verify that a snapshot repository is not getting corrupted and continues to function properly when accessed by multiple\n+ * clusters of different versions. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start a cluster in an old version: {@link TestStep#STEP1_OLD_CLUSTER}</li>\n+ *     <li>Start a cluster running the current version: {@link TestStep#STEP2_NEW_CLUSTER}</li>\n+ *     <li>Again start a cluster in an old version: {@link TestStep#STEP3_OLD_CLUSTER}</li>\n+ *     <li>Once again start a cluster running the current version: {@link TestStep#STEP4_NEW_CLUSTER}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class MultiVersionRepositoryAccessIT extends ESRestTestCase {\n+\n+    private enum TestStep {\n+        STEP1_OLD_CLUSTER(\"step1\"),\n+        STEP2_NEW_CLUSTER(\"step2\"),\n+        STEP3_OLD_CLUSTER(\"step3\"),\n+        STEP4_NEW_CLUSTER(\"step4\");\n+\n+        private final String name;\n+\n+        TestStep(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"step1\":\n+                    return STEP1_OLD_CLUSTER;\n+                case \"step2\":\n+                    return STEP2_NEW_CLUSTER;\n+                case \"step3\":\n+                    return STEP3_OLD_CLUSTER;\n+                case \"step4\":\n+                    return STEP4_NEW_CLUSTER;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    public void testCreateAndRestoreSnapshot() throws IOException {\n+        final String repoName = \"testCreateAndRestoreSnapshot\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {", "originalCommit": "cc6740e999e6eadb94eb316778019fff3e07238c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQwNTYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364405617", "bodyText": "It's taking all nodes? It's just creating the empty array for the conversion to Node not looking up [0]:)", "author": "original-brownbear", "createdAt": "2020-01-08T19:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1NDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYyNDkxNg==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364624916", "bodyText": "Java \ud83d\udde1", "author": "ywelsch", "createdAt": "2020-01-09T09:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1NDEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1NDQ0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364354447", "bodyText": "check that the snapshot can be listed before deletion?", "author": "ywelsch", "createdAt": "2020-01-08T17:34:29Z", "path": "qa/repository-multi-version/src/test/java/org/elasticsearch/upgrades/MultiVersionRepositoryAccessIT.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Tests that verify that a snapshot repository is not getting corrupted and continues to function properly when accessed by multiple\n+ * clusters of different versions. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start a cluster in an old version: {@link TestStep#STEP1_OLD_CLUSTER}</li>\n+ *     <li>Start a cluster running the current version: {@link TestStep#STEP2_NEW_CLUSTER}</li>\n+ *     <li>Again start a cluster in an old version: {@link TestStep#STEP3_OLD_CLUSTER}</li>\n+ *     <li>Once again start a cluster running the current version: {@link TestStep#STEP4_NEW_CLUSTER}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class MultiVersionRepositoryAccessIT extends ESRestTestCase {\n+\n+    private enum TestStep {\n+        STEP1_OLD_CLUSTER(\"step1\"),\n+        STEP2_NEW_CLUSTER(\"step2\"),\n+        STEP3_OLD_CLUSTER(\"step3\"),\n+        STEP4_NEW_CLUSTER(\"step4\");\n+\n+        private final String name;\n+\n+        TestStep(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"step1\":\n+                    return STEP1_OLD_CLUSTER;\n+                case \"step2\":\n+                    return STEP2_NEW_CLUSTER;\n+                case \"step3\":\n+                    return STEP3_OLD_CLUSTER;\n+                case \"step4\":\n+                    return STEP4_NEW_CLUSTER;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    public void testCreateAndRestoreSnapshot() throws IOException {\n+        final String repoName = \"testCreateAndRestoreSnapshot\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            createIndex(client, \"test-index\", shards);\n+            createRepository(client, repoName, false);\n+            createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP);\n+            final String snapshotToDeleteName = \"snapshot-to-delete\";\n+            // Create a snapshot and delete it right away again to test the impact of each version's cleanup functionality that is run\n+            // as part of the snapshot delete\n+            createSnapshot(client, repoName, snapshotToDeleteName);\n+            deleteSnapshot(client, repoName, snapshotToDeleteName);", "originalCommit": "cc6740e999e6eadb94eb316778019fff3e07238c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQxNTgxNA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364415814", "bodyText": "Sure :)", "author": "original-brownbear", "createdAt": "2020-01-08T19:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1NDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1ODk2NA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364358964", "bodyText": "what if we can't load one of these snapshot info? Should we be lenient in that case? Will this o.w. break snapshotting in a way that wasn't broken before?", "author": "ywelsch", "createdAt": "2020-01-08T17:45:03Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -351,6 +354,26 @@ public TimeValue timeout() {\n         }, listener::onFailure);\n     }\n \n+    public boolean hasOldVersionSnapshots(String repositoryName, RepositoryData repositoryData, @Nullable SnapshotId excluded) {\n+        final Collection<SnapshotId> snapshotIds = repositoryData.getSnapshotIds();\n+        final boolean hasOldFormatSnapshots;\n+        if (snapshotIds.isEmpty()) {\n+            hasOldFormatSnapshots = false;\n+        } else {\n+            if (repositoryData.shardGenerations().totalShards() > 0) {\n+                hasOldFormatSnapshots = false;\n+            } else {\n+                final Repository repository = repositoriesService.repository(repositoryName);\n+                hasOldFormatSnapshots = snapshotIds.stream().map(repository::getSnapshotInfo).anyMatch(", "originalCommit": "cc6740e999e6eadb94eb316778019fff3e07238c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQwODY3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364408672", "bodyText": "This will brake snapshotting and deleting snapshots if a snap-uuid file doesn't exist.\nI think it's much better to fail this case than to quietly ignore it.\nWe simply should definitely not be making any updates to a corrupted repo ever IMO. This will not break restoring snapshots from the repo and users should simply move to a new repo when running into this kind of corruption. We discussed this before and I think the conclusion was that if a snap- file is missing ... what guarantees do we have some __ data file isn't missing as well and quietly causing any new snapshot that uses it to be corrupted as well.\nWe also already eliminated a number of other spots around repo corruption like this where we were lenient before but aren't any longer lately so I think this fits in with our general approach to corrupted repos just fine.", "author": "original-brownbear", "createdAt": "2020-01-08T19:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYyNDcxMw==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364624713", "bodyText": "I'm mainly concerned about the situation in Cloud where repos that got previously broken due to eventual consistencies are not taking any new backups anymore, and require an operator to come in and fix the situation. I have a strong preference here to add special handling for the case where the meta file is not found and be lenient in that case (and assume it's an old style repo).", "author": "ywelsch", "createdAt": "2020-01-09T09:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYyNzY1NA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364627654", "bodyText": "I'm mainly concerned about the situation in Cloud where repos that got previously broken due to eventual consistencies are not taking any new backups anymore, and require an operator to come in and fix the situation.\n\nI would argue that this is what we want. Assuming you have a snapshot in the index-N for which the snap- blob is missing at the repo root, then what guarantees do you have that the data blobs belonging to that snapshot and are referenced in the shard level index-N do actually exist and you're not just creating and endless stream of corrupted snapshots quietly? IMO this situation should be resolved in Cloud operationally (and if it turns out to be common, automated).", "author": "original-brownbear", "createdAt": "2020-01-09T09:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYzMzgzOA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364633838", "bodyText": "Assuming you have a snapshot in the index-N for which the snap- blob is missing at the repo root, then what guarantees do you have that the data blobs belonging to that snapshot and are referenced in the shard level index-N do actually exist and you're not just creating and endless stream of corrupted snapshots quietly?\n\nI don't see how these two are related. Having a missing top-level snap- blob does not entail that you have missing segment blobs. I therefore don't follow the argument for endless corrupted snapshots. In any case, I don't think it's the responsibility of the snapshot creation / snapshot deletion API to verify unrelated snapshots, which is what this API now suddenly does with the changes here as it happens to need a full top-level scan of the repo. Let's leave this kind of verification to a separate API that checks integrity of the repo.", "author": "ywelsch", "createdAt": "2020-01-09T09:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY0MTU0MA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364641540", "bodyText": "I don't see how these two are related. Having a missing top-level snap- blob does not entail that you have missing segment blobs. I therefore don't follow the argument for endless corrupted snapshots.\n\nTwo points here:\n\nThe argument isn't specific to S3 here. The absence of a file that is supposed to be there but is not means that the repository is corrupted and other files could be missing for whatever reason (say a broken NFS setup).\nConcretely to the point, If a snap- blob is missing due to eventual consistency issues the sequence of events would be:\n\n\nsnap- and all the other meta and data blobs related to a snapshot were deleted and a new index-N was written\nNext operation failed to pick up index-N due to inconsistent listing and instead picked up index-(N-1) that still included the snapshot and then writes out index-N again still including the snapshot.\nIf the two operations were so close to each other, maybe we also picked up an older shard level index-N blob that references data blobs that are actually gone already? I don't think this can be ruled out at all and is somewhat likely even.\n\n\nI don't think it's the responsibility of the snapshot creation / snapshot deletion API to verify unrelated snapshots, which is what this API now suddenly does with the changes here as it happens to need a full top-level scan of the repo. Let's leave this kind of verification to a separate API that checks integrity of the repo.\n\nAgreed, I don't think it's the responsibility of snapshot create and delete to do any verification outright. But I though consensus was that if either of these operations detected the repository to be in a corrupted state, it wouldn't continue to make updates to the repo. If I remember correctly, the reasoning was precisely that if e.g. an NFS issue makes some files go missing and we continue to modify the repo ignoring/resiliently handling that corruption, then we take away any chance of the operator to fix the storage layer instead of losing those snapshots for good?", "author": "original-brownbear", "createdAt": "2020-01-09T09:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3NjAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364676012", "bodyText": "@ywelsch as discussed on another channel, I adjusted things to now ignored a missing snap-${uuid}.dat blob and assume old generation in that case.\nI also added a test for this scenario in 7d5d256 (I know it's a little hacky, but I still liked it better than starting to manually mess with files in the repos used by the REST/BwC tests).", "author": "original-brownbear", "createdAt": "2020-01-09T10:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM1ODk2NA=="}], "type": "inlineReview"}, {"oid": "fd55b40c870ddfa370ee38d2943cd599a68b93ab", "url": "https://github.com/elastic/elasticsearch/commit/fd55b40c870ddfa370ee38d2943cd599a68b93ab", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-08T19:30:16Z", "type": "commit"}, {"oid": "f1cda9ddbde710db0a7cb92fdc6da3485695c102", "url": "https://github.com/elastic/elasticsearch/commit/f1cda9ddbde710db0a7cb92fdc6da3485695c102", "message": "CR: more checks + renaming", "committedDate": "2020-01-08T20:13:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYwOTYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364609614", "bodyText": "suit -> suite", "author": "tlrx", "createdAt": "2020-01-09T08:30:12Z", "path": "qa/repository-multi-version/src/test/java/org/elasticsearch/upgrades/MultiVersionRepositoryAccessIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasItem;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Tests that verify that a snapshot repository is not getting corrupted and continues to function properly when accessed by multiple\n+ * clusters of different versions. Concretely this test suit is simulating the following scenario:", "originalCommit": "f1cda9ddbde710db0a7cb92fdc6da3485695c102", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYxMDYxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364610611", "bodyText": "Use getTestName()", "author": "tlrx", "createdAt": "2020-01-09T08:32:56Z", "path": "qa/repository-multi-version/src/test/java/org/elasticsearch/upgrades/MultiVersionRepositoryAccessIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasItem;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Tests that verify that a snapshot repository is not getting corrupted and continues to function properly when accessed by multiple\n+ * clusters of different versions. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start and run against a cluster in an old version: {@link TestStep#STEP1_OLD_CLUSTER}</li>\n+ *     <li>Start and run against a cluster running the current version: {@link TestStep#STEP2_NEW_CLUSTER}</li>\n+ *     <li>Run against the old version cluster from the first step: {@link TestStep#STEP3_OLD_CLUSTER}</li>\n+ *     <li>Run against the current version cluster from the second step: {@link TestStep#STEP4_NEW_CLUSTER}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class MultiVersionRepositoryAccessIT extends ESRestTestCase {\n+\n+    private enum TestStep {\n+        STEP1_OLD_CLUSTER(\"step1\"),\n+        STEP2_NEW_CLUSTER(\"step2\"),\n+        STEP3_OLD_CLUSTER(\"step3\"),\n+        STEP4_NEW_CLUSTER(\"step4\");\n+\n+        private final String name;\n+\n+        TestStep(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"step1\":\n+                    return STEP1_OLD_CLUSTER;\n+                case \"step2\":\n+                    return STEP2_NEW_CLUSTER;\n+                case \"step3\":\n+                    return STEP3_OLD_CLUSTER;\n+                case \"step4\":\n+                    return STEP4_NEW_CLUSTER;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    public void testCreateAndRestoreSnapshot() throws IOException {\n+        final String repoName = \"testCreateAndRestoreSnapshot\";", "originalCommit": "f1cda9ddbde710db0a7cb92fdc6da3485695c102", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYyNzg3MA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364627870", "bodyText": "neat :) didn't know about that one", "author": "original-brownbear", "createdAt": "2020-01-09T09:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYxMDYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYxNDg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364614880", "bodyText": "I think it deserves its own utility method, something like assertSnapshotStatusSuccessful()", "author": "tlrx", "createdAt": "2020-01-09T08:42:39Z", "path": "qa/repository-multi-version/src/test/java/org/elasticsearch/upgrades/MultiVersionRepositoryAccessIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasItem;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Tests that verify that a snapshot repository is not getting corrupted and continues to function properly when accessed by multiple\n+ * clusters of different versions. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start and run against a cluster in an old version: {@link TestStep#STEP1_OLD_CLUSTER}</li>\n+ *     <li>Start and run against a cluster running the current version: {@link TestStep#STEP2_NEW_CLUSTER}</li>\n+ *     <li>Run against the old version cluster from the first step: {@link TestStep#STEP3_OLD_CLUSTER}</li>\n+ *     <li>Run against the current version cluster from the second step: {@link TestStep#STEP4_NEW_CLUSTER}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class MultiVersionRepositoryAccessIT extends ESRestTestCase {\n+\n+    private enum TestStep {\n+        STEP1_OLD_CLUSTER(\"step1\"),\n+        STEP2_NEW_CLUSTER(\"step2\"),\n+        STEP3_OLD_CLUSTER(\"step3\"),\n+        STEP4_NEW_CLUSTER(\"step4\");\n+\n+        private final String name;\n+\n+        TestStep(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"step1\":\n+                    return STEP1_OLD_CLUSTER;\n+                case \"step2\":\n+                    return STEP2_NEW_CLUSTER;\n+                case \"step3\":\n+                    return STEP3_OLD_CLUSTER;\n+                case \"step4\":\n+                    return STEP4_NEW_CLUSTER;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    public void testCreateAndRestoreSnapshot() throws IOException {\n+        final String repoName = \"testCreateAndRestoreSnapshot\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            createIndex(client, \"test-index\", shards);\n+            createRepository(client, repoName, false);\n+            createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP);\n+            final String snapshotToDeleteName = \"snapshot-to-delete\";\n+            // Create a snapshot and delete it right away again to test the impact of each version's cleanup functionality that is run\n+            // as part of the snapshot delete\n+            createSnapshot(client, repoName, snapshotToDeleteName);\n+            final List<Map<String, Object>> snapshotsIncludingToDelete = listSnapshots(repoName);\n+            // Every step creates one snapshot and we have to add one more for the temporary snapshot\n+            assertThat(snapshotsIncludingToDelete, hasSize(TEST_STEP.ordinal() + 1 + 1));\n+            assertThat(snapshotsIncludingToDelete.stream().map(\n+                sn -> (String) sn.get(\"snapshot\")).collect(Collectors.toList()), hasItem(snapshotToDeleteName));\n+            deleteSnapshot(client, repoName, snapshotToDeleteName);\n+            final List<Map<String, Object>> snapshots = listSnapshots(repoName);\n+            assertThat(snapshots, hasSize(TEST_STEP.ordinal() + 1));\n+            final SnapshotsStatusResponse statusResponse = client.snapshot().status(new SnapshotsStatusRequest(repoName,\n+                snapshots.stream().map(sn -> (String) sn.get(\"snapshot\")).toArray(String[]::new)), RequestOptions.DEFAULT);\n+            for (SnapshotStatus status : statusResponse.getSnapshots()) {\n+                assertThat(status.getShardsStats().getFailedShards(), is(0));\n+            }\n+            if (TEST_STEP == TestStep.STEP3_OLD_CLUSTER) {\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER, shards);\n+            } else if (TEST_STEP == TestStep.STEP4_NEW_CLUSTER) {\n+                for (TestStep value : TestStep.values()) {\n+                    ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + value, shards);\n+                }\n+            }\n+        } finally {\n+            deleteRepository(repoName);\n+        }\n+    }\n+\n+    public void testReadOnlyRepo() throws IOException {\n+        final String repoName = \"testReadOnlyRepo\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            final boolean readOnly = TEST_STEP.ordinal() > 1; // only restore from read-only repo in steps 3 and 4\n+            createRepository(client, repoName, readOnly);\n+            if (readOnly == false) {\n+                createIndex(client, \"test-index\", shards);\n+                createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP);\n+            }\n+            final List<Map<String, Object>> snapshots = listSnapshots(repoName);\n+            switch (TEST_STEP) {\n+                case STEP1_OLD_CLUSTER:\n+                    assertThat(snapshots, hasSize(1));\n+                    break;\n+                case STEP2_NEW_CLUSTER:\n+                case STEP4_NEW_CLUSTER:\n+                case STEP3_OLD_CLUSTER:\n+                    assertThat(snapshots, hasSize(2));\n+                    break;\n+            }\n+            final SnapshotsStatusResponse statusResponse = client.snapshot().status(new SnapshotsStatusRequest(repoName,\n+                snapshots.stream().map(sn -> (String) sn.get(\"snapshot\")).toArray(String[]::new)), RequestOptions.DEFAULT);\n+            for (SnapshotStatus status : statusResponse.getSnapshots()) {\n+                assertThat(status.getShardsStats().getFailedShards(), is(0));\n+            }\n+            if (TEST_STEP == TestStep.STEP3_OLD_CLUSTER) {\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER, shards);\n+            } else if (TEST_STEP == TestStep.STEP4_NEW_CLUSTER) {\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER, shards);\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP2_NEW_CLUSTER, shards);\n+            }\n+        }\n+    }\n+\n+    public void testUpgradeMovesRepoToNewMetaVersion() throws IOException {\n+        if (TEST_STEP.ordinal() > 1) {\n+            // Only testing the first 2 steps here\n+            return;\n+        }\n+        final String repoName = \"testUpgradeMovesRepoToNewMetaVersion\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            createIndex(client, \"test-index\", shards);\n+            createRepository(client, repoName, false);\n+            createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP);\n+            final List<Map<String, Object>> snapshots = listSnapshots(repoName);\n+            // Every step creates one snapshot\n+            assertThat(snapshots, hasSize(TEST_STEP.ordinal() + 1));\n+            final SnapshotsStatusResponse statusResponse = client.snapshot().status(new SnapshotsStatusRequest(repoName,\n+                snapshots.stream().map(sn -> (String) sn.get(\"snapshot\")).toArray(String[]::new)), RequestOptions.DEFAULT);\n+            for (SnapshotStatus status : statusResponse.getSnapshots()) {\n+                assertThat(status.getShardsStats().getFailedShards(), is(0));\n+            }", "originalCommit": "f1cda9ddbde710db0a7cb92fdc6da3485695c102", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYyNzgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364627816", "bodyText": "Sounds good :) Done", "author": "original-brownbear", "createdAt": "2020-01-09T09:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYxNDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYxNjIyMw==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364616223", "bodyText": "Maybe check that the deletion is acked?", "author": "tlrx", "createdAt": "2020-01-09T08:45:53Z", "path": "qa/repository-multi-version/src/test/java/org/elasticsearch/upgrades/MultiVersionRepositoryAccessIT.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.upgrades;\n+\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Node;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.snapshots.RestoreInfo;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasItem;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ * Tests that verify that a snapshot repository is not getting corrupted and continues to function properly when accessed by multiple\n+ * clusters of different versions. Concretely this test suit is simulating the following scenario:\n+ * <ul>\n+ *     <li>Start and run against a cluster in an old version: {@link TestStep#STEP1_OLD_CLUSTER}</li>\n+ *     <li>Start and run against a cluster running the current version: {@link TestStep#STEP2_NEW_CLUSTER}</li>\n+ *     <li>Run against the old version cluster from the first step: {@link TestStep#STEP3_OLD_CLUSTER}</li>\n+ *     <li>Run against the current version cluster from the second step: {@link TestStep#STEP4_NEW_CLUSTER}</li>\n+ * </ul>\n+ * TODO: Add two more steps: delete all old version snapshots from the repository, then downgrade again and verify that the repository\n+ *       is not being corrupted. This requires first merging the logic for reading the min_version field in RepositoryData back to 7.6.\n+ */\n+public class MultiVersionRepositoryAccessIT extends ESRestTestCase {\n+\n+    private enum TestStep {\n+        STEP1_OLD_CLUSTER(\"step1\"),\n+        STEP2_NEW_CLUSTER(\"step2\"),\n+        STEP3_OLD_CLUSTER(\"step3\"),\n+        STEP4_NEW_CLUSTER(\"step4\");\n+\n+        private final String name;\n+\n+        TestStep(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        public static TestStep parse(String value) {\n+            switch (value) {\n+                case \"step1\":\n+                    return STEP1_OLD_CLUSTER;\n+                case \"step2\":\n+                    return STEP2_NEW_CLUSTER;\n+                case \"step3\":\n+                    return STEP3_OLD_CLUSTER;\n+                case \"step4\":\n+                    return STEP4_NEW_CLUSTER;\n+                default:\n+                    throw new AssertionError(\"unknown test step: \" + value);\n+            }\n+        }\n+    }\n+\n+    protected static final TestStep TEST_STEP = TestStep.parse(System.getProperty(\"tests.rest.suite\"));\n+\n+    @Override\n+    protected boolean preserveSnapshotsUponCompletion() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean preserveReposUponCompletion() {\n+        return true;\n+    }\n+\n+    public void testCreateAndRestoreSnapshot() throws IOException {\n+        final String repoName = \"testCreateAndRestoreSnapshot\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            createIndex(client, \"test-index\", shards);\n+            createRepository(client, repoName, false);\n+            createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP);\n+            final String snapshotToDeleteName = \"snapshot-to-delete\";\n+            // Create a snapshot and delete it right away again to test the impact of each version's cleanup functionality that is run\n+            // as part of the snapshot delete\n+            createSnapshot(client, repoName, snapshotToDeleteName);\n+            final List<Map<String, Object>> snapshotsIncludingToDelete = listSnapshots(repoName);\n+            // Every step creates one snapshot and we have to add one more for the temporary snapshot\n+            assertThat(snapshotsIncludingToDelete, hasSize(TEST_STEP.ordinal() + 1 + 1));\n+            assertThat(snapshotsIncludingToDelete.stream().map(\n+                sn -> (String) sn.get(\"snapshot\")).collect(Collectors.toList()), hasItem(snapshotToDeleteName));\n+            deleteSnapshot(client, repoName, snapshotToDeleteName);\n+            final List<Map<String, Object>> snapshots = listSnapshots(repoName);\n+            assertThat(snapshots, hasSize(TEST_STEP.ordinal() + 1));\n+            final SnapshotsStatusResponse statusResponse = client.snapshot().status(new SnapshotsStatusRequest(repoName,\n+                snapshots.stream().map(sn -> (String) sn.get(\"snapshot\")).toArray(String[]::new)), RequestOptions.DEFAULT);\n+            for (SnapshotStatus status : statusResponse.getSnapshots()) {\n+                assertThat(status.getShardsStats().getFailedShards(), is(0));\n+            }\n+            if (TEST_STEP == TestStep.STEP3_OLD_CLUSTER) {\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER, shards);\n+            } else if (TEST_STEP == TestStep.STEP4_NEW_CLUSTER) {\n+                for (TestStep value : TestStep.values()) {\n+                    ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + value, shards);\n+                }\n+            }\n+        } finally {\n+            deleteRepository(repoName);\n+        }\n+    }\n+\n+    public void testReadOnlyRepo() throws IOException {\n+        final String repoName = \"testReadOnlyRepo\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            final boolean readOnly = TEST_STEP.ordinal() > 1; // only restore from read-only repo in steps 3 and 4\n+            createRepository(client, repoName, readOnly);\n+            if (readOnly == false) {\n+                createIndex(client, \"test-index\", shards);\n+                createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP);\n+            }\n+            final List<Map<String, Object>> snapshots = listSnapshots(repoName);\n+            switch (TEST_STEP) {\n+                case STEP1_OLD_CLUSTER:\n+                    assertThat(snapshots, hasSize(1));\n+                    break;\n+                case STEP2_NEW_CLUSTER:\n+                case STEP4_NEW_CLUSTER:\n+                case STEP3_OLD_CLUSTER:\n+                    assertThat(snapshots, hasSize(2));\n+                    break;\n+            }\n+            final SnapshotsStatusResponse statusResponse = client.snapshot().status(new SnapshotsStatusRequest(repoName,\n+                snapshots.stream().map(sn -> (String) sn.get(\"snapshot\")).toArray(String[]::new)), RequestOptions.DEFAULT);\n+            for (SnapshotStatus status : statusResponse.getSnapshots()) {\n+                assertThat(status.getShardsStats().getFailedShards(), is(0));\n+            }\n+            if (TEST_STEP == TestStep.STEP3_OLD_CLUSTER) {\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER, shards);\n+            } else if (TEST_STEP == TestStep.STEP4_NEW_CLUSTER) {\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER, shards);\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP2_NEW_CLUSTER, shards);\n+            }\n+        }\n+    }\n+\n+    public void testUpgradeMovesRepoToNewMetaVersion() throws IOException {\n+        if (TEST_STEP.ordinal() > 1) {\n+            // Only testing the first 2 steps here\n+            return;\n+        }\n+        final String repoName = \"testUpgradeMovesRepoToNewMetaVersion\";\n+        try (RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(adminClient().getNodes().toArray(new Node[0])))) {\n+            final int shards = 3;\n+            createIndex(client, \"test-index\", shards);\n+            createRepository(client, repoName, false);\n+            createSnapshot(client, repoName, \"snapshot-\" + TEST_STEP);\n+            final List<Map<String, Object>> snapshots = listSnapshots(repoName);\n+            // Every step creates one snapshot\n+            assertThat(snapshots, hasSize(TEST_STEP.ordinal() + 1));\n+            final SnapshotsStatusResponse statusResponse = client.snapshot().status(new SnapshotsStatusRequest(repoName,\n+                snapshots.stream().map(sn -> (String) sn.get(\"snapshot\")).toArray(String[]::new)), RequestOptions.DEFAULT);\n+            for (SnapshotStatus status : statusResponse.getSnapshots()) {\n+                assertThat(status.getShardsStats().getFailedShards(), is(0));\n+            }\n+            if (TEST_STEP == TestStep.STEP1_OLD_CLUSTER) {\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER, shards);\n+            } else {\n+                deleteSnapshot(client, repoName, \"snapshot-\" + TestStep.STEP1_OLD_CLUSTER);\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-\" + TestStep.STEP2_NEW_CLUSTER, shards);\n+                createSnapshot(client, repoName, \"snapshot-1\");\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-1\", shards);\n+                deleteSnapshot(client, repoName, \"snapshot-\" + TestStep.STEP2_NEW_CLUSTER);\n+                createSnapshot(client, repoName, \"snapshot-2\");\n+                ensureSnapshotRestoreWorks(client, repoName, \"snapshot-2\", shards);\n+            }\n+        } finally {\n+            deleteRepository(repoName);\n+        }\n+    }\n+\n+    private void deleteSnapshot(RestHighLevelClient client, String repoName, String name) throws IOException {\n+        client.snapshot().delete(new DeleteSnapshotRequest(repoName, name), RequestOptions.DEFAULT);", "originalCommit": "f1cda9ddbde710db0a7cb92fdc6da3485695c102", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYyNzc4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/50692#discussion_r364627789", "bodyText": "Sounds good :) Done", "author": "original-brownbear", "createdAt": "2020-01-09T09:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDYxNjIyMw=="}], "type": "inlineReview"}, {"oid": "c1436d39eb305bb0f292540b0fe089f3fd2524a0", "url": "https://github.com/elastic/elasticsearch/commit/c1436d39eb305bb0f292540b0fe089f3fd2524a0", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-09T08:55:58Z", "type": "commit"}, {"oid": "d4a18d85b81fd98a52fdd0b258d8ee1f085c21c6", "url": "https://github.com/elastic/elasticsearch/commit/d4a18d85b81fd98a52fdd0b258d8ee1f085c21c6", "message": "nicer", "committedDate": "2020-01-09T09:09:35Z", "type": "commit"}, {"oid": "ba5f826ac80001849411b3451daeee217d5f015f", "url": "https://github.com/elastic/elasticsearch/commit/ba5f826ac80001849411b3451daeee217d5f015f", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-09T10:05:27Z", "type": "commit"}, {"oid": "7d5d2565b0e8c0df84d89e0fd5f3c37d5a87199b", "url": "https://github.com/elastic/elasticsearch/commit/7d5d2565b0e8c0df84d89e0fd5f3c37d5a87199b", "message": "assume old version when missing snap- blob", "committedDate": "2020-01-09T10:52:41Z", "type": "commit"}, {"oid": "2ee45d638269c08fadae2cabfd680591841d465c", "url": "https://github.com/elastic/elasticsearch/commit/2ee45d638269c08fadae2cabfd680591841d465c", "message": "Merge remote-tracking branch 'elastic/master' into test-downgrade-bwc", "committedDate": "2020-01-09T13:38:29Z", "type": "commit"}]}