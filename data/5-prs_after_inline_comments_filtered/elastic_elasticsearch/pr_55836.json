{"pr_number": 55836, "pr_title": "Add cache for application privileges", "pr_createdAt": "2020-04-28T03:16:23Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55836", "timeline": [{"oid": "b72d0d3de19b0d6c2c650401201fa648ddb1f6be", "url": "https://github.com/elastic/elasticsearch/commit/b72d0d3de19b0d6c2c650401201fa648ddb1f6be", "message": "WIP", "committedDate": "2020-04-27T05:19:31Z", "type": "commit"}, {"oid": "a02aba35ea0e04c5717e6240a71d0625d82e129a", "url": "https://github.com/elastic/elasticsearch/commit/a02aba35ea0e04c5717e6240a71d0625d82e129a", "message": "Add tests", "committedDate": "2020-04-27T06:42:26Z", "type": "commit"}, {"oid": "6d9fa0aca50fc709c47963d892720c487be02e37", "url": "https://github.com/elastic/elasticsearch/commit/6d9fa0aca50fc709c47963d892720c487be02e37", "message": "Add invalidation", "committedDate": "2020-04-27T08:30:40Z", "type": "commit"}, {"oid": "ee33fffc1ed432cd7baee23db54222947ac1c69b", "url": "https://github.com/elastic/elasticsearch/commit/ee33fffc1ed432cd7baee23db54222947ac1c69b", "message": "Add some corrurrency liveness protection", "committedDate": "2020-04-27T08:51:28Z", "type": "commit"}, {"oid": "4bbd16d80b1279f7bd981eed82409fd9830d3df4", "url": "https://github.com/elastic/elasticsearch/commit/4bbd16d80b1279f7bd981eed82409fd9830d3df4", "message": "Add API for both rest and transport", "committedDate": "2020-04-27T12:39:03Z", "type": "commit"}, {"oid": "df28676568c9ac872ebcb07c31da7449b313d2f0", "url": "https://github.com/elastic/elasticsearch/commit/df28676568c9ac872ebcb07c31da7449b313d2f0", "message": "Simplify NativePrivilegeStore", "committedDate": "2020-04-27T15:54:25Z", "type": "commit"}, {"oid": "4a63a16a5ee3c17670219c087d157d77761d2cf5", "url": "https://github.com/elastic/elasticsearch/commit/4a63a16a5ee3c17670219c087d157d77761d2cf5", "message": "Minor", "committedDate": "2020-04-27T15:56:50Z", "type": "commit"}, {"oid": "a1d177cbcf5d99d7cb0f9bf9e2593fed5c27eaa8", "url": "https://github.com/elastic/elasticsearch/commit/a1d177cbcf5d99d7cb0f9bf9e2593fed5c27eaa8", "message": "More tweak", "committedDate": "2020-04-27T16:10:30Z", "type": "commit"}, {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a", "url": "https://github.com/elastic/elasticsearch/commit/05061f972d863e577d838ac9ee721b9e23b4f68a", "message": "Add single node tests\n\nRest tests\nDocuments\nOther tweaks and optimizations", "committedDate": "2020-04-28T02:49:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5ODM0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r416298343", "bodyText": "This pattern is used in CompositeRolesStore. However it is still possible that the cache gets invalidated immediately after the if check. The window for it to happen is much small, but still exists in theory.\nThe other pattern is to use ListenableFuture. This would solves the stale entry problem here because the future itself is removed from the cached. So adding items to the removed future has no impact to the cache. However, this pattern could potentially have a deadlock issue? If the thread computing for future crashes, will all the other thread waiting for it get stuck? If this is true, I'd prefer to use the first pattern since a stale entry (with very low chance) is less harmful than deadlocking.", "author": "ywangd", "createdAt": "2020-04-28T03:24:32Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;\n+            if (concreteApplicationNames == null) {\n+                cacheStatus = cacheStatusForApplicationNames(applicationNamesCacheKey);\n+            } else {\n+                cacheStatus = cacheStatusForApplicationNames(concreteApplicationNames);\n+            }\n+\n+            if (cacheStatus.v1().isEmpty()) {\n+                logger.debug(\"All application privileges found in cache\");\n+                final Set<ApplicationPrivilegeDescriptor> cachedDescriptors =\n+                    cacheStatus.v2().values().stream().flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n+                listener.onResponse(filterDescriptorsForNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", cacheStatus.v1());\n+                innerGetPrivileges(cacheStatus.v1(), ActionListener.wrap(fetchedDescriptors -> {\n+                    final Map<String, Set<ApplicationPrivilegeDescriptor>> mapOfFetchedDescriptors = fetchedDescriptors.stream()\n+                        .collect(Collectors.groupingBy(ApplicationPrivilegeDescriptor::getApplication, Collectors.toUnmodifiableSet()));\n+                    final Set<String> allApplicationNames =\n+                        Stream.concat(cacheStatus.v2().keySet().stream(), mapOfFetchedDescriptors.keySet().stream())\n+                            .collect(Collectors.toUnmodifiableSet());\n+                    // Avoid caching potential stale results.\n+                    // TODO: It is still possible that cache gets invalidated immediately after the if check\n+                    if (invalidationCounter == numInvalidation.get()) {", "originalCommit": "05061f972d863e577d838ac9ee721b9e23b4f68a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NDQ2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431864462", "bodyText": "I think a ReadWriteLock would solve the problem. Treat the invalidator as the writer and the cache population as the reader. The invalidator would need exclusive access, but we could support multiple populators.\nI'll need to think about it again when it's not midnight, but I think it's reasonable (if used alongside the invalidationCounter so the lock window is small).", "author": "tvernum", "createdAt": "2020-05-28T14:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5ODM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5ODc3MA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r416298770", "bodyText": "This is a minor optimisation so we do not store an etnry of {Set('app-1'), Set('app-1')}, where there is no expansion at all.", "author": "ywangd", "createdAt": "2020-04-28T03:25:51Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;\n+            if (concreteApplicationNames == null) {\n+                cacheStatus = cacheStatusForApplicationNames(applicationNamesCacheKey);\n+            } else {\n+                cacheStatus = cacheStatusForApplicationNames(concreteApplicationNames);\n+            }\n+\n+            if (cacheStatus.v1().isEmpty()) {\n+                logger.debug(\"All application privileges found in cache\");\n+                final Set<ApplicationPrivilegeDescriptor> cachedDescriptors =\n+                    cacheStatus.v2().values().stream().flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n+                listener.onResponse(filterDescriptorsForNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", cacheStatus.v1());\n+                innerGetPrivileges(cacheStatus.v1(), ActionListener.wrap(fetchedDescriptors -> {\n+                    final Map<String, Set<ApplicationPrivilegeDescriptor>> mapOfFetchedDescriptors = fetchedDescriptors.stream()\n+                        .collect(Collectors.groupingBy(ApplicationPrivilegeDescriptor::getApplication, Collectors.toUnmodifiableSet()));\n+                    final Set<String> allApplicationNames =\n+                        Stream.concat(cacheStatus.v2().keySet().stream(), mapOfFetchedDescriptors.keySet().stream())\n+                            .collect(Collectors.toUnmodifiableSet());\n+                    // Avoid caching potential stale results.\n+                    // TODO: It is still possible that cache gets invalidated immediately after the if check\n+                    if (invalidationCounter == numInvalidation.get()) {\n+                        // Do not cache the names if expansion has no effect\n+                        if (allApplicationNames.equals(applicationNamesCacheKey) == false) {", "originalCommit": "05061f972d863e577d838ac9ee721b9e23b4f68a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5OTM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r416299394", "bodyText": "For invalidation, the application names cache is always completey invalidated since it requires some effort to identify the applicable entries. We could do this, but the gain may not be much.", "author": "ywangd", "createdAt": "2020-04-28T03:27:45Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,17 +223,69 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?\n                     ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener),\n                         hit -> buildPrivilege(hit.getId(), hit.getSourceRef()));\n                 }\n             });\n         }\n     }\n \n-    private boolean isSinglePrivilegeMatch(Collection<String> applications, Collection<String> names) {\n-        return applications != null && applications.size() == 1 && hasWildcard(applications) == false && names != null && names.size() == 1;\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        numInvalidation.incrementAndGet();\n+        // Always completely invalidate application names cache due to wildcard\n+        applicationNamesCache.invalidateAll();\n+        final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);", "originalCommit": "05061f972d863e577d838ac9ee721b9e23b4f68a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg3NDQwOA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431874408", "bodyText": "Remind me, what's Kibana's typical usage pattern for querying? Does it use wildcards for the application name?\nIf so, I think invalidating the name cache means that invalidating for a single application (which might not even exist) would effectively invalidate the whole cache because it would mean that querying for kibana* would end up not using any cache at all.", "author": "tvernum", "createdAt": "2020-05-28T14:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5OTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUxNjIwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432516200", "bodyText": "Kibana always sends a single concrete application name kibana-.kibana. So it should be fine for Kibana's typical usage.\nBut let me know if you think it is still necessary. The logic would look like something as the follows:\nforeach cache key (type is Set<String>)\n   foreach key member\n     foreach application\n        if (key member == application) or (key member is a wildcard and matches application)\n          invalidate the cache key\nJava code would be\nStreamSupport.stream(applicationNamesCache.keys().spliterator(), false)\n    .filter(keys -> keys.contains(\"*\")\n        || Sets.intersection(keys, uniqueNames).isEmpty() == false\n        || keys.stream().filter(k -> k.endsWith(\"*\")).anyMatch(\n            k -> uniqueNames.stream().anyMatch(n -> n.regionMatches(false, 0, k, 0, k.length()-1))))\n    .forEach(applicationNamesCache::invalidate);", "author": "ywangd", "createdAt": "2020-05-29T14:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5OTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNzE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r433007191", "bodyText": "Let's leave it - realistically we're talking about Kibana only, so clearing all applications isn't actually going to hurt anyone, and the only time we will clear the cache is on privilege update which happens when you install a new Kibana version.", "author": "tvernum", "createdAt": "2020-06-01T01:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5OTM5NA=="}], "type": "inlineReview"}, {"oid": "daafb80a97c35c1f5d1bc3a138409cb016160e73", "url": "https://github.com/elastic/elasticsearch/commit/daafb80a97c35c1f5d1bc3a138409cb016160e73", "message": "checkstyle", "committedDate": "2020-04-28T03:29:08Z", "type": "commit"}, {"oid": "545e27c3aef42158a6e296bb6077a9981e4d3589", "url": "https://github.com/elastic/elasticsearch/commit/545e27c3aef42158a6e296bb6077a9981e4d3589", "message": "More checkstyle", "committedDate": "2020-04-28T03:39:29Z", "type": "commit"}, {"oid": "5987b3bf823e09fe685211395cdb8257de45a4c6", "url": "https://github.com/elastic/elasticsearch/commit/5987b3bf823e09fe685211395cdb8257de45a4c6", "message": "checkstyle again", "committedDate": "2020-04-28T04:07:53Z", "type": "commit"}, {"oid": "60941785ac57b06e5ed9e305acd120db48566d32", "url": "https://github.com/elastic/elasticsearch/commit/60941785ac57b06e5ed9e305acd120db48566d32", "message": "Fix json API file", "committedDate": "2020-04-28T04:09:59Z", "type": "commit"}, {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912", "url": "https://github.com/elastic/elasticsearch/commit/1c58309b87b38718e10825eb15b9344ae9b38912", "message": "Update API json file", "committedDate": "2020-04-28T04:27:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MTE4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417061181", "bodyText": "We prefer Set.of to Collections.singleton", "author": "tvernum", "createdAt": "2020-04-29T04:32:20Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MjEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417062133", "bodyText": "You should avoid using a CacheIteratorHelper unless you absolutely need it.\nThis method iterates over the whole cache looking for matching items. In this case you don't need to do that, you can just invalidate an entry by key.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    descriptorsCacheHelper.removeKeysIf(uniqueNames::contains);\n          \n          \n            \n                   uniqueNames.forEach(descriptorsCache::invalidate);", "author": "tvernum", "createdAt": "2020-04-29T04:36:48Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,17 +223,69 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?\n                     ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener),\n                         hit -> buildPrivilege(hit.getId(), hit.getSourceRef()));\n                 }\n             });\n         }\n     }\n \n-    private boolean isSinglePrivilegeMatch(Collection<String> applications, Collection<String> names) {\n-        return applications != null && applications.size() == 1 && hasWildcard(applications) == false && names != null && names.size() == 1;\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        numInvalidation.incrementAndGet();\n+        // Always completely invalidate application names cache due to wildcard\n+        applicationNamesCache.invalidateAll();\n+        final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);\n+        descriptorsCacheHelper.removeKeysIf(uniqueNames::contains);", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MjcxOA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417062718", "bodyText": "I don't think you need this.", "author": "tvernum", "createdAt": "2020-04-29T04:39:22Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2NjkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417966902", "bodyText": "Right I don't need interate for either of the two caches. I'll remove both helpers.", "author": "ywangd", "createdAt": "2020-04-30T12:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MjcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2Mjk2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417062965", "bodyText": "Nit, empty line", "author": "tvernum", "createdAt": "2020-04-29T04:40:36Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2Njk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417966969", "bodyText": "Ack", "author": "ywangd", "createdAt": "2020-04-30T12:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2Mjk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MzUxOA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417063518", "bodyText": "Warning bells go off for me when I see complex Tuples like this (though I'm guilty of using them as well).\nI'd prefer we avoided it entirely, but if we really need it, can we assign the members to appropriately named local vars as soon as possible after the method returns?", "author": "tvernum", "createdAt": "2020-04-29T04:43:02Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2OTg0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417969849", "bodyText": "This complexity is due to an attempt to optimize number of documents to be fetched from index. It can be simplified if we always fetching everything when hitting the index is unavoidable (as you suggested below).", "author": "ywangd", "createdAt": "2020-04-30T12:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MzUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3MTYwMw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417971603", "bodyText": "Once we remove this optimization the Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> data structure is no longer necessary. So complexity will definitely be reduced", "author": "ywangd", "createdAt": "2020-04-30T12:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjQ0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417072447", "bodyText": "If I update the privileges for 2 apps (1 already cached, 1 not yet cached) right at this point, then 1 app would be served from the cache and be pre-update and the other would be served from the index and be post-update.\nI think if we're going to have to hit the index anyway, we should just load for all applications and ensure we get as close as possible to a point-in-time read.", "author": "tvernum", "createdAt": "2020-04-29T05:20:56Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;\n+            if (concreteApplicationNames == null) {\n+                cacheStatus = cacheStatusForApplicationNames(applicationNamesCacheKey);\n+            } else {\n+                cacheStatus = cacheStatusForApplicationNames(concreteApplicationNames);\n+            }\n+\n+            if (cacheStatus.v1().isEmpty()) {\n+                logger.debug(\"All application privileges found in cache\");\n+                final Set<ApplicationPrivilegeDescriptor> cachedDescriptors =\n+                    cacheStatus.v2().values().stream().flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n+                listener.onResponse(filterDescriptorsForNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", cacheStatus.v1());\n+                innerGetPrivileges(cacheStatus.v1(), ActionListener.wrap(fetchedDescriptors -> {", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3MDY5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417970699", "bodyText": "I was trying to optimize and reduce the number of documents to fetch. But maybe it is not worth the effort.", "author": "ywangd", "createdAt": "2020-04-30T12:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA4MzI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417083274", "bodyText": "I'm not sure about this. It seems like this API ends up doing something other than what it was supposed to, just because we assume that the caller wants it.\nI understand why - if the privileges have changed then the roles cache is probably wrong, but it seems like it's chain side-effects together.", "author": "tvernum", "createdAt": "2020-04-29T06:00:50Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.privilege;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TransportClearPrivilegesCacheAction extends TransportNodesAction<ClearPrivilegesCacheRequest, ClearPrivilegesCacheResponse,\n+    ClearPrivilegesCacheRequest.Node, ClearPrivilegesCacheResponse.Node> {\n+\n+    private final NativePrivilegeStore privilegesStore;\n+    private final CompositeRolesStore rolesStore;\n+\n+    @Inject\n+    public TransportClearPrivilegesCacheAction(\n+        ThreadPool threadPool,\n+        ClusterService clusterService,\n+        TransportService transportService,\n+        ActionFilters actionFilters,\n+        NativePrivilegeStore privilegesStore,\n+        CompositeRolesStore rolesStore) {\n+        super(\n+            ClearPrivilegesCacheAction.NAME,\n+            threadPool,\n+            clusterService,\n+            transportService,\n+            actionFilters,\n+            ClearPrivilegesCacheRequest::new,\n+            ClearPrivilegesCacheRequest.Node::new,\n+            ThreadPool.Names.MANAGEMENT,\n+            ClearPrivilegesCacheResponse.Node.class);\n+        this.privilegesStore = privilegesStore;\n+        this.rolesStore = rolesStore;\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse newResponse(\n+        ClearPrivilegesCacheRequest request, List<ClearPrivilegesCacheResponse.Node> nodes, List<FailedNodeException> failures) {\n+        return new ClearPrivilegesCacheResponse(clusterService.getClusterName(), nodes, failures);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheRequest.Node newNodeRequest(ClearPrivilegesCacheRequest request) {\n+        return new ClearPrivilegesCacheRequest.Node(request);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node newNodeResponse(StreamInput in) throws IOException {\n+        return new ClearPrivilegesCacheResponse.Node(in);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node nodeOperation(ClearPrivilegesCacheRequest.Node request, Task task) {\n+        if (request.getApplicationNames() == null || request.getApplicationNames().length == 0) {\n+            privilegesStore.invalidateAll();\n+        } else {\n+            privilegesStore.invalidate(Arrays.asList(request.getApplicationNames()));\n+        }\n+        rolesStore.invalidateAll();", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4Mzk2MA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417783960", "bodyText": "From just the API point of view, you are right that these two should not be tied together. There are valid use cases when user only wants to actively clear privileges cache. I did this because the two are always tied together in NativePrivilegesStore since it was clearing role cache before my change.\nI tried to avoid nested callbacks (clear role cache then clear privileges cache). It seems OK and more efficient by just looking at NativePrivilegesStore. But it does feel wrong from pure API side.\nI could either just go with nested callback or create a transport layer only action to clear both caches. So it is not exposed at REST layer and still has the efficiency on transport layer. But this does lead some code redundancy. Another option is to have a query parameter for the clear privilege cache API. When set to true, it clears both caches. What do you think?", "author": "ywangd", "createdAt": "2020-04-30T06:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA4MzI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MDMyNA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417090324", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        privilegesStore.invalidate(Arrays.asList(request.getApplicationNames()));\n          \n          \n            \n                        privilegesStore.invalidate(List.of(request.getApplicationNames()));", "author": "tvernum", "createdAt": "2020-04-29T06:23:32Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.privilege;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TransportClearPrivilegesCacheAction extends TransportNodesAction<ClearPrivilegesCacheRequest, ClearPrivilegesCacheResponse,\n+    ClearPrivilegesCacheRequest.Node, ClearPrivilegesCacheResponse.Node> {\n+\n+    private final NativePrivilegeStore privilegesStore;\n+    private final CompositeRolesStore rolesStore;\n+\n+    @Inject\n+    public TransportClearPrivilegesCacheAction(\n+        ThreadPool threadPool,\n+        ClusterService clusterService,\n+        TransportService transportService,\n+        ActionFilters actionFilters,\n+        NativePrivilegeStore privilegesStore,\n+        CompositeRolesStore rolesStore) {\n+        super(\n+            ClearPrivilegesCacheAction.NAME,\n+            threadPool,\n+            clusterService,\n+            transportService,\n+            actionFilters,\n+            ClearPrivilegesCacheRequest::new,\n+            ClearPrivilegesCacheRequest.Node::new,\n+            ThreadPool.Names.MANAGEMENT,\n+            ClearPrivilegesCacheResponse.Node.class);\n+        this.privilegesStore = privilegesStore;\n+        this.rolesStore = rolesStore;\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse newResponse(\n+        ClearPrivilegesCacheRequest request, List<ClearPrivilegesCacheResponse.Node> nodes, List<FailedNodeException> failures) {\n+        return new ClearPrivilegesCacheResponse(clusterService.getClusterName(), nodes, failures);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheRequest.Node newNodeRequest(ClearPrivilegesCacheRequest request) {\n+        return new ClearPrivilegesCacheRequest.Node(request);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node newNodeResponse(StreamInput in) throws IOException {\n+        return new ClearPrivilegesCacheResponse.Node(in);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node nodeOperation(ClearPrivilegesCacheRequest.Node request, Task task) {\n+        if (request.getApplicationNames() == null || request.getApplicationNames().length == 0) {\n+            privilegesStore.invalidateAll();\n+        } else {\n+            privilegesStore.invalidate(Arrays.asList(request.getApplicationNames()));", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTE5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417091192", "bodyText": "Separate to this PR, it feels like we could consolidate these duplicate classes into a common base class.", "author": "tvernum", "createdAt": "2020-04-29T06:26:12Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/privilege/ClearPrivilegesCacheResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action.privilege;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.nodes.BaseNodeResponse;\n+import org.elasticsearch.action.support.nodes.BaseNodesResponse;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class ClearPrivilegesCacheResponse extends BaseNodesResponse<ClearPrivilegesCacheResponse.Node>", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMDM1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r419220357", "bodyText": "A common base class for all ClearXxxCacheResponse?", "author": "ywangd", "createdAt": "2020-05-04T05:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMDg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431610879", "bodyText": "Yes. Not a priority, but there's a bunch of copy paste here that we could ditch.", "author": "tvernum", "createdAt": "2020-05-28T06:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417091649", "bodyText": "Where do we call this? I think we should avoid having this method if we can.", "author": "tvernum", "createdAt": "2020-04-29T06:27:35Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/CacheIteratorHelper.java", "diffHunk": "@@ -56,4 +56,17 @@ public void removeKeysIf(Predicate<K> removeIf) {\n             }\n         }\n     }\n+\n+    public void removeValuesIf(Predicate<V> removeIf) {", "originalCommit": "1c58309b87b38718e10825eb15b9344ae9b38912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NDIzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417784231", "bodyText": "This is indeed not needed anymore. Will remove.", "author": "ywangd", "createdAt": "2020-04-30T06:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTY0OQ=="}], "type": "inlineReview"}, {"oid": "9100c24ceca158023ef2059ef0a16fea9c57f91c", "url": "https://github.com/elastic/elasticsearch/commit/9100c24ceca158023ef2059ef0a16fea9c57f91c", "message": "WIP", "committedDate": "2020-04-30T02:39:32Z", "type": "commit"}, {"oid": "3f9c5b7688845a6b301d683967d3d77207da35cb", "url": "https://github.com/elastic/elasticsearch/commit/3f9c5b7688845a6b301d683967d3d77207da35cb", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-Authored-By: Tim Vernum <tim@adjective.org>", "committedDate": "2020-04-30T06:24:10Z", "type": "commit"}, {"oid": "08865ddb8c0773b5bc38caef85a2a8ecf9b38b7f", "url": "https://github.com/elastic/elasticsearch/commit/08865ddb8c0773b5bc38caef85a2a8ecf9b38b7f", "message": "Merge branch 'es-54317-app-privilege-cache' of github.com:ywangd/elasticsearch into es-54317-app-privilege-cache", "committedDate": "2020-04-30T06:25:00Z", "type": "commit"}, {"oid": "b9538a8692484fe98164a5ee465ffa99076a5ecd", "url": "https://github.com/elastic/elasticsearch/commit/b9538a8692484fe98164a5ee465ffa99076a5ecd", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java\n\nCo-Authored-By: Tim Vernum <tim@adjective.org>", "committedDate": "2020-04-30T06:32:18Z", "type": "commit"}, {"oid": "9c5e94761e40d1847576f0c99cf1b10b8604513b", "url": "https://github.com/elastic/elasticsearch/commit/9c5e94761e40d1847576f0c99cf1b10b8604513b", "message": "Merge branch 'es-54317-app-privilege-cache' of github.com:ywangd/elasticsearch into es-54317-app-privilege-cache", "committedDate": "2020-04-30T06:34:40Z", "type": "commit"}, {"oid": "f5b166c9d734f2d62fa0a485a776d9bdc742d0bb", "url": "https://github.com/elastic/elasticsearch/commit/f5b166c9d734f2d62fa0a485a776d9bdc742d0bb", "message": "WIP", "committedDate": "2020-04-30T06:40:25Z", "type": "commit"}, {"oid": "1e7ce7c2c3f46c4be7849187acff2912184850e0", "url": "https://github.com/elastic/elasticsearch/commit/1e7ce7c2c3f46c4be7849187acff2912184850e0", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-04-30T12:13:22Z", "type": "commit"}, {"oid": "f1f3e728644dc5e07eaccbef2f341fb6d368bb7d", "url": "https://github.com/elastic/elasticsearch/commit/f1f3e728644dc5e07eaccbef2f341fb6d368bb7d", "message": "Address feedback", "committedDate": "2020-04-30T12:26:16Z", "type": "commit"}, {"oid": "a7b5b409e6e9fb4a4a88a4ebbbb1d6f1f49a877a", "url": "https://github.com/elastic/elasticsearch/commit/a7b5b409e6e9fb4a4a88a4ebbbb1d6f1f49a877a", "message": "Checkstyle", "committedDate": "2020-04-30T12:36:57Z", "type": "commit"}, {"oid": "5306bc13d3f368cf7ed26a4c4a12b3bac09a9eab", "url": "https://github.com/elastic/elasticsearch/commit/5306bc13d3f368cf7ed26a4c4a12b3bac09a9eab", "message": "Address feedback", "committedDate": "2020-05-04T03:27:17Z", "type": "commit"}, {"oid": "03680bc9891557553be743288523860c71fa26be", "url": "https://github.com/elastic/elasticsearch/commit/03680bc9891557553be743288523860c71fa26be", "message": "Skip yaml tests for 7.x", "committedDate": "2020-05-04T04:26:45Z", "type": "commit"}, {"oid": "cdfe886b0920685089581ed4d7c391a261355d1f", "url": "https://github.com/elastic/elasticsearch/commit/cdfe886b0920685089581ed4d7c391a261355d1f", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-05-04T04:27:16Z", "type": "commit"}, {"oid": "435993df091f77e2f25a5460d7854003a482a5aa", "url": "https://github.com/elastic/elasticsearch/commit/435993df091f77e2f25a5460d7854003a482a5aa", "message": "Fix yaml tests", "committedDate": "2020-05-04T04:47:09Z", "type": "commit"}, {"oid": "20be80d5e9ecc72936533b6797a79406ba415213", "url": "https://github.com/elastic/elasticsearch/commit/20be80d5e9ecc72936533b6797a79406ba415213", "message": "Add HLRC relevant files", "committedDate": "2020-05-04T05:28:02Z", "type": "commit"}, {"oid": "d2f2f3eeeb122b29b4d12defd8f9f4f0e5500b57", "url": "https://github.com/elastic/elasticsearch/commit/d2f2f3eeeb122b29b4d12defd8f9f4f0e5500b57", "message": "check style", "committedDate": "2020-05-04T05:38:39Z", "type": "commit"}, {"oid": "f1f7035fb45ceeefeda9d006ca7ae96ae7549d50", "url": "https://github.com/elastic/elasticsearch/commit/f1f7035fb45ceeefeda9d006ca7ae96ae7549d50", "message": "Fix broken docs", "committedDate": "2020-05-04T06:32:53Z", "type": "commit"}, {"oid": "db6020eef6900835ea5ed094f76967db28b8302e", "url": "https://github.com/elastic/elasticsearch/commit/db6020eef6900835ea5ed094f76967db28b8302e", "message": "Add bwc for the new transport action", "committedDate": "2020-05-04T23:11:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4MzEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r419783106", "bodyText": "Added BWC handling.", "author": "ywangd", "createdAt": "2020-05-04T23:16:18Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.privilege;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TransportClearPrivilegesCacheAction extends TransportNodesAction<ClearPrivilegesCacheRequest, ClearPrivilegesCacheResponse,\n+    ClearPrivilegesCacheRequest.Node, ClearPrivilegesCacheResponse.Node> {\n+\n+    private final NativePrivilegeStore privilegesStore;\n+    private final CompositeRolesStore rolesStore;\n+\n+    @Inject\n+    public TransportClearPrivilegesCacheAction(\n+        ThreadPool threadPool,\n+        ClusterService clusterService,\n+        TransportService transportService,\n+        ActionFilters actionFilters,\n+        NativePrivilegeStore privilegesStore,\n+        CompositeRolesStore rolesStore) {\n+        super(\n+            ClearPrivilegesCacheAction.NAME,\n+            threadPool,\n+            clusterService,\n+            transportService,\n+            actionFilters,\n+            ClearPrivilegesCacheRequest::new,\n+            ClearPrivilegesCacheRequest.Node::new,\n+            ThreadPool.Names.MANAGEMENT,\n+            ClearPrivilegesCacheResponse.Node.class);\n+        this.privilegesStore = privilegesStore;\n+        this.rolesStore = rolesStore;\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse newResponse(\n+        ClearPrivilegesCacheRequest request, List<ClearPrivilegesCacheResponse.Node> nodes, List<FailedNodeException> failures) {\n+        return new ClearPrivilegesCacheResponse(clusterService.getClusterName(), nodes, failures);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheRequest.Node newNodeRequest(ClearPrivilegesCacheRequest request) {\n+        return new ClearPrivilegesCacheRequest.Node(request);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node newNodeResponse(StreamInput in) throws IOException {\n+        return new ClearPrivilegesCacheResponse.Node(in);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node nodeOperation(ClearPrivilegesCacheRequest.Node request, Task task) {\n+        if (request.getApplicationNames() == null || request.getApplicationNames().length == 0) {\n+            privilegesStore.invalidateAll();\n+        } else {\n+            privilegesStore.invalidate(List.of(request.getApplicationNames()));\n+        }\n+        if (request.isClearRolesCache()) {\n+            rolesStore.invalidateAll();\n+        }\n+        return new ClearPrivilegesCacheResponse.Node(clusterService.localNode());\n+    }\n+\n+    @Override\n+    protected void resolveRequest(ClearPrivilegesCacheRequest request, ClusterState clusterState) {\n+        assert request.concreteNodes() == null : \"request concreteNodes shouldn't be set\";\n+        String[] nodesIds = clusterState.nodes().resolveNodes(request.nodesIds());\n+        // TODO: version needs to be updated once 7.x backport is in place\n+        request.setConcreteNodes(Arrays.stream(nodesIds).map(clusterState.nodes()::get)\n+            .filter(node -> node.getVersion().onOrAfter(Version.V_8_0_0)).toArray(DiscoveryNode[]::new));", "originalCommit": "db6020eef6900835ea5ed094f76967db28b8302e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NzY1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r419797659", "bodyText": "Do we need a ReplacedRoute here similar to the one in clear role cache action? i.e.:\n\n  \n    \n      elasticsearch/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/role/RestClearRolesCacheAction.java\n    \n    \n        Lines 36 to 37\n      in\n      022d3d7\n    \n    \n    \n    \n\n        \n          \n           return Collections.singletonList(new ReplacedRoute(POST, \"/_security/role/{name}/_clear_cache\", POST, \n        \n\n        \n          \n               \"/_xpack/security/role/{name}/_clear_cache\")); \n        \n    \n  \n\n\nMy understanding is that the ReplacedRoute was needed because of xpack migration into main repo and is not necessary for new APIs. So I didn't add it here.", "author": "ywangd", "createdAt": "2020-05-05T00:04:35Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/privilege/RestClearPrivilegesAction.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.privilege;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestActions.NodesResponseRestListener;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.security.rest.action.SecurityBaseRestHandler;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+\n+public class RestClearPrivilegesAction extends SecurityBaseRestHandler {\n+\n+    public RestClearPrivilegesAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"security_clear_privileges_cache_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return Collections.singletonList(new Route(POST, \"/_security/privilege/{application}/_clear_cache\"));", "originalCommit": "db6020eef6900835ea5ed094f76967db28b8302e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "73dda1fecc2d32e45faf34b6aefafd866e65fdc3", "url": "https://github.com/elastic/elasticsearch/commit/73dda1fecc2d32e45faf34b6aefafd866e65fdc3", "message": "Add working rolling upgrade mixed-cluster tests for privilege cache clearing", "committedDate": "2020-05-05T02:06:17Z", "type": "commit"}, {"oid": "ea9172f4cef32ddc4829cdf2bd44d197748618f8", "url": "https://github.com/elastic/elasticsearch/commit/ea9172f4cef32ddc4829cdf2bd44d197748618f8", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-05-05T02:06:35Z", "type": "commit"}, {"oid": "65f9524627fcaaadd7ec6350a36fbf20738980d5", "url": "https://github.com/elastic/elasticsearch/commit/65f9524627fcaaadd7ec6350a36fbf20738980d5", "message": "Remove bwc handling code and simply report no handler", "committedDate": "2020-05-05T03:56:23Z", "type": "commit"}, {"oid": "04bb476648b14a9390e392d367d5f33d59e9e49c", "url": "https://github.com/elastic/elasticsearch/commit/04bb476648b14a9390e392d367d5f33d59e9e49c", "message": "Checkstyle", "committedDate": "2020-05-05T04:02:07Z", "type": "commit"}, {"oid": "07b7837c4284d40541d51eba66d431dc9680d80c", "url": "https://github.com/elastic/elasticsearch/commit/07b7837c4284d40541d51eba66d431dc9680d80c", "message": "Clear privilege cache on security index changes", "committedDate": "2020-05-15T01:12:05Z", "type": "commit"}, {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "url": "https://github.com/elastic/elasticsearch/commit/34464d73dbe7fabc0e1ac39ea8877666740f1b22", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-05-15T01:12:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNzc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431607798", "bodyText": "Should the docs have a callout <1> for the application name?", "author": "tvernum", "createdAt": "2020-05-28T06:27:10Z", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/documentation/SecurityDocumentationIT.java", "diffHunk": "@@ -1003,6 +1005,52 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    public void testClearPrivilegesCache() throws Exception {\n+        RestHighLevelClient client = highLevelClient();\n+        {\n+            //tag::clear-privileges-cache-request\n+            ClearPrivilegesCacheRequest request = new ClearPrivilegesCacheRequest(\"my_app\");", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMDM0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431610347", "bodyText": "I don't like that this method follow bean conventions, but applicationNames doesn't. Can we pick one style?\nSpeaking personally, I think isClearRolesCache reads poorly, and clearRolesCache or shouldClearRolesCache are better.", "author": "tvernum", "createdAt": "2020-05-28T06:33:41Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/privilege/ClearPrivilegesCacheRequest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action.privilege;\n+\n+import org.elasticsearch.action.support.nodes.BaseNodesRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.io.IOException;\n+\n+public class ClearPrivilegesCacheRequest extends BaseNodesRequest<ClearPrivilegesCacheRequest> {\n+\n+    private String[] applicationNames;\n+    private boolean clearRolesCache = false;\n+\n+    public ClearPrivilegesCacheRequest() {\n+        super((String[]) null);\n+    }\n+\n+    public ClearPrivilegesCacheRequest(StreamInput in) throws IOException {\n+        super(in);\n+        applicationNames = in.readOptionalStringArray();\n+        clearRolesCache = in.readBoolean();\n+    }\n+\n+    public ClearPrivilegesCacheRequest applicationNames(String... applicationNames) {\n+        this.applicationNames = applicationNames;\n+        return this;\n+    }\n+\n+    public ClearPrivilegesCacheRequest clearRolesCache(boolean clearRolesCache) {\n+        this.clearRolesCache = clearRolesCache;\n+        return this;\n+    }\n+\n+    public String[] applicationNames() {\n+        return applicationNames;\n+    }\n+\n+    public boolean isClearRolesCache() {", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1ODgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432458836", "bodyText": "You are right. I'll change it to clearRolesCache, which feels more consistent with overall naming style of request classes.", "author": "ywangd", "createdAt": "2020-05-29T12:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMDM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY0NTA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431645047", "bodyText": "I don't follow this comment.", "author": "tvernum", "createdAt": "2020-05-28T07:48:12Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -410,6 +410,7 @@ public static void buildRoleFromDescriptors(Collection<RoleDescriptor> roleDescr\n             final Set<String> applicationPrivilegeNames = applicationPrivilegesMap.values().stream()\n                     .flatMap(Collection::stream)\n                     .collect(Collectors.toSet());\n+            // Role itself is cached, so skipping caching for application privileges", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4ODk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432288977", "bodyText": "Good catch! This comment is obsolete and should be removed. It is for the initial iteration where I tried to separate this usages from others.", "author": "ywangd", "createdAt": "2020-05-29T06:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY0NTA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NjU1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431686559", "bodyText": "Why is this a LinkedHashSet? I don't understand why the original order would matter for the cache key.", "author": "tvernum", "createdAt": "2020-05-28T08:59:47Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ3Mjk4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432472983", "bodyText": "hmm I have no idea now. It was previously Set.copyOf, but somehow I changed it to LinkedHashSet last time I made the change to \"always fetch for all requested applications if we have to hit the index\". Maybe I was trying to experimenting something. Cannot remember ... I'll change it back to Set.copyOf.", "author": "ywangd", "createdAt": "2020-05-29T13:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NjU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxOTYzNA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431819634", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"returning empty application privileges as application names result in empty list\");\n          \n          \n            \n                        logger.debug(\"returning empty application privileges for [{}] as application names result in empty list\",\n          \n          \n            \n                            applicationNamesCacheKey);", "author": "tvernum", "createdAt": "2020-05-28T13:06:43Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);\n+\n+        // Always fetch for the concrete application names even when the passed-in application names has no wildcard.\n+        // This serves as a negative lookup, i.e. when a passed-in non-wildcard application does not exist.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxOTk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431819941", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"All application privileges found in cache\");\n          \n          \n            \n                            logger.debug(\"All application privileges for [{}] found in cache\", applicationNamesCacheKey);", "author": "tvernum", "createdAt": "2020-05-28T13:07:12Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);\n+\n+        // Always fetch for the concrete application names even when the passed-in application names has no wildcard.\n+        // This serves as a negative lookup, i.e. when a passed-in non-wildcard application does not exist.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+        } else {\n+            final Set<ApplicationPrivilegeDescriptor> cachedDescriptors = cachedDescriptorsForApplicationNames(\n+                concreteApplicationNames != null ? concreteApplicationNames : applicationNamesCacheKey);\n+            if (cachedDescriptors != null) {\n+                logger.debug(\"All application privileges found in cache\");", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NjAyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431866021", "bodyText": "That's a weird mix of assert and require.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assert Objects.requireNonNull(applications).isEmpty() == false;\n          \n          \n            \n                    assert applications != null && applications.size() > 0 : \"Application names are required (found \" + applications + \")\";", "author": "tvernum", "createdAt": "2020-05-28T14:12:14Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);\n+\n+        // Always fetch for the concrete application names even when the passed-in application names has no wildcard.\n+        // This serves as a negative lookup, i.e. when a passed-in non-wildcard application does not exist.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+        } else {\n+            final Set<ApplicationPrivilegeDescriptor> cachedDescriptors = cachedDescriptorsForApplicationNames(\n+                concreteApplicationNames != null ? concreteApplicationNames : applicationNamesCacheKey);\n+            if (cachedDescriptors != null) {\n+                logger.debug(\"All application privileges found in cache\");\n+                listener.onResponse(filterDescriptorsForPrivilegeNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", applicationNamesCacheKey);\n+                innerGetPrivileges(applicationNamesCacheKey, ActionListener.wrap(fetchedDescriptors -> {\n+                    final Map<String, Set<ApplicationPrivilegeDescriptor>> mapOfFetchedDescriptors = fetchedDescriptors.stream()\n+                        .collect(Collectors.groupingBy(ApplicationPrivilegeDescriptor::getApplication, Collectors.toUnmodifiableSet()));\n+                    // Avoid caching potential stale results.\n+                    // TODO: It is still possible that cache gets invalidated immediately after the if check\n+                    if (invalidationCounter == numInvalidation.get()) {\n+                        final Set<String> fetchedApplicationNames = Collections.unmodifiableSet(mapOfFetchedDescriptors.keySet());\n+                        // Do not cache the names if expansion has no effect\n+                        if (fetchedApplicationNames.equals(applicationNamesCacheKey) == false) {\n+                            logger.debug(\"Caching application names query: {} = {}\", applicationNamesCacheKey, fetchedApplicationNames);\n+                            applicationNamesCache.put(applicationNamesCacheKey, fetchedApplicationNames);\n+                        }\n+                        for (Map.Entry<String, Set<ApplicationPrivilegeDescriptor>> entry : mapOfFetchedDescriptors.entrySet()) {\n+                            logger.debug(\"Caching descriptors for application: {}\", entry.getKey());\n+                            descriptorsCache.put(entry.getKey(), entry.getValue());\n+                        }\n+                    }\n+                    listener.onResponse(filterDescriptorsForPrivilegeNames(fetchedDescriptors, names));\n+                }, listener::onFailure));\n+            }\n+        }\n+    }\n+\n+    private void innerGetPrivileges(Collection<String> applications,\n+        ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+        assert Objects.requireNonNull(applications).isEmpty() == false;", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NzIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431867230", "bodyText": "Nit: I think the order of the methods in this file is a bit random.\nThis probably should be after innerGetPrivileges since it's an implementation detail of that method.", "author": "tvernum", "createdAt": "2020-05-28T14:13:55Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,25 +195,75 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?\n                     ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener),\n                         hit -> buildPrivilege(hit.getId(), hit.getSourceRef()));\n                 }\n             });\n         }\n     }\n \n-    private boolean isSinglePrivilegeMatch(Collection<String> applications, Collection<String> names) {\n-        return applications != null && applications.size() == 1 && hasWildcard(applications) == false && names != null && names.size() == 1;\n+    public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            invalidateAll();\n+        }\n     }\n \n-    private boolean hasWildcard(Collection<String> applications) {\n-        return applications.stream().anyMatch(n -> n.endsWith(\"*\"));\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        numInvalidation.incrementAndGet();\n+        // Always completely invalidate application names cache due to wildcard\n+        applicationNamesCache.invalidateAll();\n+        final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);\n+        uniqueNames.forEach(descriptorsCache::invalidate);\n     }\n \n-    private QueryBuilder getPrivilegeNameQuery(Collection<String> names) {\n-        return QueryBuilders.termsQuery(ApplicationPrivilegeDescriptor.Fields.NAME.getPreferredName(), names);\n+    public void invalidateAll() {\n+        logger.debug(\"Invalidating all application privileges caches\");\n+        numInvalidation.incrementAndGet();\n+        applicationNamesCache.invalidateAll();\n+        descriptorsCache.invalidateAll();\n+    }\n+\n+    /**\n+     * Try resolve all privileges for given application names from the cache.\n+     * It returns non-null result only when privileges of ALL applications are\n+     * found in the cache, i.e. it returns null if any of application name is\n+     * NOT found in the cache. Since the cached is keyed by concrete application\n+     * name, this means any wildcard will result in null.\n+     */\n+    private Set<ApplicationPrivilegeDescriptor> cachedDescriptorsForApplicationNames(Set<String> applicationNames) {\n+\n+        final Set<ApplicationPrivilegeDescriptor> cachedDescriptors = new HashSet<>();\n+        for (String applicationName: applicationNames) {\n+            if (applicationName.endsWith(\"*\")) {\n+                return null;\n+            } else {\n+                final Set<ApplicationPrivilegeDescriptor> descriptors = descriptorsCache.get(applicationName);\n+                if (descriptors == null) {\n+                    return null;\n+                } else {\n+                    cachedDescriptors.addAll(descriptors);\n+                }\n+            }\n+        }\n+        return Collections.unmodifiableSet(cachedDescriptors);\n+    }\n+\n+    /**\n+     * Filter to get all privilege descriptors that have any of the given privilege names.\n+     */\n+    private Collection<ApplicationPrivilegeDescriptor> filterDescriptorsForPrivilegeNames(\n+        Collection<ApplicationPrivilegeDescriptor> descriptors, Collection<String> privilegeNames) {\n+        // empty set of names equals to retrieve everything\n+        if (isEmpty(privilegeNames)) {\n+            return descriptors;\n+        }\n+        return descriptors.stream().filter(d -> privilegeNames.contains(d.getName())).collect(Collectors.toUnmodifiableSet());\n     }\n \n     private QueryBuilder getApplicationNameQuery(Collection<String> applications) {", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ4MDAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432480022", "bodyText": "Not sure If I understand correctly, but this method (L269) is already after innerGetPrivileges (L173).\nIn terms of overall method ordering, I have seen two preferences: 1) order by visibility with public first and private last; 2) group by related functions with public methods followed by their supporting private methods.\nMy impression is the ES code base loosely follows option 2. This file is example of it. Do we have a recommended style?", "author": "ywangd", "createdAt": "2020-05-29T13:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NzIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNjE3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r433006172", "bodyText": "Sorry, I was a bit loose with my terminology.\ngetApplicationNameQuery is after innerGetPrivileges, but not immediately after.\nI see\n\ninnerGetPrivileges\nonSecurityIndexStateChange\ninvalidate\ninvalidateAll\ncachedDescriptorsForApplicationNames\nfilterDescriptorsForPrivilegeNames\ngetApplicationNameQuery\n\nI can't see any pattern to that order.", "author": "tvernum", "createdAt": "2020-06-01T01:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NzIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyMDU3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r433820572", "bodyText": "Thanks for the elaboration. I tried to organise them by following option 2. Private methods are listed after the public methods that are the callers. The result is as follows:\npublic void getPrivileges\nprivate void innerGetPrivileges\nprivate QueryBuilder getApplicationNameQuery\nprivate ApplicationPrivilegeDescriptor buildPrivilege\nprivate Set<ApplicationPrivilegeDescriptor> cachedDescriptorsForApplicationNames\nprivate Collection<ApplicationPrivilegeDescriptor> filterDescriptorsForPrivilegeNames\n\npublic void putPrivileges\nprivate void innerPutPrivilege\n\npublic void deletePrivileges\nprivate <T> void clearCaches\nprivate static Tuple<String, String> nameFromDocId\nprivate static String toDocId\n\npublic void onSecurityIndexStateChange\npublic void invalidate\npublic void invalidateAll\n\nprivate static boolean isEmpty\nDoes above ordering look reasonable to you?", "author": "ywangd", "createdAt": "2020-06-02T11:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NzIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2ODcwNA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431868704", "bodyText": "I don't think we need this TODO do we?\nI think in this context it's simpler to parse everything than try and track doc changes (because we trust the cache if it's populated, we only go to the index when the cache is missing something).", "author": "tvernum", "createdAt": "2020-05-28T14:15:59Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,25 +195,75 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ4MjEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432482123", "bodyText": "You are right. I wrote the Todo when I was trying out a few optimisation ideas, e.g.: 1) only fetch things that are missing in cache; 2) fetch everything but only parsing what is missing in cache;\nBut later we decided to simplify things by always fetching everything if we have to hit the index and repopulate the cache to make sure it is always up to date. So this todo is no longer necessary.", "author": "ywangd", "createdAt": "2020-05-29T13:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2ODcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzE0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432237143", "bodyText": "Should the action names be different? It seems hard to check that the right value is cached when they're all the same.", "author": "tvernum", "createdAt": "2020-05-29T03:32:20Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNjkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432536901", "bodyText": "I made them differently by prefixing the values.", "author": "ywangd", "createdAt": "2020-05-29T14:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzc3OA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432237778", "bodyText": "I think this is a sign that this test shouldn't be an integration test like this. If it weren't quite so integrated you would be able to spy on the client used by the privilege store.", "author": "tvernum", "createdAt": "2020-05-29T03:35:30Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"read\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"write\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"admin\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()));\n+\n+        final PutPrivilegesRequest putPrivilegesRequest = new PutPrivilegesRequest();\n+        putPrivilegesRequest.setPrivileges(applicationPrivilegeDescriptors);\n+        final ActionFuture<PutPrivilegesResponse> future =\n+            client().execute(PutPrivilegesAction.INSTANCE, putPrivilegesRequest);\n+\n+        final PutPrivilegesResponse putPrivilegesResponse = future.actionGet();\n+        assertEquals(2, putPrivilegesResponse.created().size());\n+        assertEquals(6, putPrivilegesResponse.created().values().stream().mapToInt(List::size).sum());\n+    }\n+\n+    public void testGetPrivileges() {\n+        final Client client = client();\n+\n+        ApplicationPrivilegeDescriptor[] privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"write\").execute().actionGet().privileges();\n+\n+        assertEquals(1, privileges.length);\n+        assertEquals(\"app-2\", privileges[0].getApplication());\n+        assertEquals(\"write\", privileges[0].getName());\n+\n+        // A hacky way to test cache is populated and used by deleting the backing documents.\n+        // The test will fail if the cache is not in place", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzODA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432238042", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testGetPrivileges() {\n          \n          \n            \n                public void testGetPrivilegesUsesCache() {", "author": "tvernum", "createdAt": "2020-05-29T03:36:50Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"read\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"write\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"admin\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()));\n+\n+        final PutPrivilegesRequest putPrivilegesRequest = new PutPrivilegesRequest();\n+        putPrivilegesRequest.setPrivileges(applicationPrivilegeDescriptors);\n+        final ActionFuture<PutPrivilegesResponse> future =\n+            client().execute(PutPrivilegesAction.INSTANCE, putPrivilegesRequest);\n+\n+        final PutPrivilegesResponse putPrivilegesResponse = future.actionGet();\n+        assertEquals(2, putPrivilegesResponse.created().size());\n+        assertEquals(6, putPrivilegesResponse.created().values().stream().mapToInt(List::size).sum());\n+    }\n+\n+    public void testGetPrivileges() {", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzODc1OA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432238758", "bodyText": "Something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testWildcard() {\n          \n          \n            \n                public void testPopulationOfCacheWhenLoadingPrivilegesForAllApplications() {\n          \n      \n    \n    \n  \n\n?", "author": "tvernum", "createdAt": "2020-05-29T03:39:58Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"read\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"write\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"admin\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()));\n+\n+        final PutPrivilegesRequest putPrivilegesRequest = new PutPrivilegesRequest();\n+        putPrivilegesRequest.setPrivileges(applicationPrivilegeDescriptors);\n+        final ActionFuture<PutPrivilegesResponse> future =\n+            client().execute(PutPrivilegesAction.INSTANCE, putPrivilegesRequest);\n+\n+        final PutPrivilegesResponse putPrivilegesResponse = future.actionGet();\n+        assertEquals(2, putPrivilegesResponse.created().size());\n+        assertEquals(6, putPrivilegesResponse.created().values().stream().mapToInt(List::size).sum());\n+    }\n+\n+    public void testGetPrivileges() {\n+        final Client client = client();\n+\n+        ApplicationPrivilegeDescriptor[] privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"write\").execute().actionGet().privileges();\n+\n+        assertEquals(1, privileges.length);\n+        assertEquals(\"app-2\", privileges[0].getApplication());\n+        assertEquals(\"write\", privileges[0].getName());\n+\n+        // A hacky way to test cache is populated and used by deleting the backing documents.\n+        // The test will fail if the cache is not in place\n+        assertFalse(client.prepareBulk()\n+            .add(new DeleteRequest(SECURITY_MAIN_ALIAS, DOC_TYPE_VALUE + \"_app-2:read\"))\n+            .add(new DeleteRequest(SECURITY_MAIN_ALIAS, DOC_TYPE_VALUE + \"_app-2:write\"))\n+            .add(new DeleteRequest(SECURITY_MAIN_ALIAS, DOC_TYPE_VALUE + \"_app-2:admin\"))\n+            .setRefreshPolicy(IMMEDIATE).execute().actionGet().hasFailures());\n+\n+        // We can still get the privileges because it is cached\n+        privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"read\").execute().actionGet().privileges();\n+\n+        assertEquals(1, privileges.length);\n+\n+        // We can get all app-2 privileges because cache is keyed by application\n+        privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").execute().actionGet().privileges();\n+\n+        assertEquals(3, privileges.length);\n+\n+        // Now properly invalidate the cache\n+        final ClearPrivilegesCacheResponse clearPrivilegesCacheResponse =\n+            client.execute(ClearPrivilegesCacheAction.INSTANCE, new ClearPrivilegesCacheRequest()).actionGet();\n+        assertFalse(clearPrivilegesCacheResponse.hasFailures());\n+\n+        // app-2 is no longer found\n+        privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"read\").execute().actionGet().privileges();\n+        assertEquals(0, privileges.length);\n+    }\n+\n+    public void testWildcard() {", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzOTQ0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432239442", "bodyText": "Why did this test get removed?\nIsn't that still a valid scenario?", "author": "tvernum", "createdAt": "2020-05-29T03:43:09Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreTests.java", "diffHunk": "@@ -114,42 +118,27 @@ public void cleanup() {\n     }\n \n     public void testGetSinglePrivilegeByName() throws Exception {\n-        final ApplicationPrivilegeDescriptor sourcePrivilege = new ApplicationPrivilegeDescriptor(\"myapp\", \"admin\",\n-            newHashSet(\"action:admin/*\", \"action:login\", \"data:read/*\"), emptyMap()\n-        );\n-\n-        final PlainActionFuture<ApplicationPrivilegeDescriptor> future = new PlainActionFuture<>();\n-        store.getPrivilege(\"myapp\", \"admin\", future);\n-        assertThat(requests, iterableWithSize(1));\n-        assertThat(requests.get(0), instanceOf(GetRequest.class));\n-        GetRequest request = (GetRequest) requests.get(0);\n-        assertThat(request.index(), equalTo(RestrictedIndicesNames.SECURITY_MAIN_ALIAS));\n-        assertThat(request.id(), equalTo(\"application-privilege_myapp:admin\"));\n-\n-        final String docSource = Strings.toString(sourcePrivilege);\n-        listener.get().onResponse(new GetResponse(\n-            new GetResult(request.index(), request.id(), 0, 1, 1L, true,\n-                new BytesArray(docSource), emptyMap(), emptyMap())\n+        final List<ApplicationPrivilegeDescriptor> sourcePrivileges = List.of(\n+            new ApplicationPrivilegeDescriptor(\"myapp\", \"admin\",\n+                newHashSet(\"action:admin/*\", \"action:login\", \"data:read/*\"), emptyMap()\n         ));\n-        final ApplicationPrivilegeDescriptor getPrivilege = future.get(1, TimeUnit.SECONDS);\n-        assertThat(getPrivilege, equalTo(sourcePrivilege));\n-    }\n \n-    public void testGetMissingPrivilege() throws Exception {", "originalCommit": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUyOTA0NA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432529044", "bodyText": "The method under tests, NativePrivilegeStore#getPrivilege, is removed. So there test is no longer necessary.\nNativePrivilegeStore#getPrivilege is removed because the code now always fetch all privileges for an application for caching purpose.", "author": "ywangd", "createdAt": "2020-05-29T14:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzOTQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNjY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r433006644", "bodyText": "Do we have a test somewhere for\npublic void getPrivileges(Collection<String> applications, \n                          Collection<String> names,\n                          ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener)\n\nwhen the application exists but none of the privilege names do? That feels like something worth testing.", "author": "tvernum", "createdAt": "2020-06-01T01:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzOTQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0NDY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r433844690", "bodyText": "I added back a modified version of testGetMissingPrivilege. But then I think it is not really necessary. Please let me explain:\nThe code now always issue a search request, from end result's perspective, the difference really is just how many SearchHit is returned. It could be 0, 1 or N. What you described here is a case of 0. There are other cases of 0 hits, e.g. non-existent application, but they are not different in terms of search response.\nSearch response is turned into a collection of ApplicationPrivilegeDescriptor by buildPrivilege and ScrollHelper#fetchAllByEntity. What we do want test is buildPrivilege since it is part of the class and it is only relevant when SearchHit is greater than 0, because when there is no SearchHit, it won't get executed at all and we probably can trust ScrollHelper to do its job by returning an empty list.\nI guess this is probably why both testGetPrivilegesByWildcardApplicationName and testGetPrivilegesByStarApplicationName did not bother to test the future results (since they are just empty lists). And one could say they already suffice to be tests for 0 SearchHit.\nWith above being said, I decided to keep testGetMissingPrivilege since it is already added and an extra test is not a bad thing.", "author": "ywangd", "createdAt": "2020-06-02T12:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzOTQ0Mg=="}], "type": "inlineReview"}, {"oid": "e87d8974b248a20d5947facd397d7b2b9bb206bb", "url": "https://github.com/elastic/elasticsearch/commit/e87d8974b248a20d5947facd397d7b2b9bb206bb", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-05-29T06:58:14Z", "type": "commit"}, {"oid": "5acc7ec3738dc134013ff5f7ab955ee95b330779", "url": "https://github.com/elastic/elasticsearch/commit/5acc7ec3738dc134013ff5f7ab955ee95b330779", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-05-29T06:58:42Z", "type": "commit"}, {"oid": "5e3174a6b8a3ecf6591e3c68bc51195d8d177a06", "url": "https://github.com/elastic/elasticsearch/commit/5e3174a6b8a3ecf6591e3c68bc51195d8d177a06", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-05-29T13:15:02Z", "type": "commit"}, {"oid": "385fb124c868d55fe903db2d732e875364135231", "url": "https://github.com/elastic/elasticsearch/commit/385fb124c868d55fe903db2d732e875364135231", "message": "Update x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-05-29T14:23:54Z", "type": "commit"}, {"oid": "e411dc9254178c9b7a389d5c90a5922abdf7cdbd", "url": "https://github.com/elastic/elasticsearch/commit/e411dc9254178c9b7a389d5c90a5922abdf7cdbd", "message": "Update x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-05-29T14:24:21Z", "type": "commit"}, {"oid": "58b3942a138c135a4ed9caeeaf4c83e38e59336e", "url": "https://github.com/elastic/elasticsearch/commit/58b3942a138c135a4ed9caeeaf4c83e38e59336e", "message": "Address feedback", "committedDate": "2020-05-29T14:36:41Z", "type": "commit"}, {"oid": "a8f8e81d7dce8dcf736ef55ba712f2090b6c9fcc", "url": "https://github.com/elastic/elasticsearch/commit/a8f8e81d7dce8dcf736ef55ba712f2090b6c9fcc", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-05-29T14:37:02Z", "type": "commit"}, {"oid": "9a763c37817121dadf2878891660e7b602ebbd67", "url": "https://github.com/elastic/elasticsearch/commit/9a763c37817121dadf2878891660e7b602ebbd67", "message": "Address feedback", "committedDate": "2020-05-29T14:45:49Z", "type": "commit"}, {"oid": "a43b3ef2a3ccb784e7bdbfbf1a95788b61607d31", "url": "https://github.com/elastic/elasticsearch/commit/a43b3ef2a3ccb784e7bdbfbf1a95788b61607d31", "message": "Fix docs", "committedDate": "2020-05-29T14:56:35Z", "type": "commit"}, {"oid": "ac6c39f8beb3f496832074b355df868358c29b6e", "url": "https://github.com/elastic/elasticsearch/commit/ac6c39f8beb3f496832074b355df868358c29b6e", "message": "Address feedback", "committedDate": "2020-06-02T13:56:02Z", "type": "commit"}, {"oid": "8e1dc13e46237b7e169d444710c578bd31c7e557", "url": "https://github.com/elastic/elasticsearch/commit/8e1dc13e46237b7e169d444710c578bd31c7e557", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-06-02T13:56:41Z", "type": "commit"}, {"oid": "21c89fba7a493461dca8a8551fb7dc3d54e96a67", "url": "https://github.com/elastic/elasticsearch/commit/21c89fba7a493461dca8a8551fb7dc3d54e96a67", "message": "Remove todo as it is pointless", "committedDate": "2020-06-02T13:58:25Z", "type": "commit"}, {"oid": "1499a26c051cae85fc78aa80c33c6bc5fa7abfdd", "url": "https://github.com/elastic/elasticsearch/commit/1499a26c051cae85fc78aa80c33c6bc5fa7abfdd", "message": "Address feedback for readwritelock and cache invalidation", "committedDate": "2020-06-03T13:10:21Z", "type": "commit"}, {"oid": "3b7e773b93672fe53f289a84e26d095fb3cacf6c", "url": "https://github.com/elastic/elasticsearch/commit/3b7e773b93672fe53f289a84e26d095fb3cacf6c", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-06-03T13:10:38Z", "type": "commit"}, {"oid": "83a0e196d5e3b39a70a30c9c4f3df800f77ee19c", "url": "https://github.com/elastic/elasticsearch/commit/83a0e196d5e3b39a70a30c9c4f3df800f77ee19c", "message": "add tests for caching behaviour", "committedDate": "2020-06-04T08:47:19Z", "type": "commit"}, {"oid": "3deef1e803df46d643f42e1557d3e4b7bb7c00b7", "url": "https://github.com/elastic/elasticsearch/commit/3deef1e803df46d643f42e1557d3e4b7bb7c00b7", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-06-04T08:47:37Z", "type": "commit"}, {"oid": "9364e36f80aa3d4f8c2a14267a4abddf032d3dba", "url": "https://github.com/elastic/elasticsearch/commit/9364e36f80aa3d4f8c2a14267a4abddf032d3dba", "message": "Add TTL as a safety net. Also consolidate cache size to a single setting", "committedDate": "2020-06-15T01:56:41Z", "type": "commit"}, {"oid": "0280c3e9cec5c4d659c868337f13a83b70f303f5", "url": "https://github.com/elastic/elasticsearch/commit/0280c3e9cec5c4d659c868337f13a83b70f303f5", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-06-15T01:56:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY1MzI5NA==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r444653294", "bodyText": "I think we can release the lock immediately after incrementing numInvalidation. It will mean that, in theory, we could invalidate things that we don't need to, but would mean holding a lock for less time.\nDid you consider the trade-off of how long to lock for vs perfect cache accuracy?\nIf we keep the lock around all the invalidation process, then I think the calculation of uniqueNames should be before the lock is acquired.", "author": "tvernum", "createdAt": "2020-06-24T05:31:35Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -346,4 +419,55 @@ private static String toDocId(String application, String name) {\n         return DOC_TYPE_VALUE + \"_\" + application + \":\" + name;\n     }\n \n+    public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            invalidateAll();\n+        }\n+    }\n+\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        if (descriptorsCache == null) {\n+            return;\n+        }\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        try (ReleasableLock ignored = invalidationWriteLock.acquire()) {\n+            numInvalidation.incrementAndGet();\n+            final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);\n+            // Always completely invalidate application names cache due to wildcard\n+            applicationNamesCache.invalidateAll();\n+            uniqueNames.forEach(descriptorsCache::invalidate);\n+        }", "originalCommit": "0280c3e9cec5c4d659c868337f13a83b70f303f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc0NDk1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r446744953", "bodyText": "Thanks @tvernum. Your comment is very insightful. You are right we could minimize the locking time in this case. The possibility of invalidating more than necessary should be very low. The getPrivileges thread needs to read the incremented value of numInvalidation and perform a search query and all these have to complete before the cache is invalidated. The chance should be extremely low. I have updated the code to minimize the locking for both invalidate and invalidateAll.\nA more possible scenario is \"unnecessarily skipping put result in cache\". We only cache when numInvalidation does not change. But this value changes for both partially and full cache invalidation. In the case of partial invalidation, the things get invalidated may not be relevant to the things that we want to cache. But the code would just skip caching them regardlessly for simplicity. This however has nothing to do with the locking, i.e. the same situation exists before we added the locking. Overall, combined with how Kibana behaves, I think this is an acceptable trade-off because:\n\nThe chance is still low\nWe always fully invalidate applicationNamesCache even for partially invalidation. And we decide to keep it this way for simplicity.\n\nAlso moved descriptorsCache != null check before the read lock, so we do not just lock and find out there is no cache to use. It is an edge case optimization but anyway it is easy to add.", "author": "ywangd", "createdAt": "2020-06-29T02:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY1MzI5NA=="}], "type": "inlineReview"}, {"oid": "ae3c7842c5fe525c7bce92fe38dcfccec4e16c7c", "url": "https://github.com/elastic/elasticsearch/commit/ae3c7842c5fe525c7bce92fe38dcfccec4e16c7c", "message": "Address feedback about lock duration", "committedDate": "2020-06-29T02:35:50Z", "type": "commit"}, {"oid": "68a4dc1167aa96c99021ad5d62a168c93b9c6d6d", "url": "https://github.com/elastic/elasticsearch/commit/68a4dc1167aa96c99021ad5d62a168c93b9c6d6d", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache", "committedDate": "2020-06-29T02:35:58Z", "type": "commit"}]}