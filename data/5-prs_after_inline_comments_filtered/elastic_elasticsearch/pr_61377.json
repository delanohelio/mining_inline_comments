{"pr_number": 61377, "pr_title": "ILM migrate data between tiers", "pr_createdAt": "2020-08-20T15:49:29Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61377", "timeline": [{"oid": "f4a37a9517769194cf8b2667fef5e130a1ec6bb1", "url": "https://github.com/elastic/elasticsearch/commit/f4a37a9517769194cf8b2667fef5e130a1ec6bb1", "message": "Enable the _tier attribute as a node filter", "committedDate": "2020-08-20T15:46:41Z", "type": "commit"}, {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2", "url": "https://github.com/elastic/elasticsearch/commit/024a0de407f25e77870f792e3b023e8825ee0cb2", "message": "ILM: inject a migrate step to migrate data between data tiers", "committedDate": "2020-08-20T15:46:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4OTQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474089405", "bodyText": "should we make this configurable and serializable for the step? (ie. use just the one allocation decider depending on where it is used)\nI'd say we want a fully allocated index so verifying both always is alright. What do you think?", "author": "andreidan", "createdAt": "2020-08-20T15:50:52Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java", "diffHunk": "@@ -40,8 +43,23 @@\n \n     private static final Logger logger = LogManager.getLogger(AllocationRoutedStep.class);\n \n-    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(Collections.singletonList(\n-            new FilterAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS))));\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new FilterAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY,\n+                ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMTE2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474321163", "bodyText": "Hmm... I actually think that we may want to split checking the allocation for the migrate action into a separate step. For example, the allocation routed step currently has a pretty generic message (Waiting for [n] shards to be allocated to nodes matching the given filters). I think if we split this into a new MigrationRouted step we could give it a much better explanation, for example, something like:\nwaiting [23m] for [3] shards to be allocated on nodes with the [data_warm] tier\nadditionally, I think we could also even throw an error to signal to the user when things were in a bad state, something like:\nexception waiting for index to be moved to the [data_cold] tier, there are currently no [data_cold] nodes in the cluster\nThen the step could be retryable (so we check every 10 minutes) and it at least gives us a way of signaling to a user (alerting on the ilm-history index for example) when they are in an irreconcilable position and need to adjust their cluster.\nWhat do you think?", "author": "dakrone", "createdAt": "2020-08-20T23:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4OTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NjM3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474556373", "bodyText": "You make a great point on validating if the cluster has any node with a particular role available. I'll create another step for the migrate action (the nicer messages will be a great UX improvement as well)", "author": "andreidan", "createdAt": "2020-08-21T09:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4OTQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MDE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474090175", "bodyText": "should we remove the possible_require and _exclude settings (which might've been set manually before) to make sure they don't invalidate the \"migrate to the next data tier\" goal?", "author": "andreidan", "createdAt": "2020-08-20T15:52:00Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);\n+    }\n+\n+    private final boolean enabled;\n+\n+    public static MigrateAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public MigrateAction(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public MigrateAction(StreamInput in) throws IOException {\n+        this(in.readBoolean());\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeBoolean(enabled);\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(ENABLED_FIELD.getPreferredName(), enabled);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return true;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        if (enabled) {\n+            Map<String, String> include = Map.of(\"_tier\", \"data_\" + phase);\n+            AllocateAction migrateDataAction = new AllocateAction(null, include, null, null);", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjE3MA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322170", "bodyText": "That's a good question, I'm not sure we'd want to piecemeal remove all of them, because they could be something for an additional attribute that we want to preserve between phases.\nI will have to think on it a bit, it also makes me wonder whether we should make it configurable whether all other index-level allocation filtering settings are removed/preserved when doing the migration.", "author": "dakrone", "createdAt": "2020-08-20T23:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NTAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474555008", "bodyText": "It's an interesting one - we do not allow to have the migrate action enabled in a phase that has the allocate action (configuring allocation), so maybe it makes sense for the migrate action to invalidate the possible allocation filterings the index might have (for eg. from a previous phase where the migrate action was disabled and the allocation action was configured)", "author": "andreidan", "createdAt": "2020-08-21T09:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MDE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMTM2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474321361", "bodyText": "enabled should be true by default I think?", "author": "dakrone", "createdAt": "2020-08-20T23:13:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);\n+    }\n+\n+    private final boolean enabled;", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMTUyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474321529", "bodyText": "I think we could use optionalConstructorArg here, so a user could specify \"migrate\": {} if they wanted the default (which would be enabled)", "author": "dakrone", "createdAt": "2020-08-20T23:14:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjU1NA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322554", "bodyText": "Can you add a sanity assert that the value in this map is always one of the DataTier.DATA_(HOT|WARM|COLD|FROZEN) values? (in case those names are changed)", "author": "dakrone", "createdAt": "2020-08-20T23:17:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);\n+    }\n+\n+    private final boolean enabled;\n+\n+    public static MigrateAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public MigrateAction(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public MigrateAction(StreamInput in) throws IOException {\n+        this(in.readBoolean());\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeBoolean(enabled);\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(ENABLED_FIELD.getPreferredName(), enabled);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return true;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        if (enabled) {\n+            Map<String, String> include = Map.of(\"_tier\", \"data_\" + phase);", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322674", "bodyText": "Good catch :D", "author": "dakrone", "createdAt": "2020-08-20T23:18:21Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverAction.java", "diffHunk": "@@ -27,7 +27,7 @@\n import java.util.Objects;\n \n /**\n- * A {@link LifecycleAction} which deletes the index.\n+ * A {@link LifecycleAction} which rolls over the index.", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjk1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322955", "bodyText": "I think we should add the migrate action explicitly to the hot actions as well (the hot phase doesn't have to start at min_age: 0ms)", "author": "dakrone", "createdAt": "2020-08-20T23:19:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -40,18 +43,18 @@\n     static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0ODA4MA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474548080", "bodyText": "Interesting. Could this potentially cause confusion if new indices are configured to go to the hot nodes (via #61342 ) and a policy has the migrate action configured to be disabled?", "author": "andreidan", "createdAt": "2020-08-21T08:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY3ODQ3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r475678476", "bodyText": "It could, but I was thinking of a pre-existing index having an ILM policy applied, it would be a bit strange if only the warm/cold/frozen phases moved the data around, instead of starting it on the hot nodes", "author": "dakrone", "createdAt": "2020-08-24T14:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4ODEyOA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r484788128", "bodyText": "Added a couple of tests for these scenarios in fe1fb8f", "author": "andreidan", "createdAt": "2020-09-08T09:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMzUxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474323510", "bodyText": "This might be better named shouldInjectMigrateStepForPhase I think", "author": "dakrone", "createdAt": "2020-08-20T23:21:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -86,12 +89,38 @@ public String getWriteableName() {\n                     actionMap.put(UnfollowAction.NAME, new UnfollowAction());\n                     phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n                 }\n+\n+                if (shouldMigrateDataToTiers(phase)) {\n+                    Map<String, LifecycleAction> actionMap = new HashMap<>(phase.getActions());\n+                    actionMap.put(MigrateAction.NAME, new MigrateAction(true));\n+                    phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n+                }\n+\n                 orderedPhases.add(phase);\n             }\n         }\n         return orderedPhases;\n     }\n \n+    boolean shouldMigrateDataToTiers(Phase phase) {", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNDQ0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474324446", "bodyText": "This could use your definesAllocationRules(allocateAction) helper here instead of manually checking, though I think maybe that helper needs to use isEmpty rather than checking for null so that an allocate action with \"include\": {} doesn't trip the assertion", "author": "dakrone", "createdAt": "2020-08-20T23:24:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -86,12 +89,38 @@ public String getWriteableName() {\n                     actionMap.put(UnfollowAction.NAME, new UnfollowAction());\n                     phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n                 }\n+\n+                if (shouldMigrateDataToTiers(phase)) {\n+                    Map<String, LifecycleAction> actionMap = new HashMap<>(phase.getActions());\n+                    actionMap.put(MigrateAction.NAME, new MigrateAction(true));\n+                    phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n+                }\n+\n                 orderedPhases.add(phase);\n             }\n         }\n         return orderedPhases;\n     }\n \n+    boolean shouldMigrateDataToTiers(Phase phase) {\n+        AllocateAction allocateAction = (AllocateAction) phase.getActions().get(AllocateAction.NAME);\n+        if (allocateAction != null) {\n+            if (allocateAction.getExclude().isEmpty() == false ||\n+                allocateAction.getInclude().isEmpty() == false ||\n+                allocateAction.getRequire().isEmpty() == false) {", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNDc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474324775", "bodyText": "These should use the .isEmpty() check rather than checking for null, since they could be \"include\": {} and be non-null but not actually have any allocation rules", "author": "dakrone", "createdAt": "2020-08-20T23:25:15Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -226,5 +255,24 @@ public void validate(Collection<Phase> phases) {\n                 \"] action may not be used in the [\" + HOT_PHASE +\n                 \"] phase without an accompanying [\" + RolloverAction.NAME + \"] action\");\n         }\n+\n+        // look for phases that have the migrate action enabled and also specify allocation rules via the AllocateAction\n+        String phasesWithConflictingMigrationActions = phases.stream()\n+            .filter(phase -> phase.getActions().containsKey(MigrateAction.NAME) &&\n+                ((MigrateAction) phase.getActions().get(MigrateAction.NAME)).isEnabled() &&\n+                phase.getActions().containsKey(AllocateAction.NAME) &&\n+                definesAllocationRules((AllocateAction) phase.getActions().get(AllocateAction.NAME))\n+            )\n+            .map(Phase::getName)\n+            .collect(Collectors.joining(\",\"));\n+        if (Strings.hasText(phasesWithConflictingMigrationActions)) {\n+            throw new IllegalArgumentException(\"phases [\" + phasesWithConflictingMigrationActions + \"] specify an enabled \" +\n+                MigrateAction.NAME + \" action and the \" + AllocateAction.NAME + \" action. specify only one data migration action in these\" +\n+                \" phases\");\n+        }\n+    }\n+\n+    private boolean definesAllocationRules(AllocateAction action) {\n+        return action.getRequire() != null || action.getInclude() != null || action.getExclude() != null;", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNDg4NA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474324884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean definesAllocationRules(AllocateAction action) {\n          \n          \n            \n                private static boolean definesAllocationRules(AllocateAction action) {", "author": "dakrone", "createdAt": "2020-08-20T23:25:33Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -226,5 +255,24 @@ public void validate(Collection<Phase> phases) {\n                 \"] action may not be used in the [\" + HOT_PHASE +\n                 \"] phase without an accompanying [\" + RolloverAction.NAME + \"] action\");\n         }\n+\n+        // look for phases that have the migrate action enabled and also specify allocation rules via the AllocateAction\n+        String phasesWithConflictingMigrationActions = phases.stream()\n+            .filter(phase -> phase.getActions().containsKey(MigrateAction.NAME) &&\n+                ((MigrateAction) phase.getActions().get(MigrateAction.NAME)).isEnabled() &&\n+                phase.getActions().containsKey(AllocateAction.NAME) &&\n+                definesAllocationRules((AllocateAction) phase.getActions().get(AllocateAction.NAME))\n+            )\n+            .map(Phase::getName)\n+            .collect(Collectors.joining(\",\"));\n+        if (Strings.hasText(phasesWithConflictingMigrationActions)) {\n+            throw new IllegalArgumentException(\"phases [\" + phasesWithConflictingMigrationActions + \"] specify an enabled \" +\n+                MigrateAction.NAME + \" action and the \" + AllocateAction.NAME + \" action. specify only one data migration action in these\" +\n+                \" phases\");\n+        }\n+    }\n+\n+    private boolean definesAllocationRules(AllocateAction action) {", "originalCommit": "024a0de407f25e77870f792e3b023e8825ee0cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ca9800f7154008e261c77f342aa90a7cce6cb6ea", "url": "https://github.com/elastic/elasticsearch/commit/ca9800f7154008e261c77f342aa90a7cce6cb6ea", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-01T16:31:21Z", "type": "commit"}, {"oid": "07dc8de3a23d5a57bd4c4d25a4c4c98c69558afc", "url": "https://github.com/elastic/elasticsearch/commit/07dc8de3a23d5a57bd4c4d25a4c4c98c69558afc", "message": "Add a DataTierMigrationRoutedStep and cleanup", "committedDate": "2020-09-03T18:13:55Z", "type": "commit"}, {"oid": "42900b26f322189b57ecb776f344c9df2936acb3", "url": "https://github.com/elastic/elasticsearch/commit/42900b26f322189b57ecb776f344c9df2936acb3", "message": "Fix tests", "committedDate": "2020-09-04T09:26:49Z", "type": "commit"}, {"oid": "5d6729b4eb18c09ab29a8a1f79dfb2b0a64ff63f", "url": "https://github.com/elastic/elasticsearch/commit/5d6729b4eb18c09ab29a8a1f79dfb2b0a64ff63f", "message": "Fix test", "committedDate": "2020-09-04T09:51:59Z", "type": "commit"}, {"oid": "28ccee9ec0fe0e3f8eca8d473940ef7e4f1e6624", "url": "https://github.com/elastic/elasticsearch/commit/28ccee9ec0fe0e3f8eca8d473940ef7e4f1e6624", "message": "Remove invalid tier name setting validation from ILM step\n\nWe already validate the data tier setting values as part of the\nindex settings validation.", "committedDate": "2020-09-04T16:20:53Z", "type": "commit"}, {"oid": "45d2eb38d227799f7d6c78578fe4941ab7b2c2ed", "url": "https://github.com/elastic/elasticsearch/commit/45d2eb38d227799f7d6c78578fe4941ab7b2c2ed", "message": "Add test for DataTierMigrationRoutedStep", "committedDate": "2020-09-04T16:47:23Z", "type": "commit"}, {"oid": "6c05591ce911008dc22e4dd342991f56deb9f4f0", "url": "https://github.com/elastic/elasticsearch/commit/6c05591ce911008dc22e4dd342991f56deb9f4f0", "message": "Disable data tier migration in the full policy we use for timeseries ITS\n\nWe'll have dedicated data tier integration tests that'll have data migration\nenabled.", "committedDate": "2020-09-04T16:57:57Z", "type": "commit"}, {"oid": "783061d20182d147e1ac064e71505c6fb62156c0", "url": "https://github.com/elastic/elasticsearch/commit/783061d20182d147e1ac064e71505c6fb62156c0", "message": "Remove unused import", "committedDate": "2020-09-04T16:59:54Z", "type": "commit"}, {"oid": "ab3ac3362b344e5caf8d3ed0211c6487533ebb4a", "url": "https://github.com/elastic/elasticsearch/commit/ab3ac3362b344e5caf8d3ed0211c6487533ebb4a", "message": "Revert \"Disable data tier migration in the full policy we use for timeseries ITS\"\n\nThis reverts commit 6c05591ce911008dc22e4dd342991f56deb9f4f0.", "committedDate": "2020-09-06T13:30:32Z", "type": "commit"}, {"oid": "6b74d7cc81bbdd55e8d1fe69d0b65f3e6a17ea7e", "url": "https://github.com/elastic/elasticsearch/commit/6b74d7cc81bbdd55e8d1fe69d0b65f3e6a17ea7e", "message": "Add MigrateActionTest", "committedDate": "2020-09-06T13:51:56Z", "type": "commit"}, {"oid": "61ed9eb4bcf546a6e59dbbf55878debbea3470d8", "url": "https://github.com/elastic/elasticsearch/commit/61ed9eb4bcf546a6e59dbbf55878debbea3470d8", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-06T13:53:25Z", "type": "commit"}, {"oid": "6f83f914f5906f6b871f0db39aa14cc4ee199327", "url": "https://github.com/elastic/elasticsearch/commit/6f83f914f5906f6b871f0db39aa14cc4ee199327", "message": "Don't randomly pick a disabled migrate action as it has no steps", "committedDate": "2020-09-07T13:29:06Z", "type": "commit"}, {"oid": "4bef9b262c50904a86b0ccac50daac0e64e8b5d3", "url": "https://github.com/elastic/elasticsearch/commit/4bef9b262c50904a86b0ccac50daac0e64e8b5d3", "message": "Add ILM tier migratino IT", "committedDate": "2020-09-07T13:29:14Z", "type": "commit"}, {"oid": "50245950fe3b5a3a30e74d52488c4d5137e7486a", "url": "https://github.com/elastic/elasticsearch/commit/50245950fe3b5a3a30e74d52488c4d5137e7486a", "message": "Use 0 replicas in docs test as `check-migration` waits for replicas to start", "committedDate": "2020-09-07T15:23:16Z", "type": "commit"}, {"oid": "41dc480bc6a1e1000c07c802c0f86b4f629ce946", "url": "https://github.com/elastic/elasticsearch/commit/41dc480bc6a1e1000c07c802c0f86b4f629ce946", "message": "Fix ILMHistoryTests", "committedDate": "2020-09-07T15:23:36Z", "type": "commit"}, {"oid": "d9b63903424e848699866bde33e59773e0d0fe02", "url": "https://github.com/elastic/elasticsearch/commit/d9b63903424e848699866bde33e59773e0d0fe02", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-07T15:24:14Z", "type": "commit"}, {"oid": "8e9a4f3248f7f5ab374842f5696212f3371ae36a", "url": "https://github.com/elastic/elasticsearch/commit/8e9a4f3248f7f5ab374842f5696212f3371ae36a", "message": "Disable migrate action in test that waits for shard allocations", "committedDate": "2020-09-07T15:37:11Z", "type": "commit"}, {"oid": "996c747191e5f90754fb7d1dad3802228b206410", "url": "https://github.com/elastic/elasticsearch/commit/996c747191e5f90754fb7d1dad3802228b206410", "message": "Add ILM client MigrateAction", "committedDate": "2020-09-07T16:55:35Z", "type": "commit"}, {"oid": "83c31b682ba7cee573066f83e8b7ce29ac63478e", "url": "https://github.com/elastic/elasticsearch/commit/83c31b682ba7cee573066f83e8b7ce29ac63478e", "message": "Remove unused import", "committedDate": "2020-09-07T16:56:44Z", "type": "commit"}, {"oid": "c1746d4a6322027112f1c80ea747f12549db4d06", "url": "https://github.com/elastic/elasticsearch/commit/c1746d4a6322027112f1c80ea747f12549db4d06", "message": "Fix HLRC tests", "committedDate": "2020-09-07T17:07:25Z", "type": "commit"}, {"oid": "fe1fb8f5e70847ccdfb5e52e519aad6c09164e2b", "url": "https://github.com/elastic/elasticsearch/commit/fe1fb8f5e70847ccdfb5e52e519aad6c09164e2b", "message": "Add tests for conflicting auto allocate to hot nodes and MigrateAction configurations", "committedDate": "2020-09-07T17:56:05Z", "type": "commit"}, {"oid": "e435a2f26b9fc1def4256ff053e7f7ab12878b72", "url": "https://github.com/elastic/elasticsearch/commit/e435a2f26b9fc1def4256ff053e7f7ab12878b72", "message": "Use valid tier name in test", "committedDate": "2020-09-07T18:40:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4ODYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r484788635", "bodyText": "We need to add client support for the SearchableSnapshot action too", "author": "andreidan", "createdAt": "2020-09-08T09:42:04Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ilm/LifecyclePolicy.java", "diffHunk": "@@ -57,10 +57,13 @@\n             throw new IllegalArgumentException(\"ordered \" + PHASES_FIELD.getPreferredName() + \" are not supported\");\n         }, PHASES_FIELD);\n \n-        ALLOWED_ACTIONS.put(\"hot\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, RolloverAction.NAME));\n-        ALLOWED_ACTIONS.put(\"warm\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, AllocateAction.NAME, ForceMergeAction.NAME,\n-            ReadOnlyAction.NAME, ShrinkAction.NAME));\n-        ALLOWED_ACTIONS.put(\"cold\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, AllocateAction.NAME, FreezeAction.NAME));\n+        ALLOWED_ACTIONS.put(\"hot\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, RolloverAction.NAME));\n+        ALLOWED_ACTIONS.put(\"warm\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            ForceMergeAction.NAME, ReadOnlyAction.NAME, ShrinkAction.NAME));\n+        ALLOWED_ACTIONS.put(\"cold\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            FreezeAction.NAME));\n+        ALLOWED_ACTIONS.put(\"frozen\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            FreezeAction.NAME));", "originalCommit": "e435a2f26b9fc1def4256ff053e7f7ab12878b72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODk4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485198986", "bodyText": "Can you open an issue for that so we don't forget?", "author": "dakrone", "createdAt": "2020-09-08T21:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4ODYzNQ=="}], "type": "inlineReview"}, {"oid": "656afe540f78a4e674b556159527e1d0bc9efa95", "url": "https://github.com/elastic/elasticsearch/commit/656afe540f78a4e674b556159527e1d0bc9efa95", "message": "Implement hashcode", "committedDate": "2020-09-08T10:12:22Z", "type": "commit"}, {"oid": "a24b0fc2bb3bf165f4f06df2e4cfdfaa537093ad", "url": "https://github.com/elastic/elasticsearch/commit/a24b0fc2bb3bf165f4f06df2e4cfdfaa537093ad", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-08T10:20:21Z", "type": "commit"}, {"oid": "8d806e2cd886600eda641c6dead953cec98e175b", "url": "https://github.com/elastic/elasticsearch/commit/8d806e2cd886600eda641c6dead953cec98e175b", "message": "Make method static", "committedDate": "2020-09-08T10:47:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMDI4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485930287", "bodyText": "I don't think this will work, because it's checking for the exact role, so for example, if the allocation were set to data_warm, and we had data nodes but not nodes with the exact data_warm role, this would say that they were not found (even though they are).\nWe should check for either an exact match or the presence of any nodes with the data role", "author": "dakrone", "createdAt": "2020-09-09T21:24:10Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            String tier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(tier)) {", "originalCommit": "8d806e2cd886600eda641c6dead953cec98e175b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2MjMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r486162336", "bodyText": "Great point", "author": "andreidan", "createdAt": "2020-09-10T08:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMDI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMTQyOA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485931428", "bodyText": "I think we discussed making this throw an exception if there were no nodes with the target tier in the cluster, so that the ERROR state was signaled (and the user could alert for it), but this only sets the result to false.", "author": "dakrone", "createdAt": "2020-09-09T21:26:34Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            String tier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(tier)) {\n+                        targetTierNodeFound = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            String statusMessage = String.format(Locale.ROOT, \"%s lifecycle action [%s] waiting for [%s] shards to be moved to the [%s] \" +\n+                    \"tier\" + (targetTierNodeFound ? \"\" : \" but there are currently no [%s] nodes in the cluster\"),\n+                index, getKey().getAction(), allocationPendingAllShards, tier, tier);\n+            logger.debug(statusMessage);\n+            return new Result(false, new AllocationInfo(idxMeta.getNumberOfReplicas(), allocationPendingAllShards, true, statusMessage));", "originalCommit": "8d806e2cd886600eda641c6dead953cec98e175b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM5NjcwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r486396705", "bodyText": "Discussed this with @dakrone and we decided not to use an exception in this case as it'll move the step into the ERROR step and that might be confusing to the user. The DataTierMigrationRoutedStep is a ClusterStateWaitStep so it will naturally retry by re-evaluating if the migration is complete on every cluster state change.", "author": "andreidan", "createdAt": "2020-09-10T14:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMzM4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485933387", "bodyText": "We should remove this from the hot phase (I know you know this already, this is just a placeholder comment)", "author": "dakrone", "createdAt": "2020-09-09T21:31:06Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -37,21 +40,21 @@\n     static final String FROZEN_PHASE = \"frozen\";\n     static final String DELETE_PHASE = \"delete\";\n     static final List<String> VALID_PHASES = Arrays.asList(HOT_PHASE, WARM_PHASE, COLD_PHASE, FROZEN_PHASE, DELETE_PHASE);\n-    static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n-        ForceMergeAction.NAME);\n+    static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, MigrateAction.NAME,", "originalCommit": "8d806e2cd886600eda641c6dead953cec98e175b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNDc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485934798", "bodyText": "Could you add javadocs please?", "author": "dakrone", "createdAt": "2020-09-09T21:34:27Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/step/info/AllocationInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm.step.info;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class AllocationInfo implements ToXContentObject {", "originalCommit": "8d806e2cd886600eda641c6dead953cec98e175b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNTE5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485935198", "bodyText": "I think \"actual_replicas\" is a little difficult to tell what it means, maybe there's a clearer name we could use?", "author": "dakrone", "createdAt": "2020-09-09T21:35:19Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/step/info/AllocationInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm.step.info;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class AllocationInfo implements ToXContentObject {\n+    private final long actualReplicas;\n+    private final long numberShardsLeftToAllocate;\n+    private final boolean allShardsActive;\n+    private final String message;\n+\n+    static final ParseField ACTUAL_REPLICAS = new ParseField(\"actual_replicas\");", "originalCommit": "8d806e2cd886600eda641c6dead953cec98e175b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2ODUzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r486168535", "bodyText": "Yes, I agree. It'll be a breaking change, but possibly going with the well known number_of_replicas would be better?", "author": "andreidan", "createdAt": "2020-09-10T08:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNTg2MA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485935860", "bodyText": "Whoops I think this is a typo that can be removed?", "author": "dakrone", "createdAt": "2020-09-09T21:36:50Z", "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunnerTests.java", "diffHunk": "@@ -91,6 +92,8 @@\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.when;\n \n+;\n+", "originalCommit": "8d806e2cd886600eda641c6dead953cec98e175b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2133715100e7c1ee0367ad6a13a66032164953c0", "url": "https://github.com/elastic/elasticsearch/commit/2133715100e7c1ee0367ad6a13a66032164953c0", "message": "Check for \"data\" role in `check-migration` step", "committedDate": "2020-09-10T09:23:18Z", "type": "commit"}, {"oid": "991fdc078797bae280cb3b37c26bcc60c67cb317", "url": "https://github.com/elastic/elasticsearch/commit/991fdc078797bae280cb3b37c26bcc60c67cb317", "message": "Document AllocationInfo and rename `actual_replicas` to `number_of_replicas`", "committedDate": "2020-09-10T09:33:42Z", "type": "commit"}, {"oid": "be6592903733d247980b680d6075d2ed30bf89ce", "url": "https://github.com/elastic/elasticsearch/commit/be6592903733d247980b680d6075d2ed30bf89ce", "message": "Disallow the migrate action in the hot phase", "committedDate": "2020-09-10T09:38:59Z", "type": "commit"}, {"oid": "39b518e8e9804a79ce1346afbba6ceb72b868c71", "url": "https://github.com/elastic/elasticsearch/commit/39b518e8e9804a79ce1346afbba6ceb72b868c71", "message": "Remove rogue ;", "committedDate": "2020-09-10T09:42:59Z", "type": "commit"}, {"oid": "f3a64d3163d1f4c0793a7667645ff71efa8459a6", "url": "https://github.com/elastic/elasticsearch/commit/f3a64d3163d1f4c0793a7667645ff71efa8459a6", "message": "Fix HLRC tests", "committedDate": "2020-09-10T11:40:15Z", "type": "commit"}, {"oid": "d11979714856055de2e3d1076e2bf3eeb0ee5a77", "url": "https://github.com/elastic/elasticsearch/commit/d11979714856055de2e3d1076e2bf3eeb0ee5a77", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-10T11:40:51Z", "type": "commit"}, {"oid": "8f855c550baf9e244f7e65508e47bbf9de6833c6", "url": "https://github.com/elastic/elasticsearch/commit/8f855c550baf9e244f7e65508e47bbf9de6833c6", "message": "Fix ILMHistoryTests", "committedDate": "2020-09-10T12:16:26Z", "type": "commit"}, {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "url": "https://github.com/elastic/elasticsearch/commit/0636d0ec5f82435d95b794a6ca4bedf31d40db99", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-14T12:40:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI0OTY0OA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488249648", "bodyText": "I realized something about this, I think we should do AllocateAction prior to the migrate action, or else we are liable to get \"stuck\".\nFor example, if a user had multiple hot nodes and only a single warm node, we would try to migrate an index with one replica from hot to warm, but the replica could never allocate, since there is only a single node. Instead, we should do the allocate action first (where a user could set number_of_replicas to 0) before migrating to the next tier.\nWhat do you think?", "author": "dakrone", "createdAt": "2020-09-14T22:05:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -40,18 +43,18 @@\n     static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n         ForceMergeAction.NAME);\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n-        AllocateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n-    static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        FreezeAction.NAME, SearchableSnapshotAction.NAME);\n-    static final List<String> ORDERED_VALID_FROZEN_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+        MigrateAction.NAME, AllocateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);", "originalCommit": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NDE2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488964164", "bodyText": "I also realize we can get stuck the opposite way too, so either way it's possible to get stuck, but I think that doing allocate first is still the way we should go. Curious about what you think", "author": "dakrone", "createdAt": "2020-09-15T20:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI0OTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyOTk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r489329963", "bodyText": "You make a great point Lee. I think we should go forward this way as it also keeps the \"number of replicas is modified before the allocations change\" behaviour consistent with how the allocate action works.\nMaybe it's a bit more of a future talk, but I do wonder if it'd be a good time to extract the \"change number of replicas\" into its own action. I think being conflated with the allocation rules in the allocate action is generally confusing, but even more so now where we'd expect the users to use both the allocate and the migrate (admittedly, not necessarily explicitly declaring it) actions to achieve the \"reduce number of replicas and then relocate index\" scenario.\nI think a change-replicas-number action would be welcome at this stage.", "author": "andreidan", "createdAt": "2020-09-16T10:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI0OTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1MTU0NA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488251544", "bodyText": "I think in this one we can be more specific in the debug message, so perhaps:\n[check-migration] migration for index [foo] to the [data_cold] tier cannot progress, as not all shards are active\n\n(we can pull the tier name from the index setting)", "author": "dakrone", "createdAt": "2020-09-14T22:07:49Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.cluster.node.DiscoveryNodeRole.DATA_ROLE;\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());", "originalCommit": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1MzY4OA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488253688", "bodyText": "same here about log messages, perhaps:\n[check-migration] migration of index [foo] to tier [data_cold] complete\n\nIt's definitely a lot nicer to grep for in logs :)", "author": "dakrone", "createdAt": "2020-09-14T22:10:36Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.cluster.node.DiscoveryNodeRole.DATA_ROLE;\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            String tier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(DATA_ROLE.roleName()) || role.roleName().equals(tier)) {\n+                        targetTierNodeFound = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            String statusMessage = String.format(Locale.ROOT, \"%s lifecycle action [%s] waiting for [%s] shards to be moved to the [%s] \" +\n+                    \"tier\" + (targetTierNodeFound ? \"\" : \" but there are currently no [%s] nodes in the cluster\"),\n+                index, getKey().getAction(), allocationPendingAllShards, tier, tier);\n+            logger.debug(statusMessage);\n+            return new Result(false, new AllocationInfo(idxMeta.getNumberOfReplicas(), allocationPendingAllShards, true, statusMessage));\n+        } else {\n+            logger.debug(\"{} lifecycle action for [{}] complete\", index, getKey().getAction());", "originalCommit": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1NTcwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488255705", "bodyText": "Super minor, but it's confusing to call the parameter here (and in the function above) \"actualReplicas\", it makes it seem like there should be a \"allocatedReplicas\" parameter somewhere as well. Maybe we can just call in numReplicas?", "author": "dakrone", "createdAt": "2020-09-14T22:13:30Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/step/info/AllocationInfo.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm.step.info;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Represents the state of an index's shards allocation, including a user friendly message describing the current state.\n+ * It allows to transfer the allocation information to {@link org.elasticsearch.common.xcontent.XContent} using\n+ * {@link #toXContent(XContentBuilder, Params)}\n+ */\n+public class AllocationInfo implements ToXContentObject {\n+\n+    private final long numberOfReplicas;\n+    private final long numberShardsLeftToAllocate;\n+    private final boolean allShardsActive;\n+    private final String message;\n+\n+    static final ParseField NUMBER_OF_REPLICAS = new ParseField(\"number_of_replicas\");\n+    static final ParseField SHARDS_TO_ALLOCATE = new ParseField(\"shards_left_to_allocate\");\n+    static final ParseField ALL_SHARDS_ACTIVE = new ParseField(\"all_shards_active\");\n+    static final ParseField MESSAGE = new ParseField(\"message\");\n+    static final ConstructingObjectParser<AllocationInfo, Void> PARSER = new ConstructingObjectParser<>(\"allocation_routed_step_info\",\n+        a -> new AllocationInfo((long) a[0], (long) a[1], (boolean) a[2], (String) a[3]));\n+\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), NUMBER_OF_REPLICAS);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), SHARDS_TO_ALLOCATE);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ALL_SHARDS_ACTIVE);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), MESSAGE);\n+    }\n+\n+    public AllocationInfo(long numberOfReplicas, long numberShardsLeftToAllocate, boolean allShardsActive, String message) {\n+        this.numberOfReplicas = numberOfReplicas;\n+        this.numberShardsLeftToAllocate = numberShardsLeftToAllocate;\n+        this.allShardsActive = allShardsActive;\n+        this.message = message;\n+    }\n+\n+    /**\n+     * Builds the AllocationInfo representing a cluster state with a routing table that does not have enough shards active for a\n+     * particular index.\n+     */\n+    public static AllocationInfo waitingForActiveShardsAllocationInfo(long actualReplicas) {\n+        return new AllocationInfo(actualReplicas, -1, false,\n+            \"Waiting for all shard copies to be active\");\n+    }\n+\n+    /**\n+     * Builds the AllocationInfo representing a cluster state with a routing table that has all the shards active for a particular index\n+     * but there are still {@link #numberShardsLeftToAllocate} left to be allocated.\n+     */\n+    public static AllocationInfo allShardsActiveAllocationInfo(long actualReplicas, long numberShardsLeftToAllocate) {", "originalCommit": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyNDMxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r489424311", "bodyText": "Totally, my grep skills failed me.", "author": "andreidan", "createdAt": "2020-09-16T13:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1NTcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1ODk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488258989", "bodyText": "I think rather than:\nphases [warm,cold] specify an enabled migrate action and the allocate action. specify only one data migration action in these phases\n\nWe should clarify that it's the actual allocation rules that cause problems (they're free to adjust replica count as much as they'd like):\nphase [warm,cold] specifies an enabled migrate action and an allocate action with allocation rules, specify only a single data migration in each phase", "author": "dakrone", "createdAt": "2020-09-14T22:18:03Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -226,5 +250,24 @@ public void validate(Collection<Phase> phases) {\n                 \"] action may not be used in the [\" + HOT_PHASE +\n                 \"] phase without an accompanying [\" + RolloverAction.NAME + \"] action\");\n         }\n+\n+        // look for phases that have the migrate action enabled and also specify allocation rules via the AllocateAction\n+        String phasesWithConflictingMigrationActions = phases.stream()\n+            .filter(phase -> phase.getActions().containsKey(MigrateAction.NAME) &&\n+                ((MigrateAction) phase.getActions().get(MigrateAction.NAME)).isEnabled() &&\n+                phase.getActions().containsKey(AllocateAction.NAME) &&\n+                definesAllocationRules((AllocateAction) phase.getActions().get(AllocateAction.NAME))\n+            )\n+            .map(Phase::getName)\n+            .collect(Collectors.joining(\",\"));\n+        if (Strings.hasText(phasesWithConflictingMigrationActions)) {\n+            throw new IllegalArgumentException(\"phases [\" + phasesWithConflictingMigrationActions + \"] specify an enabled \" +\n+                MigrateAction.NAME + \" action and the \" + AllocateAction.NAME + \" action. specify only one data migration action in these\" +", "originalCommit": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MDY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488260670", "bodyText": "Should we have the check for \"cold\" node allocation before starting up the frozen node? We have it for the other phases, so probably best to check for it just so it doesn't end up disappearing for only the cold phase some time in the future", "author": "dakrone", "createdAt": "2020-09-14T22:20:20Z", "path": "x-pack/plugin/ilm/src/internalClusterTest/java/org/elasticsearch/xpack/ilm/DataTiersMigrationsTests.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.DataTier;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.ilm.DataTierMigrationRoutedStep;\n+import org.elasticsearch.xpack.core.ilm.ExplainLifecycleRequest;\n+import org.elasticsearch.xpack.core.ilm.ExplainLifecycleResponse;\n+import org.elasticsearch.xpack.core.ilm.IndexLifecycleExplainResponse;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.Phase;\n+import org.elasticsearch.xpack.core.ilm.action.ExplainLifecycleAction;\n+import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction;\n+import org.junit.Before;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.test.NodeRoles.onlyRole;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n+public class DataTiersMigrationsTests extends ESIntegTestCase {\n+\n+    private String policy;\n+    private String managedIndex;\n+\n+    @Before\n+    public void refreshDataStreamAndPolicy() {\n+        policy = \"policy-\" + randomAlphaOfLength(5);\n+        managedIndex = \"index-\" + randomAlphaOfLengthBetween(10, 15).toLowerCase(Locale.ROOT);\n+    }\n+\n+    @Override\n+    protected boolean ignoreExternalCluster() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(LocalStateCompositeXPackPlugin.class, IndexLifecycle.class);\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        Settings.Builder settings = Settings.builder().put(super.nodeSettings(nodeOrdinal));\n+        settings.put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.SECURITY_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.WATCHER_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.GRAPH_ENABLED.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_POLL_INTERVAL, \"1s\");\n+        settings.put(LifecycleSettings.SLM_HISTORY_INDEX_ENABLED_SETTING.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_HISTORY_INDEX_ENABLED, false);\n+        return settings.build();\n+    }\n+\n+    public static Settings hotNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_HOT_NODE_ROLE);\n+    }\n+\n+    public static Settings warmNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_WARM_NODE_ROLE);\n+    }\n+\n+    public static Settings coldNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_COLD_NODE_ROLE);\n+    }\n+\n+    public static Settings frozenNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_FROZEN_NODE_ROLE);\n+    }\n+\n+    public void testIndexDataTierMigration() throws Exception {\n+        internalCluster().startMasterOnlyNodes(1, Settings.EMPTY);\n+        logger.info(\"starting hot data node\");\n+        internalCluster().startNode(hotNode(Settings.EMPTY));\n+\n+        Phase hotPhase = new Phase(\"hot\", TimeValue.ZERO, Collections.emptyMap());\n+        Phase warmPhase = new Phase(\"warm\", TimeValue.ZERO, Collections.emptyMap());\n+        Phase coldPhase = new Phase(\"cold\", TimeValue.ZERO, Collections.emptyMap());\n+        Phase frozenPhase = new Phase(\"frozen\", TimeValue.ZERO, Collections.emptyMap());\n+        LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(policy, Map.of(\"hot\", hotPhase, \"warm\", warmPhase, \"cold\", coldPhase,\n+            \"frozen\", frozenPhase));\n+        PutLifecycleAction.Request putLifecycleRequest = new PutLifecycleAction.Request(lifecyclePolicy);\n+        PutLifecycleAction.Response putLifecycleResponse = client().execute(PutLifecycleAction.INSTANCE, putLifecycleRequest).get();\n+        assertAcked(putLifecycleResponse);\n+\n+        Settings settings = Settings.builder().put(indexSettings()).put(SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(SETTING_NUMBER_OF_REPLICAS, 0).put(LifecycleSettings.LIFECYCLE_NAME, policy).build();\n+        CreateIndexResponse res = client().admin().indices().prepareCreate(managedIndex).setSettings(settings).get();\n+        assertTrue(res.isAcknowledged());\n+\n+        assertBusy(() -> {\n+            ExplainLifecycleRequest explainRequest = new ExplainLifecycleRequest().indices(managedIndex);\n+            ExplainLifecycleResponse explainResponse = client().execute(ExplainLifecycleAction.INSTANCE,\n+                explainRequest).get();\n+\n+            IndexLifecycleExplainResponse indexLifecycleExplainResponse = explainResponse.getIndexResponses().get(managedIndex);\n+            assertThat(indexLifecycleExplainResponse.getPhase(), is(\"warm\"));\n+            assertThat(indexLifecycleExplainResponse.getStep(), is(DataTierMigrationRoutedStep.NAME));\n+        });\n+\n+        logger.info(\"starting warm data node\");\n+        internalCluster().startNode(warmNode(Settings.EMPTY));\n+        assertBusy(() -> {\n+            ExplainLifecycleRequest explainRequest = new ExplainLifecycleRequest().indices(managedIndex);\n+            ExplainLifecycleResponse explainResponse = client().execute(ExplainLifecycleAction.INSTANCE,\n+                explainRequest).get();\n+\n+            IndexLifecycleExplainResponse indexLifecycleExplainResponse = explainResponse.getIndexResponses().get(managedIndex);\n+            assertThat(indexLifecycleExplainResponse.getPhase(), is(\"cold\"));\n+            assertThat(indexLifecycleExplainResponse.getStep(), is(DataTierMigrationRoutedStep.NAME));\n+        });\n+\n+        logger.info(\"starting cold data node\");\n+        internalCluster().startNode(coldNode(Settings.EMPTY));", "originalCommit": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyNjk5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r489426992", "bodyText": "Yes, changed to wait for the complete step in the cold phase (removed the frozen node and checks)", "author": "andreidan", "createdAt": "2020-09-16T13:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MDY3MA=="}], "type": "inlineReview"}, {"oid": "500a275e3a6f572cde128f96dd4d2e665ca8d2a8", "url": "https://github.com/elastic/elasticsearch/commit/500a275e3a6f572cde128f96dd4d2e665ca8d2a8", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-16T09:28:41Z", "type": "commit"}, {"oid": "9b90555a1689bd2fbc9c8fc992f8a106dfa87c02", "url": "https://github.com/elastic/elasticsearch/commit/9b90555a1689bd2fbc9c8fc992f8a106dfa87c02", "message": "Remove frozen phase from HLRC", "committedDate": "2020-09-16T10:39:09Z", "type": "commit"}, {"oid": "eddd223b8ab42eece98285cf49006a506495137d", "url": "https://github.com/elastic/elasticsearch/commit/eddd223b8ab42eece98285cf49006a506495137d", "message": "Execute the allocate action before migrate", "committedDate": "2020-09-16T11:31:54Z", "type": "commit"}, {"oid": "d733d729f08dba4a9011a7fd9d050b6985b2cb06", "url": "https://github.com/elastic/elasticsearch/commit/d733d729f08dba4a9011a7fd9d050b6985b2cb06", "message": "Adjust test to wait until ILM completes in the cold phase", "committedDate": "2020-09-16T12:41:06Z", "type": "commit"}, {"oid": "4da7379208c144a1f6e97dc4fd2511886d31d502", "url": "https://github.com/elastic/elasticsearch/commit/4da7379208c144a1f6e97dc4fd2511886d31d502", "message": "Log and exception messages", "committedDate": "2020-09-16T13:18:48Z", "type": "commit"}, {"oid": "be17159a15937f46ffe769995a5428a3520683c6", "url": "https://github.com/elastic/elasticsearch/commit/be17159a15937f46ffe769995a5428a3520683c6", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers", "committedDate": "2020-09-16T16:08:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyOTIyMg==", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r489629222", "bodyText": "I think this needs to incorporate super.hashCode() or else the hash code will be the same regardless of stepkeys", "author": "dakrone", "createdAt": "2020-09-16T18:13:39Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.cluster.node.DiscoveryNodeRole.DATA_ROLE;\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        String destinationTier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] migration of index [{}] to the [{}] tier cannot progress, as not all shards are active\",\n+                    getKey().getAction(), index.getName(), destinationTier);\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(DATA_ROLE.roleName()) || role.roleName().equals(destinationTier)) {\n+                        targetTierNodeFound = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            String statusMessage = String.format(Locale.ROOT, \"%s lifecycle action [%s] waiting for [%s] shards to be moved to the [%s] \" +\n+                    \"tier\" + (targetTierNodeFound ? \"\" : \" but there are currently no [%s] nodes in the cluster\"),\n+                index, getKey().getAction(), allocationPendingAllShards, destinationTier, destinationTier);\n+            logger.debug(statusMessage);\n+            return new Result(false, new AllocationInfo(idxMeta.getNumberOfReplicas(), allocationPendingAllShards, true, statusMessage));\n+        } else {\n+            logger.debug(\"[{}] migration of index [{}] to tier [{}] complete\", getKey().getAction(), index, destinationTier);\n+            return new Result(true, null);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 711;", "originalCommit": "be17159a15937f46ffe769995a5428a3520683c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b83771856c3d1e8915539e1f196a5cfd8ef018d1", "url": "https://github.com/elastic/elasticsearch/commit/b83771856c3d1e8915539e1f196a5cfd8ef018d1", "message": "Drop equals and hashcode (in favour of the ones in Step)", "committedDate": "2020-09-17T08:55:56Z", "type": "commit"}]}