{"pr_number": 56786, "pr_title": "SQL: implement SUM, MIN, MAX, AVG over literals", "pr_createdAt": "2020-05-14T17:45:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56786", "timeline": [{"oid": "13a1d22f4b47c42022e9af5437c4e18a3fc4ebfc", "url": "https://github.com/elastic/elasticsearch/commit/13a1d22f4b47c42022e9af5437c4e18a3fc4ebfc", "message": "Adds support for MIN, MAX, AVG, SUM aggregates acting on literals.\nSELECT SUM(1) FROM index\nand\nSELECT SUM(1), AVG(2)\nwork both on indices and as local execution.", "committedDate": "2020-05-14T17:25:13Z", "type": "commit"}, {"oid": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "url": "https://github.com/elastic/elasticsearch/commit/254b06064a8ae9ee1fef7c37872fd7e45da96032", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 55569_impl", "committedDate": "2020-05-14T17:33:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwODUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425708515", "bodyText": "nit: To keep the result data type consistent we could move those 2 lines inside the trasformation as:\n Expression countOne = new Cast(EMPTY, new Count(EMPTY, new Literal(Source.EMPTY, 1, fna.dataType()), false), fna.dataType());\n                        Equals countEqZero = new Equals(EMPTY, countOne, new Literal(Source.EMPTY, 0, fna.dataType()));", "author": "matriv", "createdAt": "2020-05-15T10:22:58Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -772,6 +782,63 @@ private Expression simplify(BinaryComparison bc) {\n         }\n     }\n \n+    /**\n+     * Any numeric aggregates (avg, min, max, sum) acting on literals are converted to an iif(count(1)=0, null, literal*count(1)) for sum,\n+     * and to iif(count(1)=0,null,literal) for the other three.\n+     */\n+    private static class ReplaceAggregatesOfLiterals extends OptimizerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan p) {\n+            Holder<Boolean> isLocalRelation = new Holder<>(false);\n+            p.forEachUp(a -> {\n+                if (isLocalRelation.get() == false && a instanceof LocalRelation) {\n+                    isLocalRelation.set(true);\n+                }\n+            });\n+            \n+            // there is no need for a IIF(COUNT(1)=0,NULL,literal) for local relations, since the aggregate will be folded further down\n+            if (isLocalRelation.get()) {\n+                return p;\n+            }\n+\n+            Expression countOne = new Count(EMPTY, new Literal(Source.EMPTY, 1, DataTypes.LONG), false);", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwOTEzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425709135", "bodyText": "again for keeping the correct datatype: new Literal(argument.source(), argument.fold(), fna.dataType())", "author": "matriv", "createdAt": "2020-05-15T10:24:05Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -772,6 +782,63 @@ private Expression simplify(BinaryComparison bc) {\n         }\n     }\n \n+    /**\n+     * Any numeric aggregates (avg, min, max, sum) acting on literals are converted to an iif(count(1)=0, null, literal*count(1)) for sum,\n+     * and to iif(count(1)=0,null,literal) for the other three.\n+     */\n+    private static class ReplaceAggregatesOfLiterals extends OptimizerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan p) {\n+            Holder<Boolean> isLocalRelation = new Holder<>(false);\n+            p.forEachUp(a -> {\n+                if (isLocalRelation.get() == false && a instanceof LocalRelation) {\n+                    isLocalRelation.set(true);\n+                }\n+            });\n+            \n+            // there is no need for a IIF(COUNT(1)=0,NULL,literal) for local relations, since the aggregate will be folded further down\n+            if (isLocalRelation.get()) {\n+                return p;\n+            }\n+\n+            Expression countOne = new Count(EMPTY, new Literal(Source.EMPTY, 1, DataTypes.LONG), false);\n+            Equals countEqZero = new Equals(EMPTY, countOne, new Literal(Source.EMPTY, 0, DataTypes.LONG));\n+            \n+            LogicalPlan plan = p.transformExpressionsUp(e -> {\n+                Expression exp = e;\n+                String aliasName = null;\n+                if (exp instanceof Alias) {\n+                    exp = ((Alias) exp).child();\n+                    aliasName = ((Alias) e).name();\n+                }\n+\n+                if (exp instanceof FoldableNumericAggregate) {\n+                    FoldableNumericAggregate fna = (FoldableNumericAggregate) exp;\n+                    \n+                    if (fna.localFoldable()) {\n+                        Expression argument = fna.field();\n+                        Expression iifElseResult;\n+                        \n+                        if (exp instanceof Sum) {\n+                            iifElseResult = new Mul(new Source(Location.EMPTY, \"MUL(COUNT(1), \" + argument.sourceText() + \")\"), countOne,\n+                                Literal.of(argument));", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwOTU0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425709546", "bodyText": "and here: iifElseResult =  new Literal(argument.source(), argument.fold(), fna.dataType());", "author": "matriv", "createdAt": "2020-05-15T10:24:51Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -772,6 +782,63 @@ private Expression simplify(BinaryComparison bc) {\n         }\n     }\n \n+    /**\n+     * Any numeric aggregates (avg, min, max, sum) acting on literals are converted to an iif(count(1)=0, null, literal*count(1)) for sum,\n+     * and to iif(count(1)=0,null,literal) for the other three.\n+     */\n+    private static class ReplaceAggregatesOfLiterals extends OptimizerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan p) {\n+            Holder<Boolean> isLocalRelation = new Holder<>(false);\n+            p.forEachUp(a -> {\n+                if (isLocalRelation.get() == false && a instanceof LocalRelation) {\n+                    isLocalRelation.set(true);\n+                }\n+            });\n+            \n+            // there is no need for a IIF(COUNT(1)=0,NULL,literal) for local relations, since the aggregate will be folded further down\n+            if (isLocalRelation.get()) {\n+                return p;\n+            }\n+\n+            Expression countOne = new Count(EMPTY, new Literal(Source.EMPTY, 1, DataTypes.LONG), false);\n+            Equals countEqZero = new Equals(EMPTY, countOne, new Literal(Source.EMPTY, 0, DataTypes.LONG));\n+            \n+            LogicalPlan plan = p.transformExpressionsUp(e -> {\n+                Expression exp = e;\n+                String aliasName = null;\n+                if (exp instanceof Alias) {\n+                    exp = ((Alias) exp).child();\n+                    aliasName = ((Alias) e).name();\n+                }\n+\n+                if (exp instanceof FoldableNumericAggregate) {\n+                    FoldableNumericAggregate fna = (FoldableNumericAggregate) exp;\n+                    \n+                    if (fna.localFoldable()) {\n+                        Expression argument = fna.field();\n+                        Expression iifElseResult;\n+                        \n+                        if (exp instanceof Sum) {\n+                            iifElseResult = new Mul(new Source(Location.EMPTY, \"MUL(COUNT(1), \" + argument.sourceText() + \")\"), countOne,\n+                                Literal.of(argument));\n+                        } else {\n+                            iifElseResult = Literal.of(argument);", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxMjY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425712674", "bodyText": "Question: Is it necessary to provide new Source? It will be useful for debugging but couldn't lead to user's confusion if it's sees the transformation?", "author": "matriv", "createdAt": "2020-05-15T10:31:12Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -772,6 +782,63 @@ private Expression simplify(BinaryComparison bc) {\n         }\n     }\n \n+    /**\n+     * Any numeric aggregates (avg, min, max, sum) acting on literals are converted to an iif(count(1)=0, null, literal*count(1)) for sum,\n+     * and to iif(count(1)=0,null,literal) for the other three.\n+     */\n+    private static class ReplaceAggregatesOfLiterals extends OptimizerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan p) {\n+            Holder<Boolean> isLocalRelation = new Holder<>(false);\n+            p.forEachUp(a -> {\n+                if (isLocalRelation.get() == false && a instanceof LocalRelation) {\n+                    isLocalRelation.set(true);\n+                }\n+            });\n+            \n+            // there is no need for a IIF(COUNT(1)=0,NULL,literal) for local relations, since the aggregate will be folded further down\n+            if (isLocalRelation.get()) {\n+                return p;\n+            }\n+\n+            Expression countOne = new Count(EMPTY, new Literal(Source.EMPTY, 1, DataTypes.LONG), false);\n+            Equals countEqZero = new Equals(EMPTY, countOne, new Literal(Source.EMPTY, 0, DataTypes.LONG));\n+            \n+            LogicalPlan plan = p.transformExpressionsUp(e -> {\n+                Expression exp = e;\n+                String aliasName = null;\n+                if (exp instanceof Alias) {\n+                    exp = ((Alias) exp).child();\n+                    aliasName = ((Alias) e).name();\n+                }\n+\n+                if (exp instanceof FoldableNumericAggregate) {\n+                    FoldableNumericAggregate fna = (FoldableNumericAggregate) exp;\n+                    \n+                    if (fna.localFoldable()) {\n+                        Expression argument = fna.field();\n+                        Expression iifElseResult;\n+                        \n+                        if (exp instanceof Sum) {\n+                            iifElseResult = new Mul(new Source(Location.EMPTY, \"MUL(COUNT(1), \" + argument.sourceText() + \")\"), countOne,", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MTcxMA==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425691710", "bodyText": "I don't see much value in this class. It could be used as a marker but then an interface would be a better choice. The localFoldable methods are convenient but also confusing - first because folding should happen all the time (whether local or remote) and second because they can't actually fold without outside context.\nThat is, the two methods are not self sufficient, they need an external entity to work with them. And that entity already has access to their structure so instead of having the logic in two places, it can simply be moved into the rules.", "author": "costin", "createdAt": "2020-05-15T09:50:26Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/FoldableNumericAggregate.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypeConverter;\n+import org.elasticsearch.xpack.ql.util.Check;\n+\n+import java.util.List;\n+\n+public abstract class FoldableNumericAggregate extends NumericAggregate {", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MjEwNw==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425692107", "bodyText": "Is this really needed? The replacing happens in the optimization phase where the aggregations should be replaced already with a different construct.", "author": "costin", "createdAt": "2020-05-15T09:51:15Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Stats.java", "diffHunk": "@@ -31,6 +31,7 @@ public Stats replaceChildren(List<Expression> newChildren) {\n     }\n \n     public static boolean isTypeCompatible(Expression e) {\n-        return e instanceof Min || e instanceof Max || e instanceof Avg || e instanceof Sum;\n+        return (e instanceof Min || e instanceof Max || e instanceof Avg || e instanceof Sum)\n+            && ((FoldableNumericAggregate) e).localFoldable() == false;", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5Mjk0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425692946", "bodyText": "I think it's more appropriate to name this:\nReplaceAggregatesWithLiterals", "author": "costin", "createdAt": "2020-05-15T09:52:55Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -772,6 +782,63 @@ private Expression simplify(BinaryComparison bc) {\n         }\n     }\n \n+    /**\n+     * Any numeric aggregates (avg, min, max, sum) acting on literals are converted to an iif(count(1)=0, null, literal*count(1)) for sum,\n+     * and to iif(count(1)=0,null,literal) for the other three.\n+     */\n+    private static class ReplaceAggregatesOfLiterals extends OptimizerRule<LogicalPlan> {", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxMTM5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425711395", "bodyText": "return new Alias(iif.source(), aliasName == null ? iif.sourceText() : aliasName, iif)", "author": "costin", "createdAt": "2020-05-15T10:28:32Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -772,6 +782,63 @@ private Expression simplify(BinaryComparison bc) {\n         }\n     }\n \n+    /**\n+     * Any numeric aggregates (avg, min, max, sum) acting on literals are converted to an iif(count(1)=0, null, literal*count(1)) for sum,\n+     * and to iif(count(1)=0,null,literal) for the other three.\n+     */\n+    private static class ReplaceAggregatesOfLiterals extends OptimizerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan p) {\n+            Holder<Boolean> isLocalRelation = new Holder<>(false);\n+            p.forEachUp(a -> {\n+                if (isLocalRelation.get() == false && a instanceof LocalRelation) {\n+                    isLocalRelation.set(true);\n+                }\n+            });\n+            \n+            // there is no need for a IIF(COUNT(1)=0,NULL,literal) for local relations, since the aggregate will be folded further down\n+            if (isLocalRelation.get()) {\n+                return p;\n+            }\n+\n+            Expression countOne = new Count(EMPTY, new Literal(Source.EMPTY, 1, DataTypes.LONG), false);\n+            Equals countEqZero = new Equals(EMPTY, countOne, new Literal(Source.EMPTY, 0, DataTypes.LONG));\n+            \n+            LogicalPlan plan = p.transformExpressionsUp(e -> {\n+                Expression exp = e;\n+                String aliasName = null;\n+                if (exp instanceof Alias) {\n+                    exp = ((Alias) exp).child();\n+                    aliasName = ((Alias) e).name();\n+                }\n+\n+                if (exp instanceof FoldableNumericAggregate) {\n+                    FoldableNumericAggregate fna = (FoldableNumericAggregate) exp;\n+                    \n+                    if (fna.localFoldable()) {\n+                        Expression argument = fna.field();\n+                        Expression iifElseResult;\n+                        \n+                        if (exp instanceof Sum) {\n+                            iifElseResult = new Mul(new Source(Location.EMPTY, \"MUL(COUNT(1), \" + argument.sourceText() + \")\"), countOne,\n+                                Literal.of(argument));\n+                        } else {\n+                            iifElseResult = Literal.of(argument);\n+                        }\n+                        Source source = new Source(fna.sourceLocation(), \"IIF(COUNT(1) = 0, NULL, \" + iifElseResult.sourceText() + \")\");\n+                            \n+                        Iif iif = new Iif(source, countEqZero, Literal.NULL, iifElseResult);\n+                        return aliasName == null ? Expressions.wrapAsNamed(iif) : new Alias(iif.source(), aliasName, iif);", "originalCommit": "254b06064a8ae9ee1fef7c37872fd7e45da96032", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a0ea85c37b4ebe783c13d0b2b05297de7bf90fd9", "url": "https://github.com/elastic/elasticsearch/commit/a0ea85c37b4ebe783c13d0b2b05297de7bf90fd9", "message": "Address reviews", "committedDate": "2020-05-15T14:48:36Z", "type": "commit"}, {"oid": "09f62bf7f1e9053907c7c3ef212f9dbea5989231", "url": "https://github.com/elastic/elasticsearch/commit/09f62bf7f1e9053907c7c3ef212f9dbea5989231", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 55569_impl", "committedDate": "2020-05-15T14:48:50Z", "type": "commit"}, {"oid": "a4c5c96348b457dcf487107b9aa906aa1003c637", "url": "https://github.com/elastic/elasticsearch/commit/a4c5c96348b457dcf487107b9aa906aa1003c637", "message": "Small improvement", "committedDate": "2020-05-15T14:59:39Z", "type": "commit"}, {"oid": "35735fc4e6efbae68d0decd02e964021b087f4a9", "url": "https://github.com/elastic/elasticsearch/commit/35735fc4e6efbae68d0decd02e964021b087f4a9", "message": "Polish", "committedDate": "2020-05-15T15:14:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkwNDA5NA==", "url": "https://github.com/elastic/elasticsearch/pull/56786#discussion_r425904094", "bodyText": "I think we could return LONG here as COUNT is always LONG.", "author": "matriv", "createdAt": "2020-05-15T16:10:32Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -839,6 +819,21 @@ protected LogicalPlan rule(LogicalPlan p) {\n         }\n     }\n \n+    /**\n+     * A COUNT in a local relation will always be 1.\n+     */\n+    private static class ReplaceCountInLocalRelation extends OptimizerRule<Aggregate> {\n+\n+        @Override\n+        protected LogicalPlan rule(Aggregate a) {\n+            boolean hasLocalRelation = a.anyMatch(LocalRelation.class::isInstance);\n+            \n+            return hasLocalRelation ? a.transformExpressionsDown(c -> {\n+                return c instanceof Count ? new Literal(c.source(), 1, DataTypes.INTEGER) : c;", "originalCommit": "a0ea85c37b4ebe783c13d0b2b05297de7bf90fd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "35b785c0fa6e89cbd30451418f0ab42642d738ce", "url": "https://github.com/elastic/elasticsearch/commit/35b785c0fa6e89cbd30451418f0ab42642d738ce", "message": "Further polishing", "committedDate": "2020-05-15T20:43:33Z", "type": "commit"}, {"oid": "855a34856e79a86eb6e638a0cac02ec698912133", "url": "https://github.com/elastic/elasticsearch/commit/855a34856e79a86eb6e638a0cac02ec698912133", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 55569_impl", "committedDate": "2020-05-15T20:43:48Z", "type": "commit"}]}