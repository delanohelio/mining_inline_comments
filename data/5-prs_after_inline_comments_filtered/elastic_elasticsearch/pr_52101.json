{"pr_number": 52101, "pr_title": "SQL: Fix issue with timezone when paginating", "pr_createdAt": "2020-02-08T23:09:07Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52101", "timeline": [{"oid": "a488512e3abd83b8de95ef0cbfcd9b2adc2b8a86", "url": "https://github.com/elastic/elasticsearch/commit/a488512e3abd83b8de95ef0cbfcd9b2adc2b8a86", "message": "SQL: Fix issue with timezone when paginating\n\nPreviously, when the specified (or default) fetchSize led to\nsubsequent HTTP requests and the usage of cursors, those subsequent\nwere no longer using the client timezone specified in the initial\nSQL query. As a consequence, Even though the query is executed once\n(with the correct timezone) the processing of the query results by\nthe HitExtractors in the next pages was done using the default\ntimezone `Z`. This could lead to incorrect results.\n\nFix the issue by correctly using the initially specified timezone,\nwhich is found in the deserialisation of the cursor string.\n\nFixes: #51258", "committedDate": "2020-02-08T22:46:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc5NDA0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376794046", "bodyText": "Can't you move this part in the if (i==0) {} else {} above?", "author": "astefan", "createdAt": "2020-02-09T15:50:39Z", "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/rest/RestSqlTestCase.java", "diffHunk": "@@ -151,6 +155,74 @@ public void testNextPage() throws IOException {\n                 ContentType.APPLICATION_JSON), StringUtils.EMPTY, mode));\n     }\n \n+    public void testNextPageWithDatetimeAndTimezoneParam() throws IOException {\n+        Request request = new Request(\"PUT\", \"/test_date_timezone\");\n+        XContentBuilder createIndex = JsonXContent.contentBuilder().startObject();\n+        createIndex.startObject(\"mappings\");\n+        {\n+            createIndex.startObject(\"properties\");\n+            {\n+                createIndex.startObject(\"date\").field(\"type\", \"date\").field(\"format\", \"epoch_millis\");\n+                createIndex.endObject();\n+            }\n+            createIndex.endObject();\n+        }\n+        createIndex.endObject().endObject();\n+        request.setJsonEntity(Strings.toString(createIndex));\n+        client().performRequest(request);\n+\n+        request = new Request(\"PUT\", \"/test_date_timezone/_bulk\");\n+        request.addParameter(\"refresh\", \"true\");\n+        StringBuilder bulk = new StringBuilder();\n+        long[] datetimes = new long[] { 1_000, 10_000, 100_000, 1_000_000, 10_000_000 };\n+        for (long datetime : datetimes) {\n+            bulk.append(\"{\\\"index\\\":{}}\\n\");\n+            bulk.append(\"{\\\"date\\\":\").append(datetime).append(\"}\\n\");\n+        }\n+        request.setJsonEntity(bulk.toString());\n+        assertEquals(200, client().performRequest(request).getStatusLine().getStatusCode());\n+\n+        ZoneId zoneId = randomZone();\n+        String mode = randomMode();\n+        String sqlRequest =\n+                \"{\\\"query\\\":\\\"SELECT DATE_PART('TZOFFSET', date) AS tz FROM test_date_timezone ORDER BY date\\\",\"\n+                        + \"\\\"time_zone\\\":\\\"\" + zoneId.getId() + \"\\\", \"\n+                        + \"\\\"mode\\\":\\\"\" + mode + \"\\\", \"\n+                        + \"\\\"fetch_size\\\":2}\";\n+\n+        String cursor = null;\n+        for (int i = 0; i <= datetimes.length; i += 2) {\n+            Map<String, Object> response;\n+            if (i == 0) {\n+                response = runSql(new StringEntity(sqlRequest, ContentType.APPLICATION_JSON), \"\", mode);\n+            } else {\n+                response = runSql(new StringEntity(\"{\\\"cursor\\\":\\\"\" + cursor + \"\\\"\" + mode(mode) + \"}\",\n+                        ContentType.APPLICATION_JSON), StringUtils.EMPTY, mode);\n+            }\n+\n+            Map<String, Object> expected = new HashMap<>();\n+            if (i == 0) {\n+                expected.put(\"columns\", singletonList(\n+                        columnInfo(mode, \"tz\", \"integer\", JDBCType.INTEGER, 11)));\n+            }", "originalCommit": "a488512e3abd83b8de95ef0cbfcd9b2adc2b8a86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc5NzczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376797735", "bodyText": "Can you move this line on the above one?", "author": "astefan", "createdAt": "2020-02-09T16:43:55Z", "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/FetchSizeTestCase.java", "diffHunk": "@@ -102,6 +107,51 @@ public void testIncompleteScroll() throws Exception {\n         assertNoSearchContexts();\n     }\n \n+    public void testScrollWithDatetimeAndTimezoneParam() throws IOException, SQLException {\n+        Request request = new Request(\"PUT\", \"/test_date_timezone\");\n+        XContentBuilder createIndex = JsonXContent.contentBuilder().startObject();\n+        createIndex.startObject(\"mappings\");\n+        {\n+            createIndex.startObject(\"properties\");\n+            {\n+                createIndex.startObject(\"date\").field(\"type\", \"date\").field(\"format\", \"epoch_millis\");\n+                createIndex.endObject();\n+            }\n+            createIndex.endObject();\n+        }\n+        createIndex.endObject().endObject();\n+        request.setJsonEntity(Strings.toString(createIndex));\n+        client().performRequest(request);\n+\n+        request = new Request(\"PUT\", \"/test_date_timezone/_bulk\");\n+        request.addParameter(\"refresh\", \"true\");\n+        StringBuilder bulk = new StringBuilder();\n+        long[] datetimes = new long[] { 1_000, 10_000, 100_000, 1_000_000, 10_000_000 };\n+        for (long datetime : datetimes) {\n+            bulk.append(\"{\\\"index\\\":{}}\\n\");\n+            bulk.append(\"{\\\"date\\\":\").append(datetime).append(\"}\\n\");\n+        }\n+        request.setJsonEntity(bulk.toString());\n+        assertEquals(200, client().performRequest(request).getStatusLine().getStatusCode());\n+\n+        ZoneId zoneId = randomZone();\n+        Properties connectionProperties = connectionProperties();\n+        connectionProperties.put(JDBC_TIMEZONE, zoneId.toString());\n+        try (Connection c = esJdbc(connectionProperties);\n+             Statement s = c.createStatement()) {", "originalCommit": "a488512e3abd83b8de95ef0cbfcd9b2adc2b8a86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc5ODM5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376798393", "bodyText": "Sure, just kept the style from the other tests, e.g.: https://github.com/elastic/elasticsearch/pull/52101/files/a488512e3abd83b8de95ef0cbfcd9b2adc2b8a86#diff-7eb5a40bcec78e0f582b7ef886430b28R95", "author": "matriv", "createdAt": "2020-02-09T16:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc5NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzMTEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376931136", "bodyText": "A(n appropriate) formatter should help in these style-adjusting cases.", "author": "bpintea", "createdAt": "2020-02-10T08:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc5NzczNQ=="}], "type": "inlineReview"}, {"oid": "c891567c397e9a88c3adc6d8b2a67036e0ee5efb", "url": "https://github.com/elastic/elasticsearch/commit/c891567c397e9a88c3adc6d8b2a67036e0ee5efb", "message": "Address comments", "committedDate": "2020-02-09T17:06:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzODk0MA==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376938940", "bodyText": "I think it's perfectly fine as is, but was curious about the reason - if any - for choosing a fetch_size of 2, vs. 1, which would simplify the test just a bit.", "author": "bpintea", "createdAt": "2020-02-10T09:14:19Z", "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/rest/RestSqlTestCase.java", "diffHunk": "@@ -151,6 +155,70 @@ public void testNextPage() throws IOException {\n                 ContentType.APPLICATION_JSON), StringUtils.EMPTY, mode));\n     }\n \n+    public void testNextPageWithDatetimeAndTimezoneParam() throws IOException {\n+        Request request = new Request(\"PUT\", \"/test_date_timezone\");\n+        XContentBuilder createIndex = JsonXContent.contentBuilder().startObject();\n+        createIndex.startObject(\"mappings\");\n+        {\n+            createIndex.startObject(\"properties\");\n+            {\n+                createIndex.startObject(\"date\").field(\"type\", \"date\").field(\"format\", \"epoch_millis\");\n+                createIndex.endObject();\n+            }\n+            createIndex.endObject();\n+        }\n+        createIndex.endObject().endObject();\n+        request.setJsonEntity(Strings.toString(createIndex));\n+        client().performRequest(request);\n+\n+        request = new Request(\"PUT\", \"/test_date_timezone/_bulk\");\n+        request.addParameter(\"refresh\", \"true\");\n+        StringBuilder bulk = new StringBuilder();\n+        long[] datetimes = new long[] { 1_000, 10_000, 100_000, 1_000_000, 10_000_000 };\n+        for (long datetime : datetimes) {\n+            bulk.append(\"{\\\"index\\\":{}}\\n\");\n+            bulk.append(\"{\\\"date\\\":\").append(datetime).append(\"}\\n\");\n+        }\n+        request.setJsonEntity(bulk.toString());\n+        assertEquals(200, client().performRequest(request).getStatusLine().getStatusCode());\n+\n+        ZoneId zoneId = randomZone();\n+        String mode = randomMode();\n+        String sqlRequest =\n+                \"{\\\"query\\\":\\\"SELECT DATE_PART('TZOFFSET', date) AS tz FROM test_date_timezone ORDER BY date\\\",\"\n+                        + \"\\\"time_zone\\\":\\\"\" + zoneId.getId() + \"\\\", \"\n+                        + \"\\\"mode\\\":\\\"\" + mode + \"\\\", \"\n+                        + \"\\\"fetch_size\\\":2}\";", "originalCommit": "c891567c397e9a88c3adc6d8b2a67036e0ee5efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0OTIxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376949213", "bodyText": "Fetch size 2 and odd number of rows ('5') makes the last page to return 1 row.", "author": "matriv", "createdAt": "2020-02-10T09:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzODk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376965896", "bodyText": "Sure, there'll be pages with 1 and 2 rows as the j-based for makes it obvious.\nBut I was only curious to understand why is that desired in respect to what the test checks (i.e. all rows have the same timezone offset). Sorry if missing anything obvious. :-)", "author": "bpintea", "createdAt": "2020-02-10T10:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzODk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NzM1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r376967357", "bodyText": "Doesn't have to do with the bug fixed, just another safety testing that the fetch size behavior is correct.", "author": "matriv", "createdAt": "2020-02-10T10:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzODk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3NzU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r377077543", "bodyText": "Is Cursors.decodeFromString used anywhere else ? It might be that decoding a tuple of timezone or adding it as a property in the Cursor class should be the default.", "author": "costin", "createdAt": "2020-02-10T13:58:27Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TransportSqlQueryAction.java", "diffHunk": "@@ -80,13 +83,14 @@ public static void operation(PlanExecutor planExecutor, SqlQueryRequest request,\n             planExecutor.sql(cfg, request.query(), request.params(),\n                     wrap(p -> listener.onResponse(createResponseWithSchema(request, p)), listener::onFailure));\n         } else {\n-            planExecutor.nextPage(cfg, Cursors.decodeFromString(request.cursor()),\n-                    wrap(p -> listener.onResponse(createResponse(request, null, p)),\n+            Tuple<Cursor, ZoneId> decoded = Cursors.decodeFromStringWithZone(request.cursor());", "originalCommit": "c891567c397e9a88c3adc6d8b2a67036e0ee5efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5OTQ4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r377199486", "bodyText": "I'm planning to do that in an upcoming PR.", "author": "matriv", "createdAt": "2020-02-10T17:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3NzU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxODI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r377618272", "bodyText": "Ad discussed, will not pass the zoneId into the Cursor, as zoneId is the responsibility of SqlInput/OutputStreams to handle. Instead, I remove the decodeFromString and only use the decodeFromStringWithZone, so it's obvious for consumers that the zoneId is always decoded as well and returned as part of the returned Tuple.", "author": "matriv", "createdAt": "2020-02-11T12:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3NzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3Nzk5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r377077990", "bodyText": "Nit: why make it private ? I think this will make things a bit harded in debug project.", "author": "costin", "createdAt": "2020-02-10T13:59:16Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TransportSqlQueryAction.java", "diffHunk": "@@ -68,7 +71,7 @@ protected void doExecute(Task task, SqlQueryRequest request, ActionListener<SqlQ\n     /**\n      * Actual implementation of the action. Statically available to support embedded mode.\n      */\n-    public static void operation(PlanExecutor planExecutor, SqlQueryRequest request, ActionListener<SqlQueryResponse> listener,\n+    private static void operation(PlanExecutor planExecutor, SqlQueryRequest request, ActionListener<SqlQueryResponse> listener,", "originalCommit": "c891567c397e9a88c3adc6d8b2a67036e0ee5efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MDg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52101#discussion_r377080885", "bodyText": "Ah, didn't think of that, Thx, I'll revert", "author": "matriv", "createdAt": "2020-02-10T14:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3Nzk5MA=="}], "type": "inlineReview"}, {"oid": "81605e862fc02d3c55550b4f8d8d0e8748352376", "url": "https://github.com/elastic/elasticsearch/commit/81605e862fc02d3c55550b4f8d8d0e8748352376", "message": "revert private on operation()", "committedDate": "2020-02-10T18:21:18Z", "type": "commit"}, {"oid": "01203570d98db00e4cbaf696c7790e6203f8f4ce", "url": "https://github.com/elastic/elasticsearch/commit/01203570d98db00e4cbaf696c7790e6203f8f4ce", "message": "Merge remote-tracking branch 'upstream/master' into fix-51258", "committedDate": "2020-02-10T19:01:47Z", "type": "commit"}, {"oid": "e95628a8296e0bc712ecaece512e661d202a4085", "url": "https://github.com/elastic/elasticsearch/commit/e95628a8296e0bc712ecaece512e661d202a4085", "message": "make sure decodefromstringWithZone is always used", "committedDate": "2020-02-11T12:57:19Z", "type": "commit"}]}