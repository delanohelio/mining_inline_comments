{"pr_number": 65600, "pr_title": "Add xpack info and usage endpoints for runtime fields", "pr_createdAt": "2020-11-30T13:11:40Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65600", "timeline": [{"oid": "0e02542a9ffbfb060e4000c8f9660ef09aab765e", "url": "https://github.com/elastic/elasticsearch/commit/0e02542a9ffbfb060e4000c8f9660ef09aab765e", "message": "Add xpack info and usage endpoints for runtime fields", "committedDate": "2020-11-25T21:05:23Z", "type": "commit"}, {"oid": "4bfe5105a25f5c1df40bb49532403fe9c7bf7b28", "url": "https://github.com/elastic/elasticsearch/commit/4bfe5105a25f5c1df40bb49532403fe9c7bf7b28", "message": "wip", "committedDate": "2020-11-30T12:59:57Z", "type": "commit"}, {"oid": "782a558385199f337a0f76b3d9ef1f49bf257520", "url": "https://github.com/elastic/elasticsearch/commit/782a558385199f337a0f76b3d9ef1f49bf257520", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry", "committedDate": "2020-11-30T13:00:20Z", "type": "commit"}, {"oid": "5773c0bd0c921c22136d04e55942ff751215f050", "url": "https://github.com/elastic/elasticsearch/commit/5773c0bd0c921c22136d04e55942ff751215f050", "message": "iter", "committedDate": "2020-11-30T13:09:06Z", "type": "commit"}, {"oid": "82979ec030e88234eaac340b22937dcbb2ba44fe", "url": "https://github.com/elastic/elasticsearch/commit/82979ec030e88234eaac340b22937dcbb2ba44fe", "message": "spotless", "committedDate": "2020-11-30T13:18:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NDUwNA==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532594504", "bodyText": "We have MappingVisitor which already implements some of this, although it looks in properties rather than runtime - might be worth extending or re-using some of that?", "author": "romseygeek", "createdAt": "2020-11-30T13:26:27Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");", "originalCommit": "82979ec030e88234eaac340b22937dcbb2ba44fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5ODI0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532598240", "bodyText": "I am aware, those rely on standard field type structure also. To reuse the existing mappings visitor I should have made a runtime visitor that looks in the runtime section instead of properties, and also plugin a function to process fields differently for runtime fields, as we want to have additional stats for them. Also, the standard mappings visitor looks at multi fields recursively which is not something that we support for runtime fields. The only call to this visitor would be from the runtime fields usage api, hence I thought it's overkill. I believe it would be more lines added for the added flexibility than shared between the two implementations. What do you think?", "author": "javanna", "createdAt": "2020-11-30T13:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NDUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5OTU1OA==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532799558", "bodyText": "I figure if we see the need later we'll add a visitor but that this works fine for now.", "author": "nik9000", "createdAt": "2020-11-30T18:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NDUwNA=="}], "type": "inlineReview"}, {"oid": "295826641939488e46074883d37582afb542e055", "url": "https://github.com/elastic/elasticsearch/commit/295826641939488e46074883d37582afb542e055", "message": "docs failures", "committedDate": "2020-11-30T13:36:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5ODkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532798925", "bodyText": "\ud83d\udc4d\nWhile you are here could you make them one per line and alphabetical order? I know it is a pain but it'll push everyone who comes after you to be neat and tidy.", "author": "nik9000", "createdAt": "2020-11-30T18:11:00Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/action/XPackUsageFeatureAction.java", "diffHunk": "@@ -47,17 +44,13 @@\n     public static final XPackUsageFeatureAction DATA_STREAMS = new XPackUsageFeatureAction(XPackField.DATA_STREAMS);\n     public static final XPackUsageFeatureAction DATA_TIERS = new XPackUsageFeatureAction(XPackField.DATA_TIERS);\n     public static final XPackUsageFeatureAction AGGREGATE_METRIC = new XPackUsageFeatureAction(XPackField.AGGREGATE_METRIC);\n+    public static final XPackUsageFeatureAction RUNTIME_FIELDS = new XPackUsageFeatureAction(XPackField.RUNTIME_FIELDS);\n \n-    public static final List<XPackUsageFeatureAction> ALL;\n-    static {\n-        final List<XPackUsageFeatureAction> actions = new ArrayList<>();\n-        actions.addAll(Arrays.asList(\n-            SECURITY, MONITORING, WATCHER, GRAPH, MACHINE_LEARNING, LOGSTASH, EQL, SQL, ROLLUP, INDEX_LIFECYCLE, SNAPSHOT_LIFECYCLE, CCR,\n-            TRANSFORM, VECTORS, VOTING_ONLY, FROZEN_INDICES, SPATIAL, ANALYTICS, DATA_STREAMS, SEARCHABLE_SNAPSHOTS, DATA_TIERS,\n-            AGGREGATE_METRIC\n-        ));\n-        ALL = Collections.unmodifiableList(actions);\n-    }\n+    static final List<XPackUsageFeatureAction> ALL = List.of(\n+        SECURITY, MONITORING, WATCHER, GRAPH, MACHINE_LEARNING, LOGSTASH, EQL, SQL, ROLLUP, INDEX_LIFECYCLE, SNAPSHOT_LIFECYCLE, CCR,\n+        TRANSFORM, VECTORS, VOTING_ONLY, FROZEN_INDICES, SPATIAL, ANALYTICS, DATA_STREAMS, SEARCHABLE_SNAPSHOTS, DATA_TIERS,\n+        AGGREGATE_METRIC, RUNTIME_FIELDS", "originalCommit": "295826641939488e46074883d37582afb542e055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDEwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532800105", "bodyText": "If you cast to Map<?, ?> you don't need to suppress and .values will still return Object. You can't .put on the map but you don't need to.", "author": "nik9000", "createdAt": "2020-11-30T18:12:55Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;", "originalCommit": "295826641939488e46074883d37582afb542e055", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532800167", "bodyText": "Just a sneaky way to save a line.", "author": "nik9000", "createdAt": "2020-11-30T18:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE5MTkxOA==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r533191918", "bodyText": "nice trick", "author": "javanna", "createdAt": "2020-12-01T09:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTA3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532801076", "bodyText": "Is there any chance you could flip this so it continues if mappingMetadata is null. I find quick continues to be easier to short cut in my head when reading. With these indenting ifs I have to scroll down and check if there is an else.", "author": "nik9000", "createdAt": "2020-11-30T18:14:35Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {", "originalCommit": "295826641939488e46074883d37582afb542e055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTcxNg==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532801716", "bodyText": "If script isn't an instanceof Map can it be a String? Would we get the short form here?", "author": "nik9000", "createdAt": "2020-11-30T18:15:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {", "originalCommit": "295826641939488e46074883d37582afb542e055", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjA0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532862044", "bodyText": "It is my understanding that regardless of how it was submitted, the script always gets outputted in the long form. I will double check though. That is also why I am using the Script class in the unit tests", "author": "javanna", "createdAt": "2020-11-30T19:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjIzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532802235", "bodyText": "Any reason not to use a List in the response? I know we sometimes use List and sometimes arrays but I've never been sure why.", "author": "nik9000", "createdAt": "2020-11-30T18:16:28Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Map<String, Object> script = (Map<String, Object>) scriptObject;\n+                                    Object sourceObject = script.get(\"source\");\n+                                    if (sourceObject != null) {\n+                                        String scriptSource = sourceObject.toString();\n+                                        int chars = scriptSource.length();\n+                                        long lines = scriptSource.lines().count();\n+                                        int docUsages = countOccurrences(scriptSource, \"doc[\\\\[\\\\.]\");\n+                                        int sourceUsages = countOccurrences(scriptSource, \"params\\\\._source\");\n+                                        stats.update(chars, lines, sourceUsages, docUsages);\n+                                    }\n+                                    Object langObject = script.get(\"lang\");\n+                                    if (langObject != null) {\n+                                        stats.scriptLangs.add(langObject.toString());\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        RuntimeFieldStats[] runtimeFieldStats = fieldTypes.values().toArray(new RuntimeFieldStats[0]);\n+        Arrays.sort(runtimeFieldStats, Comparator.comparing(RuntimeFieldStats::type));\n+        return new RuntimeFieldsFeatureSetUsage(runtimeFieldStats);", "originalCommit": "295826641939488e46074883d37582afb542e055", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMDE4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532900183", "bodyText": "I generally use a list when elements need to be added, and an array otherwise. I guess you'd like to use a list because it can be made truly immutable?", "author": "javanna", "createdAt": "2020-11-30T21:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MzY3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532943676", "bodyText": "Mostly because we accumulated a list so it feels like we may as well keep it that way. Either way is fine.", "author": "nik9000", "createdAt": "2020-11-30T22:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjc5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532802796", "bodyText": "= 0 is the default, right?", "author": "nik9000", "createdAt": "2020-11-30T18:17:25Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Map<String, Object> script = (Map<String, Object>) scriptObject;\n+                                    Object sourceObject = script.get(\"source\");\n+                                    if (sourceObject != null) {\n+                                        String scriptSource = sourceObject.toString();\n+                                        int chars = scriptSource.length();\n+                                        long lines = scriptSource.lines().count();\n+                                        int docUsages = countOccurrences(scriptSource, \"doc[\\\\[\\\\.]\");\n+                                        int sourceUsages = countOccurrences(scriptSource, \"params\\\\._source\");\n+                                        stats.update(chars, lines, sourceUsages, docUsages);\n+                                    }\n+                                    Object langObject = script.get(\"lang\");\n+                                    if (langObject != null) {\n+                                        stats.scriptLangs.add(langObject.toString());\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        RuntimeFieldStats[] runtimeFieldStats = fieldTypes.values().toArray(new RuntimeFieldStats[0]);\n+        Arrays.sort(runtimeFieldStats, Comparator.comparing(RuntimeFieldStats::type));\n+        return new RuntimeFieldsFeatureSetUsage(runtimeFieldStats);\n+    }\n+\n+    private final RuntimeFieldStats[] stats;\n+\n+    RuntimeFieldsFeatureSetUsage(RuntimeFieldStats[] stats) {\n+        super(XPackField.RUNTIME_FIELDS, true, true);\n+        this.stats = stats;\n+    }\n+\n+    public RuntimeFieldsFeatureSetUsage(StreamInput in) throws IOException {\n+        super(in);\n+        this.stats = in.readArray(RuntimeFieldStats::new, RuntimeFieldStats[]::new);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeArray(stats);\n+    }\n+\n+    RuntimeFieldStats[] getRuntimeFieldStats() {\n+        return stats;\n+    }\n+\n+    @Override\n+    protected void innerXContent(XContentBuilder builder, Params params) throws IOException {\n+        super.innerXContent(builder, params);\n+        builder.startArray(\"field_types\");\n+        for (RuntimeFieldStats stats : stats) {\n+            stats.toXContent(builder, params);\n+        }\n+        builder.endArray();\n+    }\n+\n+    @Override\n+    public Version getMinimalSupportedVersion() {\n+        return Version.V_7_11_0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        RuntimeFieldsFeatureSetUsage that = (RuntimeFieldsFeatureSetUsage) o;\n+        return Arrays.equals(stats, that.stats);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(stats);\n+    }\n+\n+    private static int countOccurrences(String script, String keyword) {\n+        int occurrences = 0;\n+        Pattern pattern = Pattern.compile(keyword);\n+        Matcher matcher = pattern.matcher(script);\n+        while (matcher.find()) {\n+            occurrences++;\n+        }\n+        return occurrences;\n+    }\n+\n+    static final class RuntimeFieldStats implements Writeable, ToXContentObject {\n+        private final String type;\n+        private int count = 0;\n+        private int indexCount = 0;\n+        private final Set<String> scriptLangs;\n+        private long scriptLessCount = 0;\n+        private long maxLines = 0;\n+        private long totalLines = 0;\n+        private long maxChars = 0;\n+        private long totalChars = 0;\n+        private long maxSourceUsages = 0;\n+        private long totalSourceUsages = 0;\n+        private long maxDocUsages = 0;\n+        private long totalDocUsages = 0;", "originalCommit": "295826641939488e46074883d37582afb542e055", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MzI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532863270", "bodyText": "I guess, but I always forget.", "author": "javanna", "createdAt": "2020-11-30T19:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMjkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532902902", "bodyText": "I think its worth double checking if this matches stuff like doc\\. I never can remember the escaping rules for character classes.", "author": "nik9000", "createdAt": "2020-11-30T21:05:29Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Map<String, Object> script = (Map<String, Object>) scriptObject;\n+                                    Object sourceObject = script.get(\"source\");\n+                                    if (sourceObject != null) {\n+                                        String scriptSource = sourceObject.toString();\n+                                        int chars = scriptSource.length();\n+                                        long lines = scriptSource.lines().count();\n+                                        int docUsages = countOccurrences(scriptSource, \"doc[\\\\[\\\\.]\");", "originalCommit": "295826641939488e46074883d37582afb542e055", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwNTU5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532905592", "bodyText": "I think it's ok, but I am not sure I can be trusted, I will double check", "author": "javanna", "createdAt": "2020-11-30T21:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMjkwMg=="}], "type": "inlineReview"}, {"oid": "c45f6cd6bbd6bc3288a80e2165df62eaa1bfc249", "url": "https://github.com/elastic/elasticsearch/commit/c45f6cd6bbd6bc3288a80e2165df62eaa1bfc249", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry", "committedDate": "2020-12-01T09:05:18Z", "type": "commit"}, {"oid": "b8447c39accd010536e1e5a0bf22cccb1016c298", "url": "https://github.com/elastic/elasticsearch/commit/b8447c39accd010536e1e5a0bf22cccb1016c298", "message": "iter", "committedDate": "2020-12-01T10:19:38Z", "type": "commit"}, {"oid": "16854e38568815d87e125dea671a12158adae53e", "url": "https://github.com/elastic/elasticsearch/commit/16854e38568815d87e125dea671a12158adae53e", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry", "committedDate": "2020-12-07T09:28:37Z", "type": "commit"}, {"oid": "7a870e85789cab0d6cdc4e4440dbcd6c9bcdad60", "url": "https://github.com/elastic/elasticsearch/commit/7a870e85789cab0d6cdc4e4440dbcd6c9bcdad60", "message": "iter", "committedDate": "2020-12-07T22:45:38Z", "type": "commit"}, {"oid": "c976a46d687826c9b03661ec1024f56769c4a7e1", "url": "https://github.com/elastic/elasticsearch/commit/c976a46d687826c9b03661ec1024f56769c4a7e1", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry", "committedDate": "2020-12-08T07:51:08Z", "type": "commit"}]}