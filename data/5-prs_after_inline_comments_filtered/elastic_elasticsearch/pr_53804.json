{"pr_number": 53804, "pr_title": "Add new point field.", "pr_createdAt": "2020-03-19T14:54:41Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53804", "timeline": [{"oid": "916a52b5c9a4aea7402c984b912f41875cfedc7b", "url": "https://github.com/elastic/elasticsearch/commit/916a52b5c9a4aea7402c984b912f41875cfedc7b", "message": "Add new point field.", "committedDate": "2020-03-19T14:50:21Z", "type": "commit"}, {"oid": "bfb8d4a06c4f367e844eade6b9132a3aa7a8e6c2", "url": "https://github.com/elastic/elasticsearch/commit/bfb8d4a06c4f367e844eade6b9132a3aa7a8e6c2", "message": "remove spaces", "committedDate": "2020-03-19T14:56:56Z", "type": "commit"}, {"oid": "be7c682200e4b773f2bfabe82769579d1718dd85", "url": "https://github.com/elastic/elasticsearch/commit/be7c682200e4b773f2bfabe82769579d1718dd85", "message": "license headers", "committedDate": "2020-03-19T15:11:30Z", "type": "commit"}, {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a", "url": "https://github.com/elastic/elasticsearch/commit/d4d2e0a5a386311fcad8c65016b799f499da343a", "message": "typo", "committedDate": "2020-03-19T15:15:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM5OTQzNA==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397399434", "bodyText": "We should probably make x and y a static ParseField type that can be reused?", "author": "nknize", "createdAt": "2020-03-24T19:13:43Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentSubParser;\n+import org.elasticsearch.common.xcontent.support.MapXContentParser;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.geometry.utils.StandardValidator;\n+import org.elasticsearch.geometry.utils.WellKnownText;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Locale;\n+\n+/**\n+ * Represents a point in the cartesian space.\n+ */\n+public final class CartesianPoint implements ToXContentFragment {\n+\n+    private float x;\n+    private float y;\n+\n+    public CartesianPoint() {\n+    }\n+\n+    public CartesianPoint(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public CartesianPoint reset(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+        return this;\n+    }\n+\n+    public CartesianPoint resetFromString(String value) {\n+        if (value.toLowerCase(Locale.ROOT).contains(\"point\")) {\n+            return resetFromWKT(value);\n+        } else {\n+            return resetFromCoordinates(value);\n+        }\n+    }\n+\n+\n+    public CartesianPoint resetFromCoordinates(String value) {\n+        String[] vals = value.split(\",\");\n+        if (vals.length != 2) {\n+            throw new ElasticsearchParseException(\"failed to parse [{}], expected 2 coordinates \"\n+                + \"but found: [{}]\", vals.length);\n+        }\n+        final float x;\n+        final float y;\n+        try {\n+            x = Float.parseFloat(vals[0].trim());\n+            if (Float.isFinite(x) == false) {\n+                throw new ElasticsearchParseException(\"invalid x value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", x);\n+            }\n+         } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"x must be a number\");\n+        }\n+        try {\n+            y = Float.parseFloat(vals[1].trim());\n+            if (Float.isFinite(y) == false) {\n+                throw new ElasticsearchParseException(\"invalid y value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", y);\n+            }\n+        } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"y must be a number\");\n+        }\n+        return reset(x, y);\n+    }\n+\n+    private CartesianPoint resetFromWKT(String value) {\n+        Geometry geometry;\n+        try {\n+            geometry = new WellKnownText(false, new StandardValidator(true))\n+                .fromWKT(value);\n+        } catch (Exception e) {\n+            throw new ElasticsearchParseException(\"Invalid WKT format\", e);\n+        }\n+        if (geometry.type() != ShapeType.POINT) {\n+            throw new ElasticsearchParseException(\"[geo_point] supports only POINT among WKT primitives, \" +\n+                \"but found \" + geometry.type());\n+        }\n+        org.elasticsearch.geometry.Point point = (org.elasticsearch.geometry.Point) geometry;\n+        return reset((float) point.getX(), (float) point.getY());\n+    }\n+\n+    public float getX() {\n+        return this.x;\n+    }\n+\n+    public float getY() {\n+        return this.y;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        CartesianPoint point = (CartesianPoint) o;\n+\n+        if (Float.compare(point.x, x) != 0) return false;\n+        if (Float.compare(point.y, y) != 0) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        int temp;\n+        temp = x != +0.0f ? Float.floatToIntBits(x) : 0;\n+        result = Integer.hashCode(temp);\n+        temp = y != +0.0f ? Float.floatToIntBits(y) : 0;\n+        result = 31 * result + Integer.hashCode(temp);\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return x + \", \" + y;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        return builder.startObject().field(\"x\", x).field(\"y\", y).endObject();\n+    }\n+\n+    public static CartesianPoint parsePoint(XContentParser parser, CartesianPoint point)\n+        throws IOException, ElasticsearchParseException {\n+        float x = Float.NaN;\n+        float y = Float.NaN;\n+        NumberFormatException numberFormatException = null;\n+\n+        if(parser.currentToken() == XContentParser.Token.START_OBJECT) {\n+            try (XContentSubParser subParser = new XContentSubParser(parser)) {\n+                while (subParser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                    if (subParser.currentToken() == XContentParser.Token.FIELD_NAME) {\n+                        String field = subParser.currentName();\n+                        if (\"x\".equals(field)) {\n+                            subParser.nextToken();\n+                            switch (subParser.currentToken()) {\n+                                case VALUE_NUMBER:\n+                                case VALUE_STRING:\n+                                    try {\n+                                        x = subParser.floatValue(true);\n+                                    } catch (NumberFormatException e) {\n+                                        numberFormatException = e;\n+                                    }\n+                                    break;\n+                                default:\n+                                    throw new ElasticsearchParseException(\"x must be a number\");\n+                            }\n+                        } else if (\"y\".equals(field)) {", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwMDQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397400479", "bodyText": "I know this is largely a mirror of GeoPoint but I'm wondering if we can achieve this using ObjectParser or ConstructingObjectParser? (something we've been meaning to address w/ GeoPoint as well). I'm not sure how that works with the parsing leniency we have on Point and GeoPoint (e.g., array vs comma delimited string).  Curious if @nik9000 or @talevy have some ideas. Maybe that can be done in a followup PR.", "author": "nknize", "createdAt": "2020-03-24T19:15:32Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentSubParser;\n+import org.elasticsearch.common.xcontent.support.MapXContentParser;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.geometry.utils.StandardValidator;\n+import org.elasticsearch.geometry.utils.WellKnownText;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Locale;\n+\n+/**\n+ * Represents a point in the cartesian space.\n+ */\n+public final class CartesianPoint implements ToXContentFragment {\n+\n+    private float x;\n+    private float y;\n+\n+    public CartesianPoint() {\n+    }\n+\n+    public CartesianPoint(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public CartesianPoint reset(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+        return this;\n+    }\n+\n+    public CartesianPoint resetFromString(String value) {\n+        if (value.toLowerCase(Locale.ROOT).contains(\"point\")) {\n+            return resetFromWKT(value);\n+        } else {\n+            return resetFromCoordinates(value);\n+        }\n+    }\n+\n+\n+    public CartesianPoint resetFromCoordinates(String value) {\n+        String[] vals = value.split(\",\");\n+        if (vals.length != 2) {\n+            throw new ElasticsearchParseException(\"failed to parse [{}], expected 2 coordinates \"\n+                + \"but found: [{}]\", vals.length);\n+        }\n+        final float x;\n+        final float y;\n+        try {\n+            x = Float.parseFloat(vals[0].trim());\n+            if (Float.isFinite(x) == false) {\n+                throw new ElasticsearchParseException(\"invalid x value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", x);\n+            }\n+         } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"x must be a number\");\n+        }\n+        try {\n+            y = Float.parseFloat(vals[1].trim());\n+            if (Float.isFinite(y) == false) {\n+                throw new ElasticsearchParseException(\"invalid y value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", y);\n+            }\n+        } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"y must be a number\");\n+        }\n+        return reset(x, y);\n+    }\n+\n+    private CartesianPoint resetFromWKT(String value) {\n+        Geometry geometry;\n+        try {\n+            geometry = new WellKnownText(false, new StandardValidator(true))\n+                .fromWKT(value);\n+        } catch (Exception e) {\n+            throw new ElasticsearchParseException(\"Invalid WKT format\", e);\n+        }\n+        if (geometry.type() != ShapeType.POINT) {\n+            throw new ElasticsearchParseException(\"[geo_point] supports only POINT among WKT primitives, \" +\n+                \"but found \" + geometry.type());\n+        }\n+        org.elasticsearch.geometry.Point point = (org.elasticsearch.geometry.Point) geometry;\n+        return reset((float) point.getX(), (float) point.getY());\n+    }\n+\n+    public float getX() {\n+        return this.x;\n+    }\n+\n+    public float getY() {\n+        return this.y;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        CartesianPoint point = (CartesianPoint) o;\n+\n+        if (Float.compare(point.x, x) != 0) return false;\n+        if (Float.compare(point.y, y) != 0) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        int temp;\n+        temp = x != +0.0f ? Float.floatToIntBits(x) : 0;\n+        result = Integer.hashCode(temp);\n+        temp = y != +0.0f ? Float.floatToIntBits(y) : 0;\n+        result = 31 * result + Integer.hashCode(temp);\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return x + \", \" + y;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        return builder.startObject().field(\"x\", x).field(\"y\", y).endObject();\n+    }\n+\n+    public static CartesianPoint parsePoint(XContentParser parser, CartesianPoint point)", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNTA5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397405094", "bodyText": "I'm good with this as is for this PR, but we will likely want to consider adding Z values to points like we do for GeoPoint. This way users can add a third dimension to source only. Future PR is fine; at which time we may want to consider sharing code by deriving from GeoPointFieldMapper.TypeParser.", "author": "nknize", "createdAt": "2020-03-24T19:23:54Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA5MjkwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r400092905", "bodyText": "I agree to keep consistent with Shape field", "author": "iverase", "createdAt": "2020-03-30T10:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNTcyMA==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397405720", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Parses point represented as an object or an array, ignores malformed geopoints if needed\n          \n          \n            \n                 * Parses point represented as an object or an array, ignores malformed points if needed", "author": "nknize", "createdAt": "2020-03-24T19:25:03Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+    }\n+\n+    protected void parse(ParseContext context, CartesianPoint point) throws IOException {\n+\n+        if (fieldType().indexOptions() != IndexOptions.NONE) {\n+            context.doc().add(new XYPointField(fieldType().name(), point.getX(), point.getY()));\n+        }\n+        if (fieldType().stored()) {\n+            context.doc().add(new StoredField(fieldType().name(), point.toString()));\n+        }\n+        if (fieldType.hasDocValues()) {\n+            context.doc().add(new XYDocValuesField(fieldType().name(), point.getX(), point.getY()));\n+        } else if (fieldType().stored() || fieldType().indexOptions() != IndexOptions.NONE) {\n+            List<IndexableField> fields = new ArrayList<>(1);\n+            createFieldNamesField(context, fields);\n+            for (IndexableField field : fields) {\n+                context.doc().add(field);\n+            }\n+        }\n+        // if the mapping contains multi-fields then throw an error?\n+        if (multiFields.iterator().hasNext()) {\n+            throw new ElasticsearchParseException(\"[{}] field type does not accept multi-fields\", CONTENT_TYPE);\n+        }\n+    }\n+\n+    @Override\n+    public void parse(ParseContext context) throws IOException {\n+        context.path().add(simpleName());\n+\n+        try {\n+            CartesianPoint sparse = context.parseExternalValue(CartesianPoint.class);\n+\n+            if (sparse != null) {\n+                parse(context, sparse);\n+            } else {\n+                sparse = new CartesianPoint();\n+                XContentParser.Token token = context.parser().currentToken();\n+                if (token == XContentParser.Token.START_ARRAY) {\n+                    token = context.parser().nextToken();\n+                    if (token == XContentParser.Token.VALUE_NUMBER) {\n+                        float x = context.parser().floatValue();\n+                        context.parser().nextToken();\n+                        float y = context.parser().floatValue();\n+                        token = context.parser().nextToken();\n+                        if (token != XContentParser.Token.END_ARRAY) {\n+                            throw new ElasticsearchParseException(\"[{}] field type does not accept > 2 dimensions\", CONTENT_TYPE);\n+                        }\n+                        parse(context, sparse.reset(x, y));\n+                    } else {\n+                        while (token != XContentParser.Token.END_ARRAY) {\n+                            parsePointIgnoringMalformed(context, sparse);\n+                            token = context.parser().nextToken();\n+                        }\n+                    }\n+                } else if (token == XContentParser.Token.VALUE_NULL) {\n+                    if (fieldType.nullValue() != null) {\n+                        parse(context, (CartesianPoint) fieldType.nullValue());\n+                    }\n+                } else {\n+                    parsePointIgnoringMalformed(context, sparse);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            throw new MapperParsingException(\"failed to parse field [{}] of type [{}]\", ex, fieldType().name(), fieldType().typeName());\n+        }\n+\n+        context.path().remove();\n+    }\n+\n+    /**\n+     * Parses point represented as an object or an array, ignores malformed geopoints if needed", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzIxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397407219", "bodyText": "This feels trappy. I think we need to add a new ValuesSourceType.POINT so users can't run geo_ aggregations on cartesian types? /cc @not-napoleon  Probably best to remove doc value support from this PR and add it as a separate feature PR.", "author": "nknize", "createdAt": "2020-03-24T19:27:57Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc1Njc3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397756773", "bodyText": "That should not be there. I have removed the method so it fall back to the default implementation that throws a meaningful error.", "author": "iverase", "createdAt": "2020-03-25T10:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397407775", "bodyText": "The more I think about this the more I think it's best we disable doc values for this PR and give it some more thought in a future PR. That's fine considering we weren't planning to add cartesian aggregation support until a future version anyway.", "author": "nknize", "createdAt": "2020-03-24T19:28:55Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+    }\n+\n+    protected void parse(ParseContext context, CartesianPoint point) throws IOException {\n+\n+        if (fieldType().indexOptions() != IndexOptions.NONE) {\n+            context.doc().add(new XYPointField(fieldType().name(), point.getX(), point.getY()));\n+        }\n+        if (fieldType().stored()) {\n+            context.doc().add(new StoredField(fieldType().name(), point.toString()));\n+        }\n+        if (fieldType.hasDocValues()) {", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MTI0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r400041243", "bodyText": "The reason I added doc values was to be able to execute IndexOrDocValuesQueries. This doc values are generated at Lucene level and my feeling is that it should not be a problem for backwards compatibility as they are already part of Lucene distribution.", "author": "iverase", "createdAt": "2020-03-30T09:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwOTk2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397409967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // wrap geoQuery as a ConstantScoreQuery\n          \n          \n            \n                    // wrap XYPoint query as a ConstantScoreQuery", "author": "nknize", "createdAt": "2020-03-24T19:32:41Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryPointProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.geo.XYCircle;\n+import org.apache.lucene.geo.XYRectangle;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.xpack.spatial.index.mapper.PointFieldMapper;\n+import org.elasticsearch.xpack.spatial.index.mapper.ShapeUtils;\n+\n+\n+public class ShapeQueryPointProcessor implements AbstractSearchableGeometryFieldType.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxMDQwOA==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397410408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // geo points only support intersects\n          \n          \n            \n                    // only the intersects relation is supported for indexed cartesian point types", "author": "nknize", "createdAt": "2020-03-24T19:33:29Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryPointProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.geo.XYCircle;\n+import org.apache.lucene.geo.XYRectangle;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.xpack.spatial.index.mapper.PointFieldMapper;\n+import org.elasticsearch.xpack.spatial.index.mapper.ShapeUtils;\n+\n+\n+public class ShapeQueryPointProcessor implements AbstractSearchableGeometryFieldType.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsPointFieldType(fieldName, context);\n+        // geo points only support intersects", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxMjAxNw==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397412017", "bodyText": "Can we create a public abstract class CartesianFieldMapperTests (or XYFieldMapperTests) that serves as the foundation for XYPointandXYShape`? I'm okay with doing that in a separate PR as well. I think it will make for better test management?", "author": "nknize", "createdAt": "2020-03-24T19:36:42Z", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapperTests.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.mapper.DocumentMapper;\n+import org.elasticsearch.index.mapper.DocumentMapperParser;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParsedDocument;\n+import org.elasticsearch.index.mapper.SourceToParse;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.spatial.SpatialPlugin;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+\n+import static org.elasticsearch.xpack.spatial.index.mapper.PointFieldMapper.Names.NULL_VALUE;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class PointFieldMapperTests extends ESSingleNodeTestCase {", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxMjcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397412727", "bodyText": "\ud83d\udc4d   Excellent reuse", "author": "nknize", "createdAt": "2020-03-24T19:37:59Z", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilderTests.java", "diffHunk": "@@ -49,28 +44,27 @@\n import static org.hamcrest.Matchers.anyOf;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class ShapeQueryBuilderTests extends AbstractQueryTestCase<ShapeQueryBuilder> {\n+public abstract class ShapeQueryBuilderTests extends AbstractQueryTestCase<ShapeQueryBuilder> {", "originalCommit": "d4d2e0a5a386311fcad8c65016b799f499da343a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "84bd9221d845d0e5cf63b2beef3458d9788b5ab0", "url": "https://github.com/elastic/elasticsearch/commit/84bd9221d845d0e5cf63b2beef3458d9788b5ab0", "message": "Merge branch 'master' into pointField", "committedDate": "2020-03-25T10:08:17Z", "type": "commit"}, {"oid": "fded7b6ebfa864efc2a20c447214ccf2fcd1dfc6", "url": "https://github.com/elastic/elasticsearch/commit/fded7b6ebfa864efc2a20c447214ccf2fcd1dfc6", "message": "address review comments", "committedDate": "2020-03-25T10:38:16Z", "type": "commit"}, {"oid": "e4d8113a1d4de3c10f21b0f5edd72363739acd08", "url": "https://github.com/elastic/elasticsearch/commit/e4d8113a1d4de3c10f21b0f5edd72363739acd08", "message": "unused imports", "committedDate": "2020-03-25T10:38:38Z", "type": "commit"}, {"oid": "e09634c7f16b5e2c77bca7ab39aec02f2869d9ad", "url": "https://github.com/elastic/elasticsearch/commit/e09634c7f16b5e2c77bca7ab39aec02f2869d9ad", "message": "Added static ParseField", "committedDate": "2020-03-30T08:06:37Z", "type": "commit"}, {"oid": "d98f264d736e383c1a94acef8fd29b02d64cc1f4", "url": "https://github.com/elastic/elasticsearch/commit/d98f264d736e383c1a94acef8fd29b02d64cc1f4", "message": "Merge branch 'master' into pointField", "committedDate": "2020-03-30T08:26:15Z", "type": "commit"}, {"oid": "4631f44170c8bba83da2cc69892276a4790a8cdc", "url": "https://github.com/elastic/elasticsearch/commit/4631f44170c8bba83da2cc69892276a4790a8cdc", "message": "add base class for testing cartesian field mappers", "committedDate": "2020-03-30T08:58:59Z", "type": "commit"}, {"oid": "0d4987a70a7f82e3bb0d99ec7707f1b851dd3d6c", "url": "https://github.com/elastic/elasticsearch/commit/0d4987a70a7f82e3bb0d99ec7707f1b851dd3d6c", "message": "add support for Z value", "committedDate": "2020-03-30T10:36:59Z", "type": "commit"}, {"oid": "0a4f4ebfc9ad701a4c105abb4a35dd2273aed755", "url": "https://github.com/elastic/elasticsearch/commit/0a4f4ebfc9ad701a4c105abb4a35dd2273aed755", "message": "checkStyle", "committedDate": "2020-03-30T10:53:18Z", "type": "commit"}, {"oid": "8f1c67416a5afeb8252c1612e9068da0a07febc2", "url": "https://github.com/elastic/elasticsearch/commit/8f1c67416a5afeb8252c1612e9068da0a07febc2", "message": "merge master", "committedDate": "2020-04-07T09:29:45Z", "type": "commit"}, {"oid": "2014fde9a50c2e97c4e1551a9f6d8df0d2ca315d", "url": "https://github.com/elastic/elasticsearch/commit/2014fde9a50c2e97c4e1551a9f6d8df0d2ca315d", "message": "fix merge issues", "committedDate": "2020-04-07T09:36:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyOTkxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r434329919", "bodyText": "@iverase, Y_FIELD.getPreferredName() should be Z_FIELD.getPreferredName()?", "author": "russcam", "createdAt": "2020-06-03T06:13:57Z", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentSubParser;\n+import org.elasticsearch.common.xcontent.support.MapXContentParser;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.geometry.utils.StandardValidator;\n+import org.elasticsearch.geometry.utils.WellKnownText;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.index.mapper.GeoPointFieldMapper.Names.IGNORE_Z_VALUE;\n+\n+/**\n+ * Represents a point in the cartesian space.\n+ */\n+public final class CartesianPoint implements ToXContentFragment {\n+\n+    private static final ParseField X_FIELD = new ParseField(\"x\");\n+    private static final ParseField Y_FIELD = new ParseField(\"y\");\n+    private static final ParseField Z_FIELD = new ParseField(\"z\");\n+\n+    private float x;\n+    private float y;\n+\n+    public CartesianPoint() {\n+    }\n+\n+    public CartesianPoint(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public CartesianPoint reset(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+        return this;\n+    }\n+\n+    public CartesianPoint resetFromString(String value, final boolean ignoreZValue) {\n+        if (value.toLowerCase(Locale.ROOT).contains(\"point\")) {\n+            return resetFromWKT(value, ignoreZValue);\n+        } else {\n+            return resetFromCoordinates(value, ignoreZValue);\n+        }\n+    }\n+\n+\n+    public CartesianPoint resetFromCoordinates(String value, final boolean ignoreZValue) {\n+        String[] vals = value.split(\",\");\n+        if (vals.length > 3 || vals.length < 2) {\n+            throw new ElasticsearchParseException(\"failed to parse [{}], expected 2 or 3 coordinates \"\n+                + \"but found: [{}]\", vals, vals.length);\n+        }\n+        final float x;\n+        final float y;\n+        try {\n+            x = Float.parseFloat(vals[0].trim());\n+            if (Float.isFinite(x) == false) {\n+                throw new ElasticsearchParseException(\"invalid [{}] value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\",\n+                    X_FIELD.getPreferredName(),\n+                    x);\n+            }\n+         } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"[{}]] must be a number\", X_FIELD.getPreferredName());\n+        }\n+        try {\n+            y = Float.parseFloat(vals[1].trim());\n+            if (Float.isFinite(y) == false) {\n+                throw new ElasticsearchParseException(\"invalid [{}] value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\",\n+                    Y_FIELD.getPreferredName(),\n+                    y);\n+            }\n+        } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"[{}]] must be a number\", Y_FIELD.getPreferredName());\n+        }\n+        if (vals.length > 2) {\n+            try {\n+                CartesianPoint.assertZValue(ignoreZValue, Float.parseFloat(vals[2].trim()));\n+            } catch (NumberFormatException ex) {\n+                throw new ElasticsearchParseException(\"[{}]] must be a number\", Y_FIELD.getPreferredName());", "originalCommit": "2014fde9a50c2e97c4e1551a9f6d8df0d2ca315d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}