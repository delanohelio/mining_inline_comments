{"pr_number": 66486, "pr_title": "SQL: Implement TO_CHAR() function", "pr_createdAt": "2020-12-17T06:57:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66486", "timeline": [{"oid": "17ec6284e50375d9c1ced3b440afb7ca3eea978c", "url": "https://github.com/elastic/elasticsearch/commit/17ec6284e50375d9c1ced3b440afb7ca3eea978c", "message": "SQL: Implement to_char function (#54964)\n\nImplement to_char according to the PostgreSQL spec: https://www.postgresql.org/docs/9.1/functions-formatting.html by translating to the java.time patterns used in DATETIME_FORMAT.\nFollows: #54832", "committedDate": "2020-12-17T06:50:26Z", "type": "commit"}, {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf", "url": "https://github.com/elastic/elasticsearch/commit/32bbe9facef7d6a7b434a421966cfd342522abdf", "message": "SQL: TO_CHAR function implementation\n\n* Removed the recursive pattern matching that also required specific\nordering in the configuration of the Formatter\n* Upgraded the formatter to Postgres 13\n* All the Postgres formats are supported, there is also partial supports\n for the modifiers\n* Random unit test data generator script (in case we need to upgrade the\n format in the future)\n* Updated the documentation, added examples\n* Integration tests", "committedDate": "2020-12-17T06:50:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTMxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544855315", "bodyText": "Will move this out into a separate file.", "author": "palesz", "createdAt": "2020-12-17T07:01:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeFormatProcessor.java", "diffHunk": "@@ -36,22 +49,379 @@\n         {\"F\", \"S\"},\n         {\"z\", \"X\"}\n     };\n-    private final Formatter formatter;\n+    \n+    private static class ToCharFormatter {", "originalCommit": "32bbe9facef7d6a7b434a421966cfd342522abdf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MzczNg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545283736", "bodyText": "Since it sounds like the PR is not finished, you can mark it as draft until you get all the changes in and make it final once you are done with it so folks can actually start reviewing it.", "author": "costin", "createdAt": "2020-12-17T17:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544855997", "bodyText": "I think our tests don't run in parallel in the same JVM, so this should be safe, but if you have a better idea how to do this, I am all ears.", "author": "palesz", "createdAt": "2020-12-17T07:02:42Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    public static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(ZoneId.getAvailableZoneIds().stream().filter(\n+                z -> z.startsWith(\"America\") || z.startsWith(\"Europe\") || z.startsWith(\"Asia\") || z.startsWith(\"Africa\") \n+                    || Set.of(\"UTC\", \"GMT\", \"Z\").contains(z)\n+            ).collect(Collectors.toList()));\n+        }\n+\n+    }\n+\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\", \"TZH\", \"tzh\", \"TZM\", \"tzm\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final Set<String> PATTERNS_WITHOUT_MODIFIER_TEST = NOT_FULLY_MATCHABLE_PATTERNS;\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%6$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+    \n+        /**\n+         * Saves the generated test script into the file specified as the first and only argument.\n+         *\n+         * Once the file is generated, you can execute the following command to generate the output dataset with:\n+         *\n+         * <p>\n+         *  <code>\n+         *  PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql &gt; /tochar.csv\n+         *  </code>\n+         * </p>\n+         */\n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%2$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(Pattern.quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String expectedResult;\n+    \n+    private Locale defaultLocale = null;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString, \n+        String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+\n+    /**\n+     * Since the test dataset was exported from PostgreSQL using en_US locale, \n+     * let's stick with to that Locale during the testing of this function.\n+     */\n+    @Before\n+    public void changeLocaleToUS() {\n+        this.defaultLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+    }\n+    \n+    @After\n+    public void revertLocale() {\n+        Locale.setDefault(this.defaultLocale);\n+    }", "originalCommit": "32bbe9facef7d6a7b434a421966cfd342522abdf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzMjA2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545232062", "bodyText": "After adding the Locale.ROOT to the String.format and String.to{Lower,Upper}Case, this can be removed. Yay!", "author": "palesz", "createdAt": "2020-12-17T16:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTk5Nw=="}], "type": "inlineReview"}, {"oid": "95d32c3446b72b895ce424ee37ea901cbb21ff4e", "url": "https://github.com/elastic/elasticsearch/commit/95d32c3446b72b895ce424ee37ea901cbb21ff4e", "message": "Reverted the whitespace changes", "committedDate": "2020-12-17T16:00:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzMTEyNA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545231124", "bodyText": "Switching this to use offset instead of the zone names (so it will work on the CI server and with other Java versions too).", "author": "palesz", "createdAt": "2020-12-17T16:36:31Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    public static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(ZoneId.getAvailableZoneIds().stream().filter(\n+                z -> z.startsWith(\"America\") || z.startsWith(\"Europe\") || z.startsWith(\"Asia\") || z.startsWith(\"Africa\") \n+                    || Set.of(\"UTC\", \"GMT\", \"Z\").contains(z)\n+            ).collect(Collectors.toList()));", "originalCommit": "95d32c3446b72b895ce424ee37ea901cbb21ff4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2a9e30304ee7cf9689007bdb640bd28a1ec3578b", "url": "https://github.com/elastic/elasticsearch/commit/2a9e30304ee7cf9689007bdb640bd28a1ec3578b", "message": "Cleanups, minor bugfix, test timezone changes\n\n* Moved the ToCharFormatter into it's own file\n* Using a static set of timezones (full name, abbreviation and offsets)\navailable in Java and Postgres\n* Changed the way the century is calculated", "committedDate": "2020-12-17T22:39:14Z", "type": "commit"}, {"oid": "0b828fedd9b57a3b1be4257f367d0e85d9176f07", "url": "https://github.com/elastic/elasticsearch/commit/0b828fedd9b57a3b1be4257f367d0e85d9176f07", "message": "Checkstyle fixes, minor documentation tweaks", "committedDate": "2020-12-17T23:14:00Z", "type": "commit"}, {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "url": "https://github.com/elastic/elasticsearch/commit/5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "message": "Merge branch 'master' into feature/to-char-function", "committedDate": "2020-12-17T23:46:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3OTQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545779420", "bodyText": "was this line breaking intentional?", "author": "bpintea", "createdAt": "2020-12-18T11:44:30Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::fillNumeric;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPatterm) {\n+            return formatFn(javaPatterm, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String\n+                    formatted =", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzNDc2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545834762", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Builder formatFn(final String javaPatterm) {\n          \n          \n            \n                    public Builder formatFn(final String javaPattern) {", "author": "bpintea", "createdAt": "2020-12-18T13:36:31Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::fillNumeric;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPatterm) {", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzOTc1OA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545839758", "bodyText": "I guess the function naming is inspired from Posgres' docs (FM being the \"fill mode\"), but I still find it a tad misleading, since they actually strip (padding, like leading zeros or trailing spaces). Anyways, half a concern, maybe a quick comment would \"fill in\" the next reader. :-)", "author": "bpintea", "createdAt": "2020-12-18T13:45:40Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NDAwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545984005", "bodyText": "renamed the functions to removeLeadingZeros, removePadding", "author": "palesz", "createdAt": "2020-12-18T17:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzOTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg0MTg3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545841872", "bodyText": "I guess the comment can go.\n(Also, I thought that C++-style comments required a space after the leading slashes, I def. got some failures b/c of it.)", "author": "bpintea", "createdAt": "2020-12-18T13:49:12Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NDIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545984234", "bodyText": "Removed the comment. // does not require a space.", "author": "palesz", "createdAt": "2020-12-18T17:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg0MTg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NTc3OA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545855778", "bodyText": "Since you're iterating over the patterns in the loops above in the static block, you could also get the max length there. Just point it out, not saying it's any better.", "author": "bpintea", "createdAt": "2020-12-18T14:13:28Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyMDI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545920266", "bodyText": "True, but we can spare the cycles since this is a static number, can be computed once, the list of patterns does not change.\nNote: will put the annotation into a new line.", "author": "palesz", "createdAt": "2020-12-18T15:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NTc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NjM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545866394", "bodyText": "Wondering if extracting these strings (and the ones below) into static final vars would make sense.", "author": "bpintea", "createdAt": "2020-12-18T14:30:53Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyMTI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545921270", "bodyText": "Instead of creating static final for the strings, I can extract this check into a method with a reasonable name: isFillModeModifier(String pattern)", "author": "palesz", "createdAt": "2020-12-18T15:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NjM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545885711", "bodyText": "Wondering about the data type choice of a LinkedList (vs maybe just an ArrayList). I only see additions and removal from the tail. Has this remained like that after maybe a refactoring, or an explicit choice. I guess .removeLast() is more comfy than .remove(formatters.size() - 1), but just curious.", "author": "bpintea", "createdAt": "2020-12-18T14:54:50Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyMzE1MA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545923150", "bodyText": "Yes, removeLast is simpler and .remove(formatters.size() - 1) requires iteration over the list. Could use the list in reverse (add and remove from the beginning), but would have to reverse it at the end. At the same time, this is a local variable, using the exact type instead of the abstract class/interface seemed reasonable.", "author": "palesz", "createdAt": "2020-12-18T15:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY2MTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552661147", "bodyText": "Thx.\n\n.remove(formatters.size() - 1) requires iteration over the list.\n\nA shift would be needed, I believe, but not when popping the last element. Just a FYI, I agree removeLast() is simpler.", "author": "bpintea", "createdAt": "2021-01-06T14:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5NDA0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545894045", "bodyText": "Couldn't this be moved inside the while loop, reset to false on every iteration, like foundPattern? It currently seems reset whether a pattern is found or not.", "author": "bpintea", "createdAt": "2020-12-18T15:04:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NzYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545987609", "bodyText": "No, I cannot. If I move it into the while loop it will reset to false right after I have found the FM (the for exits and would reset this boolean to false before I find the next pattern the FM should act on).", "author": "palesz", "createdAt": "2020-12-18T17:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5NDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5OTIzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545899235", "bodyText": "Should this comment go two lines up?\nThen interestingly, for a FM dd pattern, the FM is just swallowed. Comparatively, the dd TH does print the TH. Not sure if so on purpose or not (I think it's not tested), but I guess it's acceptable, since Postgres behaves exactly the same.", "author": "bpintea", "createdAt": "2020-12-18T15:12:42Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNTE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545925175", "bodyText": "The behaviour currently matches exactly the Postgres behaviour. The patterns are tested both with and without the FM and TH modifiers.", "author": "palesz", "createdAt": "2020-12-18T15:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5OTIzNQ=="}], "type": "inlineReview"}, {"oid": "2c7a42af7a5fe597d511db3c49de369dfbe786f4", "url": "https://github.com/elastic/elasticsearch/commit/2c7a42af7a5fe597d511db3c49de369dfbe786f4", "message": "PR suggestions", "committedDate": "2020-12-18T18:06:01Z", "type": "commit"}, {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "url": "https://github.com/elastic/elasticsearch/commit/216ae9777e6e2104d3fb7af52e58b7f90310bb62", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2020-12-18T18:06:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MjIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552042234", "bodyText": "I think you mean monthToRoman", "author": "costin", "createdAt": "2021-01-05T16:26:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxOTMwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553419309", "bodyText": "Changed.", "author": "palesz", "createdAt": "2021-01-07T15:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDI0NA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552044244", "bodyText": "yearToCentury. Is it this method (and the one above) used across multiple classes to justify declaring it in the utils class? Their purpose seems quite narrow.", "author": "costin", "createdAt": "2021-01-05T16:29:12Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);\n+        }\n+    }\n+\n+    public static int century(int year) {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxOTQ0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553419442", "bodyText": "Renamed, moved.", "author": "palesz", "createdAt": "2021-01-07T15:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552044366", "bodyText": "QlIllegalArgumentException.", "author": "costin", "createdAt": "2021-01-05T16:29:23Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxOTg3NA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553419874", "bodyText": "Changed switched to lookup from array.", "author": "palesz", "createdAt": "2021-01-07T16:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NjUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552046501", "bodyText": "Why is this class called TestCase yet it doesn't have a test method?", "author": "costin", "createdAt": "2021-01-05T16:32:36Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0Njg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552046896", "bodyText": "Is there any concurrency for this counter?", "author": "costin", "createdAt": "2021-01-05T16:33:09Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552047133", "bodyText": "This is much better externalized to a file", "author": "costin", "createdAt": "2021-01-05T16:33:29Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzOTE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553439168", "bodyText": "See #66486 (comment)", "author": "palesz", "createdAt": "2021-01-07T16:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODQyNA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552048424", "bodyText": "This utility is better pulled out from this class since it is used manually for testing the results.  It's use can be indicated documented in the test or the result file.", "author": "costin", "createdAt": "2021-01-05T16:35:22Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODUxNw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552048517", "bodyText": "All these parameters need to be externalized (say to a Properties file).", "author": "costin", "createdAt": "2021-01-05T16:35:33Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzOTY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553439641", "bodyText": "See #66486 (comment), now I pick these up from the FORMATTER_MAP", "author": "palesz", "createdAt": "2021-01-07T16:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552050136", "bodyText": "You can just make the runner to be a test - otherwise this is going to be quite fragile.", "author": "costin", "createdAt": "2021-01-05T16:38:08Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5NDk3OA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552894978", "bodyText": "Can you expand?", "author": "palesz", "createdAt": "2021-01-06T18:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxOTU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553219566", "bodyText": "Instead of calling the test suite Random externally, which is unsupported since there are no guarantees about its initialization, simply the ESTestCase.", "author": "costin", "createdAt": "2021-01-07T09:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDg3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552050877", "bodyText": "What the reason for this values? 50, 5, -1200?", "author": "costin", "createdAt": "2021-01-05T16:39:14Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMzg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553423886", "bodyText": "Extracted into variables to add some context and meaning to these constants. There is no particular reason why those numbers were picked, felt they provide \"good enough\" coverage, they can be changed/increased.", "author": "palesz", "createdAt": "2021-01-07T16:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDA4OA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552054088", "bodyText": "Alignment is off", "author": "costin", "createdAt": "2021-01-05T16:44:47Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxODI3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552218279", "bodyText": "It is aligned, notice the \\n at the beginning (will separate that out into new line, so it's more obvious).", "author": "palesz", "createdAt": "2021-01-05T21:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552054281", "bodyText": "Use assume instead of catching the error. Further more why not check for this pattern before generating the test cases?", "author": "costin", "createdAt": "2021-01-05T16:45:06Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +\n+                        \"zone:                               %s\\n\" +\n+                        \"timestamp (as epoch):               %s\\n\" +\n+                        \"timestamp (java, UTC):              %s\\n\" +\n+                        \"timestamp (postgres, to_timestamp): %s\\n\" +\n+                        \"timestamp (java with zone):         %s\\n\" +\n+                        \"format string:                      %s\\n\" +\n+                        \"expected (postgres to_char result): %s\\n\" +\n+                        \"actual (ES to_char result):         %s\\n\" +\n+                        \"    FAILED (sub)pattern: %s,\",\n+                        id, zone, secondsAndFractionsSinceEpoch, timestamp, posgresTimestamp, timestamp.withZoneSameInstant(zoneId), \n+                        formatString, expectedResult, actualResult, patternMaybeWithIndex), \n+                    expectedPart, actualPart);\n+            } catch (AssertionError err) {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMDU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552220577", "bodyText": "Using assume would stop checking the rest of the patterns (we are in a for loop here). I can remove the TZ and tz from the test generator.", "author": "palesz", "createdAt": "2021-01-05T21:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgxNjE4MA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555816180", "bodyText": "Why not generate a test per pattern?\nMy previous question stands, why the check for not fully matchable is done after and not before the test execution?\nAlso what's the story behind not fully matchable? I didn't see any docs for them...", "author": "costin", "createdAt": "2021-01-12T14:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NTMzMw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552055333", "bodyText": "Arrays.asList()", "author": "costin", "createdAt": "2021-01-05T16:46:59Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNDIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553424217", "bodyText": "Done.", "author": "palesz", "createdAt": "2021-01-07T16:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NTMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NjgxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552056811", "bodyText": "Please add some docs on the number of arguments and their purpose so that folks that pick this test in the future under what they're after without having to dig too much into Postgres.", "author": "costin", "createdAt": "2021-01-05T16:49:20Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNDc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553424763", "bodyText": "Added docs.", "author": "palesz", "createdAt": "2021-01-07T16:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NjgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552058313", "bodyText": "It looks like this is the only class where these methods are defined so why not move them here?", "author": "costin", "createdAt": "2021-01-05T16:51:43Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNDk4NA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553424984", "bodyText": "Moved.", "author": "palesz", "createdAt": "2021-01-07T16:08:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552058995", "bodyText": "Fully qualifying the static method in the same class is just noise. Please update your formatting rule and just call of", "author": "costin", "createdAt": "2021-01-05T16:52:44Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1OTQ0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552059446", "bodyText": "It's worth adding some static imports for String, Integer, etc.. to simplify these function definitions.", "author": "costin", "createdAt": "2021-01-05T16:53:30Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyNTM0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552225342", "bodyText": "Added, except for String.format that clashes with the format of this class.", "author": "palesz", "createdAt": "2021-01-05T22:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1OTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MDA0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552060045", "bodyText": "Please add a comment on why 24000001 - isn't this constant defined anywhere in the Java time API?", "author": "costin", "createdAt": "2021-01-05T16:54:21Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MzQ3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552253477", "bodyText": "Switched to TemporalAccessor.get(JulianFields.JULIAN_DAY) that already does this calculation.", "author": "palesz", "createdAt": "2021-01-05T23:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTI5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061291", "bodyText": "Either fix the supress warning or initialize the variable in the static block above where FORMATTER_MAP is defined.", "author": "costin", "createdAt": "2021-01-05T16:56:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNTUxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553425519", "bodyText": "Fixed, removed the @SuppressWarnings", "author": "palesz", "createdAt": "2021-01-07T16:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061516", "bodyText": "What is fillMode?", "author": "costin", "createdAt": "2021-01-05T16:56:41Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyODc3NA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552228774", "bodyText": "Suppressing leading zeroes or removing blanks: https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE", "author": "palesz", "createdAt": "2021-01-05T22:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTcyOA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061728", "bodyText": "acceptsLowercase", "author": "costin", "createdAt": "2021-01-05T16:57:03Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjM5MA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552062390", "bodyText": "formatter, toString, asString", "author": "costin", "createdAt": "2021-01-05T16:57:54Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNjA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553426040", "bodyText": "Renamed to formatter", "author": "palesz", "createdAt": "2021-01-07T16:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTQwNg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552065406", "bodyText": "Why is this called text yet it accepts a fillMode? Why is defined as a general Function yet seems to have limited implementations?", "author": "costin", "createdAt": "2021-01-05T17:02:46Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0NTE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552245149", "bodyText": "Refactored, simplified this part.", "author": "palesz", "createdAt": "2021-01-05T22:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTY4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552065681", "bodyText": "Since there is a relationship between fillMode and ordinalSuffix should that apply to noFillMode as well?", "author": "costin", "createdAt": "2021-01-05T17:03:17Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {\n+            this.hasOrdinalSuffix = false;", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0MDY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552240674", "bodyText": "No. For example FF6 (6 digit nanosecond) should not remove the leading zeros, but can have ordinal suffix (000001st nanosecond).", "author": "palesz", "createdAt": "2021-01-05T22:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2OTUxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552069511", "bodyText": "Based on the code, it looks like the builder always ends up with text(), noFillMode or the default fill mode. If this assertion is correct, this behavior should be incapsulated in the builder to avoid calling build() and make these methods the final ones. Additionally aligned the names to better express what's going on:\ntext() -> noPadding()/removePadding()\ntext(fillMode) -> methodWithNameOfTheGivenFunction", "author": "costin", "createdAt": "2021-01-05T17:09:38Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNzQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553427409", "bodyText": "Refactored the builder numeric(), numericWithLeadingZeros(), text() and offset() replaced the build() method calls.", "author": "palesz", "createdAt": "2021-01-07T16:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2OTUxMQ=="}], "type": "inlineReview"}, {"oid": "5975d3a60746a937e035337f2d96104c8ad4e0a0", "url": "https://github.com/elastic/elasticsearch/commit/5975d3a60746a937e035337f2d96104c8ad4e0a0", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-05T21:31:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NzA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552067040", "bodyText": "Is this needed? The default implementation is doing getClass().getSimpleName().toLowerCase(Locale.ROOT) which should be toChar, if I'm not missing anything.", "author": "astefan", "createdAt": "2021-01-05T17:05:23Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToChar.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeFormatProcessor.Formatter.TO_CHAR;\n+\n+public class ToChar extends BaseDateTimeFormatFunction {\n+    public ToChar(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n+    }\n+\n+    @Override\n+    protected DateTimeFormatProcessor.Formatter formatter() {\n+        return TO_CHAR;\n+    }\n+\n+    @Override\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeFormatFunction> ctor() {\n+        return ToChar::new;\n+    }\n+    \n+    @Override\n+    protected String scriptMethodName() {\n+        return \"toChar\";", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NjYzOA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552256638", "bodyText": "That will be to[c]har instead of to[C]har, InternalSqlScriptUtils.toChar would not follow the lowerCamelCase format.", "author": "palesz", "createdAt": "2021-01-05T23:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552089952", "bodyText": "You need a test in QueryTranslatorTests as well.", "author": "astefan", "createdAt": "2021-01-05T17:44:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -300,6 +300,10 @@ public static String format(Object dateTime, String pattern, String tzId) {\n         return (String) Formatter.FORMAT.format(asDateTime(dateTime), pattern, ZoneId.of(tzId));", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5NDI3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552194279", "bodyText": "And some tests in VerifierErrorMessagesTests.", "author": "astefan", "createdAt": "2021-01-05T21:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyODY3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553428672", "bodyText": "Done.", "author": "palesz", "createdAt": "2021-01-07T16:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNTAzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552205039", "bodyText": "Could you take these patterns from ToCharFormatter's FORMATTER_MAP content? Manually listing that long list of patterns feels brittle to me (things could be missed).", "author": "astefan", "createdAt": "2021-01-05T21:25:37Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNzI0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552207243", "bodyText": "Any good reason for not using ESTestCase's random() ?", "author": "astefan", "createdAt": "2021-01-05T21:27:38Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NzY3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552257671", "bodyText": "It is not available (throws exception) when the TestGenerator.main() is executed outside of the test infrastructure.", "author": "palesz", "createdAt": "2021-01-05T23:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNzI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTIyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552211229", "bodyText": "Our test infra does have a lot of helper methods for generating random stuff. I feel like you are re-inventing the wheel here with all the randomization logic in this class.", "author": "astefan", "createdAt": "2021-01-05T21:32:06Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);", "originalCommit": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1ODI3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552258275", "bodyText": "I agree 100% and maybe I am missing something, but did not see an obvious way to use those random methods outside of the test infrastructure (TestGenerator.main()). Suggestions are welcome.", "author": "palesz", "createdAt": "2021-01-05T23:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTIyOQ=="}], "type": "inlineReview"}, {"oid": "e1c373e1e9fa444f9a6ad4ea02fe45cbd81106a3", "url": "https://github.com/elastic/elasticsearch/commit/e1c373e1e9fa444f9a6ad4ea02fe45cbd81106a3", "message": "PR suggestions", "committedDate": "2021-01-05T23:56:51Z", "type": "commit"}, {"oid": "6e9e8525c376cf2dbd6acab7d8e92b11229c5c36", "url": "https://github.com/elastic/elasticsearch/commit/6e9e8525c376cf2dbd6acab7d8e92b11229c5c36", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-05T23:57:48Z", "type": "commit"}, {"oid": "20eb9356bfdb9260c46091870288cdc2f90a09ad", "url": "https://github.com/elastic/elasticsearch/commit/20eb9356bfdb9260c46091870288cdc2f90a09ad", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-06T01:50:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNzM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545927389", "bodyText": "A matter of taste, I guess.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return year % 100 == 0 ? year / 100 : year / 100 + 1;\n          \n          \n            \n                        return year / 100 + (year % 100 == 0 ? 0 : 1);", "author": "bpintea", "createdAt": "2020-12-18T15:57:46Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);\n+        }\n+    }\n+\n+    public static int century(int year) {\n+        if (year > 0) {\n+            return year % 100 == 0 ? year / 100 : year / 100 + 1;", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyOTcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545929706", "bodyText": "I would have indexed an array, but this works too. (I guess this is imported from the original PR).", "author": "bpintea", "createdAt": "2020-12-18T16:01:52Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {", "originalCommit": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d25b353205f8d0ca7cfb001e1d501045860710a", "url": "https://github.com/elastic/elasticsearch/commit/7d25b353205f8d0ca7cfb001e1d501045860710a", "message": "PR suggestions", "committedDate": "2021-01-06T17:44:21Z", "type": "commit"}, {"oid": "5c4ad485a652ed0272e5145cdd9ceb2dd7ebebd1", "url": "https://github.com/elastic/elasticsearch/commit/5c4ad485a652ed0272e5145cdd9ceb2dd7ebebd1", "message": "PR suggestions", "committedDate": "2021-01-06T18:32:50Z", "type": "commit"}, {"oid": "6439c669ab52a0c8cdc0a3faf85bf459b2d85532", "url": "https://github.com/elastic/elasticsearch/commit/6439c669ab52a0c8cdc0a3faf85bf459b2d85532", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-06T18:55:20Z", "type": "commit"}, {"oid": "49a036095ea65cf07249ac15e22e99416df4a18c", "url": "https://github.com/elastic/elasticsearch/commit/49a036095ea65cf07249ac15e22e99416df4a18c", "message": "QueryTranslator and VerifierErrorMessages tests", "committedDate": "2021-01-06T19:11:29Z", "type": "commit"}, {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963", "url": "https://github.com/elastic/elasticsearch/commit/ffbdb3f4aaea069ce5bd2f11b1333ced8580a963", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-06T19:11:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxNzk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553217944", "bodyText": "Store the result in current directory, it's much more common - /tmp is not portable nor something where folks will typically look.", "author": "costin", "createdAt": "2021-01-07T09:45:58Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\",\n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\",\n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\",\n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+        \n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+\n+        TestRecord(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = ToCharTestScript.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+    public static final String DELIMITER = \"|\";\n+    public static final String PATTERN_DELIMITER = \" @ \";\n+    // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+    // accept the output of Elasticsearch as is\n+    public static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+    private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+    private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n+    private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n+    private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+\n+    private final List<TestRecord> testRecords = new ArrayList<>();\n+    private final List<BigDecimal> testEpochSeconds = new ArrayList<>();\n+\n+    @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+    private static Random rnd() {\n+        return ThreadLocalRandom.current();\n+    }\n+\n+    public ToCharTestScript() {\n+        generateTestTimestamps();\n+        \n+        patternsOneByOne();\n+        allPatternsTogether();\n+        lowercasePatterns();\n+        postgreSQLPatternParsingBehaviour();\n+        monthsAsRomanNumbers();\n+        randomizedPatternStrings();\n+    }\n+\n+    private void generateTestTimestamps() {\n+        final int latestYearToTest = 3000;\n+        int countOfTestYears = 150;\n+        for (int i = 0; i < countOfTestYears; i++) {\n+            testEpochSeconds.add(randomSecondsWithFractions(-latestYearToTest, latestYearToTest));\n+        }\n+\n+        int countOfTestYearsAroundYearZero = 10;\n+        for (int i = 0; i < countOfTestYearsAroundYearZero; i++) {\n+            testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+        }\n+    }\n+\n+    private void patternsOneByOne() {\n+        for (String pattern : PATTERNS) {\n+            testRecords.add(new TestRecord(\n+                randomFromCollection(testEpochSeconds),\n+                NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) ?\n+                    pattern :\n+                    String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+        }\n+    }\n+\n+    private void allPatternsTogether() {\n+        for (BigDecimal es : testEpochSeconds) {\n+            testRecords.add(new TestRecord(\n+                es,\n+                IntStream.range(0, PATTERNS.size())\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS.get(idx)))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+        }\n+    }\n+\n+    private void lowercasePatterns() {\n+        testRecords.add(new TestRecord(\n+            randomFromCollection(testEpochSeconds),\n+            IntStream.range(0, PATTERNS.size())\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS.get(idx))).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    }\n+\n+    private void postgreSQLPatternParsingBehaviour() {\n+        // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+        // that is greedy and prefers the longer format strings\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    }\n+\n+    private void monthsAsRomanNumbers() {\n+        for (int i = 1; i <= 12; i++) {\n+            testRecords.add(new TestRecord(\n+                new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()),\n+                rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+        }\n+    }\n+\n+    private void randomizedPatternStrings() {\n+        final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+\n+        final int randomizedPatternCount = 20;\n+        final int lengthOfRandomizedPattern = 30;\n+        final int pctChanceOfRandomCharacter = 80;\n+        for (int i = 0; i < randomizedPatternCount; i++) {\n+            String patternWithLiterals = IntStream.rangeClosed(1, lengthOfRandomizedPattern)\n+                    .mapToObj(idx -> {\n+                        if (rnd().nextInt(100) < pctChanceOfRandomCharacter) {\n+                            return randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1);\n+                        } else {\n+                            return (randomFromCollection(FILL_MODIFIERS) + randomFromCollection(PATTERNS) \n+                                + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS));\n+                        }})\n+                    .collect(Collectors.joining());\n+\n+            // clean up the random string from the unsupported modifiers\n+            for (String unsupportedPatternModifier : Sets.union(UNSUPPORTED_PATTERN_MODIFIERS, NOT_FULLY_MATCHABLE_PATTERNS)) {\n+                patternWithLiterals = patternWithLiterals\n+                    .replace(unsupportedPatternModifier, \"\")\n+                    .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+            }\n+            testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+        }\n+    }\n+\n+    private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+        BigDecimal seconds =\n+            new BigDecimal(RandomNumbers.randomLongBetween(rnd(), (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+        BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+        return seconds.add(fractions);\n+    }\n+\n+    private static <T> T randomFromCollection(Collection<T> list) {\n+        List<T> l = new ArrayList<>(list);\n+        return l.get(rnd().nextInt(l.size()));\n+    }\n+\n+    private static String patternWithRandomModifiers(String pattern) {\n+        if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+            return pattern;\n+        }\n+        return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+    }\n+\n+    private static String adjustZoneIdToPostgres(String zoneId) {\n+        // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+        // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+        if (zoneId.startsWith(\"+\")) {\n+            zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+        } else if (zoneId.startsWith(\"-\")) {\n+            zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+        }\n+        return zoneId;\n+    }\n+\n+    /**\n+     * Generates an SQL file (psql input) that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+     * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+     * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+     * and update the test CSV file.\n+     */\n+    private String unitTestExporterScript() {\n+        String header =\n+            \"\\n\\\\echo #\" +\n+            \"\\n\\\\echo # DO NOT EDIT manually, was generated using \" + ToCharTestScript.class.getName() +\n+            \"\\n\\\\echo #\\n\\n\";\n+        String testCases = testRecords.stream().map(tc -> {\n+            long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+            BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+            return String.format(Locale.ROOT, \n+                \"SET TIME ZONE '%6$s';\\n\"\n+                    + \"\\\\copy (SELECT %1$s as epoch_seconds_and_microsends, '%5$s' as zone_id, '%4$s' as format_string, \" \n+                    + \"(TO_TIMESTAMP(%2$d) + INTERVAL '%3$d microseconds') as to_timestamp_result, \"\n+                    + \"TO_CHAR((TO_TIMESTAMP(%2$d) + INTERVAL '%3$d microseconds'), '%4$s') as to_char_result) to stdout \" \n+                    + \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                tc.secondsAndFractionsSinceEpoch.toPlainString(),\n+                seconds,\n+                fractions.intValue(),\n+                tc.formatString,\n+                tc.zoneId,\n+                adjustZoneIdToPostgres(tc.zoneId));\n+        }).collect(Collectors.joining(\"\\n\"));\n+        return header + testCases;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];", "originalCommit": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553223272", "bodyText": "My initial comment stands - why aren't these strings externalized as in declared into a separate file?\nI'm not clear how they were produced nor why they have to be declared inside the java file and not separately?\nI like the idea of having everything in one place however in this case the input clearly comes from postgres and since the input is actually external, why not apply that to the zone list as well considering the declaration is ~ 40 strings.", "author": "costin", "createdAt": "2021-01-07T09:54:56Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(", "originalCommit": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4OTExMg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553389112", "bodyText": "The list of time zones here are a few hand-picked that are available in older JDK versions (supported, CI runs against it), latest JDK versions and also in Postgres. These are inputs to the generator and show up in the generated sql script that you can run against PostgreSQL to (re)generate the expected TO_CHAR() outputs.\nWhat about if instead of burning these in, I put the output of the SELECT name from pg_timezone_names into a file and cross-check it against the Java timezone list? The one callout I have to add is that the ToCharTestScript will have to be run against the oldest supported JDK version, otherwise the tests on the CI will fail because of unsupported time zones.", "author": "palesz", "createdAt": "2021-01-07T15:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyNzc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553527775", "bodyText": "If there's a way to generate the list, even better - put the output into a file along a header that indicates how the list came to be and make the test read it.\nI don't to over-engineer too much this PR which took significant time.", "author": "costin", "createdAt": "2021-01-07T19:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NTQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553665405", "bodyText": "Done.", "author": "palesz", "createdAt": "2021-01-08T00:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwNTM1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553605359", "bodyText": "I think all these lines would be more readable if you'd import static all these static types.", "author": "astefan", "createdAt": "2021-01-07T21:42:22Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    /**\n+     * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n+     * \n+     * Process to (re)generate the test data:\n+     * <ol>\n+     *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n+     *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n+     *       <pre>\n+     *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *       </pre>\n+     *     </li>\n+     *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n+     *       <pre>\n+     *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *           &gt; /path/to/tochar.generated.csv\n+     *       </pre>\n+     *     </li>\n+     * </ol>\n+     */\n+    public void testAgainstPostgreSQLOutput() throws Exception {\n+        String testFile = \"tochar.generated.csv\";\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(testFile).toURI());\n+        int lineNumber = 0;\n+        for (String line : Files.readAllLines(testFilePath)) {\n+            lineNumber += 1;\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            String[] cols = line.split(quote(ToCharTestScript.DELIMITER));\n+            testOneCase(testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]);\n+        }\n+    }\n+\n+    /**\n+     * @param testFile The name of the testfile where this testcase is coming from\n+     * @param lineNumber The line number of the testcase within the testfile\n+     * @param secondsAndFractionsSinceEpoch The date represented by seconds and fractions since epoch that was used to \n+     *                                      generate the TO_CHAR() PostgreSQL output.\n+     * @param zone The long/short name or offset for the timezone used when generating the expected TO_CHAR() output.\n+     * @param formatString The pattern to be tested (this is exactly the pattern that was passed into the TO_CHAR() function in PostgreSQL).\n+     * @param posgresTimestamp The timestamp represented by PostgreSQL as string in the default format (without calling TO_CHAR()).\n+     * @param expectedResult The PostgreSQL output of <code>TO_CHAR(\n+     *                       (TO_TIMESTAMP([[secondsSinceEpoch]]) + INTERVAL '[[fractions]] microseconds'), \n+     *                       '[[formatString]]')</code>.\n+     */\n+    private void testOneCase(\n+        String testFile, int lineNumber, String secondsAndFractionsSinceEpoch, String zone,\n+        String formatString, String posgresTimestamp, String expectedResult) {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = asList(expectedResult.split(quote(ToCharTestScript.PATTERN_DELIMITER)));", "originalCommit": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NTUwOA==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553665508", "bodyText": "Done.", "author": "palesz", "createdAt": "2021-01-08T00:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwNTM1OQ=="}], "type": "inlineReview"}, {"oid": "dc3d108ac7da3e5bddce059f5aab34d0dfa05e76", "url": "https://github.com/elastic/elasticsearch/commit/dc3d108ac7da3e5bddce059f5aab34d0dfa05e76", "message": "Bugfix, simplified the ToCharFormatter parser\n\nBug was related to handling `1FMth` which turned into `1st` instead of\n`1th`.", "committedDate": "2021-01-07T23:51:09Z", "type": "commit"}, {"oid": "ab2349576f284a57562e1ec90d0bee13841371dd", "url": "https://github.com/elastic/elasticsearch/commit/ab2349576f284a57562e1ec90d0bee13841371dd", "message": "PR suggestions", "committedDate": "2021-01-08T00:07:42Z", "type": "commit"}, {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4", "url": "https://github.com/elastic/elasticsearch/commit/22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-08T00:08:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk5NzI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r554997252", "bodyText": "Does this need a bounds check (2021-13-11)? month seems to come straight out of parseInt.", "author": "bpintea", "createdAt": "2021-01-11T11:58:06Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.Integer.parseInt;\n+\n+/**\n+ * Formatting according to the PostgreSQL <code>to_char</code> function specification:\n+ * https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIME-TABLE\n+ */\n+class ToCharFormatter {\n+\n+    protected static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            of(\"HH\").formatFn(\"hh\").numeric(),\n+            of(\"HH12\").formatFn(\"hh\").numeric(),\n+            of(\"HH24\").formatFn(\"HH\").numeric(),\n+            of(\"MI\").formatFn(\"mm\").numeric(),\n+            of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).numericWithLeadingZeros(),\n+            of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).numericWithLeadingZeros(),\n+            of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).numericWithLeadingZeros(),\n+            of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).numericWithLeadingZeros(),\n+            of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).numericWithLeadingZeros(),\n+            of(\"YYYY\").formatFn(\"yyyy\").numeric(),\n+            of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)).numeric(),\n+            of(\"YY\").formatFn(\"yy\").numeric(),\n+            of(\"Y\").formatFn(\"yy\", year -> year.substring(1)).numeric(),\n+            of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)).numeric(),\n+            of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)).numeric(),\n+            of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)).numeric(),\n+            of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)).numeric(),\n+            of(\"BC\").formatFn(\"G\").text(),\n+            of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"AD\").formatFn(\"G\").text(),\n+            of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Mon\").formatFn(\"MMM\").text(),\n+            of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"MM\").formatFn(\"MM\").numeric(),\n+            of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Dy\").formatFn(\"E\").text(),\n+            of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"DDD\").formatFn(\"DDD\").numeric(),\n+            of(\"IDDD\").formatFn(t -> String.format(Locale.ROOT,\n+                \"%03d\",\n+                (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))\n+            ).numeric(),\n+            of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"ID\").formatFn(\"e\").numeric(),\n+            of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))).numeric(),\n+            of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))).numeric(),\n+            of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))).numeric(),\n+            of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))).numeric(),\n+            of(\"CC\").formatFn(t -> {\n+                int century = yearToCentury(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }).numeric(),\n+            of(\"J\").formatFn(t -> String.valueOf(t.getLong(JulianFields.JULIAN_DAY))).numeric(),\n+            of(\"Q\").formatFn(\"Q\").numeric(),\n+            of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)))).text(),\n+            of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            of(\"TZH\").acceptsLowercase(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            of(\"TZM\").acceptsLowercase(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            of(\"OF\").acceptsLowercase(false).formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset).offset()\n+        );\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.acceptsLowercase) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+    \n+    private static final int MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().orElse(Integer.MAX_VALUE);\n+    \n+    private static final String[] ROMAN_NUMBERS = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\"};\n+\n+    private final String pattern;\n+    private final boolean acceptsLowercase;\n+    // Fill mode: suppress leading zeroes and padding blanks\n+    // https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE\n+    private final Function<String, String> fillModeFn;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatter;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean acceptsLowercase,\n+        Function<String, String> fillModeFn,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatter) {\n+\n+        this.pattern = pattern;\n+        this.acceptsLowercase = acceptsLowercase;\n+        this.fillModeFn = fillModeFn;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatter = formatter;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private static String monthToRoman(int month) {\n+        return ROMAN_NUMBERS[month - 1];", "originalCommit": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA3Nzc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555077763", "bodyText": "PostgreSQL roman numbers expected to be in the range 1-12 and although Undecimber exists (see also here), based on the current calls monthToRoman is only called on top of MM, which I believe (and correct me if I am wrong) will only return with 1-12, hence no checks in this method.", "author": "palesz", "createdAt": "2021-01-11T14:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk5NzI1Mg=="}], "type": "inlineReview"}, {"oid": "f12630082bf9b467a552d68e2cbc934a1871c33e", "url": "https://github.com/elastic/elasticsearch/commit/f12630082bf9b467a552d68e2cbc934a1871c33e", "message": "PR suggestions", "committedDate": "2021-01-11T14:24:28Z", "type": "commit"}, {"oid": "114dce9d497e2be83412e4e6293448629b2aa081", "url": "https://github.com/elastic/elasticsearch/commit/114dce9d497e2be83412e4e6293448629b2aa081", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-11T14:25:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwMjYyNg==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555802626", "bodyText": "replace the dot in the filename with a dash instead - tochar-test_timezones.txt or tochar-test-tz.txt", "author": "costin", "createdAt": "2021-01-12T14:18:25Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -71,6 +57,9 @@\n     private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n     private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n     private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+    // timezones that are valid both in Java and in Postgres\n+    public static final List<String> TIMEZONES_TO_TEST =\n+            readAllLinesWithoutComment(ToCharTestScript.class.getResource(\"tochar.test_timezones.txt\"));", "originalCommit": "114dce9d497e2be83412e4e6293448629b2aa081", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwMzg5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555803891", "bodyText": "Replace the dot in the filename with -, tochar-generated.csv", "author": "costin", "createdAt": "2021-01-12T14:19:25Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -44,16 +46,15 @@\n      *     </li>\n      * </ol>\n      */\n-    public void testAgainstPostgreSQLOutput() throws Exception {\n+    public void testAgainstPostgreSQLOutput() {\n         String testFile = \"tochar.generated.csv\";", "originalCommit": "114dce9d497e2be83412e4e6293448629b2aa081", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwOTA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555809065", "bodyText": "This issue is still in place - why use a ThreadLocalRandom when no concurrency is needed and not rely on Random itself?\nAlso try to move away from it being static as that's tricky to clean-up. The new Random can be created within the main method and then passed around.", "author": "costin", "createdAt": "2021-01-12T14:25:05Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+\n+        TestRecord(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = ToCharTestScript.randomFromCollection(TIMEZONES_TO_TEST);\n+        }\n+    }\n+\n+    private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+    public static final String DELIMITER = \"|\";\n+    public static final String PATTERN_DELIMITER = \" @ \";\n+    // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+    // accept the output of Elasticsearch as is\n+    public static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+    private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+    private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n+    private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n+    private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+    // timezones that are valid both in Java and in Postgres\n+    public static final List<String> TIMEZONES_TO_TEST =\n+            readAllLinesWithoutComment(ToCharTestScript.class.getResource(\"tochar.test_timezones.txt\"));\n+\n+    private final List<TestRecord> testRecords = new ArrayList<>();\n+    private final List<BigDecimal> testEpochSeconds = new ArrayList<>();\n+\n+    @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "originalCommit": "114dce9d497e2be83412e4e6293448629b2aa081", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ce0078ae467acacd3e0f4fbbc6a18a2bc280a19", "url": "https://github.com/elastic/elasticsearch/commit/5ce0078ae467acacd3e0f4fbbc6a18a2bc280a19", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-12T14:47:18Z", "type": "commit"}, {"oid": "68c5ba096234842004f5a26e2a0f6e85a6200ac7", "url": "https://github.com/elastic/elasticsearch/commit/68c5ba096234842004f5a26e2a0f6e85a6200ac7", "message": "PR suggestions", "committedDate": "2021-01-12T15:10:04Z", "type": "commit"}, {"oid": "c0a10a1c8007195fe059046dfecbd7ac33d37da5", "url": "https://github.com/elastic/elasticsearch/commit/c0a10a1c8007195fe059046dfecbd7ac33d37da5", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-12T15:10:18Z", "type": "commit"}, {"oid": "aa16611c2aa0a288ad7e9fc5caa3035fac4d979f", "url": "https://github.com/elastic/elasticsearch/commit/aa16611c2aa0a288ad7e9fc5caa3035fac4d979f", "message": "One missed file rename", "committedDate": "2021-01-19T18:03:58Z", "type": "commit"}, {"oid": "7252aaddd86faf2658ba8d6682561cca34345d03", "url": "https://github.com/elastic/elasticsearch/commit/7252aaddd86faf2658ba8d6682561cca34345d03", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-19T18:04:10Z", "type": "commit"}, {"oid": "75a93befbfffdcd65a30ccc53b10d0ed11e5bb19", "url": "https://github.com/elastic/elasticsearch/commit/75a93befbfffdcd65a30ccc53b10d0ed11e5bb19", "message": "Merge branch 'master' into feature/to-char-function", "committedDate": "2021-01-19T20:52:02Z", "type": "commit"}, {"oid": "6771c86da5d2d1a6286c55a3b7aac4f988bb45ed", "url": "https://github.com/elastic/elasticsearch/commit/6771c86da5d2d1a6286c55a3b7aac4f988bb45ed", "message": "PR suggestions (ParametersFactory, removes silencing of AssertionError)", "committedDate": "2021-01-20T15:42:38Z", "type": "commit"}, {"oid": "5b067b8e13a7aa5330c65d2bb247cbb69488ddbf", "url": "https://github.com/elastic/elasticsearch/commit/5b067b8e13a7aa5330c65d2bb247cbb69488ddbf", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function", "committedDate": "2021-01-20T15:52:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTI1Njc3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r561256777", "bodyText": "I believe it is possible to pass a rich object instead of primitives inside Object[] - not sure whether formatting works.\nAnyway, it's just a note for future reference.", "author": "costin", "createdAt": "2021-01-20T20:18:53Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -22,43 +27,56 @@\n import static org.elasticsearch.xpack.ql.type.DataTypes.KEYWORD;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.DELIMITER;\n-import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.NOT_FULLY_MATCHABLE_PATTERNS;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.PATTERN_DELIMITER;\n \n+/**\n+ * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n+ *\n+ * Process to (re)generate the test data:\n+ * <ol>\n+ *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n+ *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n+ *       <pre>\n+ *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+ *       </pre>\n+ *     </li>\n+ *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n+ *       <pre>\n+ *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+ *           &gt; /path/to/tochar-generated.csv\n+ *       </pre>\n+ *     </li>\n+ * </ol>\n+ * \n+ * In case you need to mute any of the tests, mute all tests by adding {@link org.apache.lucene.util.LuceneTestCase.AwaitsFix}\n+ * on the class level.\n+ */\n public class DateTimeToCharProcessorTests extends ESTestCase {\n-\n-    /**\n-     * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n-     * \n-     * Process to (re)generate the test data:\n-     * <ol>\n-     *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n-     *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n-     *       <pre>\n-     *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n-     *       </pre>\n-     *     </li>\n-     *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n-     *       <pre>\n-     *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n-     *           &gt; /path/to/tochar-generated.csv\n-     *       </pre>\n-     *     </li>\n-     * </ol>\n-     */\n-    public void testAgainstPostgreSQLOutput() {\n+    \n+    @ParametersFactory(argumentFormatting = \"%1$s:%2$s %5$s\")\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        List<Object[]> params = new ArrayList<>();\n         String testFile = \"tochar-generated.csv\";\n         int lineNumber = 0;\n-        for (String line : ToCharTestScript.readAllLinesWithoutComment(DateTimeToCharProcessorTests.class.getResource(testFile))) {\n+        for (String line : Files.readAllLines(Path.of(DateTimeToCharProcessorTests.class.getResource(testFile).toURI()))) {\n             lineNumber += 1;\n             if (line.startsWith(\"#\")) {\n                 continue;\n             }\n             String[] cols = line.split(quote(DELIMITER));\n-            testOneCase(testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]);\n+            params.add(new Object[]{testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]});\n         }\n+        return params;\n     }\n \n+    private final String testFile;\n+    private final int lineNumber;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;", "originalCommit": "6771c86da5d2d1a6286c55a3b7aac4f988bb45ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}