{"pr_number": 61309, "pr_title": "Correct how field retrieval handles multifields and copy_to.", "pr_createdAt": "2020-08-19T05:34:54Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61309", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyNDEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r472724122", "bodyText": "This is an unfortunate workaround. I think we should consider moving value fetching support from FieldMapper to MappedFieldType in a follow-up. That would clean this up, because when looking up a field's MappedFieldType we will already resolve aliases to their targets (and can avoid doing it manually here).", "author": "jtibshirani", "createdAt": "2020-08-19T05:43:26Z", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldValueRetriever.java", "diffHunk": "@@ -38,34 +40,40 @@\n  * Then given a specific document, it can retrieve the corresponding fields from the document's source.\n  */\n public class FieldValueRetriever {\n-    private final MappingLookup fieldMappers;\n     private final List<FieldContext> fieldContexts;\n \n     public static FieldValueRetriever create(MapperService mapperService,\n                                              Collection<FieldAndFormat> fieldAndFormats) {\n         MappingLookup fieldMappers = mapperService.documentMapper().mappers();\n-        List<FieldContext> fields = new ArrayList<>();\n+        List<FieldContext> fieldContexts = new ArrayList<>();\n \n         for (FieldAndFormat fieldAndFormat : fieldAndFormats) {\n             String fieldPattern = fieldAndFormat.field;\n             String format = fieldAndFormat.format;\n \n             Collection<String> concreteFields = mapperService.simpleMatchToFullName(fieldPattern);\n             for (String field : concreteFields) {\n-                if (fieldMappers.getMapper(field) != null && mapperService.isMetadataField(field) == false) {\n-                    Set<String> sourcePath = mapperService.sourcePath(field);\n-                    fields.add(new FieldContext(field, sourcePath, format));\n+                Mapper mapper = fieldMappers.getMapper(field);\n+                if (mapper == null || mapperService.isMetadataField(field)) {\n+                    continue;\n+                }\n+\n+                if (mapper instanceof FieldAliasMapper) {", "originalCommit": "a2b316435b89ba2cb07f74a13da2eff323db8a2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MjE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473272145", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-08-19T19:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyNDEyMg=="}], "type": "inlineReview"}, {"oid": "b8a70be2fc3e3ad610fbe3f1f5ff28632f2307f2", "url": "https://github.com/elastic/elasticsearch/commit/b8a70be2fc3e3ad610fbe3f1f5ff28632f2307f2", "message": "Remove FieldMapper#nullValue().", "committedDate": "2020-08-19T16:57:08Z", "type": "forcePushed"}, {"oid": "81b9db24ce2054b9409913b591c1455055819ff4", "url": "https://github.com/elastic/elasticsearch/commit/81b9db24ce2054b9409913b591c1455055819ff4", "message": "Fix multifield and copy_to cases in FieldValueRetrieverTests.\n\nBefore these cases asserted the wrong result. Now they capture the right\nbehavior, but currently fail.", "committedDate": "2020-08-19T17:04:43Z", "type": "commit"}, {"oid": "aa87bde384da4352d9c063d17beeec7cc12b37ad", "url": "https://github.com/elastic/elasticsearch/commit/aa87bde384da4352d9c063d17beeec7cc12b37ad", "message": "Remove FieldMapper#nullValue().", "committedDate": "2020-08-19T17:34:32Z", "type": "forcePushed"}, {"oid": "fc34f4a2dc5feedfe299936d634ebc416c0bf8db", "url": "https://github.com/elastic/elasticsearch/commit/fc34f4a2dc5feedfe299936d634ebc416c0bf8db", "message": "Refactor FieldMapper#lookupValues to return a ValueFetcher object.\n\nThis will help to implement the fix in a clean way.", "committedDate": "2020-08-19T19:01:21Z", "type": "commit"}, {"oid": "9717621f427524d0b42df1246835ed9e9efe9435", "url": "https://github.com/elastic/elasticsearch/commit/9717621f427524d0b42df1246835ed9e9efe9435", "message": "Correctly handle values from multifields and copy_to.\n\nBefore when a value was copied to a field through a parent field or copy_to, we\nparsed it using the FieldMapper from the source field. Instead we should parse\nit using the target FieldMapper.\n\nThis fix works but is a bit messy. The next commit will clean up the approach.", "committedDate": "2020-08-19T19:01:23Z", "type": "commit"}, {"oid": "aacd3907020ef8d26eeeee9a071c014c35ba689f", "url": "https://github.com/elastic/elasticsearch/commit/aacd3907020ef8d26eeeee9a071c014c35ba689f", "message": "Move source path lookup to SourceValueFetcher.\n\nNow SourceValueFetcher owns all aspects of looking up values from _source,\ninstead of requiring some information to be passed in externally.", "committedDate": "2020-08-19T19:01:26Z", "type": "commit"}, {"oid": "49c2c759bf22223058c4676729933cdad9b94b14", "url": "https://github.com/elastic/elasticsearch/commit/49c2c759bf22223058c4676729933cdad9b94b14", "message": "Remove FieldMapper#nullValue().", "committedDate": "2020-08-19T19:01:28Z", "type": "forcePushed"}, {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa", "url": "https://github.com/elastic/elasticsearch/commit/fa66569505c10d90f8a794c84f708c874730a3fa", "message": "Remove FieldMapper#nullValue().\n\nThis is no longer needed after the refactor to use ValueFetcher.", "committedDate": "2020-08-19T19:06:16Z", "type": "commit"}, {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa", "url": "https://github.com/elastic/elasticsearch/commit/fa66569505c10d90f8a794c84f708c874730a3fa", "message": "Remove FieldMapper#nullValue().\n\nThis is no longer needed after the refactor to use ValueFetcher.", "committedDate": "2020-08-19T19:06:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTQwMA==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473271400", "bodyText": "I think it'd be cleaner if this were handled by a differently named subclass. I know we have the boolean in the mapper, but it just feels funny to pass a boolean swapping out the guts of the implementation.", "author": "nik9000", "createdAt": "2020-08-19T19:33:38Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/SourceValueFetcher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.search.lookup.SourceLookup;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+/**\n+ * An implementation of {@link ValueFetcher} that knows how to extract values\n+ * from the document source. Most standard field mappers will use this class\n+ * to implement value fetching.\n+ */\n+public abstract class SourceValueFetcher implements ValueFetcher {\n+    private final Set<String> sourcePaths;\n+    private final @Nullable Object nullValue;\n+    private final boolean parsesArrayValue;\n+\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue) {\n+        this(fieldName, mapperService, parsesArrayValue, null);\n+    }\n+\n+    /**\n+     * @param fieldName The name of the field.\n+     * @param parsesArrayValue Whether the fetcher handles array values during document parsing.\n+     * @param nullValue A optional substitute value if the _source value is 'null'.\n+     */\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue, Object nullValue) {\n+        this.sourcePaths = mapperService.sourcePath(fieldName);\n+        this.nullValue = nullValue;\n+        this.parsesArrayValue = parsesArrayValue;\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(SourceLookup lookup) {\n+        List<Object> values = new ArrayList<>();\n+        for (String path : sourcePaths) {\n+            Object sourceValue = lookup.extractValue(path, nullValue);\n+            if (sourceValue == null) {\n+                return List.of();\n+            }\n+\n+            if (parsesArrayValue) {", "originalCommit": "fa66569505c10d90f8a794c84f708c874730a3fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3OTQyMw==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473379423", "bodyText": "It definitely seems cleaner in the abstract, but this approach matches the logic DocumentParser where we check FieldMapper#parsesArrayValue to decide what value to pass. I also think using parsesArrayValue in both places encourages field mappers to have a consistent approach between parseCreateField and parseSourceValue.\nI agree this is not ideal, I really wish there were a solid way to tie together the index-time parsing and value fetching logic...", "author": "jtibshirani", "createdAt": "2020-08-19T22:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTc4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473271781", "bodyText": "I don't really think this is cleaner than passing the CheckedFunction but if you like it better that is cool with me.", "author": "nik9000", "createdAt": "2020-08-19T19:34:21Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/SourceValueFetcher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.search.lookup.SourceLookup;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+/**\n+ * An implementation of {@link ValueFetcher} that knows how to extract values\n+ * from the document source. Most standard field mappers will use this class\n+ * to implement value fetching.\n+ */\n+public abstract class SourceValueFetcher implements ValueFetcher {\n+    private final Set<String> sourcePaths;\n+    private final @Nullable Object nullValue;\n+    private final boolean parsesArrayValue;\n+\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue) {\n+        this(fieldName, mapperService, parsesArrayValue, null);\n+    }\n+\n+    /**\n+     * @param fieldName The name of the field.\n+     * @param parsesArrayValue Whether the fetcher handles array values during document parsing.\n+     * @param nullValue A optional substitute value if the _source value is 'null'.\n+     */\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue, Object nullValue) {\n+        this.sourcePaths = mapperService.sourcePath(fieldName);\n+        this.nullValue = nullValue;\n+        this.parsesArrayValue = parsesArrayValue;\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(SourceLookup lookup) {\n+        List<Object> values = new ArrayList<>();\n+        for (String path : sourcePaths) {\n+            Object sourceValue = lookup.extractValue(path, nullValue);\n+            if (sourceValue == null) {\n+                return List.of();\n+            }\n+\n+            if (parsesArrayValue) {\n+                values.addAll((List<?>) parseSourceValue(sourceValue));\n+            } else {\n+                // We allow source values to contain multiple levels of arrays, such as `\"field\": [[1, 2]]`.\n+                // So we need to unwrap these arrays before passing them on to be parsed.\n+                Queue<Object> queue = new ArrayDeque<>();\n+                queue.add(sourceValue);\n+                while (queue.isEmpty() == false) {\n+                    Object value = queue.poll();\n+                    if (value instanceof List) {\n+                        queue.addAll((List<?>) value);\n+                    } else {\n+                        Object parsedValue = parseSourceValue(value);\n+                        if (parsedValue != null) {\n+                            values.add(parsedValue);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Given a value that has been extracted from a document's source, parse it into a standard\n+     * format. This parsing logic should closely mirror the value parsing in\n+     * {@link FieldMapper#parseCreateField} or {@link FieldMapper#parse}.\n+     */\n+    protected abstract Object parseSourceValue(Object value);", "originalCommit": "fa66569505c10d90f8a794c84f708c874730a3fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2MzUwMw==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473363503", "bodyText": "I agree, I think passing a function argument is readable too. It seems totally fine if the implementation evolved in that direction.\nI had a slight preference for this approach since it associates a name with the function argument: when you look at an implementation like KeywordFieldMapper#valueFetcher, the purpose of the function is very obvious.", "author": "jtibshirani", "createdAt": "2020-08-19T21:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3NTY2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473275663", "bodyText": "fieldType.value == null ? lookup -> List.of() : lookup -> List.of(fieldType.value)? It isn't really important, but it'd make me feel good.", "author": "nik9000", "createdAt": "2020-08-19T19:42:13Z", "path": "x-pack/plugin/mapper-constant-keyword/src/main/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldMapper.java", "diffHunk": "@@ -264,21 +265,16 @@ protected void parseCreateField(ParseContext context) throws IOException {\n     }\n \n     @Override\n-    public List<String> lookupValues(SourceLookup lookup, String format) {\n+    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n         if (format != null) {\n             throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n         }\n \n-        return fieldType().value == null\n+        return lookup -> fieldType().value == null", "originalCommit": "fa66569505c10d90f8a794c84f708c874730a3fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2NTExOA==", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473365118", "bodyText": "\ud83d\udc4d  will update this, feeling good is worth it !", "author": "jtibshirani", "createdAt": "2020-08-19T21:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3NTY2Mw=="}], "type": "inlineReview"}, {"oid": "f353567c195c6b181bbd5003e5359ad3e5d46649", "url": "https://github.com/elastic/elasticsearch/commit/f353567c195c6b181bbd5003e5359ad3e5d46649", "message": "Only check constant value once in ConstantKeywordFieldMapper#valueFetcher.", "committedDate": "2020-08-19T22:18:16Z", "type": "commit"}]}