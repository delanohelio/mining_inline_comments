{"pr_number": 60585, "pr_title": "Rework checking if a year is a leap year", "pr_createdAt": "2020-08-03T12:10:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60585", "timeline": [{"oid": "d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "url": "https://github.com/elastic/elasticsearch/commit/d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "message": "Rework checking if a year is a leap year\n\nThis way is faster, saving about 8% on the microbenchmark that rounds to\nthe nearest month. That is in the hot path for `date_histogram` which is\na very popular aggregation so it seems worth it to at least try and\nspeed it up a little.", "committedDate": "2020-08-03T12:12:16Z", "type": "commit"}, {"oid": "d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "url": "https://github.com/elastic/elasticsearch/commit/d2ba5938ef47250c0a1eca30a21faa93f095b2b2", "message": "Rework checking if a year is a leap year\n\nThis way is faster, saving about 8% on the microbenchmark that rounds to\nthe nearest month. That is in the hot path for `date_histogram` which is\na very popular aggregation so it seems worth it to at least try and\nspeed it up a little.", "committedDate": "2020-08-03T12:12:16Z", "type": "forcePushed"}, {"oid": "fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "url": "https://github.com/elastic/elasticsearch/commit/fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "message": "no indent", "committedDate": "2020-08-03T12:30:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxMjE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464412140", "bodyText": "This seems like a good candidate for randomized testing, since we have an alternative (slower) implementation that the new implementation should match exactly.  Then again, that might be overkill.", "author": "not-napoleon", "createdAt": "2020-08-03T13:27:15Z", "path": "server/src/test/java/org/elasticsearch/common/time/DateUtilsRoundingTests.java", "diffHunk": "@@ -46,4 +46,14 @@ public void testDateUtilsRounding() {\n             }\n         }\n     }\n+\n+    public void testIsLeapYear() {", "originalCommit": "fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxNDc1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464414751", "bodyText": "We sort of have that above. I wrote this to have something simple to double check my bit twiddling.", "author": "nik9000", "createdAt": "2020-08-03T13:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxMjE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxNTYyNw==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r464415627", "bodyText": "ah, so we do.  Should have looked deeper before I commented.", "author": "not-napoleon", "createdAt": "2020-08-03T13:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQxMjE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTExODA1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r465118053", "bodyText": "Something I was thinking about - do we see the difference because of the change from year % 400 to (year / 100) & 3, or because of unrolling the short circuit logic?  And if it's only the former, does it make more sense to leave this as a one-liner and let the optimizer short circuit it as necessary?  I'm more asking out of curiosity about how the optimizer works than out of a need to see this changed.", "author": "not-napoleon", "createdAt": "2020-08-04T15:01:53Z", "path": "server/src/main/java/org/elasticsearch/common/time/DateUtilsRounding.java", "diffHunk": "@@ -92,8 +92,27 @@ static long utcMillisAtStartOfYear(final int year) {\n         return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * MILLIS_PER_DAY; // millis per day\n     }\n \n-    private static boolean isLeapYear(final int year) {\n-        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n+    static boolean isLeapYear(final int year) {\n+        // Joda had\n+        // return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n+        // But we've replaced that with this:\n+        if ((year & 3) != 0) {\n+            return false;\n+        }\n+        if (year % 100 != 0) {\n+            return true;\n+        }\n+        return ((year / 100) & 3) == 0;", "originalCommit": "fc5734da3bb2b8a3d8e0ffe07cada23a8faaf414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NDkwNg==", "url": "https://github.com/elastic/elasticsearch/pull/60585#discussion_r465974906", "bodyText": "I think the short circuiting is actually the same here. At least, that is how I read the Java. I believe the speed is entirely around the change from (year % 400) == 0 to ((year / 100) & 3) == 0. We certainly could keep it as a one liner, but I think it as harder to read that way. Certainly harder for me to track down the disassembly chunks because the disassembler sticks line numbers in there. Not that you can truly believe them though.", "author": "nik9000", "createdAt": "2020-08-05T20:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTExODA1Mw=="}], "type": "inlineReview"}]}