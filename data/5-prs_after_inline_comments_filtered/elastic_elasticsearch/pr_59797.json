{"pr_number": 59797, "pr_title": "Make the Painless Semantic Phase External", "pr_createdAt": "2020-07-17T16:11:07Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59797", "timeline": [{"oid": "4c80224cbb7c20e50837862eafc0f8bc41f84cff", "url": "https://github.com/elastic/elasticsearch/commit/4c80224cbb7c20e50837862eafc0f8bc41f84cff", "message": "Merge branch 'master' into nodes4", "committedDate": "2020-05-04T15:56:39Z", "type": "commit"}, {"oid": "5cdb321bc0432297d5579d1029f165b5ef35d6d0", "url": "https://github.com/elastic/elasticsearch/commit/5cdb321bc0432297d5579d1029f165b5ef35d6d0", "message": "Merge branch 'master' into nodes4", "committedDate": "2020-05-04T21:52:47Z", "type": "commit"}, {"oid": "f3298b3c94c730f91247bb0f9a58a7123423f24b", "url": "https://github.com/elastic/elasticsearch/commit/f3298b3c94c730f91247bb0f9a58a7123423f24b", "message": "Merge branch 'nodes4' into nodes5", "committedDate": "2020-05-04T22:12:50Z", "type": "commit"}, {"oid": "c5153953dc331280025c2bfc5b8c145c140b5d0a", "url": "https://github.com/elastic/elasticsearch/commit/c5153953dc331280025c2bfc5b8c145c140b5d0a", "message": "remove unnecessary read/write checks", "committedDate": "2020-05-04T22:14:50Z", "type": "commit"}, {"oid": "c74a5c91176b02104639b491960ea9436c9fef0f", "url": "https://github.com/elastic/elasticsearch/commit/c74a5c91176b02104639b491960ea9436c9fef0f", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-05-04T23:42:15Z", "type": "commit"}, {"oid": "26f1d5cc262b982ea697077af5c13c40702c0c37", "url": "https://github.com/elastic/elasticsearch/commit/26f1d5cc262b982ea697077af5c13c40702c0c37", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-05-04T23:50:38Z", "type": "commit"}, {"oid": "cf023817db9f7b1e8d313a65dfb940f9fbd0e541", "url": "https://github.com/elastic/elasticsearch/commit/cf023817db9f7b1e8d313a65dfb940f9fbd0e541", "message": "Merge branch 'master' into nodes5", "committedDate": "2020-05-05T16:35:17Z", "type": "commit"}, {"oid": "4a70d3fb81f22666dbb013aa8ed07604f999d2fe", "url": "https://github.com/elastic/elasticsearch/commit/4a70d3fb81f22666dbb013aa8ed07604f999d2fe", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-05-05T16:35:23Z", "type": "commit"}, {"oid": "3201a274cba9ecb9a3752162ad5e2b5a72b360e6", "url": "https://github.com/elastic/elasticsearch/commit/3201a274cba9ecb9a3752162ad5e2b5a72b360e6", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-05-05T16:35:31Z", "type": "commit"}, {"oid": "729c1dbe82bd49f9058761d57a548f6a622bd14e", "url": "https://github.com/elastic/elasticsearch/commit/729c1dbe82bd49f9058761d57a548f6a622bd14e", "message": "Merge branch 'master' into nodes5", "committedDate": "2020-05-06T16:53:29Z", "type": "commit"}, {"oid": "c50c2ce955a2742df50d7522510f51e8855f42ed", "url": "https://github.com/elastic/elasticsearch/commit/c50c2ce955a2742df50d7522510f51e8855f42ed", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-05-06T16:53:47Z", "type": "commit"}, {"oid": "4c25b66fba923701651e21ceaeac08834e90b5d5", "url": "https://github.com/elastic/elasticsearch/commit/4c25b66fba923701651e21ceaeac08834e90b5d5", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-05-06T16:54:07Z", "type": "commit"}, {"oid": "680a8b32d49ee9d9e8c349b6b98bf440ca0c0d07", "url": "https://github.com/elastic/elasticsearch/commit/680a8b32d49ee9d9e8c349b6b98bf440ca0c0d07", "message": "remove unnecessary test code from Walker", "committedDate": "2020-05-06T17:31:55Z", "type": "commit"}, {"oid": "394cf2fa4386f5443a9c1a2e75434dd03063117a", "url": "https://github.com/elastic/elasticsearch/commit/394cf2fa4386f5443a9c1a2e75434dd03063117a", "message": "fix imports", "committedDate": "2020-05-06T17:59:43Z", "type": "commit"}, {"oid": "6b429c66512befbd1fadb82285679b19378a8e84", "url": "https://github.com/elastic/elasticsearch/commit/6b429c66512befbd1fadb82285679b19378a8e84", "message": "remove more dead code", "committedDate": "2020-05-06T22:12:46Z", "type": "commit"}, {"oid": "a9753af0cbc6f6b52295afc4e5ba5e17e4c9799a", "url": "https://github.com/elastic/elasticsearch/commit/a9753af0cbc6f6b52295afc4e5ba5e17e4c9799a", "message": "Merge branch 'master' into nodes5", "committedDate": "2020-05-07T15:37:21Z", "type": "commit"}, {"oid": "77bb1df417baf81f2673d54fd28e89581152d4c8", "url": "https://github.com/elastic/elasticsearch/commit/77bb1df417baf81f2673d54fd28e89581152d4c8", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-05-07T15:37:27Z", "type": "commit"}, {"oid": "9106ae5756e688351f69a96ba2b53f0c71d88b09", "url": "https://github.com/elastic/elasticsearch/commit/9106ae5756e688351f69a96ba2b53f0c71d88b09", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-05-07T15:37:37Z", "type": "commit"}, {"oid": "9791782411ec75c7236a92a642cee803847f8bb5", "url": "https://github.com/elastic/elasticsearch/commit/9791782411ec75c7236a92a642cee803847f8bb5", "message": "Merge branch 'master' into nodes5", "committedDate": "2020-05-11T17:33:14Z", "type": "commit"}, {"oid": "a2bbf6bec4530d4bd680a45c602647ab3514ca55", "url": "https://github.com/elastic/elasticsearch/commit/a2bbf6bec4530d4bd680a45c602647ab3514ca55", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-05-11T17:33:31Z", "type": "commit"}, {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe", "url": "https://github.com/elastic/elasticsearch/commit/86fe756fc1f4760b336e42ffa922e9de1d9c61fe", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-05-11T17:33:47Z", "type": "commit"}, {"oid": "9c67ee16ac9d5d8cb20be5ff5680e4c4472f4311", "url": "https://github.com/elastic/elasticsearch/commit/9c67ee16ac9d5d8cb20be5ff5680e4c4472f4311", "message": "fixed lexer spacing", "committedDate": "2020-05-13T18:48:20Z", "type": "commit"}, {"oid": "941d762d2da55dce4add0a69cb58791c11c54650", "url": "https://github.com/elastic/elasticsearch/commit/941d762d2da55dce4add0a69cb58791c11c54650", "message": "Merge branch 'master' into nodes5", "committedDate": "2020-05-13T20:09:01Z", "type": "commit"}, {"oid": "a378ad56d918b1d1bd40354d08423193008f7313", "url": "https://github.com/elastic/elasticsearch/commit/a378ad56d918b1d1bd40354d08423193008f7313", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-05-13T20:09:06Z", "type": "commit"}, {"oid": "1c2c1851fdd5d48b3a06b304f703364041c01e9a", "url": "https://github.com/elastic/elasticsearch/commit/1c2c1851fdd5d48b3a06b304f703364041c01e9a", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-05-13T20:09:13Z", "type": "commit"}, {"oid": "515427155b4920403075669d0b54532cc6c350ab", "url": "https://github.com/elastic/elasticsearch/commit/515427155b4920403075669d0b54532cc6c350ab", "message": "Merge branch 'master' into semantic0", "committedDate": "2020-05-14T17:30:59Z", "type": "commit"}, {"oid": "5405019217619fbfe3ab2328b0212b7086bdb97b", "url": "https://github.com/elastic/elasticsearch/commit/5405019217619fbfe3ab2328b0212b7086bdb97b", "message": "Merge branch 'semantic0' into semantic1", "committedDate": "2020-05-14T17:31:10Z", "type": "commit"}, {"oid": "ce4a9cf8504564ea84a9e05382f4cf1373e56556", "url": "https://github.com/elastic/elasticsearch/commit/ce4a9cf8504564ea84a9e05382f4cf1373e56556", "message": "Merge branch 'master' into semantic0", "committedDate": "2020-06-08T14:48:54Z", "type": "commit"}, {"oid": "f4dd1787ce97df3635d27094aca2e248d61d4afb", "url": "https://github.com/elastic/elasticsearch/commit/f4dd1787ce97df3635d27094aca2e248d61d4afb", "message": "Merge branch 'semantic0' into semantic1", "committedDate": "2020-06-08T14:49:13Z", "type": "commit"}, {"oid": "b8a7eae2b54ad2dce22bb06e903d896577bf9ee0", "url": "https://github.com/elastic/elasticsearch/commit/b8a7eae2b54ad2dce22bb06e903d896577bf9ee0", "message": "Merge branch 'master' into semantic1", "committedDate": "2020-06-10T15:29:53Z", "type": "commit"}, {"oid": "c0eb8a5308a23ee600d4d7fea096eca93a19524a", "url": "https://github.com/elastic/elasticsearch/commit/c0eb8a5308a23ee600d4d7fea096eca93a19524a", "message": "Merge branch 'master' into semantic1", "committedDate": "2020-06-12T15:40:07Z", "type": "commit"}, {"oid": "9b7e36686702931c842bf3cbaf88b7c2d6466d2d", "url": "https://github.com/elastic/elasticsearch/commit/9b7e36686702931c842bf3cbaf88b7c2d6466d2d", "message": "Merge branch 'semantic1' into semantic2", "committedDate": "2020-06-12T16:27:37Z", "type": "commit"}, {"oid": "e0acb3e74a79f35e6e9ecccdba0989ad7de8cda7", "url": "https://github.com/elastic/elasticsearch/commit/e0acb3e74a79f35e6e9ecccdba0989ad7de8cda7", "message": "Merge branch 'semantic2' into semantic3", "committedDate": "2020-06-12T16:27:53Z", "type": "commit"}, {"oid": "ae755a811e1cd3609f7b427b012e371cef807fe3", "url": "https://github.com/elastic/elasticsearch/commit/ae755a811e1cd3609f7b427b012e371cef807fe3", "message": "Merge branch 'master' into semantic1", "committedDate": "2020-06-15T17:07:52Z", "type": "commit"}, {"oid": "15ad272f43e83cb67ec804a22ae2efd5b739f742", "url": "https://github.com/elastic/elasticsearch/commit/15ad272f43e83cb67ec804a22ae2efd5b739f742", "message": "Merge branch 'semantic1' into semantic2", "committedDate": "2020-06-15T17:08:13Z", "type": "commit"}, {"oid": "5207d228095d48c32cc47ccba3049d36d10dba55", "url": "https://github.com/elastic/elasticsearch/commit/5207d228095d48c32cc47ccba3049d36d10dba55", "message": "Merge branch 'semantic2' into semantic3", "committedDate": "2020-06-15T17:45:01Z", "type": "commit"}, {"oid": "b090e91b12cf4e12b0da876079fe43a3a6d60f66", "url": "https://github.com/elastic/elasticsearch/commit/b090e91b12cf4e12b0da876079fe43a3a6d60f66", "message": "Merge branch 'master' into semantic1", "committedDate": "2020-06-18T15:06:38Z", "type": "commit"}, {"oid": "b35a06fd97652d82d9f1a1d66bdf2186f8a81a41", "url": "https://github.com/elastic/elasticsearch/commit/b35a06fd97652d82d9f1a1d66bdf2186f8a81a41", "message": "Merge branch 'semantic1' into semantic2", "committedDate": "2020-06-18T15:06:47Z", "type": "commit"}, {"oid": "ea0a33ce0d5f247bad06a653be9f22c5caa81591", "url": "https://github.com/elastic/elasticsearch/commit/ea0a33ce0d5f247bad06a653be9f22c5caa81591", "message": "Merge branch 'semantic2' into semantic3", "committedDate": "2020-06-18T15:06:57Z", "type": "commit"}, {"oid": "89f84a945c99621dd22339aec07814a6b4a6b066", "url": "https://github.com/elastic/elasticsearch/commit/89f84a945c99621dd22339aec07814a6b4a6b066", "message": "fix indentation in license header", "committedDate": "2020-06-18T15:10:56Z", "type": "commit"}, {"oid": "acce2f7e07e97173b5e7ddcb6404389fbcdde5e2", "url": "https://github.com/elastic/elasticsearch/commit/acce2f7e07e97173b5e7ddcb6404389fbcdde5e2", "message": "Merge branch 'master' into semantic3", "committedDate": "2020-06-18T16:55:03Z", "type": "commit"}, {"oid": "1fe0a3ca2939495888a10395b6d7abde239b8a25", "url": "https://github.com/elastic/elasticsearch/commit/1fe0a3ca2939495888a10395b6d7abde239b8a25", "message": "Merge branch 'semantic3' into semantic4", "committedDate": "2020-06-18T16:58:02Z", "type": "commit"}, {"oid": "439c6648feb2067036db2b041c8ed405c12a7bce", "url": "https://github.com/elastic/elasticsearch/commit/439c6648feb2067036db2b041c8ed405c12a7bce", "message": "Merge branch 'master' into semantic3", "committedDate": "2020-06-24T15:43:01Z", "type": "commit"}, {"oid": "486f779e525cbc646f85e0c99380262466c12574", "url": "https://github.com/elastic/elasticsearch/commit/486f779e525cbc646f85e0c99380262466c12574", "message": "Merge branch 'semantic3' into semantic4", "committedDate": "2020-06-24T15:43:19Z", "type": "commit"}, {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4", "url": "https://github.com/elastic/elasticsearch/commit/6f8c2d58c882d0b8f9296fe60302dc41df25f4c4", "message": "remove extraneous code", "committedDate": "2020-06-24T16:11:45Z", "type": "commit"}, {"oid": "3de00846a6baaac92bc663d54f23684957d26ce2", "url": "https://github.com/elastic/elasticsearch/commit/3de00846a6baaac92bc663d54f23684957d26ce2", "message": "Merge branch 'master' into semantic3", "committedDate": "2020-06-30T17:59:25Z", "type": "commit"}, {"oid": "591e8fbf28df972180a52b957f3c756cc25c99c1", "url": "https://github.com/elastic/elasticsearch/commit/591e8fbf28df972180a52b957f3c756cc25c99c1", "message": "Merge branch 'semantic3' into semantic4", "committedDate": "2020-06-30T17:59:35Z", "type": "commit"}, {"oid": "d11dbcd7a3d1ba91752962d3ac133cba2e050c8e", "url": "https://github.com/elastic/elasticsearch/commit/d11dbcd7a3d1ba91752962d3ac133cba2e050c8e", "message": "rename left/right to true/false for user conditional node", "committedDate": "2020-06-30T18:03:01Z", "type": "commit"}, {"oid": "d9e6809729672d2b0ad359344feba73d4250bd16", "url": "https://github.com/elastic/elasticsearch/commit/d9e6809729672d2b0ad359344feba73d4250bd16", "message": "Merge branch 'master' into semantic4", "committedDate": "2020-06-30T19:18:39Z", "type": "commit"}, {"oid": "ec8ddacd6059f1565a5da6b61898821a7c2f52b4", "url": "https://github.com/elastic/elasticsearch/commit/ec8ddacd6059f1565a5da6b61898821a7c2f52b4", "message": "Merge branch 'semantic4' into semantic5", "committedDate": "2020-06-30T19:29:39Z", "type": "commit"}, {"oid": "d843df9dba3fc04d180ee747ea36b1bb03bdcdfa", "url": "https://github.com/elastic/elasticsearch/commit/d843df9dba3fc04d180ee747ea36b1bb03bdcdfa", "message": "Merge branch 'master' into semantic4", "committedDate": "2020-07-01T14:55:21Z", "type": "commit"}, {"oid": "e45645ed4ee348ea9119183c906eb3833f47ad73", "url": "https://github.com/elastic/elasticsearch/commit/e45645ed4ee348ea9119183c906eb3833f47ad73", "message": "Merge branch 'master' into semantic4", "committedDate": "2020-07-01T17:42:56Z", "type": "commit"}, {"oid": "db96091b0d652056a25ee2681215f31bdf9655e0", "url": "https://github.com/elastic/elasticsearch/commit/db96091b0d652056a25ee2681215f31bdf9655e0", "message": "add visitor patterns for user and ir trees", "committedDate": "2020-07-01T20:32:43Z", "type": "commit"}, {"oid": "4c1902df61876b686f6a2c1899c78ee311a5e1a1", "url": "https://github.com/elastic/elasticsearch/commit/4c1902df61876b686f6a2c1899c78ee311a5e1a1", "message": "Merge branch 'master' into semantic05", "committedDate": "2020-07-01T20:45:02Z", "type": "commit"}, {"oid": "4b8742a0776b5a819fc369dc9d7889885e00c6a0", "url": "https://github.com/elastic/elasticsearch/commit/4b8742a0776b5a819fc369dc9d7889885e00c6a0", "message": "add base visitor classes", "committedDate": "2020-07-02T21:15:19Z", "type": "commit"}, {"oid": "f2d5006edbc63374240e15a57c647fd1fb05808e", "url": "https://github.com/elastic/elasticsearch/commit/f2d5006edbc63374240e15a57c647fd1fb05808e", "message": "Merge branch 'master' into semantic05", "committedDate": "2020-07-07T16:16:38Z", "type": "commit"}, {"oid": "cf0809cf2bfd7dab9182427897d3d1af77fe27cc", "url": "https://github.com/elastic/elasticsearch/commit/cf0809cf2bfd7dab9182427897d3d1af77fe27cc", "message": "Merge branch 'semantic05' into semantic5", "committedDate": "2020-07-07T16:46:25Z", "type": "commit"}, {"oid": "8f4f548fc806abeb4e3b54c5d498198b0ce4b6f3", "url": "https://github.com/elastic/elasticsearch/commit/8f4f548fc806abeb4e3b54c5d498198b0ce4b6f3", "message": "fix intellij default", "committedDate": "2020-07-07T16:53:27Z", "type": "commit"}, {"oid": "4db342843635c2138faad1b89ab80c66be59c512", "url": "https://github.com/elastic/elasticsearch/commit/4db342843635c2138faad1b89ab80c66be59c512", "message": "remove extraneous newline", "committedDate": "2020-07-07T16:58:41Z", "type": "commit"}, {"oid": "739a9f8580c26b616bbb0d15d939fcd1fca32493", "url": "https://github.com/elastic/elasticsearch/commit/739a9f8580c26b616bbb0d15d939fcd1fca32493", "message": "Merge branch 'master' into semantic5", "committedDate": "2020-07-14T15:55:30Z", "type": "commit"}, {"oid": "523bf849fd51a846b2abbdbfe12637407582e3b1", "url": "https://github.com/elastic/elasticsearch/commit/523bf849fd51a846b2abbdbfe12637407582e3b1", "message": "response to pr comments", "committedDate": "2020-07-14T16:13:38Z", "type": "commit"}, {"oid": "cf1612a0e4471f742efd198a90c7f0248ab1a130", "url": "https://github.com/elastic/elasticsearch/commit/cf1612a0e4471f742efd198a90c7f0248ab1a130", "message": "Merge branch 'master' into semantic5", "committedDate": "2020-07-14T16:29:49Z", "type": "commit"}, {"oid": "8591d38eb78bb33df2c11fec64b5259912ca1d9c", "url": "https://github.com/elastic/elasticsearch/commit/8591d38eb78bb33df2c11fec64b5259912ca1d9c", "message": "Merge branch 'master' into semantic5", "committedDate": "2020-07-14T17:02:19Z", "type": "commit"}, {"oid": "75244e2d01b925e4c9471a4fdcb703487dd03261", "url": "https://github.com/elastic/elasticsearch/commit/75244e2d01b925e4c9471a4fdcb703487dd03261", "message": "Merge branch 'master' into semantic5", "committedDate": "2020-07-14T19:04:34Z", "type": "commit"}, {"oid": "124353999810d028814421a55bd971c1a9f5f6c6", "url": "https://github.com/elastic/elasticsearch/commit/124353999810d028814421a55bd971c1a9f5f6c6", "message": "Merge branch 'master' into semantic5", "committedDate": "2020-07-15T15:31:26Z", "type": "commit"}, {"oid": "af98c81ac67701a350431d1d0c1e0059d756a33a", "url": "https://github.com/elastic/elasticsearch/commit/af98c81ac67701a350431d1d0c1e0059d756a33a", "message": "Merge branch 'semantic5' into semantic6", "committedDate": "2020-07-15T16:15:59Z", "type": "commit"}, {"oid": "80fee0c306985fa649a66ccf7ea5fd99d0810e5a", "url": "https://github.com/elastic/elasticsearch/commit/80fee0c306985fa649a66ccf7ea5fd99d0810e5a", "message": "Merge branch 'master' into semantic6", "committedDate": "2020-07-16T15:47:19Z", "type": "commit"}, {"oid": "29cd653736514e77a52384391fee28e612ad3b24", "url": "https://github.com/elastic/elasticsearch/commit/29cd653736514e77a52384391fee28e612ad3b24", "message": "response to pr comments", "committedDate": "2020-07-16T16:03:32Z", "type": "commit"}, {"oid": "06fde8117fce065bb37701b8963dc58c3eaadb4a", "url": "https://github.com/elastic/elasticsearch/commit/06fde8117fce065bb37701b8963dc58c3eaadb4a", "message": "Merge branch 'master' into semantic6", "committedDate": "2020-07-16T16:43:47Z", "type": "commit"}, {"oid": "60484d7919c9afee2f890fe9646c23ca72662187", "url": "https://github.com/elastic/elasticsearch/commit/60484d7919c9afee2f890fe9646c23ca72662187", "message": "Merge branch 'semantic6' into semantic7", "committedDate": "2020-07-16T19:46:04Z", "type": "commit"}, {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f", "url": "https://github.com/elastic/elasticsearch/commit/056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f", "message": "Merge branch 'master' into semantic7", "committedDate": "2020-07-17T15:27:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NTU2OA==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458245568", "bodyText": "Where did this go?", "author": "stu-elastic", "createdAt": "2020-07-21T16:52:37Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/SemanticHeaderPhase.java", "diffHunk": "@@ -1,88 +0,0 @@\n-/*", "originalCommit": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NzUwMw==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458247503", "bodyText": "Why the rearrangement?", "author": "stu-elastic", "createdAt": "2020-07-21T16:55:38Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java", "diffHunk": "@@ -57,16 +57,16 @@ public Location getLocation() {\n     }\n \n     /**\n-     * Callback to visit a user tree node.\n+     * Create an error with location information pointing to this node.", "originalCommit": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3MzI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458273293", "bodyText": "Merge issue.", "author": "jdconrad", "createdAt": "2020-07-21T17:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NzUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI1MTE1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458251153", "bodyText": "Pick a better way to wrap args.", "author": "stu-elastic", "createdAt": "2020-07-21T17:01:28Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java", "diffHunk": "@@ -72,108 +73,113 @@ public Operation getOperation() {\n         return userTreeVisitor.visitBinary(this, input);\n     }\n \n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n+    public static void visitDefaultSemanticAnalysis(\n+            DefaultSemanticAnalysisPhase visitor, EBinary userBinaryNode, SemanticScope semanticScope) {", "originalCommit": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NzI2OA==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459497268", "bodyText": "This is no longer relevant.", "author": "jdconrad", "createdAt": "2020-07-23T14:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI1MTE1Mw=="}], "type": "inlineReview"}, {"oid": "9742de607bef6fcfe372d6a85d7070ef8f3ba629", "url": "https://github.com/elastic/elasticsearch/commit/9742de607bef6fcfe372d6a85d7070ef8f3ba629", "message": "Merge branch 'master' into semantic7", "committedDate": "2020-07-21T17:39:39Z", "type": "commit"}, {"oid": "c1847360d791e3f6c22a35fffb9e209cb790384d", "url": "https://github.com/elastic/elasticsearch/commit/c1847360d791e3f6c22a35fffb9e209cb790384d", "message": "Merge branch 'master' into semantic7", "committedDate": "2020-07-22T22:37:48Z", "type": "commit"}, {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "url": "https://github.com/elastic/elasticsearch/commit/7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "message": "make semantic phase external", "committedDate": "2020-07-22T23:52:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMTU4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459531586", "bodyText": "Are the changes to this file due to intellij?  What happens if you regen?", "author": "stu-elastic", "createdAt": "2020-07-23T15:21:12Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java", "diffHunk": "@@ -1,13 +1,17 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.Lexer;", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0MjExMg==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459542112", "bodyText": "Picked up in optimize imports. I'll fix this.", "author": "jdconrad", "createdAt": "2020-07-23T15:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMTU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMjE2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459532162", "bodyText": "Similar question about generated vs intellij", "author": "stu-elastic", "createdAt": "2020-07-23T15:21:58Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java", "diffHunk": "@@ -1,13 +1,25 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.atn.*;", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0MjEzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459542135", "bodyText": "Picked up in optimize imports. I'll fix this.", "author": "jdconrad", "createdAt": "2020-07-23T15:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMjE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0NTAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459545015", "bodyText": "Provide a one sentence explanation for each public method.", "author": "stu-elastic", "createdAt": "2020-07-23T15:40:23Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyNTExMw==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459625113", "bodyText": "Will do. This is going to take a bit of time.", "author": "jdconrad", "createdAt": "2020-07-23T17:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0NTAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODUwNA==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459568504", "bodyText": "I like the new use of Negate condition in DefaultSemanticAnalysisPhase.", "author": "stu-elastic", "createdAt": "2020-07-23T16:15:52Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java", "diffHunk": "@@ -55,48 +50,4 @@ public String getDecimal() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         // terminal node; no children\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        analyze(semanticScope, false);\n-    }\n-\n-    void analyze(SemanticScope semanticScope, boolean negate) {\n-        if (semanticScope.getCondition(this, Write.class)) {", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMzAwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459623009", "bodyText": ":)", "author": "jdconrad", "createdAt": "2020-07-23T17:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTYwMg==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459571602", "bodyText": "Consider moving this definition closer to it's use.", "author": "stu-elastic", "createdAt": "2020-07-23T16:20:50Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));\n+        }\n+\n+        for (int i = 0; i < userArgumentsSize; ++i) {\n+            AExpression userArgumentNode = userArgumentNodes.get(i);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(types[i]));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewObjNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitCallLocal(ECallLocal userCallLocalNode, SemanticScope semanticScope) {\n+        String methodName = userCallLocalNode.getMethodName();\n+        List<AExpression> userArgumentNodes = userCallLocalNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userCallLocalNode, Write.class)) {\n+            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to function call [\" + methodName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        FunctionTable.LocalFunction localFunction = null;\n+        PainlessMethod importedMethod = null;\n+        PainlessClassBinding classBinding = null;\n+        int classBindingOffset = 0;\n+        PainlessInstanceBinding instanceBinding = null;\n+\n+        Class<?> valueType;\n+\n+        localFunction = scriptScope.getFunctionTable().getFunction(methodName, userArgumentsSize);\n+\n+        // user cannot call internal functions, reset to null if an internal function is found\n+        if (localFunction != null && localFunction.isInternal()) {\n+            localFunction = null;\n+        }\n+\n+        if (localFunction == null) {\n+            importedMethod = scriptScope.getPainlessLookup().lookupImportedPainlessMethod(methodName, userArgumentsSize);\n+\n+            if (importedMethod == null) {\n+                classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize);\n+\n+                // check to see if this class binding requires an implicit this reference\n+                if (classBinding != null && classBinding.typeParameters.isEmpty() == false &&\n+                        classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                    classBinding = null;\n+                }\n+\n+                if (classBinding == null) {\n+                    // This extra check looks for a possible match where the class binding requires an implicit this\n+                    // reference.  This is a temporary solution to allow the class binding access to data from the\n+                    // base script class without need for a user to add additional arguments.  A long term solution\n+                    // will likely involve adding a class instance binding where any instance can have a class binding\n+                    // as part of its API.  However, the situation at run-time is difficult and will modifications that\n+                    // are a substantial change if even possible to do.\n+                    classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize + 1);\n+\n+                    if (classBinding != null) {\n+                        if (classBinding.typeParameters.isEmpty() == false &&\n+                                classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                            classBindingOffset = 1;\n+                        } else {\n+                            classBinding = null;\n+                        }\n+                    }\n+\n+                    if (classBinding == null) {\n+                        instanceBinding = scriptScope.getPainlessLookup().lookupPainlessInstanceBinding(methodName, userArgumentsSize);\n+\n+                        if (instanceBinding == null) {\n+                            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                                    \"Unknown call [\" + methodName + \"] with [\" + userArgumentNodes + \"] arguments.\"));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        List<Class<?>> typeParameters;\n+\n+        if (localFunction != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardLocalFunction(localFunction));\n+\n+            typeParameters = new ArrayList<>(localFunction.getTypeParameters());\n+            valueType = localFunction.getReturnType();\n+        } else if (importedMethod != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessMethod(importedMethod));\n+\n+            scriptScope.markNonDeterministic(importedMethod.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(importedMethod.typeParameters);\n+            valueType = importedMethod.returnType;\n+        } else if (classBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessClassBinding(classBinding));\n+            semanticScope.putDecoration(userCallLocalNode, new StandardConstant(classBindingOffset));\n+\n+            scriptScope.markNonDeterministic(classBinding.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(classBinding.typeParameters);\n+            valueType = classBinding.returnType;\n+        } else if (instanceBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessInstanceBinding(instanceBinding));\n+\n+            typeParameters = new ArrayList<>(instanceBinding.typeParameters);\n+            valueType = instanceBinding.returnType;\n+        } else {\n+            throw new IllegalStateException(\"Illegal tree structure.\");\n+        }\n+        // if the class binding is using an implicit this reference then the arguments counted must\n+        // be incremented by 1 as the this reference will not be part of the arguments passed into\n+        // the class binding call\n+        for (int argument = 0; argument < userArgumentsSize; ++argument) {\n+            AExpression userArgumentNode = userArgumentNodes.get(argument);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(typeParameters.get(argument + classBindingOffset)));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCallLocalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, SemanticScope semanticScope) {\n+        boolean bool = userBooleanConstantNode.getBool();\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Write.class)) {\n+            throw userBooleanConstantNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to boolean constant [\" + bool + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Read.class) == false) {\n+            throw userBooleanConstantNode.createError(\n+                    new IllegalArgumentException(\"not a statement: boolean constant [\" + bool + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userBooleanConstantNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userBooleanConstantNode, new StandardConstant(bool));\n+    }\n+\n+    @Override\n+    public void visitNumeric(ENumeric userNumericNode, SemanticScope semanticScope) {\n+        String numeric = userNumericNode.getNumeric();\n+\n+        if (semanticScope.getCondition(userNumericNode, Negate.class)) {\n+            numeric = \"-\" + numeric;\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Write.class)) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to numeric constant [\" + numeric + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Read.class) == false) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"not a statement: numeric constant [\" + numeric + \"] not used\"));\n+        }\n+\n+        int radix = userNumericNode.getRadix();\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (numeric.endsWith(\"d\") || numeric.endsWith(\"D\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Double.parseDouble(numeric.substring(0, numeric.length() - 1));\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"f\") || numeric.endsWith(\"F\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Float.parseFloat(numeric.substring(0, numeric.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"l\") || numeric.endsWith(\"L\")) {\n+            try {\n+                constant = Long.parseLong(numeric.substring(0, numeric.length() - 1), radix);\n+                valueType = long.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid long constant [\" + numeric + \"].\"));\n+            }\n+        } else {\n+            try {\n+                TargetType targetType = semanticScope.getDecoration(userNumericNode, TargetType.class);\n+                Class<?> sort = targetType == null ? int.class : targetType.getTargetType();\n+                int integer = Integer.parseInt(numeric, radix);\n+\n+                if (sort == byte.class && integer >= Byte.MIN_VALUE && integer <= Byte.MAX_VALUE) {\n+                    constant = (byte)integer;\n+                    valueType = byte.class;\n+                } else if (sort == char.class && integer >= Character.MIN_VALUE && integer <= Character.MAX_VALUE) {\n+                    constant = (char)integer;\n+                    valueType = char.class;\n+                } else if (sort == short.class && integer >= Short.MIN_VALUE && integer <= Short.MAX_VALUE) {\n+                    constant = (short)integer;\n+                    valueType = short.class;\n+                } else {\n+                    constant = integer;\n+                    valueType = int.class;\n+                }\n+            } catch (NumberFormatException exception) {\n+                try {\n+                    // Check if we can parse as a long. If so then hint that the user might prefer that.\n+                    Long.parseLong(numeric, radix);\n+                    throw userNumericNode.createError(new IllegalArgumentException(\n+                            \"Invalid int constant [\" + numeric + \"]. If you want a long constant then change it to [\" + numeric + \"L].\"));\n+                } catch (NumberFormatException longNoGood) {\n+                    // Ignored\n+                }\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid int constant [\" + numeric + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userNumericNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userNumericNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitDecimal(EDecimal userDecimalNode, SemanticScope semanticScope) {\n+        String decimal = userDecimalNode.getDecimal();\n+\n+        if (semanticScope.getCondition(userDecimalNode, Negate.class)) {\n+            decimal = \"-\" + decimal;\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Write.class)) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to decimal constant [\" + decimal + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Read.class) == false) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\"not a statement: decimal constant [\" + decimal + \"] not used\"));\n+        }\n+\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (decimal.endsWith(\"f\") || decimal.endsWith(\"F\")) {\n+            try {\n+                constant = Float.parseFloat(decimal.substring(0, decimal.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + decimal + \"].\"));\n+            }\n+        } else {\n+            String toParse = decimal;\n+            if (toParse.endsWith(\"d\") || decimal.endsWith(\"D\")) {\n+                toParse = toParse.substring(0, decimal.length() - 1);\n+            }\n+            try {\n+                constant = Double.parseDouble(toParse);\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + decimal + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userDecimalNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userDecimalNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitString(EString userStringNode, SemanticScope semanticScope) {\n+        String string = userStringNode.getString();\n+\n+        if (semanticScope.getCondition(userStringNode, Write.class)) {\n+            throw userStringNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to string constant [\" + string + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userStringNode, Read.class) == false) {\n+            throw userStringNode.createError(new IllegalArgumentException(\"not a statement: string constant [\" + string + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userStringNode, new ValueType(String.class));\n+        semanticScope.putDecoration(userStringNode, new StandardConstant(string));\n+    }\n+\n+    @Override\n+    public void visitNull(ENull userNullNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNullNode, Write.class)) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to null constant\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNullNode, Read.class) == false) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"not a statement: null constant not used\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userNullNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType != null) {\n+            if (targetType.getTargetType().isPrimitive()) {\n+                throw userNullNode.createError(new IllegalArgumentException(\n+                        \"Cannot cast null to a primitive type [\" + targetType.getTargetCanonicalTypeName() + \"].\"));\n+            }\n+\n+            valueType = targetType.getTargetType();\n+        } else {\n+            valueType = Object.class;\n+        }\n+\n+        semanticScope.putDecoration(userNullNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitRegex(ERegex userRegexNode, SemanticScope semanticScope) {\n+        String pattern = userRegexNode.getPattern();\n+        String flags = userRegexNode.getFlags();\n+\n+        if (semanticScope.getCondition(userRegexNode, Write.class)) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to regex constant [\" + pattern + \"] with flags [\" + flags + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userRegexNode, Read.class) == false) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"not a statement: regex constant [\" + pattern + \"] with flags [\" + flags + \"] not used\"));\n+        }\n+\n+        if (semanticScope.getScriptScope().getCompilerSettings().areRegexesEnabled() == false) {\n+            throw userRegexNode.createError(new IllegalStateException(\"Regexes are disabled. Set [script.painless.regex.enabled] to [true] \"\n+                    + \"in elasticsearch.yaml to allow them. Be careful though, regexes break out of Painless's protection against deep \"\n+                    + \"recursion and long loops.\"));\n+        }\n+\n+        Location location = userRegexNode.getLocation();\n+\n+        int constant = 0;\n+\n+        for (int i = 0; i < flags.length(); ++i) {\n+            char flag = flags.charAt(i);\n+\n+            switch (flag) {\n+                case 'c':\n+                    constant |= Pattern.CANON_EQ;\n+                    break;\n+                case 'i':\n+                    constant |= Pattern.CASE_INSENSITIVE;\n+                    break;\n+                case 'l':\n+                    constant |= Pattern.LITERAL;\n+                    break;\n+                case 'm':\n+                    constant |= Pattern.MULTILINE;\n+                    break;\n+                case 's':\n+                    constant |= Pattern.DOTALL;\n+                    break;\n+                case 'U':\n+                    constant |= Pattern.UNICODE_CHARACTER_CLASS;\n+                    break;\n+                case 'u':\n+                    constant |= Pattern.UNICODE_CASE;\n+                    break;\n+                case 'x':\n+                    constant |= Pattern.COMMENTS;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"invalid regular expression: unknown flag [\" + flag + \"]\");\n+            }\n+        }\n+\n+        try {\n+            Pattern.compile(pattern, constant);\n+        } catch (PatternSyntaxException pse) {\n+            throw new Location(location.getSourceName(), location.getOffset() + 1 + pse.getIndex()).createError(\n+                    new IllegalArgumentException(\"invalid regular expression: \" +\n+                            \"could not compile regex constant [\" + pattern + \"] with flags [\" + flags + \"]\", pse));\n+        }\n+\n+        semanticScope.putDecoration(userRegexNode, new ValueType(Pattern.class));\n+        semanticScope.putDecoration(userRegexNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitLambda(ELambda userLambdaNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userLambdaNode, Write.class)) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to a lambda\"));\n+        }\n+\n+        if (semanticScope.getCondition(userLambdaNode, Read.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not a statement: lambda not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userLambdaNode, TargetType.class);\n+        List<String> canonicalTypeNameParameters = userLambdaNode.getCanonicalTypeNameParameters();\n+\n+        Class<?> returnType;\n+        List<Class<?>> typeParameters;\n+        PainlessMethod interfaceMethod;\n+\n+        // inspect the target first, set interface method if we know it.\n+        if (targetType == null) {\n+            // we don't know anything: treat as def\n+            returnType = def.class;\n+            // don't infer any types, replace any null types with def\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (String type : canonicalTypeNameParameters) {\n+                if (type == null) {\n+                    typeParameters.add(def.class);\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(type);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + type + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        } else {\n+            // we know the method statically, infer return type and any unknown/def types\n+            interfaceMethod = scriptScope.getPainlessLookup().lookupFunctionalInterfacePainlessMethod(targetType.getTargetType());\n+            if (interfaceMethod == null) {\n+                throw userLambdaNode.createError(new IllegalArgumentException(\"Cannot pass lambda to \" +\n+                        \"[\" + targetType.getTargetCanonicalTypeName() + \"], not a functional interface\"));\n+            }\n+            // check arity before we manipulate parameters\n+            if (interfaceMethod.typeParameters.size() != canonicalTypeNameParameters.size())\n+                throw new IllegalArgumentException(\"Incorrect number of parameters for [\" + interfaceMethod.javaMethod.getName() +\n+                        \"] in [\" + targetType.getTargetCanonicalTypeName() + \"]\");\n+            // for method invocation, its allowed to ignore the return value\n+            if (interfaceMethod.returnType == void.class) {\n+                returnType = def.class;\n+            } else {\n+                returnType = interfaceMethod.returnType;\n+            }\n+            // replace any null types with the actual type\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (int i = 0; i < canonicalTypeNameParameters.size(); i++) {\n+                String paramType = canonicalTypeNameParameters.get(i);\n+                if (paramType == null) {\n+                    typeParameters.add(interfaceMethod.typeParameters.get(i));\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(paramType);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + paramType + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        }\n+\n+        Location location = userLambdaNode.getLocation();\n+        List<String> parameterNames = userLambdaNode.getParameterNames();\n+        LambdaScope lambdaScope = semanticScope.newLambdaScope(returnType);\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            Class<?> type = typeParameters.get(index);\n+            String parameterName = parameterNames.get(index);\n+            lambdaScope.defineVariable(location, type, parameterName, true);\n+        }\n+\n+        SBlock userBlockNode = userLambdaNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"cannot generate empty lambda\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, lambdaScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, MethodEscape.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not all paths return a value for lambda\"));\n+        }\n+\n+        // prepend capture list to lambda's arguments\n+        List<Variable> capturedVariables = new ArrayList<>(lambdaScope.getCaptures());\n+        List<Class<?>> typeParametersWithCaptures = new ArrayList<>(capturedVariables.size() + typeParameters.size());\n+        List<String> parameterNamesWithCaptures = new ArrayList<>(capturedVariables.size() + parameterNames.size());\n+\n+        for (Variable capturedVariable : capturedVariables) {\n+            typeParametersWithCaptures.add(capturedVariable.getType());\n+            parameterNamesWithCaptures.add(capturedVariable.getName());\n+        }\n+\n+        typeParametersWithCaptures.addAll(typeParameters);\n+        parameterNamesWithCaptures.addAll(parameterNames);\n+\n+        // desugar lambda body into a synthetic method\n+        String name = scriptScope.getNextSyntheticName(\"lambda\");\n+        scriptScope.getFunctionTable().addFunction(name, returnType, typeParametersWithCaptures, true, true);\n+\n+        Class<?> valueType;\n+        // setup method reference to synthetic method\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",\" + capturedVariables.size();\n+            valueType = String.class;\n+            semanticScope.putDecoration(userLambdaNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    location, targetType.getTargetType(), \"this\", name, capturedVariables.size());\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userLambdaNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userLambdaNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userLambdaNode, new MethodNameDecoration(name));\n+        semanticScope.putDecoration(userLambdaNode, new ReturnType(returnType));\n+        semanticScope.putDecoration(userLambdaNode, new TypeParameters(typeParametersWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new ParameterNames(parameterNamesWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new CapturesDecoration(capturedVariables));\n+    }\n+\n+    @Override\n+    public void visitFunctionRef(EFunctionRef userFunctionRefNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        Location location = userFunctionRefNode.getLocation();\n+        String symbol = userFunctionRefNode.getSymbol();\n+        String methodName = userFunctionRefNode.getMethodName();\n+        boolean read = semanticScope.getCondition(userFunctionRefNode, Read.class);\n+\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(symbol);\n+        TargetType targetType = semanticScope.getDecoration(userFunctionRefNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (symbol.equals(\"this\") || type != null)  {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to function reference [\" + symbol + \":\" + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: function reference [\" + symbol + \":\" + methodName + \"] not used\"));\n+            }\n+\n+            if (targetType == null) {\n+                valueType = String.class;\n+                String defReferenceEncoding = \"S\" + symbol + \".\" + methodName + \",0\";\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                        location, targetType.getTargetType(), symbol, methodName, 0);\n+                valueType = targetType.getTargetType();\n+                semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+            }\n+        } else {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to capturing function reference [\" + symbol + \":\"  + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: capturing function reference [\" + symbol + \":\"  + methodName + \"] not used\"));\n+            }\n+\n+            SemanticScope.Variable captured = semanticScope.getVariable(location, symbol);\n+            semanticScope.putDecoration(userFunctionRefNode, new CapturesDecoration(Collections.singletonList(captured)));\n+            if (targetType == null) {\n+                String defReferenceEncoding;\n+                if (captured.getType() == def.class) {\n+                    // dynamic implementation\n+                    defReferenceEncoding = \"D\" + symbol + \".\" + methodName + \",1\";\n+                } else {\n+                    // typed implementation\n+                    defReferenceEncoding = \"S\" + captured.getCanonicalTypeName() + \".\" + methodName + \",1\";\n+                }\n+                valueType = String.class;\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                valueType = targetType.getTargetType();\n+                // static case\n+                if (captured.getType() != def.class) {\n+                    FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(), location,\n+                            targetType.getTargetType(), captured.getCanonicalTypeName(), methodName, 1);\n+                    semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+                }\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArrayFunctionRef(ENewArrayFunctionRef userNewArrayFunctionRefNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userNewArrayFunctionRefNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Write.class)) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"cannot assign a value to new array function reference with target type [ + \" + canonicalTypeName  + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Read.class) == false) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"not a statement: new array function reference with target type [\" + canonicalTypeName + \"] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userNewArrayFunctionRefNode, TargetType.class);\n+\n+        Class<?> valueType;\n+        Class<?> clazz = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReturnType(clazz));\n+\n+        if (clazz == null) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        String name = scriptScope.getNextSyntheticName(\"newarray\");\n+        scriptScope.getFunctionTable().addFunction(name, clazz, Collections.singletonList(int.class), true, true);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new MethodNameDecoration(name));\n+\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",0\";\n+            valueType = String.class;\n+            scriptScope.putDecoration(userNewArrayFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    userNewArrayFunctionRefNode.getLocation(), targetType.getTargetType(), \"this\", name, 0);\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitSymbol(ESymbol userSymbolNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userSymbolNode, Read.class);\n+        boolean write = semanticScope.getCondition(userSymbolNode, Write.class);\n+        String symbol = userSymbolNode.getSymbol();\n+        Class<?> staticType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(symbol);\n+\n+        if (staticType != null)  {\n+            if (write) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"invalid assignment: \" +\n+                        \"cannot write a value to a static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: \" +\n+                        \"static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"] not used\"));\n+            }\n+\n+            semanticScope.putDecoration(userSymbolNode, new StaticType(staticType));\n+        } else if (semanticScope.isVariableDefined(symbol)) {\n+            if (read == false && write == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: variable [\" + symbol + \"] not used\"));\n+            }\n+\n+            Location location = userSymbolNode.getLocation();\n+            Variable variable = semanticScope.getVariable(location, symbol);\n+\n+            if (write && variable.isFinal()) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"Variable [\" + variable.getName() + \"] is read-only.\"));\n+            }\n+\n+            Class<?> valueType = variable.getType();\n+            semanticScope.putDecoration(userSymbolNode, new ValueType(valueType));\n+        } else {\n+            semanticScope.putDecoration(userSymbolNode, new PartialCanonicalTypeName(symbol));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDot(EDot userDotNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userDotNode, Read.class);\n+        boolean write = semanticScope.getCondition(userDotNode, Write.class);\n+\n+        if (read == false && write == false) {\n+            throw userDotNode.createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String index = userDotNode.getIndex();", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyNDQ0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459624446", "bodyText": "Moved these as far down as possible.", "author": "jdconrad", "createdAt": "2020-07-23T17:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjgxOA==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459592818", "bodyText": "de-indent this line.", "author": "stu-elastic", "createdAt": "2020-07-23T16:56:06Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyNDc1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459624755", "bodyText": "Done.", "author": "jdconrad", "createdAt": "2020-07-23T17:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459595674", "bodyText": "Why is this different in DefaultSemanticAnalysisPhase?  Is it just the changes to use decorations?", "author": "stu-elastic", "createdAt": "2020-07-23T17:00:44Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java", "diffHunk": "@@ -68,90 +57,4 @@ public Operation getOperation() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         childNode.visit(userTreeVisitor, scope);\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n-                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        if (semanticScope.getCondition(this, Read.class) == false) {\n-            throw createError(new IllegalArgumentException(\n-                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        Class<?> valueType;\n-        Class<?> promote = null;\n-\n-        if ((operation == Operation.SUB || operation == Operation.ADD) &&\n-                (childNode instanceof ENumeric || childNode instanceof EDecimal)) {\n-            semanticScope.setCondition(childNode, Read.class);\n-            semanticScope.copyDecoration(this, childNode, TargetType.class);\n-            semanticScope.replicateCondition(this, childNode, Explicit.class);\n-            semanticScope.replicateCondition(this, childNode, Internal.class);\n-\n-            if (childNode instanceof ENumeric) {\n-                ENumeric numeric = (ENumeric)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    numeric.analyze(semanticScope, numeric.getNumeric().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else if (childNode instanceof EDecimal) {\n-                EDecimal decimal = (EDecimal)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    decimal.analyze(semanticScope, decimal.getDecimal().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else {\n-                throw createError(new IllegalArgumentException(\"illegal tree structure\"));\n-            }\n-\n-            valueType = semanticScope.getDecoration(childNode, ValueType.class).getValueType();", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMjkxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459622911", "bodyText": "Yes, this what changed by adding the Negate decoration. Parsing a negative numeric constant (and decimal constant) is a bit odd as the parser gives you the tokens MINUS and NUMERIC, but if they're separated a user cannot enter the negative maximum value as the positive one exceeds the positive max since the negation won't be applied until a parent node. Special care is taken to ensure this doesn't happen that way by collapsing the unary node with the Negate decoration.", "author": "jdconrad", "createdAt": "2020-07-23T17:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODcwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459598705", "bodyText": "Where did this cast move to in DefaultSemanticAnalysisPhase?", "author": "stu-elastic", "createdAt": "2020-07-23T17:05:58Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java", "diffHunk": "@@ -57,35 +48,6 @@ public AExpression getExpressionNode() {\n \n     @Override\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n-        expressionNode.visit(userTreeVisitor, scope);\n-    }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        Class<?> rtnType = semanticScope.getReturnType();\n-        boolean isVoid = rtnType == void.class;\n-        boolean lastSource = semanticScope.getCondition(this, LastSource.class);\n-\n-        if (lastSource && !isVoid) {\n-            semanticScope.setCondition(expressionNode, Read.class);\n-        }\n-\n-        AExpression.analyze(expressionNode, semanticScope);\n-        Class<?> expressionValueType = semanticScope.getDecoration(expressionNode, ValueType.class).getValueType();\n-\n-        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n-        semanticScope.putDecoration(expressionNode, new TargetType(rtn ? rtnType : expressionValueType));\n-\n-        if (rtn) {\n-            semanticScope.setCondition(expressionNode, Internal.class);\n-        }\n-\n-        expressionNode.cast(semanticScope);", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459620126", "bodyText": "Slight logic change:\nIt's now decorateWithCast(userStatementNode, semanticScope); and only applied if this value is returned; otherwise the cast is redundant under the old logic since we set both value type and target type to the same thing.", "author": "jdconrad", "createdAt": "2020-07-23T17:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTkxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459599915", "bodyText": "Line these conditions up.", "author": "stu-elastic", "createdAt": "2020-07-23T17:08:06Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {", "originalCommit": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMDAzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459600031", "bodyText": "All five of 'em.", "author": "stu-elastic", "createdAt": "2020-07-23T17:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459620972", "bodyText": "I lined them up. Note that standard style dictates a line continuation is intended twice normally.", "author": "jdconrad", "createdAt": "2020-07-23T17:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTkxNQ=="}], "type": "inlineReview"}, {"oid": "b53b318e950ac59d92fb80bccf2cf895bc026e94", "url": "https://github.com/elastic/elasticsearch/commit/b53b318e950ac59d92fb80bccf2cf895bc026e94", "message": "response to pr comments", "committedDate": "2020-07-23T17:50:57Z", "type": "commit"}, {"oid": "c79b2494389347f46202c48176b635b8dbfbb3f7", "url": "https://github.com/elastic/elasticsearch/commit/c79b2494389347f46202c48176b635b8dbfbb3f7", "message": "regen antlr to unedited", "committedDate": "2020-07-23T17:54:51Z", "type": "commit"}, {"oid": "89abb7eca8ecc760f8bc900440be3f3ac3a5a58c", "url": "https://github.com/elastic/elasticsearch/commit/89abb7eca8ecc760f8bc900440be3f3ac3a5a58c", "message": "realign if/else statements", "committedDate": "2020-07-23T18:02:00Z", "type": "commit"}, {"oid": "57f5699ed257b3df9e44a03ba37809abee76fb32", "url": "https://github.com/elastic/elasticsearch/commit/57f5699ed257b3df9e44a03ba37809abee76fb32", "message": "Merge branch 'master' into semantic7", "committedDate": "2020-07-27T15:18:24Z", "type": "commit"}, {"oid": "f1772c6afdf3d8b3d98eb397f3739f270ea1d1a1", "url": "https://github.com/elastic/elasticsearch/commit/f1772c6afdf3d8b3d98eb397f3739f270ea1d1a1", "message": "added basic comments to each public method for\nDefaultSemanticAnalysisPhase", "committedDate": "2020-07-27T16:49:16Z", "type": "commit"}, {"oid": "eac1d61e41717df51b42edf65cbd1570a2a46663", "url": "https://github.com/elastic/elasticsearch/commit/eac1d61e41717df51b42edf65cbd1570a2a46663", "message": "remove statement, use read instead", "committedDate": "2020-03-27T23:55:26Z", "type": "commit"}, {"oid": "082e94b4a590591196625bad85750d2fcbc4f551", "url": "https://github.com/elastic/elasticsearch/commit/082e94b4a590591196625bad85750d2fcbc4f551", "message": "add tests for not a statement", "committedDate": "2020-03-30T16:27:34Z", "type": "commit"}, {"oid": "d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "url": "https://github.com/elastic/elasticsearch/commit/d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-03-30T16:51:01Z", "type": "commit"}, {"oid": "4459ee9a8029edd7c995865bd3202830def8097c", "url": "https://github.com/elastic/elasticsearch/commit/4459ee9a8029edd7c995865bd3202830def8097c", "message": "move isDefOptimized to output instead of as mutable state on the nodes", "committedDate": "2020-03-30T19:02:43Z", "type": "commit"}, {"oid": "1eb0a513f54a2abc3a4d90877d43297a246e7dac", "url": "https://github.com/elastic/elasticsearch/commit/1eb0a513f54a2abc3a4d90877d43297a246e7dac", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-03-30T19:05:32Z", "type": "commit"}, {"oid": "372ec631791fceda73c22bb1dfbba176aeba7c1f", "url": "https://github.com/elastic/elasticsearch/commit/372ec631791fceda73c22bb1dfbba176aeba7c1f", "message": "Merge branch 'nodes0' into nodes1", "committedDate": "2020-03-30T19:05:58Z", "type": "commit"}, {"oid": "99c54f190497586547ab073b41a0c5d39d89b5fd", "url": "https://github.com/elastic/elasticsearch/commit/99c54f190497586547ab073b41a0c5d39d89b5fd", "message": "remove AStoreable and give individual nodes responsibility to check\nwrite", "committedDate": "2020-03-30T20:18:46Z", "type": "commit"}, {"oid": "2eceff4ba180840b185ae834b963c9b7ae1f58bc", "url": "https://github.com/elastic/elasticsearch/commit/2eceff4ba180840b185ae834b963c9b7ae1f58bc", "message": "clean up write messages and add tests", "committedDate": "2020-03-30T22:18:14Z", "type": "commit"}, {"oid": "78961f80bef311dfa557dd0288dec8a7a1564be6", "url": "https://github.com/elastic/elasticsearch/commit/78961f80bef311dfa557dd0288dec8a7a1564be6", "message": "elimate extraneous new array function reference ir node", "committedDate": "2020-03-30T22:57:27Z", "type": "commit"}, {"oid": "7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "url": "https://github.com/elastic/elasticsearch/commit/7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "message": "switch ir function ref nodes to different types", "committedDate": "2020-03-31T20:07:52Z", "type": "commit"}, {"oid": "791eca3b0d29f37c9d84fd196fb03618d33b8606", "url": "https://github.com/elastic/elasticsearch/commit/791eca3b0d29f37c9d84fd196fb03618d33b8606", "message": "remove ILambda in favor of ir tree calculating def method call recipe", "committedDate": "2020-03-31T20:45:25Z", "type": "commit"}, {"oid": "e77796275a7bf20572efb4dd1610e26ad0adefe1", "url": "https://github.com/elastic/elasticsearch/commit/e77796275a7bf20572efb4dd1610e26ad0adefe1", "message": "remove sub nodes from user tree", "committedDate": "2020-03-31T22:52:45Z", "type": "commit"}, {"oid": "0eba55c612cfbc1b967b0cd1e2e99fa01b53ec6e", "url": "https://github.com/elastic/elasticsearch/commit/0eba55c612cfbc1b967b0cd1e2e99fa01b53ec6e", "message": "remove PainlessCast from output as it's completely local", "committedDate": "2020-04-01T22:20:46Z", "type": "commit"}, {"oid": "8d0ac605207b4fd8fb38942de0e7831dd2dfce9e", "url": "https://github.com/elastic/elasticsearch/commit/8d0ac605207b4fd8fb38942de0e7831dd2dfce9e", "message": "partially removed type from lexer", "committedDate": "2020-04-02T23:59:28Z", "type": "commit"}, {"oid": "38c15bc41853f468504d1e6517aa78f8d528e4a6", "url": "https://github.com/elastic/elasticsearch/commit/38c15bc41853f468504d1e6517aa78f8d528e4a6", "message": "removed ambiguity in parsing related to casting versus binary", "committedDate": "2020-04-03T23:19:27Z", "type": "commit"}, {"oid": "3bfed8d6631a604e3da06aa734be4a50ee7c078b", "url": "https://github.com/elastic/elasticsearch/commit/3bfed8d6631a604e3da06aa734be4a50ee7c078b", "message": "handle negation in the user tree instead of relying on the walker", "committedDate": "2020-04-04T00:42:02Z", "type": "commit"}, {"oid": "f8235dfa22a5e02193bc45b12f35b18eb08df896", "url": "https://github.com/elastic/elasticsearch/commit/f8235dfa22a5e02193bc45b12f35b18eb08df896", "message": "lexer hack completely removed", "committedDate": "2020-04-06T20:57:57Z", "type": "commit"}, {"oid": "94b6c80f963c042dae95604d3c6b469fff10d9ac", "url": "https://github.com/elastic/elasticsearch/commit/94b6c80f963c042dae95604d3c6b469fff10d9ac", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-04-08T17:03:44Z", "type": "commit"}, {"oid": "e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "url": "https://github.com/elastic/elasticsearch/commit/e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "message": "Merge branch 'nodes0' into nodes1", "committedDate": "2020-04-08T17:03:54Z", "type": "commit"}, {"oid": "97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "url": "https://github.com/elastic/elasticsearch/commit/97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-08T17:24:14Z", "type": "commit"}, {"oid": "68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "url": "https://github.com/elastic/elasticsearch/commit/68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "message": "Merge branch 'nodes2' into nodes3", "committedDate": "2020-04-08T17:26:09Z", "type": "commit"}, {"oid": "112048c228d27db7920c45d54c504965bf273be5", "url": "https://github.com/elastic/elasticsearch/commit/112048c228d27db7920c45d54c504965bf273be5", "message": "Merge branch 'nodes3' into nodes4", "committedDate": "2020-04-08T17:29:05Z", "type": "commit"}, {"oid": "5669498608729c5633e15b53142b0126e9d2e2c7", "url": "https://github.com/elastic/elasticsearch/commit/5669498608729c5633e15b53142b0126e9d2e2c7", "message": "Merge branch 'nodes4' into nodes5", "committedDate": "2020-04-08T17:30:40Z", "type": "commit"}, {"oid": "56b43370baaac38d98593a92fe96fb063c5b0585", "url": "https://github.com/elastic/elasticsearch/commit/56b43370baaac38d98593a92fe96fb063c5b0585", "message": "add javadocs", "committedDate": "2020-04-08T19:23:30Z", "type": "commit"}, {"oid": "1f6bf2f30cb90de1e386f96326ea146435e73921", "url": "https://github.com/elastic/elasticsearch/commit/1f6bf2f30cb90de1e386f96326ea146435e73921", "message": "add guards for invalid static values", "committedDate": "2020-04-08T22:16:30Z", "type": "commit"}, {"oid": "50fc23b95ff6254430cbe5b1fe3382ebed451752", "url": "https://github.com/elastic/elasticsearch/commit/50fc23b95ff6254430cbe5b1fe3382ebed451752", "message": "add partial types tests and not a symbol tests", "committedDate": "2020-04-09T20:56:43Z", "type": "commit"}, {"oid": "1b61f58c3a9fbbd924eaa7647d96b9541d4e9919", "url": "https://github.com/elastic/elasticsearch/commit/1b61f58c3a9fbbd924eaa7647d96b9541d4e9919", "message": "add tests for valid static types", "committedDate": "2020-04-09T21:50:23Z", "type": "commit"}, {"oid": "07b1efe9f647668e41a4121ab987968d1ba7b425", "url": "https://github.com/elastic/elasticsearch/commit/07b1efe9f647668e41a4121ab987968d1ba7b425", "message": "add precedence node to handle final lexer hack removal path", "committedDate": "2020-04-09T23:33:29Z", "type": "commit"}, {"oid": "251ff50fcac2ded70f1026560cf7cb67d1e86c28", "url": "https://github.com/elastic/elasticsearch/commit/251ff50fcac2ded70f1026560cf7cb67d1e86c28", "message": "Merge branch 'master' into nodes1", "committedDate": "2020-04-10T15:30:43Z", "type": "commit"}, {"oid": "198fa475e180a169ca1911734d49096dbaf4a1f3", "url": "https://github.com/elastic/elasticsearch/commit/198fa475e180a169ca1911734d49096dbaf4a1f3", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-10T15:36:40Z", "type": "commit"}, {"oid": "dd82b5f86711cb8d99c686d9fa21ddb035e84880", "url": "https://github.com/elastic/elasticsearch/commit/dd82b5f86711cb8d99c686d9fa21ddb035e84880", "message": "Merge branch 'nodes2' into nodes3", "committedDate": "2020-04-10T15:40:21Z", "type": "commit"}, {"oid": "87cafb387bc0f8096d3b7929b1d5186c481fdb39", "url": "https://github.com/elastic/elasticsearch/commit/87cafb387bc0f8096d3b7929b1d5186c481fdb39", "message": "Merge branch 'nodes3' into nodes4", "committedDate": "2020-04-10T15:42:14Z", "type": "commit"}, {"oid": "c466828680319beea3cc0087cfbf0ba73e5010eb", "url": "https://github.com/elastic/elasticsearch/commit/c466828680319beea3cc0087cfbf0ba73e5010eb", "message": "Merge branch 'nodes4' into nodes5", "committedDate": "2020-04-10T15:44:06Z", "type": "commit"}, {"oid": "e60482addcf51170606e74a6c0870481b705f14e", "url": "https://github.com/elastic/elasticsearch/commit/e60482addcf51170606e74a6c0870481b705f14e", "message": "move prefix into nodes its actually used in", "committedDate": "2020-04-10T18:35:21Z", "type": "commit"}, {"oid": "8c902dad68b1317b13097a4818d45f9fc1bed7a5", "url": "https://github.com/elastic/elasticsearch/commit/8c902dad68b1317b13097a4818d45f9fc1bed7a5", "message": "Use block instead of list of statements for Lambda", "committedDate": "2020-04-14T20:28:16Z", "type": "commit"}, {"oid": "a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "url": "https://github.com/elastic/elasticsearch/commit/a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "message": "Merge branch 'master' into nodes1", "committedDate": "2020-04-14T23:12:20Z", "type": "commit"}, {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328", "url": "https://github.com/elastic/elasticsearch/commit/4c93293c2ada3933550f1b64fa303a8785b7b328", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-14T23:12:46Z", "type": "commit"}, {"oid": "14079081e7c0e4fb365a4a48abef0aa16f0a9692", "url": "https://github.com/elastic/elasticsearch/commit/14079081e7c0e4fb365a4a48abef0aa16f0a9692", "message": "add primitive types to remove binary recognition of cast", "committedDate": "2020-04-15T20:18:06Z", "type": "commit"}, {"oid": "7a349b32470df4fa11b472acae915c8a5a63b5a2", "url": "https://github.com/elastic/elasticsearch/commit/7a349b32470df4fa11b472acae915c8a5a63b5a2", "message": "remove unnecessary nodes from EDot", "committedDate": "2020-04-15T20:39:54Z", "type": "commit"}, {"oid": "68679c8c4249bc8af9b28b449b5695fa8816b0cf", "url": "https://github.com/elastic/elasticsearch/commit/68679c8c4249bc8af9b28b449b5695fa8816b0cf", "message": "remove precedence", "committedDate": "2020-04-15T20:58:15Z", "type": "commit"}, {"oid": "bb55509d9540c641e5f50e184bd4790153fbedea", "url": "https://github.com/elastic/elasticsearch/commit/bb55509d9540c641e5f50e184bd4790153fbedea", "message": "remove node creation in EUnary", "committedDate": "2020-04-16T22:03:44Z", "type": "commit"}, {"oid": "1de2751d9913ab8ebca868c727b759cbbb1c7b2a", "url": "https://github.com/elastic/elasticsearch/commit/1de2751d9913ab8ebca868c727b759cbbb1c7b2a", "message": "remove remaining node instantiations within the semantic pass", "committedDate": "2020-04-16T22:31:34Z", "type": "commit"}, {"oid": "e991a4ea8ad596fcb7eddece58a977cb8e353d7c", "url": "https://github.com/elastic/elasticsearch/commit/e991a4ea8ad596fcb7eddece58a977cb8e353d7c", "message": "partial first pass of cleaning up members of user tree nodes", "committedDate": "2020-04-16T23:58:30Z", "type": "commit"}, {"oid": "99b541f1f495fdfd0a0973e76395a00e17eb0091", "url": "https://github.com/elastic/elasticsearch/commit/99b541f1f495fdfd0a0973e76395a00e17eb0091", "message": "clean up more nodes members", "committedDate": "2020-04-17T19:48:27Z", "type": "commit"}, {"oid": "82476866eaff495a3b21e88f5807db838704ca97", "url": "https://github.com/elastic/elasticsearch/commit/82476866eaff495a3b21e88f5807db838704ca97", "message": "setup user nodes for external pass by making members private w/ getters", "committedDate": "2020-04-17T20:49:16Z", "type": "commit"}, {"oid": "85e1f8a498f19d824cb68ab5debfc3ba60177e8c", "url": "https://github.com/elastic/elasticsearch/commit/85e1f8a498f19d824cb68ab5debfc3ba60177e8c", "message": "name changes Scope to SemanticScope, ScriptRoot to ScriptScope", "committedDate": "2020-04-17T21:36:56Z", "type": "commit"}, {"oid": "2e37afe020fb8fc695b4f409dfe3e436db93c9a3", "url": "https://github.com/elastic/elasticsearch/commit/2e37afe020fb8fc695b4f409dfe3e436db93c9a3", "message": "fix typo", "committedDate": "2020-04-17T21:40:21Z", "type": "commit"}, {"oid": "d320ced583d94e5418ded9e5b71597c37c88d6dd", "url": "https://github.com/elastic/elasticsearch/commit/d320ced583d94e5418ded9e5b71597c37c88d6dd", "message": "move ScriptScope into SemanticScope", "committedDate": "2020-04-17T22:14:57Z", "type": "commit"}, {"oid": "b59eeea1b6c89921ca748f86ecafc76ba4bd627f", "url": "https://github.com/elastic/elasticsearch/commit/b59eeea1b6c89921ca748f86ecafc76ba4bd627f", "message": "remove EConstant", "committedDate": "2020-04-17T22:19:29Z", "type": "commit"}, {"oid": "c3f8c8c8cacccaa5defd6c8480b7e62b8a20b21a", "url": "https://github.com/elastic/elasticsearch/commit/c3f8c8c8cacccaa5defd6c8480b7e62b8a20b21a", "message": "remove DType nodes and remove SDeclaration from SCatch", "committedDate": "2020-04-17T23:03:16Z", "type": "commit"}, {"oid": "b4c096235d00f02c4d6fa2aad72cf05db45ced23", "url": "https://github.com/elastic/elasticsearch/commit/b4c096235d00f02c4d6fa2aad72cf05db45ced23", "message": "add decorators for semantic pass", "committedDate": "2020-04-18T00:38:57Z", "type": "commit"}, {"oid": "9ccfaeb99d980d7ab6c14b6927134f8077197f60", "url": "https://github.com/elastic/elasticsearch/commit/9ccfaeb99d980d7ab6c14b6927134f8077197f60", "message": "partially add decoration for output.actual", "committedDate": "2020-04-18T16:15:00Z", "type": "commit"}, {"oid": "0095dbcc4cd53ba80364ea0ca345aea81fd34bfe", "url": "https://github.com/elastic/elasticsearch/commit/0095dbcc4cd53ba80364ea0ca345aea81fd34bfe", "message": "finish converting output.actual to decorator value", "committedDate": "2020-04-18T17:42:39Z", "type": "commit"}, {"oid": "71e457d8dd55ca485bc6d247ac9133d8112133df", "url": "https://github.com/elastic/elasticsearch/commit/71e457d8dd55ca485bc6d247ac9133d8112133df", "message": "fix value type decorations", "committedDate": "2020-04-18T19:03:33Z", "type": "commit"}, {"oid": "e2a9866b8eede31d25c086351ac282d926d39c14", "url": "https://github.com/elastic/elasticsearch/commit/e2a9866b8eede31d25c086351ac282d926d39c14", "message": "rename scopetable to writescope", "committedDate": "2020-04-18T19:34:32Z", "type": "commit"}, {"oid": "d30f595bcdb4d29569ab4cc918630e07459ba9b9", "url": "https://github.com/elastic/elasticsearch/commit/d30f595bcdb4d29569ab4cc918630e07459ba9b9", "message": "add copy to decorator", "committedDate": "2020-04-18T19:48:51Z", "type": "commit"}, {"oid": "ec0411cc1891cbe54e8cc56d8f60c3e79068ef20", "url": "https://github.com/elastic/elasticsearch/commit/ec0411cc1891cbe54e8cc56d8f60c3e79068ef20", "message": "replace expression input with decoration", "committedDate": "2020-04-19T03:15:56Z", "type": "commit"}, {"oid": "36d32f3bbb8e8c32c6d89b8101535f6071502d54", "url": "https://github.com/elastic/elasticsearch/commit/36d32f3bbb8e8c32c6d89b8101535f6071502d54", "message": "change expression output static type to be a decoration", "committedDate": "2020-04-19T17:07:56Z", "type": "commit"}, {"oid": "7244c21ff11ae59e5f611d71ad9c6c2ea2d86ced", "url": "https://github.com/elastic/elasticsearch/commit/7244c21ff11ae59e5f611d71ad9c6c2ea2d86ced", "message": "remove expression output except node", "committedDate": "2020-04-19T17:36:23Z", "type": "commit"}, {"oid": "2ea3183844713a178d0003adf53a467432c3aa2e", "url": "https://github.com/elastic/elasticsearch/commit/2ea3183844713a178d0003adf53a467432c3aa2e", "message": "replace user statement input with decorations", "committedDate": "2020-04-19T17:58:19Z", "type": "commit"}, {"oid": "f974d8ff77ac9db1e735358fd9d786013ca62fcd", "url": "https://github.com/elastic/elasticsearch/commit/f974d8ff77ac9db1e735358fd9d786013ca62fcd", "message": "remove statement count from statement output", "committedDate": "2020-04-19T18:27:53Z", "type": "commit"}, {"oid": "fc463f80eb88ad4a85f8c500446ce1fd41376c40", "url": "https://github.com/elastic/elasticsearch/commit/fc463f80eb88ad4a85f8c500446ce1fd41376c40", "message": "switched statement output to decorations", "committedDate": "2020-04-19T19:52:42Z", "type": "commit"}, {"oid": "2c68562a1e9e126f6579654024ff9b89821162a9", "url": "https://github.com/elastic/elasticsearch/commit/2c68562a1e9e126f6579654024ff9b89821162a9", "message": "start to convert ir tree building to an external phase", "committedDate": "2020-04-19T20:54:34Z", "type": "commit"}, {"oid": "57baf7282a3126fd1b2324283c72ed4b4fd36a38", "url": "https://github.com/elastic/elasticsearch/commit/57baf7282a3126fd1b2324283c72ed4b4fd36a38", "message": "move all statement nodes to build ir tree", "committedDate": "2020-04-20T00:09:55Z", "type": "commit"}, {"oid": "3fc720dcc165911dafd1d73ce92883b9ad1407ed", "url": "https://github.com/elastic/elasticsearch/commit/3fc720dcc165911dafd1d73ce92883b9ad1407ed", "message": "completed transition of expression nodes to move ir building to separate\nphase", "committedDate": "2020-04-21T03:45:19Z", "type": "commit"}, {"oid": "99cf8bc1d8b291fd75ab9b4c92fea594c07da602", "url": "https://github.com/elastic/elasticsearch/commit/99cf8bc1d8b291fd75ab9b4c92fea594c07da602", "message": "fixed tests", "committedDate": "2020-04-21T05:39:21Z", "type": "commit"}, {"oid": "c8076bfa4366e371aaba802a038db3c56ce43074", "url": "https://github.com/elastic/elasticsearch/commit/c8076bfa4366e371aaba802a038db3c56ce43074", "message": "Merge branch 'master' into nodes2", "committedDate": "2020-04-21T14:51:10Z", "type": "commit"}, {"oid": "a4d34169a4724a4111cb30c9671e79798b64f3ef", "url": "https://github.com/elastic/elasticsearch/commit/a4d34169a4724a4111cb30c9671e79798b64f3ef", "message": "response to pr comments", "committedDate": "2020-04-21T16:38:42Z", "type": "commit"}, {"oid": "dafeaeb13af618684c04f0f5d38d509d4af92533", "url": "https://github.com/elastic/elasticsearch/commit/dafeaeb13af618684c04f0f5d38d509d4af92533", "message": "Merge branch 'master' into nodes2", "committedDate": "2020-04-21T17:31:42Z", "type": "commit"}, {"oid": "ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "url": "https://github.com/elastic/elasticsearch/commit/ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "message": "Merge branch 'nodes2' into nodes3", "committedDate": "2020-04-21T17:32:33Z", "type": "commit"}, {"oid": "9f2cdd1d6db22e474db4a1664b28942f32b6e8d6", "url": "https://github.com/elastic/elasticsearch/commit/9f2cdd1d6db22e474db4a1664b28942f32b6e8d6", "message": "Merge branch 'nodes3' into nodes4", "committedDate": "2020-04-21T17:38:07Z", "type": "commit"}, {"oid": "3250d9eeb0a9c1532353d79fb3daceb74f941686", "url": "https://github.com/elastic/elasticsearch/commit/3250d9eeb0a9c1532353d79fb3daceb74f941686", "message": "Merge branch 'nodes4' into nodes5", "committedDate": "2020-04-21T17:44:40Z", "type": "commit"}, {"oid": "d965f14ba797d115a5e499178807bbc288e7136b", "url": "https://github.com/elastic/elasticsearch/commit/d965f14ba797d115a5e499178807bbc288e7136b", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-04-21T17:47:09Z", "type": "commit"}, {"oid": "229f99c28164fe814514b26a412c191eae39de4c", "url": "https://github.com/elastic/elasticsearch/commit/229f99c28164fe814514b26a412c191eae39de4c", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-04-21T17:51:01Z", "type": "commit"}, {"oid": "b7216acce6e99edad979591605ac5efc2edb776b", "url": "https://github.com/elastic/elasticsearch/commit/b7216acce6e99edad979591605ac5efc2edb776b", "message": "Merge branch 'semantic0' into semantic1", "committedDate": "2020-04-21T17:52:46Z", "type": "commit"}, {"oid": "888c90bff8bbedb73e769dea43c2db4c7312f387", "url": "https://github.com/elastic/elasticsearch/commit/888c90bff8bbedb73e769dea43c2db4c7312f387", "message": "Merge branch 'semantic1' into semantic2", "committedDate": "2020-04-21T17:57:54Z", "type": "commit"}, {"oid": "8499779928eaabb98d618d9a31091f888d2ca38b", "url": "https://github.com/elastic/elasticsearch/commit/8499779928eaabb98d618d9a31091f888d2ca38b", "message": "Merge branch 'semantic2' into semantic3", "committedDate": "2020-04-21T18:00:16Z", "type": "commit"}, {"oid": "9dc9855f1053d088f1ba1687269e10fc87bea38c", "url": "https://github.com/elastic/elasticsearch/commit/9dc9855f1053d088f1ba1687269e10fc87bea38c", "message": "Merge branch 'semantic3' into semantic4", "committedDate": "2020-04-21T18:01:52Z", "type": "commit"}, {"oid": "831d34262872b5a68c6ddb19343c4b8cf47e3201", "url": "https://github.com/elastic/elasticsearch/commit/831d34262872b5a68c6ddb19343c4b8cf47e3201", "message": "Merge branch 'semantic4' into semantic5", "committedDate": "2020-04-21T18:03:56Z", "type": "commit"}, {"oid": "ac53464dbd37bd30c1ab1e97e2c704f3bafd9258", "url": "https://github.com/elastic/elasticsearch/commit/ac53464dbd37bd30c1ab1e97e2c704f3bafd9258", "message": "moved header generation to external phase", "committedDate": "2020-04-21T22:39:09Z", "type": "commit"}, {"oid": "6e12b999cd590edb968130cd5a8757e774a89e88", "url": "https://github.com/elastic/elasticsearch/commit/6e12b999cd590edb968130cd5a8757e774a89e88", "message": "move statement nodes to external pass format", "committedDate": "2020-04-22T21:13:15Z", "type": "commit"}, {"oid": "b2eaaba7d50a628620a659fe93959986270179fe", "url": "https://github.com/elastic/elasticsearch/commit/b2eaaba7d50a628620a659fe93959986270179fe", "message": "update user expression nodes to visitor pattern", "committedDate": "2020-04-23T22:04:31Z", "type": "commit"}, {"oid": "ecd7d428a5b5f127eca82d68b7f429492f278b8f", "url": "https://github.com/elastic/elasticsearch/commit/ecd7d428a5b5f127eca82d68b7f429492f278b8f", "message": "fixes", "committedDate": "2020-04-23T22:59:21Z", "type": "commit"}, {"oid": "2d07ee67e79b3922b206c7132b260eb221aa6f98", "url": "https://github.com/elastic/elasticsearch/commit/2d07ee67e79b3922b206c7132b260eb221aa6f98", "message": "more fixes", "committedDate": "2020-04-23T23:42:13Z", "type": "commit"}, {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "url": "https://github.com/elastic/elasticsearch/commit/a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "message": "Merge branch 'master' into nodes3", "committedDate": "2020-04-24T14:26:04Z", "type": "commit"}, {"oid": "1531a1e5ae9574fe54a26a63651c26c64391d733", "url": "https://github.com/elastic/elasticsearch/commit/1531a1e5ae9574fe54a26a63651c26c64391d733", "message": "Merge branch 'nodes3' into nodes4", "committedDate": "2020-04-24T14:34:07Z", "type": "commit"}, {"oid": "b16f828448b6416194d7bbbe4bb7f77808b9b62f", "url": "https://github.com/elastic/elasticsearch/commit/b16f828448b6416194d7bbbe4bb7f77808b9b62f", "message": "Merge branch 'nodes4' into nodes5", "committedDate": "2020-04-24T14:34:42Z", "type": "commit"}, {"oid": "cd139e2bf3de1f018a0659466066d7f2744a3f33", "url": "https://github.com/elastic/elasticsearch/commit/cd139e2bf3de1f018a0659466066d7f2744a3f33", "message": "Merge branch 'nodes5' into nodes6", "committedDate": "2020-04-24T14:34:59Z", "type": "commit"}, {"oid": "ca1febb58a3fb9b59d904a85ba27cef7b4ffb58a", "url": "https://github.com/elastic/elasticsearch/commit/ca1febb58a3fb9b59d904a85ba27cef7b4ffb58a", "message": "Merge branch 'nodes6' into semantic0", "committedDate": "2020-04-24T14:35:15Z", "type": "commit"}, {"oid": "7fd5ec24b8e903d2738a13c6c45856354aaa2364", "url": "https://github.com/elastic/elasticsearch/commit/7fd5ec24b8e903d2738a13c6c45856354aaa2364", "message": "Merge branch 'semantic0' into semantic1", "committedDate": "2020-04-24T14:35:25Z", "type": "commit"}, {"oid": "69d9579a9de2797b04b0910fe18a36668777d778", "url": "https://github.com/elastic/elasticsearch/commit/69d9579a9de2797b04b0910fe18a36668777d778", "message": "Merge branch 'semantic1' into semantic2", "committedDate": "2020-04-24T14:35:35Z", "type": "commit"}, {"oid": "2a0635de911f98cd66f0f1ddb15bc25beda5b34a", "url": "https://github.com/elastic/elasticsearch/commit/2a0635de911f98cd66f0f1ddb15bc25beda5b34a", "message": "Merge branch 'semantic2' into semantic3", "committedDate": "2020-04-24T14:35:53Z", "type": "commit"}, {"oid": "edd3db7c4b6ee005dd814e3a5af8884962e2334b", "url": "https://github.com/elastic/elasticsearch/commit/edd3db7c4b6ee005dd814e3a5af8884962e2334b", "message": "Merge branch 'semantic3' into semantic4", "committedDate": "2020-04-24T14:36:04Z", "type": "commit"}, {"oid": "7428df991ac48815834122d254b9caa14988411b", "url": "https://github.com/elastic/elasticsearch/commit/7428df991ac48815834122d254b9caa14988411b", "message": "Merge branch 'semantic4' into semantic5", "committedDate": "2020-04-24T14:36:15Z", "type": "commit"}, {"oid": "a840eb2cafec3be2e6b00a3f96b8ef4dfd705784", "url": "https://github.com/elastic/elasticsearch/commit/a840eb2cafec3be2e6b00a3f96b8ef4dfd705784", "message": "Merge branch 'semantic5' into semantic6", "committedDate": "2020-04-24T14:36:35Z", "type": "commit"}, {"oid": "147bd2a0a19dc0d346b34ddd3481437b868ee7ee", "url": "https://github.com/elastic/elasticsearch/commit/147bd2a0a19dc0d346b34ddd3481437b868ee7ee", "message": "Merge branch 'semantic6' into semantic7", "committedDate": "2020-04-24T14:36:54Z", "type": "commit"}, {"oid": "64796ba9432bd5240d7bd1a9190503622d0af0ba", "url": "https://github.com/elastic/elasticsearch/commit/64796ba9432bd5240d7bd1a9190503622d0af0ba", "message": "Merge branch 'master' into nodes3", "committedDate": "2020-04-29T20:36:52Z", "type": "commit"}, {"oid": "35a029e05a0b237f0de461efc33cb94992739614", "url": "https://github.com/elastic/elasticsearch/commit/35a029e05a0b237f0de461efc33cb94992739614", "message": "response to pr comments", "committedDate": "2020-04-29T20:57:49Z", "type": "commit"}, {"oid": "948d6ecef2a5b02f15c90a96b35cbbaec9971720", "url": "https://github.com/elastic/elasticsearch/commit/948d6ecef2a5b02f15c90a96b35cbbaec9971720", "message": "Merge branch 'master' into nodes3", "committedDate": "2020-04-29T21:49:47Z", "type": "commit"}, {"oid": "5542b0f9fd649660bc36198b7d45161a8954794e", "url": "https://github.com/elastic/elasticsearch/commit/5542b0f9fd649660bc36198b7d45161a8954794e", "message": "Merge branch 'nodes3' into nodes4", "committedDate": "2020-04-29T21:49:54Z", "type": "commit"}]}