{"pr_number": 58507, "pr_title": "Aggregation tests for Wildcard Field", "pr_createdAt": "2020-06-24T17:14:13Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58507", "timeline": [{"oid": "09edd02e28afa30e69867bfe3d4ebfc183882a65", "url": "https://github.com/elastic/elasticsearch/commit/09edd02e28afa30e69867bfe3d4ebfc183882a65", "message": "wildcard field tests for terms agg", "committedDate": "2020-06-18T17:10:30Z", "type": "commit"}, {"oid": "e69d37349fdf9fbbeb9ae37d6c1c0c690f5291fc", "url": "https://github.com/elastic/elasticsearch/commit/e69d37349fdf9fbbeb9ae37d6c1c0c690f5291fc", "message": "Add tests for wildcard agg support", "committedDate": "2020-06-23T14:07:50Z", "type": "commit"}, {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009", "url": "https://github.com/elastic/elasticsearch/commit/3223032d5192f0702f41a52ea8e8ab18eaaa4009", "message": "words", "committedDate": "2020-06-23T14:50:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4Njk2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445786961", "bodyText": "I think Optional prefers things to look like:\nRandomIndexWriter indexWriter = indexWriterConfg.map(c -> new RandomIndexWriter(random(), directory, c).orElseGet(() -> new RandomIndexWriter(random(), directory);", "author": "nik9000", "createdAt": "2020-06-25T19:23:22Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -535,13 +537,27 @@ protected void doAssertReducedMultiBucketConsumer(Aggregation agg, MultiBucketCo\n     }\n \n     protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n-            T aggregationBuilder,\n-            Query query,\n-            CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n-            Consumer<V> verify,\n-            MappedFieldType... fieldTypes) throws IOException {\n+        T aggregationBuilder,\n+        Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n+        testCase(aggregationBuilder, Optional.empty(), query, buildIndex, verify, fieldTypes);\n+    }\n+\n+    protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n+        T aggregationBuilder,\n+        Optional<IndexWriterConfig> indexWriterConfig, Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n         try (Directory directory = newDirectory()) {\n-            RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+            RandomIndexWriter indexWriter;", "originalCommit": "3223032d5192f0702f41a52ea8e8ab18eaaa4009", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0OTg2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r449149869", "bodyText": "Yeah, I agree that's what Optional would like this to look like.  Unfortunately, new RandomIndexWriter can throw an IOException, and the lambda Optional#map and friends expect is declared to not throw.  I could do something to wrap and throw an unchecked exception, but I think it'd be less clear than just using the if/else block.  Open to suggestions if you know a way to do this that isn't terrible.", "author": "not-napoleon", "createdAt": "2020-07-02T16:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4Njk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4ODAzNg==", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445788036", "bodyText": "This says \"when I don't tell you what analyzer to use then use the wildcard analyzer\". I believe Elasticsearch always sets the analyzer. The wildcard field mapper looks like it does. I don't think either test needs this.", "author": "nik9000", "createdAt": "2020-06-25T19:25:34Z", "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);", "originalCommit": "3223032d5192f0702f41a52ea8e8ab18eaaa4009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MzA4MA==", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445793080", "bodyText": "(StringTerms results) -> should do the same thing with a little less ceremony.", "author": "nik9000", "createdAt": "2020-06-25T19:36:09Z", "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);\n+\n+        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME);\n+        builder.ignoreAbove(MAX_FIELD_LENGTH);\n+        wildcardFieldMapper = builder.build(new Mapper.BuilderContext(createIndexSettings().getSettings(), new ContentPath(0)));\n+\n+        wildcardFieldType = wildcardFieldMapper.fieldType();\n+    }\n+\n+    private void addFields(ParseContext.Document parseDoc, Document doc, String docContent) throws IOException {\n+        ArrayList<IndexableField> fields = new ArrayList<>();\n+        wildcardFieldMapper.createFields(docContent, parseDoc, fields);\n+\n+        for (IndexableField indexableField : fields) {\n+            doc.add(indexableField);\n+        }\n+    }\n+\n+    private void indexDoc(ParseContext.Document parseDoc, Document doc, RandomIndexWriter iw) throws IOException {\n+        IndexableField field = parseDoc.getByKey(wildcardFieldMapper.name());\n+        if (field != null) {\n+            doc.add(field);\n+        }\n+        iw.addDocument(doc);\n+    }\n+\n+    private void indexStrings(RandomIndexWriter iw, String... values) throws IOException {\n+        Document doc = new Document();\n+        ParseContext.Document parseDoc = new ParseContext.Document();\n+        for (String value : values) {\n+            addFields(parseDoc, doc, value);\n+        }\n+        indexDoc(parseDoc, doc, iw);\n+    }\n+\n+    public void testTermsAggregation() throws IOException {\n+        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n+            .field(WILDCARD_FIELD_NAME)\n+            .order(BucketOrder.key(true));\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"c\");\n+            },\n+            (Consumer<StringTerms>) result -> {", "originalCommit": "3223032d5192f0702f41a52ea8e8ab18eaaa4009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MzY1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445793652", "bodyText": "Could you try running with aggregateAfter set? I think that'd be useful to make sure works as well.", "author": "nik9000", "createdAt": "2020-06-25T19:37:18Z", "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);\n+\n+        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME);\n+        builder.ignoreAbove(MAX_FIELD_LENGTH);\n+        wildcardFieldMapper = builder.build(new Mapper.BuilderContext(createIndexSettings().getSettings(), new ContentPath(0)));\n+\n+        wildcardFieldType = wildcardFieldMapper.fieldType();\n+    }\n+\n+    private void addFields(ParseContext.Document parseDoc, Document doc, String docContent) throws IOException {\n+        ArrayList<IndexableField> fields = new ArrayList<>();\n+        wildcardFieldMapper.createFields(docContent, parseDoc, fields);\n+\n+        for (IndexableField indexableField : fields) {\n+            doc.add(indexableField);\n+        }\n+    }\n+\n+    private void indexDoc(ParseContext.Document parseDoc, Document doc, RandomIndexWriter iw) throws IOException {\n+        IndexableField field = parseDoc.getByKey(wildcardFieldMapper.name());\n+        if (field != null) {\n+            doc.add(field);\n+        }\n+        iw.addDocument(doc);\n+    }\n+\n+    private void indexStrings(RandomIndexWriter iw, String... values) throws IOException {\n+        Document doc = new Document();\n+        ParseContext.Document parseDoc = new ParseContext.Document();\n+        for (String value : values) {\n+            addFields(parseDoc, doc, value);\n+        }\n+        indexDoc(parseDoc, doc, iw);\n+    }\n+\n+    public void testTermsAggregation() throws IOException {\n+        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n+            .field(WILDCARD_FIELD_NAME)\n+            .order(BucketOrder.key(true));\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"c\");\n+            },\n+            (Consumer<StringTerms>) result -> {\n+                assertTrue(AggregationInspectionHelper.hasValue(result));\n+\n+                assertEquals(3, result.getBuckets().size());\n+                assertEquals(\"a\", result.getBuckets().get(0).getKeyAsString());\n+                assertEquals(2L, result.getBuckets().get(0).getDocCount());\n+                assertEquals(\"b\", result.getBuckets().get(1).getKeyAsString());\n+                assertEquals(3L, result.getBuckets().get(1).getDocCount());\n+                assertEquals(\"c\", result.getBuckets().get(2).getKeyAsString());\n+                assertEquals(1L, result.getBuckets().get(2).getDocCount());\n+            },\n+            wildcardFieldType);\n+    }\n+\n+    public void testCompositeTermsAggregation() throws IOException {\n+        CompositeAggregationBuilder aggregationBuilder = new CompositeAggregationBuilder(\n+            \"name\",\n+            List.of(\n+                new TermsValuesSourceBuilder(\"terms_key\").field(WILDCARD_FIELD_NAME)\n+            )\n+        );\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"c\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"d\");\n+                indexStrings(iw, \"c\");", "originalCommit": "3223032d5192f0702f41a52ea8e8ab18eaaa4009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1cef1c9a60bcb5a11212691d5b70da9071806324", "url": "https://github.com/elastic/elasticsearch/commit/1cef1c9a60bcb5a11212691d5b70da9071806324", "message": "Merge branch 'master' into extend-composite-over-wildcard", "committedDate": "2020-07-02T16:37:37Z", "type": "commit"}, {"oid": "11e171fc5c4bfc8e2a9bcac5429ba0eaaf70b4de", "url": "https://github.com/elastic/elasticsearch/commit/11e171fc5c4bfc8e2a9bcac5429ba0eaaf70b4de", "message": "add search after test", "committedDate": "2020-07-06T17:37:07Z", "type": "commit"}, {"oid": "6d67fd8c271f4feb80578885052b3cf889b72115", "url": "https://github.com/elastic/elasticsearch/commit/6d67fd8c271f4feb80578885052b3cf889b72115", "message": "remove unneeded IndexWriterConfig", "committedDate": "2020-07-09T19:08:08Z", "type": "commit"}, {"oid": "4f6640aa143b93ba13f98e7fa702c42f22e9a6ef", "url": "https://github.com/elastic/elasticsearch/commit/4f6640aa143b93ba13f98e7fa702c42f22e9a6ef", "message": "Merge branch 'master' into extend-composite-over-wildcard", "committedDate": "2020-07-23T14:54:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNDk5OA==", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r459604998", "bodyText": "Maybe revert this bit too?", "author": "nik9000", "createdAt": "2020-07-23T17:16:37Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -547,13 +547,14 @@ protected void doAssertReducedMultiBucketConsumer(Aggregation agg, MultiBucketCo\n     }\n \n     protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n-            T aggregationBuilder,\n-            Query query,\n-            CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n-            Consumer<V> verify,\n-            MappedFieldType... fieldTypes) throws IOException {\n+        T aggregationBuilder,\n+        Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n         try (Directory directory = newDirectory()) {\n-            RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+            RandomIndexWriter indexWriter;\n+            indexWriter = new RandomIndexWriter(random(), directory);", "originalCommit": "4f6640aa143b93ba13f98e7fa702c42f22e9a6ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff670b6cc7925d2bf07214a735ff0efbb34abb9e", "url": "https://github.com/elastic/elasticsearch/commit/ff670b6cc7925d2bf07214a735ff0efbb34abb9e", "message": "response to PR feedback", "committedDate": "2020-07-28T13:52:32Z", "type": "commit"}, {"oid": "9ff11b501c917ac2d86da02001620ddb8802d657", "url": "https://github.com/elastic/elasticsearch/commit/9ff11b501c917ac2d86da02001620ddb8802d657", "message": "Merge branch 'master' into extend-composite-over-wildcard", "committedDate": "2020-07-29T14:01:34Z", "type": "commit"}]}