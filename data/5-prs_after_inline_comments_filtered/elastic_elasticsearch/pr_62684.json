{"pr_number": 62684, "pr_title": "Speed up RepositoryData Serialization", "pr_createdAt": "2020-09-21T08:00:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62684", "timeline": [{"oid": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "url": "https://github.com/elastic/elasticsearch/commit/98965d2b970d1832c9be9c924b4a7c5407e8a755", "message": "Speed up RepositoryData Serialization\n\nMake serializing `RepositoryData` a little faster and split up/document the code for it a little\nas well given how massive this method has gotten at this point.", "committedDate": "2020-09-21T07:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1NTE0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491855144", "bodyText": "No need for methods that mostly parse the same string here (like parsing the snapshot list in repository data) to over and over do the same regex magic in most cases.", "author": "original-brownbear", "createdAt": "2020-09-21T08:01:45Z", "path": "server/src/main/java/org/elasticsearch/Version.java", "diffHunk": "@@ -204,6 +210,14 @@ public static Version fromString(String version) {\n         if (!Strings.hasLength(version)) {\n             return Version.CURRENT;\n         }\n+        final Version cached = stringToVersion.get(version);\n+        if (cached != null) {\n+            return cached;\n+        }\n+        return fromStringSlow(version);", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1NTg4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491855883", "bodyText": "No need to re-create the same string over and over for the same version constants (obviously in some cases this is wasted memory when we work with version constants that aren't cached but that's rare and the overhead is trivial anyway).", "author": "original-brownbear", "createdAt": "2020-09-21T08:03:25Z", "path": "server/src/main/java/org/elasticsearch/Version.java", "diffHunk": "@@ -249,6 +264,7 @@ public static Version fromString(String version) {\n         this.revision = (byte) ((id / 100) % 100);\n         this.build = (byte) (id % 100);\n         this.luceneVersion = Objects.requireNonNull(luceneVersion);\n+        this.toString = major + \".\" + minor + \".\" + revision;", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1NjMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491856302", "bodyText": "No need to instantiate a whole new map here in a loop for each snapshot when we can just extract the index id in a loop as we go.", "author": "original-brownbear", "createdAt": "2020-09-21T08:04:17Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -463,16 +463,23 @@ public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final\n         for (final SnapshotId snapshot : getSnapshotIds()) {\n             builder.startObject();\n             builder.field(NAME, snapshot.getName());\n-            builder.field(UUID, snapshot.getUUID());\n-            if (snapshotStates.containsKey(snapshot.getUUID())) {\n-                builder.field(STATE, snapshotStates.get(snapshot.getUUID()).value());\n+            final String snapshotUUID = snapshot.getUUID();\n+            builder.field(UUID, snapshotUUID);\n+            final SnapshotState state = snapshotStates.get(snapshotUUID);\n+            if (state != null) {\n+                builder.field(STATE, state.value());\n             }\n             if (shouldWriteIndexGens) {\n-                builder.field(INDEX_METADATA_LOOKUP, indexMetaDataGenerations.lookup.getOrDefault(snapshot, Collections.emptyMap())\n-                    .entrySet().stream().collect(Collectors.toMap(entry -> entry.getKey().getId(), Map.Entry::getValue)));", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1NjY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491856651", "bodyText": "Fill this up during parsing instead of doing another loop at the end of this method over all the indices", "author": "original-brownbear", "createdAt": "2020-09-21T08:05:03Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1NzAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491857018", "bodyText": "We only ever fill indexMetaIdentifiers once so we can just outright use the map from the parser.", "author": "original-brownbear", "createdAt": "2020-09-21T08:05:51Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();\n         final ShardGenerations.Builder shardGenerations = ShardGenerations.builder();\n-        final Map<String, String> indexMetaIdentifiers = new HashMap<>();\n         final Map<SnapshotId, Map<String, String>> indexMetaLookup = new HashMap<>();\n-\n-        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {\n-            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n-                String field = parser.currentName();\n-                if (SNAPSHOTS.equals(field)) {\n-                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {\n-                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                            String name = null;\n-                            String uuid = null;\n-                            SnapshotState state = null;\n-                            Map<String, String> metaGenerations = new HashMap<>();\n-                            Version version = null;\n-                            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                String currentFieldName = parser.currentName();\n-                                parser.nextToken();\n-                                if (NAME.equals(currentFieldName)) {\n-                                    name = parser.text();\n-                                } else if (UUID.equals(currentFieldName)) {\n-                                    uuid = parser.text();\n-                                } else if (STATE.equals(currentFieldName)) {\n-                                    state = SnapshotState.fromValue(parser.numberValue().byteValue());\n-                                } else if (INDEX_METADATA_LOOKUP.equals(currentFieldName)) {\n-                                    metaGenerations.putAll(parser.mapStrings());\n-                                } else if (VERSION.equals(currentFieldName)) {\n-                                    version = Version.fromString(parser.text());\n-                                }\n-                            }\n-                            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n-                            if (state != null) {\n-                                snapshotStates.put(uuid, state);\n-                            }\n-                            if (version != null) {\n-                                snapshotVersions.put(uuid, version);\n-                            }\n-                            snapshots.put(snapshotId.getUUID(), snapshotId);\n-                            if (metaGenerations.isEmpty() == false) {\n-                                indexMetaLookup.put(snapshotId, metaGenerations);\n-                            }\n-                        }\n-                    } else {\n-                        throw new ElasticsearchParseException(\"expected array for [\" + field + \"]\");\n-                    }\n-                } else if (INDICES.equals(field)) {\n-                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                        throw new ElasticsearchParseException(\"start object expected [indices]\");\n-                    }\n-                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                        final String indexName = parser.currentName();\n-                        final List<SnapshotId> snapshotIds = new ArrayList<>();\n-                        final List<String> gens = new ArrayList<>();\n-\n-                        IndexId indexId = null;\n-                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                            throw new ElasticsearchParseException(\"start object expected index[\" + indexName + \"]\");\n-                        }\n-                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                            final String indexMetaFieldName = parser.currentName();\n-                            parser.nextToken();\n-                            if (INDEX_ID.equals(indexMetaFieldName)) {\n-                                indexId = new IndexId(indexName, parser.text());\n-                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {\n-                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {\n-                                    throw new ElasticsearchParseException(\"start array expected [snapshots]\");\n-                                }\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    String uuid = null;\n-                                    // the old format pre 5.4.1 which contains the snapshot name and uuid\n-                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {\n-                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                            String currentFieldName = parser.currentName();\n-                                            parser.nextToken();\n-                                            if (UUID.equals(currentFieldName)) {\n-                                                uuid = parser.text();\n-                                            }\n-                                        }\n-                                    } else {\n-                                        // the new format post 5.4.1 that only contains the snapshot uuid,\n-                                        // since we already have the name/uuid combo in the snapshots array\n-                                        uuid = parser.text();\n-                                    }\n-\n-                                    SnapshotId snapshotId = snapshots.get(uuid);\n-                                    if (snapshotId != null) {\n-                                        snapshotIds.add(snapshotId);\n-                                    } else {\n-                                        // A snapshotted index references a snapshot which does not exist in\n-                                        // the list of snapshots. This can happen when multiple clusters in\n-                                        // different versions create or delete snapshot in the same repository.\n-                                        throw new ElasticsearchParseException(\"Detected a corrupted repository, index \" + indexId\n-                                            + \" references an unknown snapshot uuid [\" + uuid + \"]\");\n-                                    }\n-                                }\n-                            } else if (SHARD_GENERATIONS.equals(indexMetaFieldName)) {\n-                                XContentParserUtils.ensureExpectedToken(\n-                                    XContentParser.Token.START_ARRAY, parser.currentToken(), parser::getTokenLocation);\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    gens.add(parser.textOrNull());\n-                                }\n-\n-                            }\n-                        }\n-                        assert indexId != null;\n-                        indexSnapshots.put(indexId, Collections.unmodifiableList(snapshotIds));\n-                        for (int i = 0; i < gens.size(); i++) {\n-                            String parsedGen = gens.get(i);\n-                            if (fixBrokenShardGens) {\n-                                parsedGen = ShardGenerations.fixShardGeneration(parsedGen);\n-                            }\n-                            if (parsedGen != null) {\n-                                shardGenerations.put(indexId, i, parsedGen);\n-                            }\n-                        }\n-                    }\n-                } else if (INDEX_METADATA_IDENTIFIERS.equals(field)) {\n+        Map<String, String> indexMetaIdentifiers = null;\n+        while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n+            final String field = parser.currentName();\n+            switch (field) {\n+                case SNAPSHOTS:\n+                    parseSnapshots(parser, snapshots, snapshotStates, snapshotVersions, indexMetaLookup);\n+                    break;\n+                case INDICES:\n+                    parseIndices(parser, fixBrokenShardGens, snapshots, indexSnapshots, indexLookup, shardGenerations);\n+                    break;\n+                case INDEX_METADATA_IDENTIFIERS:\n                     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n                         throw new ElasticsearchParseException(\"start object expected [\" + INDEX_METADATA_IDENTIFIERS + \"]\");\n                     }\n-                    indexMetaIdentifiers.putAll(parser.mapStrings());", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1NzU5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491857592", "bodyText": "All logic beyond this point hasn't really changed much except for moving to switch and using separate+ documented methods for parsing the lower levels.", "author": "original-brownbear", "createdAt": "2020-09-21T08:07:00Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();\n         final ShardGenerations.Builder shardGenerations = ShardGenerations.builder();\n-        final Map<String, String> indexMetaIdentifiers = new HashMap<>();\n         final Map<SnapshotId, Map<String, String>> indexMetaLookup = new HashMap<>();\n-\n-        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {\n-            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n-                String field = parser.currentName();\n-                if (SNAPSHOTS.equals(field)) {\n-                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {\n-                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                            String name = null;\n-                            String uuid = null;\n-                            SnapshotState state = null;\n-                            Map<String, String> metaGenerations = new HashMap<>();\n-                            Version version = null;\n-                            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                String currentFieldName = parser.currentName();\n-                                parser.nextToken();\n-                                if (NAME.equals(currentFieldName)) {\n-                                    name = parser.text();\n-                                } else if (UUID.equals(currentFieldName)) {\n-                                    uuid = parser.text();\n-                                } else if (STATE.equals(currentFieldName)) {\n-                                    state = SnapshotState.fromValue(parser.numberValue().byteValue());\n-                                } else if (INDEX_METADATA_LOOKUP.equals(currentFieldName)) {\n-                                    metaGenerations.putAll(parser.mapStrings());\n-                                } else if (VERSION.equals(currentFieldName)) {\n-                                    version = Version.fromString(parser.text());\n-                                }\n-                            }\n-                            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n-                            if (state != null) {\n-                                snapshotStates.put(uuid, state);\n-                            }\n-                            if (version != null) {\n-                                snapshotVersions.put(uuid, version);\n-                            }\n-                            snapshots.put(snapshotId.getUUID(), snapshotId);\n-                            if (metaGenerations.isEmpty() == false) {\n-                                indexMetaLookup.put(snapshotId, metaGenerations);\n-                            }\n-                        }\n-                    } else {\n-                        throw new ElasticsearchParseException(\"expected array for [\" + field + \"]\");\n-                    }\n-                } else if (INDICES.equals(field)) {\n-                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                        throw new ElasticsearchParseException(\"start object expected [indices]\");\n-                    }\n-                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                        final String indexName = parser.currentName();\n-                        final List<SnapshotId> snapshotIds = new ArrayList<>();\n-                        final List<String> gens = new ArrayList<>();\n-\n-                        IndexId indexId = null;\n-                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                            throw new ElasticsearchParseException(\"start object expected index[\" + indexName + \"]\");\n-                        }\n-                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                            final String indexMetaFieldName = parser.currentName();\n-                            parser.nextToken();\n-                            if (INDEX_ID.equals(indexMetaFieldName)) {\n-                                indexId = new IndexId(indexName, parser.text());\n-                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {\n-                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {\n-                                    throw new ElasticsearchParseException(\"start array expected [snapshots]\");\n-                                }\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    String uuid = null;\n-                                    // the old format pre 5.4.1 which contains the snapshot name and uuid\n-                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {\n-                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                            String currentFieldName = parser.currentName();\n-                                            parser.nextToken();\n-                                            if (UUID.equals(currentFieldName)) {\n-                                                uuid = parser.text();\n-                                            }\n-                                        }\n-                                    } else {\n-                                        // the new format post 5.4.1 that only contains the snapshot uuid,\n-                                        // since we already have the name/uuid combo in the snapshots array\n-                                        uuid = parser.text();\n-                                    }\n-\n-                                    SnapshotId snapshotId = snapshots.get(uuid);\n-                                    if (snapshotId != null) {\n-                                        snapshotIds.add(snapshotId);\n-                                    } else {\n-                                        // A snapshotted index references a snapshot which does not exist in\n-                                        // the list of snapshots. This can happen when multiple clusters in\n-                                        // different versions create or delete snapshot in the same repository.\n-                                        throw new ElasticsearchParseException(\"Detected a corrupted repository, index \" + indexId\n-                                            + \" references an unknown snapshot uuid [\" + uuid + \"]\");\n-                                    }\n-                                }\n-                            } else if (SHARD_GENERATIONS.equals(indexMetaFieldName)) {\n-                                XContentParserUtils.ensureExpectedToken(\n-                                    XContentParser.Token.START_ARRAY, parser.currentToken(), parser::getTokenLocation);\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    gens.add(parser.textOrNull());\n-                                }\n-\n-                            }\n-                        }\n-                        assert indexId != null;\n-                        indexSnapshots.put(indexId, Collections.unmodifiableList(snapshotIds));\n-                        for (int i = 0; i < gens.size(); i++) {\n-                            String parsedGen = gens.get(i);\n-                            if (fixBrokenShardGens) {\n-                                parsedGen = ShardGenerations.fixShardGeneration(parsedGen);\n-                            }\n-                            if (parsedGen != null) {\n-                                shardGenerations.put(indexId, i, parsedGen);\n-                            }\n-                        }\n-                    }\n-                } else if (INDEX_METADATA_IDENTIFIERS.equals(field)) {\n+        Map<String, String> indexMetaIdentifiers = null;\n+        while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n+            final String field = parser.currentName();\n+            switch (field) {", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1ODAxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491858011", "bodyText": "Again saving a map relative to the old implementation by not using putAll once on a single map and instead just using the map from the parser", "author": "original-brownbear", "createdAt": "2020-09-21T08:07:51Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();\n         final ShardGenerations.Builder shardGenerations = ShardGenerations.builder();\n-        final Map<String, String> indexMetaIdentifiers = new HashMap<>();\n         final Map<SnapshotId, Map<String, String>> indexMetaLookup = new HashMap<>();\n-\n-        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {\n-            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n-                String field = parser.currentName();\n-                if (SNAPSHOTS.equals(field)) {\n-                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {\n-                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                            String name = null;\n-                            String uuid = null;\n-                            SnapshotState state = null;\n-                            Map<String, String> metaGenerations = new HashMap<>();\n-                            Version version = null;\n-                            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                String currentFieldName = parser.currentName();\n-                                parser.nextToken();\n-                                if (NAME.equals(currentFieldName)) {\n-                                    name = parser.text();\n-                                } else if (UUID.equals(currentFieldName)) {\n-                                    uuid = parser.text();\n-                                } else if (STATE.equals(currentFieldName)) {\n-                                    state = SnapshotState.fromValue(parser.numberValue().byteValue());\n-                                } else if (INDEX_METADATA_LOOKUP.equals(currentFieldName)) {\n-                                    metaGenerations.putAll(parser.mapStrings());\n-                                } else if (VERSION.equals(currentFieldName)) {\n-                                    version = Version.fromString(parser.text());\n-                                }\n-                            }\n-                            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n-                            if (state != null) {\n-                                snapshotStates.put(uuid, state);\n-                            }\n-                            if (version != null) {\n-                                snapshotVersions.put(uuid, version);\n-                            }\n-                            snapshots.put(snapshotId.getUUID(), snapshotId);\n-                            if (metaGenerations.isEmpty() == false) {\n-                                indexMetaLookup.put(snapshotId, metaGenerations);\n-                            }\n-                        }\n-                    } else {\n-                        throw new ElasticsearchParseException(\"expected array for [\" + field + \"]\");\n-                    }\n-                } else if (INDICES.equals(field)) {\n-                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                        throw new ElasticsearchParseException(\"start object expected [indices]\");\n-                    }\n-                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                        final String indexName = parser.currentName();\n-                        final List<SnapshotId> snapshotIds = new ArrayList<>();\n-                        final List<String> gens = new ArrayList<>();\n-\n-                        IndexId indexId = null;\n-                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                            throw new ElasticsearchParseException(\"start object expected index[\" + indexName + \"]\");\n-                        }\n-                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                            final String indexMetaFieldName = parser.currentName();\n-                            parser.nextToken();\n-                            if (INDEX_ID.equals(indexMetaFieldName)) {\n-                                indexId = new IndexId(indexName, parser.text());\n-                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {\n-                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {\n-                                    throw new ElasticsearchParseException(\"start array expected [snapshots]\");\n-                                }\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    String uuid = null;\n-                                    // the old format pre 5.4.1 which contains the snapshot name and uuid\n-                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {\n-                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                            String currentFieldName = parser.currentName();\n-                                            parser.nextToken();\n-                                            if (UUID.equals(currentFieldName)) {\n-                                                uuid = parser.text();\n-                                            }\n-                                        }\n-                                    } else {\n-                                        // the new format post 5.4.1 that only contains the snapshot uuid,\n-                                        // since we already have the name/uuid combo in the snapshots array\n-                                        uuid = parser.text();\n-                                    }\n-\n-                                    SnapshotId snapshotId = snapshots.get(uuid);\n-                                    if (snapshotId != null) {\n-                                        snapshotIds.add(snapshotId);\n-                                    } else {\n-                                        // A snapshotted index references a snapshot which does not exist in\n-                                        // the list of snapshots. This can happen when multiple clusters in\n-                                        // different versions create or delete snapshot in the same repository.\n-                                        throw new ElasticsearchParseException(\"Detected a corrupted repository, index \" + indexId\n-                                            + \" references an unknown snapshot uuid [\" + uuid + \"]\");\n-                                    }\n-                                }\n-                            } else if (SHARD_GENERATIONS.equals(indexMetaFieldName)) {\n-                                XContentParserUtils.ensureExpectedToken(\n-                                    XContentParser.Token.START_ARRAY, parser.currentToken(), parser::getTokenLocation);\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    gens.add(parser.textOrNull());\n-                                }\n-\n-                            }\n-                        }\n-                        assert indexId != null;\n-                        indexSnapshots.put(indexId, Collections.unmodifiableList(snapshotIds));\n-                        for (int i = 0; i < gens.size(); i++) {\n-                            String parsedGen = gens.get(i);\n-                            if (fixBrokenShardGens) {\n-                                parsedGen = ShardGenerations.fixShardGeneration(parsedGen);\n-                            }\n-                            if (parsedGen != null) {\n-                                shardGenerations.put(indexId, i, parsedGen);\n-                            }\n-                        }\n-                    }\n-                } else if (INDEX_METADATA_IDENTIFIERS.equals(field)) {\n+        Map<String, String> indexMetaIdentifiers = null;\n+        while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n+            final String field = parser.currentName();\n+            switch (field) {\n+                case SNAPSHOTS:\n+                    parseSnapshots(parser, snapshots, snapshotStates, snapshotVersions, indexMetaLookup);\n+                    break;\n+                case INDICES:\n+                    parseIndices(parser, fixBrokenShardGens, snapshots, indexSnapshots, indexLookup, shardGenerations);\n+                    break;\n+                case INDEX_METADATA_IDENTIFIERS:\n                     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n                         throw new ElasticsearchParseException(\"start object expected [\" + INDEX_METADATA_IDENTIFIERS + \"]\");\n                     }\n-                    indexMetaIdentifiers.putAll(parser.mapStrings());\n-                } else if (MIN_VERSION.equals(field)) {\n+                    indexMetaIdentifiers = parser.mapStrings();\n+                    break;\n+                case MIN_VERSION:\n                     if (parser.nextToken() != XContentParser.Token.VALUE_STRING) {\n                         throw new ElasticsearchParseException(\"version string expected [min_version]\");\n                     }\n                     final Version version = Version.fromString(parser.text());\n                     assert SnapshotsService.useShardGenerations(version);\n-                } else {\n+                    break;\n+                default:\n                     throw new ElasticsearchParseException(\"unknown field name  [\" + field + \"]\");\n-                }\n             }\n-        } else {\n-            throw new ElasticsearchParseException(\"start object expected\");\n         }\n-        final Map<String, IndexId> indexLookup =\n-            indexSnapshots.keySet().stream().collect(Collectors.toMap(IndexId::getId, Function.identity()));\n+\n         return new RepositoryData(genId, snapshots, snapshotStates, snapshotVersions, indexSnapshots, shardGenerations.build(),\n-            new IndexMetaDataGenerations(indexMetaLookup.entrySet().stream().collect(\n-                Collectors.toMap(Map.Entry::getKey, e -> e.getValue().entrySet().stream()\n-                    .collect(Collectors.toMap(entry -> indexLookup.get(entry.getKey()), Map.Entry::getValue)))), indexMetaIdentifiers));\n+                buildIndexMetaGenerations(indexMetaLookup, indexLookup, indexMetaIdentifiers));\n     }\n \n+    /**\n+     * Builds {@link IndexMetaDataGenerations} instance from the information parsed previously.\n+     *\n+     * @param indexMetaLookup      map of {@link SnapshotId} to map of index id (as returned by {@link IndexId#getId}) that defines the\n+     *                             index metadata generations for the snapshot that was parsed by {@link #parseSnapshots}\n+     * @param indexLookup          map of index uuid (as returned by {@link IndexId#getId}) to {@link IndexId} that was parsed by\n+     *                             {@link #parseIndices}\n+     * @param indexMetaIdentifiers map of index generation to index meta identifiers parsed by {@link #snapshotsFromXContent}\n+     * @return index meta generations instance\n+     */\n+    private static IndexMetaDataGenerations buildIndexMetaGenerations(Map<SnapshotId, Map<String, String>> indexMetaLookup,\n+                                                                      Map<String, IndexId> indexLookup,\n+                                                                      Map<String, String> indexMetaIdentifiers) {\n+        if (indexMetaLookup.isEmpty()) {\n+            return IndexMetaDataGenerations.EMPTY;\n+        }\n+        // Build a new map that instead of indexing the per-snapshot index generations by index id string, is indexed by IndexId\n+        final Map<SnapshotId, Map<IndexId, String>> indexGenerations = new HashMap<>(indexMetaLookup.size());\n+        for (Map.Entry<SnapshotId, Map<String, String>> snapshotIdMapEntry : indexMetaLookup.entrySet()) {\n+            final Map<String, String> val = snapshotIdMapEntry.getValue();\n+            final Map<IndexId, String> forSnapshot = new HashMap<>(val.size());\n+            for (Map.Entry<String, String> generationEntry : val.entrySet()) {\n+                forSnapshot.put(indexLookup.get(generationEntry.getKey()), generationEntry.getValue());\n+            }\n+            indexGenerations.put(snapshotIdMapEntry.getKey(), forSnapshot);\n+        }\n+        return new IndexMetaDataGenerations(indexGenerations, indexMetaIdentifiers);\n+    }\n+\n+    /**\n+     * Parses the \"snapshots\" field and fills maps for the various per snapshot properties. This method must run before\n+     * {@link #parseIndices} which will rely on the maps of snapshot properties to have been populated already.\n+     *\n+     * @param parser           x-content parse\n+     * @param snapshots        map of snapshot uuid to {@link SnapshotId}\n+     * @param snapshotStates   map of snapshot uuid to {@link SnapshotState}\n+     * @param snapshotVersions map of snapshot uuid to {@link Version} that the snapshot was taken in\n+     * @param indexMetaLookup  map of {@link SnapshotId} to map of index id (as returned by {@link IndexId#getId}) that defines the index\n+     *                         metadata generations for the snapshot\n+     */\n+    private static void parseSnapshots(XContentParser parser, Map<String, SnapshotId> snapshots, Map<String, SnapshotState> snapshotStates,\n+                                       Map<String, Version> snapshotVersions,\n+                                       Map<SnapshotId, Map<String, String>> indexMetaLookup) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_ARRAY) {\n+            throw new ElasticsearchParseException(\"expected array for [\" + SNAPSHOTS + \"]\");\n+        }\n+        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n+            String name = null;\n+            String uuid = null;\n+            SnapshotState state = null;\n+            Map<String, String> metaGenerations = null;\n+            Version version = null;\n+            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                String currentFieldName = parser.currentName();\n+                parser.nextToken();\n+                switch (currentFieldName) {\n+                    case NAME:\n+                        name = parser.text();\n+                        break;\n+                    case UUID:\n+                        uuid = parser.text();\n+                        break;\n+                    case STATE:\n+                        state = SnapshotState.fromValue((byte) parser.intValue());\n+                        break;\n+                    case INDEX_METADATA_LOOKUP:\n+                        metaGenerations = parser.mapStrings();", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDU5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491970592", "bodyText": "I'm not sure we can guarantee that the collection returned by this method is truly unmodifiable if we remove this?", "author": "tlrx", "createdAt": "2020-09-21T11:31:53Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -168,7 +168,7 @@ public long getGenId() {\n      * Returns an unmodifiable collection of the snapshot ids.\n      */\n     public Collection<SnapshotId> getSnapshotIds() {\n-        return Collections.unmodifiableCollection(snapshotIds.values());\n+        return snapshotIds.values();", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAwMTkyNA==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r492001924", "bodyText": "I think this is fine because if you look at the constructor of RepositoryData we always make sure that snapshotIds is unmodifiable which entails that it's value collection is as well :)", "author": "original-brownbear", "createdAt": "2020-09-21T12:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAwNTgxOA==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r492005818", "bodyText": "Right - I did not look at all the ctors, thanks", "author": "tlrx", "createdAt": "2020-09-21T12:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NjE4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491976182", "bodyText": "We have utility methods in XContentParserUtils for this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n          \n          \n            \n            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);", "author": "tlrx", "createdAt": "2020-09-21T11:43:57Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAwMzEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r492003126", "bodyText": "I know, I actually wanted to use it here in all these spots but then I realized that it's pretty inefficient in it's current form. I fixed it to behave better in #62691 and would rather wait for that PR to go in before making that change to not make this method even larger (in terms of what it compiles to).", "author": "original-brownbear", "createdAt": "2020-09-21T12:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NjE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NzU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491977596", "bodyText": "Use XContentParserUtils if possible", "author": "tlrx", "createdAt": "2020-09-21T11:46:43Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();\n         final ShardGenerations.Builder shardGenerations = ShardGenerations.builder();\n-        final Map<String, String> indexMetaIdentifiers = new HashMap<>();\n         final Map<SnapshotId, Map<String, String>> indexMetaLookup = new HashMap<>();\n-\n-        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {\n-            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n-                String field = parser.currentName();\n-                if (SNAPSHOTS.equals(field)) {\n-                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {\n-                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                            String name = null;\n-                            String uuid = null;\n-                            SnapshotState state = null;\n-                            Map<String, String> metaGenerations = new HashMap<>();\n-                            Version version = null;\n-                            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                String currentFieldName = parser.currentName();\n-                                parser.nextToken();\n-                                if (NAME.equals(currentFieldName)) {\n-                                    name = parser.text();\n-                                } else if (UUID.equals(currentFieldName)) {\n-                                    uuid = parser.text();\n-                                } else if (STATE.equals(currentFieldName)) {\n-                                    state = SnapshotState.fromValue(parser.numberValue().byteValue());\n-                                } else if (INDEX_METADATA_LOOKUP.equals(currentFieldName)) {\n-                                    metaGenerations.putAll(parser.mapStrings());\n-                                } else if (VERSION.equals(currentFieldName)) {\n-                                    version = Version.fromString(parser.text());\n-                                }\n-                            }\n-                            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n-                            if (state != null) {\n-                                snapshotStates.put(uuid, state);\n-                            }\n-                            if (version != null) {\n-                                snapshotVersions.put(uuid, version);\n-                            }\n-                            snapshots.put(snapshotId.getUUID(), snapshotId);\n-                            if (metaGenerations.isEmpty() == false) {\n-                                indexMetaLookup.put(snapshotId, metaGenerations);\n-                            }\n-                        }\n-                    } else {\n-                        throw new ElasticsearchParseException(\"expected array for [\" + field + \"]\");\n-                    }\n-                } else if (INDICES.equals(field)) {\n-                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                        throw new ElasticsearchParseException(\"start object expected [indices]\");\n-                    }\n-                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                        final String indexName = parser.currentName();\n-                        final List<SnapshotId> snapshotIds = new ArrayList<>();\n-                        final List<String> gens = new ArrayList<>();\n-\n-                        IndexId indexId = null;\n-                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                            throw new ElasticsearchParseException(\"start object expected index[\" + indexName + \"]\");\n-                        }\n-                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                            final String indexMetaFieldName = parser.currentName();\n-                            parser.nextToken();\n-                            if (INDEX_ID.equals(indexMetaFieldName)) {\n-                                indexId = new IndexId(indexName, parser.text());\n-                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {\n-                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {\n-                                    throw new ElasticsearchParseException(\"start array expected [snapshots]\");\n-                                }\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    String uuid = null;\n-                                    // the old format pre 5.4.1 which contains the snapshot name and uuid\n-                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {\n-                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                            String currentFieldName = parser.currentName();\n-                                            parser.nextToken();\n-                                            if (UUID.equals(currentFieldName)) {\n-                                                uuid = parser.text();\n-                                            }\n-                                        }\n-                                    } else {\n-                                        // the new format post 5.4.1 that only contains the snapshot uuid,\n-                                        // since we already have the name/uuid combo in the snapshots array\n-                                        uuid = parser.text();\n-                                    }\n-\n-                                    SnapshotId snapshotId = snapshots.get(uuid);\n-                                    if (snapshotId != null) {\n-                                        snapshotIds.add(snapshotId);\n-                                    } else {\n-                                        // A snapshotted index references a snapshot which does not exist in\n-                                        // the list of snapshots. This can happen when multiple clusters in\n-                                        // different versions create or delete snapshot in the same repository.\n-                                        throw new ElasticsearchParseException(\"Detected a corrupted repository, index \" + indexId\n-                                            + \" references an unknown snapshot uuid [\" + uuid + \"]\");\n-                                    }\n-                                }\n-                            } else if (SHARD_GENERATIONS.equals(indexMetaFieldName)) {\n-                                XContentParserUtils.ensureExpectedToken(\n-                                    XContentParser.Token.START_ARRAY, parser.currentToken(), parser::getTokenLocation);\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    gens.add(parser.textOrNull());\n-                                }\n-\n-                            }\n-                        }\n-                        assert indexId != null;\n-                        indexSnapshots.put(indexId, Collections.unmodifiableList(snapshotIds));\n-                        for (int i = 0; i < gens.size(); i++) {\n-                            String parsedGen = gens.get(i);\n-                            if (fixBrokenShardGens) {\n-                                parsedGen = ShardGenerations.fixShardGeneration(parsedGen);\n-                            }\n-                            if (parsedGen != null) {\n-                                shardGenerations.put(indexId, i, parsedGen);\n-                            }\n-                        }\n-                    }\n-                } else if (INDEX_METADATA_IDENTIFIERS.equals(field)) {\n+        Map<String, String> indexMetaIdentifiers = null;\n+        while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n+            final String field = parser.currentName();\n+            switch (field) {\n+                case SNAPSHOTS:\n+                    parseSnapshots(parser, snapshots, snapshotStates, snapshotVersions, indexMetaLookup);\n+                    break;\n+                case INDICES:\n+                    parseIndices(parser, fixBrokenShardGens, snapshots, indexSnapshots, indexLookup, shardGenerations);\n+                    break;\n+                case INDEX_METADATA_IDENTIFIERS:\n                     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n                         throw new ElasticsearchParseException(\"start object expected [\" + INDEX_METADATA_IDENTIFIERS + \"]\");", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAwMzU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r492003543", "bodyText": "Same comment here as above 100% on board with it, but let's wait for #62691 ?", "author": "original-brownbear", "createdAt": "2020-09-21T12:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3ODQzNA==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491978434", "bodyText": "Use throwUnknownField()", "author": "tlrx", "createdAt": "2020-09-21T11:47:45Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();\n         final ShardGenerations.Builder shardGenerations = ShardGenerations.builder();\n-        final Map<String, String> indexMetaIdentifiers = new HashMap<>();\n         final Map<SnapshotId, Map<String, String>> indexMetaLookup = new HashMap<>();\n-\n-        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {\n-            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n-                String field = parser.currentName();\n-                if (SNAPSHOTS.equals(field)) {\n-                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {\n-                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                            String name = null;\n-                            String uuid = null;\n-                            SnapshotState state = null;\n-                            Map<String, String> metaGenerations = new HashMap<>();\n-                            Version version = null;\n-                            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                String currentFieldName = parser.currentName();\n-                                parser.nextToken();\n-                                if (NAME.equals(currentFieldName)) {\n-                                    name = parser.text();\n-                                } else if (UUID.equals(currentFieldName)) {\n-                                    uuid = parser.text();\n-                                } else if (STATE.equals(currentFieldName)) {\n-                                    state = SnapshotState.fromValue(parser.numberValue().byteValue());\n-                                } else if (INDEX_METADATA_LOOKUP.equals(currentFieldName)) {\n-                                    metaGenerations.putAll(parser.mapStrings());\n-                                } else if (VERSION.equals(currentFieldName)) {\n-                                    version = Version.fromString(parser.text());\n-                                }\n-                            }\n-                            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n-                            if (state != null) {\n-                                snapshotStates.put(uuid, state);\n-                            }\n-                            if (version != null) {\n-                                snapshotVersions.put(uuid, version);\n-                            }\n-                            snapshots.put(snapshotId.getUUID(), snapshotId);\n-                            if (metaGenerations.isEmpty() == false) {\n-                                indexMetaLookup.put(snapshotId, metaGenerations);\n-                            }\n-                        }\n-                    } else {\n-                        throw new ElasticsearchParseException(\"expected array for [\" + field + \"]\");\n-                    }\n-                } else if (INDICES.equals(field)) {\n-                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                        throw new ElasticsearchParseException(\"start object expected [indices]\");\n-                    }\n-                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                        final String indexName = parser.currentName();\n-                        final List<SnapshotId> snapshotIds = new ArrayList<>();\n-                        final List<String> gens = new ArrayList<>();\n-\n-                        IndexId indexId = null;\n-                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                            throw new ElasticsearchParseException(\"start object expected index[\" + indexName + \"]\");\n-                        }\n-                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                            final String indexMetaFieldName = parser.currentName();\n-                            parser.nextToken();\n-                            if (INDEX_ID.equals(indexMetaFieldName)) {\n-                                indexId = new IndexId(indexName, parser.text());\n-                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {\n-                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {\n-                                    throw new ElasticsearchParseException(\"start array expected [snapshots]\");\n-                                }\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    String uuid = null;\n-                                    // the old format pre 5.4.1 which contains the snapshot name and uuid\n-                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {\n-                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                            String currentFieldName = parser.currentName();\n-                                            parser.nextToken();\n-                                            if (UUID.equals(currentFieldName)) {\n-                                                uuid = parser.text();\n-                                            }\n-                                        }\n-                                    } else {\n-                                        // the new format post 5.4.1 that only contains the snapshot uuid,\n-                                        // since we already have the name/uuid combo in the snapshots array\n-                                        uuid = parser.text();\n-                                    }\n-\n-                                    SnapshotId snapshotId = snapshots.get(uuid);\n-                                    if (snapshotId != null) {\n-                                        snapshotIds.add(snapshotId);\n-                                    } else {\n-                                        // A snapshotted index references a snapshot which does not exist in\n-                                        // the list of snapshots. This can happen when multiple clusters in\n-                                        // different versions create or delete snapshot in the same repository.\n-                                        throw new ElasticsearchParseException(\"Detected a corrupted repository, index \" + indexId\n-                                            + \" references an unknown snapshot uuid [\" + uuid + \"]\");\n-                                    }\n-                                }\n-                            } else if (SHARD_GENERATIONS.equals(indexMetaFieldName)) {\n-                                XContentParserUtils.ensureExpectedToken(\n-                                    XContentParser.Token.START_ARRAY, parser.currentToken(), parser::getTokenLocation);\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    gens.add(parser.textOrNull());\n-                                }\n-\n-                            }\n-                        }\n-                        assert indexId != null;\n-                        indexSnapshots.put(indexId, Collections.unmodifiableList(snapshotIds));\n-                        for (int i = 0; i < gens.size(); i++) {\n-                            String parsedGen = gens.get(i);\n-                            if (fixBrokenShardGens) {\n-                                parsedGen = ShardGenerations.fixShardGeneration(parsedGen);\n-                            }\n-                            if (parsedGen != null) {\n-                                shardGenerations.put(indexId, i, parsedGen);\n-                            }\n-                        }\n-                    }\n-                } else if (INDEX_METADATA_IDENTIFIERS.equals(field)) {\n+        Map<String, String> indexMetaIdentifiers = null;\n+        while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n+            final String field = parser.currentName();\n+            switch (field) {\n+                case SNAPSHOTS:\n+                    parseSnapshots(parser, snapshots, snapshotStates, snapshotVersions, indexMetaLookup);\n+                    break;\n+                case INDICES:\n+                    parseIndices(parser, fixBrokenShardGens, snapshots, indexSnapshots, indexLookup, shardGenerations);\n+                    break;\n+                case INDEX_METADATA_IDENTIFIERS:\n                     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n                         throw new ElasticsearchParseException(\"start object expected [\" + INDEX_METADATA_IDENTIFIERS + \"]\");\n                     }\n-                    indexMetaIdentifiers.putAll(parser.mapStrings());\n-                } else if (MIN_VERSION.equals(field)) {\n+                    indexMetaIdentifiers = parser.mapStrings();\n+                    break;\n+                case MIN_VERSION:\n                     if (parser.nextToken() != XContentParser.Token.VALUE_STRING) {\n                         throw new ElasticsearchParseException(\"version string expected [min_version]\");\n                     }\n                     final Version version = Version.fromString(parser.text());\n                     assert SnapshotsService.useShardGenerations(version);\n-                } else {\n+                    break;\n+                default:\n                     throw new ElasticsearchParseException(\"unknown field name  [\" + field + \"]\");", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAwNTA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r492005096", "bodyText": "++ neat didn't about this one :)", "author": "original-brownbear", "createdAt": "2020-09-21T12:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3ODQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MTEyNA==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491981124", "bodyText": "Can we assert the state we are in after calling the parsing methods?", "author": "tlrx", "createdAt": "2020-09-21T11:50:29Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();\n         final ShardGenerations.Builder shardGenerations = ShardGenerations.builder();\n-        final Map<String, String> indexMetaIdentifiers = new HashMap<>();\n         final Map<SnapshotId, Map<String, String>> indexMetaLookup = new HashMap<>();\n-\n-        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {\n-            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n-                String field = parser.currentName();\n-                if (SNAPSHOTS.equals(field)) {\n-                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {\n-                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                            String name = null;\n-                            String uuid = null;\n-                            SnapshotState state = null;\n-                            Map<String, String> metaGenerations = new HashMap<>();\n-                            Version version = null;\n-                            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                String currentFieldName = parser.currentName();\n-                                parser.nextToken();\n-                                if (NAME.equals(currentFieldName)) {\n-                                    name = parser.text();\n-                                } else if (UUID.equals(currentFieldName)) {\n-                                    uuid = parser.text();\n-                                } else if (STATE.equals(currentFieldName)) {\n-                                    state = SnapshotState.fromValue(parser.numberValue().byteValue());\n-                                } else if (INDEX_METADATA_LOOKUP.equals(currentFieldName)) {\n-                                    metaGenerations.putAll(parser.mapStrings());\n-                                } else if (VERSION.equals(currentFieldName)) {\n-                                    version = Version.fromString(parser.text());\n-                                }\n-                            }\n-                            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n-                            if (state != null) {\n-                                snapshotStates.put(uuid, state);\n-                            }\n-                            if (version != null) {\n-                                snapshotVersions.put(uuid, version);\n-                            }\n-                            snapshots.put(snapshotId.getUUID(), snapshotId);\n-                            if (metaGenerations.isEmpty() == false) {\n-                                indexMetaLookup.put(snapshotId, metaGenerations);\n-                            }\n-                        }\n-                    } else {\n-                        throw new ElasticsearchParseException(\"expected array for [\" + field + \"]\");\n-                    }\n-                } else if (INDICES.equals(field)) {\n-                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                        throw new ElasticsearchParseException(\"start object expected [indices]\");\n-                    }\n-                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                        final String indexName = parser.currentName();\n-                        final List<SnapshotId> snapshotIds = new ArrayList<>();\n-                        final List<String> gens = new ArrayList<>();\n-\n-                        IndexId indexId = null;\n-                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                            throw new ElasticsearchParseException(\"start object expected index[\" + indexName + \"]\");\n-                        }\n-                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                            final String indexMetaFieldName = parser.currentName();\n-                            parser.nextToken();\n-                            if (INDEX_ID.equals(indexMetaFieldName)) {\n-                                indexId = new IndexId(indexName, parser.text());\n-                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {\n-                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {\n-                                    throw new ElasticsearchParseException(\"start array expected [snapshots]\");\n-                                }\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    String uuid = null;\n-                                    // the old format pre 5.4.1 which contains the snapshot name and uuid\n-                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {\n-                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                            String currentFieldName = parser.currentName();\n-                                            parser.nextToken();\n-                                            if (UUID.equals(currentFieldName)) {\n-                                                uuid = parser.text();\n-                                            }\n-                                        }\n-                                    } else {\n-                                        // the new format post 5.4.1 that only contains the snapshot uuid,\n-                                        // since we already have the name/uuid combo in the snapshots array\n-                                        uuid = parser.text();\n-                                    }\n-\n-                                    SnapshotId snapshotId = snapshots.get(uuid);\n-                                    if (snapshotId != null) {\n-                                        snapshotIds.add(snapshotId);\n-                                    } else {\n-                                        // A snapshotted index references a snapshot which does not exist in\n-                                        // the list of snapshots. This can happen when multiple clusters in\n-                                        // different versions create or delete snapshot in the same repository.\n-                                        throw new ElasticsearchParseException(\"Detected a corrupted repository, index \" + indexId\n-                                            + \" references an unknown snapshot uuid [\" + uuid + \"]\");\n-                                    }\n-                                }\n-                            } else if (SHARD_GENERATIONS.equals(indexMetaFieldName)) {\n-                                XContentParserUtils.ensureExpectedToken(\n-                                    XContentParser.Token.START_ARRAY, parser.currentToken(), parser::getTokenLocation);\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    gens.add(parser.textOrNull());\n-                                }\n-\n-                            }\n-                        }\n-                        assert indexId != null;\n-                        indexSnapshots.put(indexId, Collections.unmodifiableList(snapshotIds));\n-                        for (int i = 0; i < gens.size(); i++) {\n-                            String parsedGen = gens.get(i);\n-                            if (fixBrokenShardGens) {\n-                                parsedGen = ShardGenerations.fixShardGeneration(parsedGen);\n-                            }\n-                            if (parsedGen != null) {\n-                                shardGenerations.put(indexId, i, parsedGen);\n-                            }\n-                        }\n-                    }\n-                } else if (INDEX_METADATA_IDENTIFIERS.equals(field)) {\n+        Map<String, String> indexMetaIdentifiers = null;\n+        while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n+            final String field = parser.currentName();\n+            switch (field) {\n+                case SNAPSHOTS:\n+                    parseSnapshots(parser, snapshots, snapshotStates, snapshotVersions, indexMetaLookup);\n+                    break;", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAwNzYwMw==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r492007603", "bodyText": "It's tricky IMO. We can't really assert this I think (because corrupted RepositoryData would trip the assertion) so it's not really correct to assert.\nMy thinking was that https://github.com/elastic/elasticsearch/pull/62684/files#diff-98674f75d80495aed41485d9103543e0R712 eventually ensures that the parser parsed the snapshots field first and figured that's enough and we don't need another runtime check for it?", "author": "original-brownbear", "createdAt": "2020-09-21T12:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAxMTY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r492011641", "bodyText": "OK, let's keep it that way then.", "author": "tlrx", "createdAt": "2020-09-21T12:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MTEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MTc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62684#discussion_r491981747", "bodyText": "Use ensureExpectedToken()", "author": "tlrx", "createdAt": "2020-09-21T11:51:08Z", "path": "server/src/main/java/org/elasticsearch/repositories/RepositoryData.java", "diffHunk": "@@ -522,150 +529,229 @@ public IndexMetaDataGenerations indexMetaDataGenerations() {\n      *                           from cached bytes that we trust to not contain broken generations.\n      */\n     public static RepositoryData snapshotsFromXContent(XContentParser parser, long genId, boolean fixBrokenShardGens) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected\");\n+        }\n+\n         final Map<String, SnapshotId> snapshots = new HashMap<>();\n         final Map<String, SnapshotState> snapshotStates = new HashMap<>();\n         final Map<String, Version> snapshotVersions = new HashMap<>();\n         final Map<IndexId, List<SnapshotId>> indexSnapshots = new HashMap<>();\n+        final Map<String, IndexId> indexLookup = new HashMap<>();\n         final ShardGenerations.Builder shardGenerations = ShardGenerations.builder();\n-        final Map<String, String> indexMetaIdentifiers = new HashMap<>();\n         final Map<SnapshotId, Map<String, String>> indexMetaLookup = new HashMap<>();\n-\n-        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {\n-            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n-                String field = parser.currentName();\n-                if (SNAPSHOTS.equals(field)) {\n-                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {\n-                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                            String name = null;\n-                            String uuid = null;\n-                            SnapshotState state = null;\n-                            Map<String, String> metaGenerations = new HashMap<>();\n-                            Version version = null;\n-                            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                String currentFieldName = parser.currentName();\n-                                parser.nextToken();\n-                                if (NAME.equals(currentFieldName)) {\n-                                    name = parser.text();\n-                                } else if (UUID.equals(currentFieldName)) {\n-                                    uuid = parser.text();\n-                                } else if (STATE.equals(currentFieldName)) {\n-                                    state = SnapshotState.fromValue(parser.numberValue().byteValue());\n-                                } else if (INDEX_METADATA_LOOKUP.equals(currentFieldName)) {\n-                                    metaGenerations.putAll(parser.mapStrings());\n-                                } else if (VERSION.equals(currentFieldName)) {\n-                                    version = Version.fromString(parser.text());\n-                                }\n-                            }\n-                            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n-                            if (state != null) {\n-                                snapshotStates.put(uuid, state);\n-                            }\n-                            if (version != null) {\n-                                snapshotVersions.put(uuid, version);\n-                            }\n-                            snapshots.put(snapshotId.getUUID(), snapshotId);\n-                            if (metaGenerations.isEmpty() == false) {\n-                                indexMetaLookup.put(snapshotId, metaGenerations);\n-                            }\n-                        }\n-                    } else {\n-                        throw new ElasticsearchParseException(\"expected array for [\" + field + \"]\");\n-                    }\n-                } else if (INDICES.equals(field)) {\n-                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                        throw new ElasticsearchParseException(\"start object expected [indices]\");\n-                    }\n-                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                        final String indexName = parser.currentName();\n-                        final List<SnapshotId> snapshotIds = new ArrayList<>();\n-                        final List<String> gens = new ArrayList<>();\n-\n-                        IndexId indexId = null;\n-                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n-                            throw new ElasticsearchParseException(\"start object expected index[\" + indexName + \"]\");\n-                        }\n-                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                            final String indexMetaFieldName = parser.currentName();\n-                            parser.nextToken();\n-                            if (INDEX_ID.equals(indexMetaFieldName)) {\n-                                indexId = new IndexId(indexName, parser.text());\n-                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {\n-                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {\n-                                    throw new ElasticsearchParseException(\"start array expected [snapshots]\");\n-                                }\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    String uuid = null;\n-                                    // the old format pre 5.4.1 which contains the snapshot name and uuid\n-                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {\n-                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n-                                            String currentFieldName = parser.currentName();\n-                                            parser.nextToken();\n-                                            if (UUID.equals(currentFieldName)) {\n-                                                uuid = parser.text();\n-                                            }\n-                                        }\n-                                    } else {\n-                                        // the new format post 5.4.1 that only contains the snapshot uuid,\n-                                        // since we already have the name/uuid combo in the snapshots array\n-                                        uuid = parser.text();\n-                                    }\n-\n-                                    SnapshotId snapshotId = snapshots.get(uuid);\n-                                    if (snapshotId != null) {\n-                                        snapshotIds.add(snapshotId);\n-                                    } else {\n-                                        // A snapshotted index references a snapshot which does not exist in\n-                                        // the list of snapshots. This can happen when multiple clusters in\n-                                        // different versions create or delete snapshot in the same repository.\n-                                        throw new ElasticsearchParseException(\"Detected a corrupted repository, index \" + indexId\n-                                            + \" references an unknown snapshot uuid [\" + uuid + \"]\");\n-                                    }\n-                                }\n-                            } else if (SHARD_GENERATIONS.equals(indexMetaFieldName)) {\n-                                XContentParserUtils.ensureExpectedToken(\n-                                    XContentParser.Token.START_ARRAY, parser.currentToken(), parser::getTokenLocation);\n-                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n-                                    gens.add(parser.textOrNull());\n-                                }\n-\n-                            }\n-                        }\n-                        assert indexId != null;\n-                        indexSnapshots.put(indexId, Collections.unmodifiableList(snapshotIds));\n-                        for (int i = 0; i < gens.size(); i++) {\n-                            String parsedGen = gens.get(i);\n-                            if (fixBrokenShardGens) {\n-                                parsedGen = ShardGenerations.fixShardGeneration(parsedGen);\n-                            }\n-                            if (parsedGen != null) {\n-                                shardGenerations.put(indexId, i, parsedGen);\n-                            }\n-                        }\n-                    }\n-                } else if (INDEX_METADATA_IDENTIFIERS.equals(field)) {\n+        Map<String, String> indexMetaIdentifiers = null;\n+        while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {\n+            final String field = parser.currentName();\n+            switch (field) {\n+                case SNAPSHOTS:\n+                    parseSnapshots(parser, snapshots, snapshotStates, snapshotVersions, indexMetaLookup);\n+                    break;\n+                case INDICES:\n+                    parseIndices(parser, fixBrokenShardGens, snapshots, indexSnapshots, indexLookup, shardGenerations);\n+                    break;\n+                case INDEX_METADATA_IDENTIFIERS:\n                     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n                         throw new ElasticsearchParseException(\"start object expected [\" + INDEX_METADATA_IDENTIFIERS + \"]\");\n                     }\n-                    indexMetaIdentifiers.putAll(parser.mapStrings());\n-                } else if (MIN_VERSION.equals(field)) {\n+                    indexMetaIdentifiers = parser.mapStrings();\n+                    break;\n+                case MIN_VERSION:\n                     if (parser.nextToken() != XContentParser.Token.VALUE_STRING) {\n                         throw new ElasticsearchParseException(\"version string expected [min_version]\");\n                     }\n                     final Version version = Version.fromString(parser.text());\n                     assert SnapshotsService.useShardGenerations(version);\n-                } else {\n+                    break;\n+                default:\n                     throw new ElasticsearchParseException(\"unknown field name  [\" + field + \"]\");\n-                }\n             }\n-        } else {\n-            throw new ElasticsearchParseException(\"start object expected\");\n         }\n-        final Map<String, IndexId> indexLookup =\n-            indexSnapshots.keySet().stream().collect(Collectors.toMap(IndexId::getId, Function.identity()));\n+\n         return new RepositoryData(genId, snapshots, snapshotStates, snapshotVersions, indexSnapshots, shardGenerations.build(),\n-            new IndexMetaDataGenerations(indexMetaLookup.entrySet().stream().collect(\n-                Collectors.toMap(Map.Entry::getKey, e -> e.getValue().entrySet().stream()\n-                    .collect(Collectors.toMap(entry -> indexLookup.get(entry.getKey()), Map.Entry::getValue)))), indexMetaIdentifiers));\n+                buildIndexMetaGenerations(indexMetaLookup, indexLookup, indexMetaIdentifiers));\n     }\n \n+    /**\n+     * Builds {@link IndexMetaDataGenerations} instance from the information parsed previously.\n+     *\n+     * @param indexMetaLookup      map of {@link SnapshotId} to map of index id (as returned by {@link IndexId#getId}) that defines the\n+     *                             index metadata generations for the snapshot that was parsed by {@link #parseSnapshots}\n+     * @param indexLookup          map of index uuid (as returned by {@link IndexId#getId}) to {@link IndexId} that was parsed by\n+     *                             {@link #parseIndices}\n+     * @param indexMetaIdentifiers map of index generation to index meta identifiers parsed by {@link #snapshotsFromXContent}\n+     * @return index meta generations instance\n+     */\n+    private static IndexMetaDataGenerations buildIndexMetaGenerations(Map<SnapshotId, Map<String, String>> indexMetaLookup,\n+                                                                      Map<String, IndexId> indexLookup,\n+                                                                      Map<String, String> indexMetaIdentifiers) {\n+        if (indexMetaLookup.isEmpty()) {\n+            return IndexMetaDataGenerations.EMPTY;\n+        }\n+        // Build a new map that instead of indexing the per-snapshot index generations by index id string, is indexed by IndexId\n+        final Map<SnapshotId, Map<IndexId, String>> indexGenerations = new HashMap<>(indexMetaLookup.size());\n+        for (Map.Entry<SnapshotId, Map<String, String>> snapshotIdMapEntry : indexMetaLookup.entrySet()) {\n+            final Map<String, String> val = snapshotIdMapEntry.getValue();\n+            final Map<IndexId, String> forSnapshot = new HashMap<>(val.size());\n+            for (Map.Entry<String, String> generationEntry : val.entrySet()) {\n+                forSnapshot.put(indexLookup.get(generationEntry.getKey()), generationEntry.getValue());\n+            }\n+            indexGenerations.put(snapshotIdMapEntry.getKey(), forSnapshot);\n+        }\n+        return new IndexMetaDataGenerations(indexGenerations, indexMetaIdentifiers);\n+    }\n+\n+    /**\n+     * Parses the \"snapshots\" field and fills maps for the various per snapshot properties. This method must run before\n+     * {@link #parseIndices} which will rely on the maps of snapshot properties to have been populated already.\n+     *\n+     * @param parser           x-content parse\n+     * @param snapshots        map of snapshot uuid to {@link SnapshotId}\n+     * @param snapshotStates   map of snapshot uuid to {@link SnapshotState}\n+     * @param snapshotVersions map of snapshot uuid to {@link Version} that the snapshot was taken in\n+     * @param indexMetaLookup  map of {@link SnapshotId} to map of index id (as returned by {@link IndexId#getId}) that defines the index\n+     *                         metadata generations for the snapshot\n+     */\n+    private static void parseSnapshots(XContentParser parser, Map<String, SnapshotId> snapshots, Map<String, SnapshotState> snapshotStates,\n+                                       Map<String, Version> snapshotVersions,\n+                                       Map<SnapshotId, Map<String, String>> indexMetaLookup) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_ARRAY) {\n+            throw new ElasticsearchParseException(\"expected array for [\" + SNAPSHOTS + \"]\");\n+        }\n+        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n+            String name = null;\n+            String uuid = null;\n+            SnapshotState state = null;\n+            Map<String, String> metaGenerations = null;\n+            Version version = null;\n+            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                String currentFieldName = parser.currentName();\n+                parser.nextToken();\n+                switch (currentFieldName) {\n+                    case NAME:\n+                        name = parser.text();\n+                        break;\n+                    case UUID:\n+                        uuid = parser.text();\n+                        break;\n+                    case STATE:\n+                        state = SnapshotState.fromValue((byte) parser.intValue());\n+                        break;\n+                    case INDEX_METADATA_LOOKUP:\n+                        metaGenerations = parser.mapStrings();\n+                        break;\n+                    case VERSION:\n+                        version = Version.fromString(parser.text());\n+                        break;\n+                }\n+            }\n+            final SnapshotId snapshotId = new SnapshotId(name, uuid);\n+            if (state != null) {\n+                snapshotStates.put(uuid, state);\n+            }\n+            if (version != null) {\n+                snapshotVersions.put(uuid, version);\n+            }\n+            snapshots.put(uuid, snapshotId);\n+            if (metaGenerations != null && metaGenerations.isEmpty() == false) {\n+                indexMetaLookup.put(snapshotId, metaGenerations);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parses information about all indices tracked in the repository and populates {@code indexSnapshots}, {@code indexLookup} and\n+     * {@code shardGenerations}.\n+     *\n+     * @param parser              x-content parser\n+     * @param fixBrokenShardGens  whether or not to fix broken shard generation (see {@link #snapshotsFromXContent} for details)\n+     * @param snapshots           map of snapshot uuid to {@link SnapshotId} that was populated by {@link #parseSnapshots}\n+     * @param indexSnapshots      map of {@link IndexId} to list of {@link SnapshotId} that contain the given index\n+     * @param indexLookup         map of index uuid (as returned by {@link IndexId#getId}) to {@link IndexId}\n+     * @param shardGenerations    shard generations builder that is populated index by this method\n+     */\n+    private static void parseIndices(XContentParser parser, boolean fixBrokenShardGens, Map<String, SnapshotId> snapshots,\n+                                     Map<IndexId, List<SnapshotId>> indexSnapshots, Map<String, IndexId> indexLookup,\n+                                     ShardGenerations.Builder shardGenerations) throws IOException {\n+        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {\n+            throw new ElasticsearchParseException(\"start object expected [indices]\");", "originalCommit": "98965d2b970d1832c9be9c924b4a7c5407e8a755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a1eb724ae751af99b5cd6f268ca696ba322eec2e", "url": "https://github.com/elastic/elasticsearch/commit/a1eb724ae751af99b5cd6f268ca696ba322eec2e", "message": "Merge remote-tracking branch 'elastic/master' into optimize-repo-data-serialization", "committedDate": "2020-09-21T12:28:37Z", "type": "commit"}, {"oid": "0cf07a738f95fb8de15802e2f6dc13249e8916b9", "url": "https://github.com/elastic/elasticsearch/commit/0cf07a738f95fb8de15802e2f6dc13249e8916b9", "message": "nicer exception", "committedDate": "2020-09-21T12:38:45Z", "type": "commit"}]}