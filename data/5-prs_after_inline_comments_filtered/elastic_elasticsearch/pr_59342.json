{"pr_number": 59342, "pr_title": "Add license feature usage api", "pr_createdAt": "2020-07-09T20:55:17Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59342", "timeline": [{"oid": "811286d5a7c5b4e35264133a27e0fbbf8f35b42c", "url": "https://github.com/elastic/elasticsearch/commit/811286d5a7c5b4e35264133a27e0fbbf8f35b42c", "message": "Add license feature usage api\n\nThis commit adds a new api to track when gold+ features are used within\nx-pack. The tracking is done internally whenever a feature is checked\nagainst the current license. The output of the api is a list of each\nused feature, which includes the name, license level, and last time it\nwas used. In addition to a unit test for the tracking, a rest test is\nadded which ensures starting up a default configured node does not\nresult in any features registering as used.\n\nThere are a couple features which currently do not work well with the\ntracking, as they are checked in a manner that makes them look always\nused. Those features will be fixed in followups, and in this PR they are\nomitted from the feature usage output.", "committedDate": "2020-07-09T20:48:22Z", "type": "commit"}, {"oid": "9c389b18ffd06f08e8de300d62ed82ebfad02ceb", "url": "https://github.com/elastic/elasticsearch/commit/9c389b18ffd06f08e8de300d62ed82ebfad02ceb", "message": "checkstyle", "committedDate": "2020-07-09T21:04:01Z", "type": "commit"}, {"oid": "bc144235611493d536ce60db1e130087725b69dd", "url": "https://github.com/elastic/elasticsearch/commit/bc144235611493d536ce60db1e130087725b69dd", "message": "fix compile", "committedDate": "2020-07-09T21:26:04Z", "type": "commit"}, {"oid": "2f36787e78340d49cafc0c0e4cff439b2695044a", "url": "https://github.com/elastic/elasticsearch/commit/2f36787e78340d49cafc0c0e4cff439b2695044a", "message": "fix local state insanity", "committedDate": "2020-07-09T21:55:53Z", "type": "commit"}, {"oid": "d54ff1adc8bd2567ccfc145397fb73ab0f63bf27", "url": "https://github.com/elastic/elasticsearch/commit/d54ff1adc8bd2567ccfc145397fb73ab0f63bf27", "message": "testing conventions...", "committedDate": "2020-07-09T22:40:44Z", "type": "commit"}, {"oid": "057b83b99d8993b7308f5aeed99a594c2a0e3ff4", "url": "https://github.com/elastic/elasticsearch/commit/057b83b99d8993b7308f5aeed99a594c2a0e3ff4", "message": "unit tests", "committedDate": "2020-07-09T23:12:20Z", "type": "commit"}, {"oid": "5bcbfb2fc3f5e52563bccf3865d04b643cf28f7d", "url": "https://github.com/elastic/elasticsearch/commit/5bcbfb2fc3f5e52563bccf3865d04b643cf28f7d", "message": "iter", "committedDate": "2020-07-09T23:31:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyNTk2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r452625961", "bodyText": "The existing expression of licenseState.isSecurityEnabled() && licenseState.checkFeature(Feature.SECURITY_DLS_FLS) has a potential racing issue between the two license checks. I noticed we have been somewhat inconsistent in handling this. In some places, e.g. ResizeRequestInterceptor, we use licenseState.copyCurrentLicenseState() to ensure checks are always done against the same license. In other places including this one, no special handling is done. The new changes also retain this behaviour. My question is: what is our recommend approach for this subtle issue? I am OK with either approach as long as it is consistently applied.\nI am also curious about the benefit of the new MemoizedSupplier. Why do we need to check the license deeper in the loop? Isn't it sufficient and more efficient to check in the outermost if statement?", "author": "ywangd", "createdAt": "2020-07-10T05:14:47Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/interceptor/BulkShardRequestInterceptor.java", "diffHunk": "@@ -41,7 +42,8 @@ public BulkShardRequestInterceptor(ThreadPool threadPool, XPackLicenseState lice\n     @Override\n     public void intercept(RequestInfo requestInfo, AuthorizationEngine authzEngine, AuthorizationInfo authorizationInfo,\n                           ActionListener<Void> listener) {\n-        boolean shouldIntercept = licenseState.isSecurityEnabled() && licenseState.checkFeature(Feature.SECURITY_DLS_FLS);\n+        boolean shouldIntercept = licenseState.isSecurityEnabled();\n+        var licenseChecker = new MemoizedSupplier<>(() -> licenseState.checkFeature(Feature.SECURITY_DLS_FLS));", "originalCommit": "5bcbfb2fc3f5e52563bccf3865d04b643cf28f7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyNzQzNA==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r453027434", "bodyText": "what is our recommend approach for this subtle issue?\n\nIt is true there is a race condition, but in practice I don't think we need to worry about it. This is an extreme edge case, where the license changes mid request. AFAIU, the copy method was added to handle the race condition in tests, not for any problem found by users. That said, the long term solution to this is to change all of our checks to use a stashed copy in the ThreadContext that would be inserted when the request is first received. That idea is described in #53909.\n\nI am also curious about the benefit of the new MemoizedSupplier. Why do we need to check the license deeper in the loop?\n\nWe don't know if DLS/FLS is actually used until we resolve the each indices' access controls inside the loop. Thus we need to check when resolving each index. It is true this is similar to the problem described above, and could be partially solved by copying the license state. However, it also means needlessly updating the last used time in quick succession. I could go either way, but thought reducing those updates was worthwhile given the simpleness of implementing the MemoizedSupplier.", "author": "rjernst", "createdAt": "2020-07-10T19:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyNTk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyNzU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r452627566", "bodyText": "Ah I see, the license checking is moved here because we need to accurately tracking the usage, i.e. only check it when it is absolutely necessary. In this case, I wonder whether we should check it after the instanceof, i.e. bulkItemRequest.request() instanceof UpdateRequest && licenseChecker.get().", "author": "ywangd", "createdAt": "2020-07-10T05:21:21Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/interceptor/BulkShardRequestInterceptor.java", "diffHunk": "@@ -54,7 +56,7 @@ public void intercept(RequestInfo requestInfo, AuthorizationEngine authzEngine,\n                     boolean fls = indexAccessControl.getFieldPermissions().hasFieldLevelSecurity();\n                     boolean dls = indexAccessControl.getDocumentPermissions().hasDocumentLevelPermissions();\n                     if (fls || dls) {\n-                        if (bulkItemRequest.request() instanceof UpdateRequest) {\n+                        if (licenseChecker.get() && bulkItemRequest.request() instanceof UpdateRequest) {", "originalCommit": "5bcbfb2fc3f5e52563bccf3865d04b643cf28f7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyODY0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r452628647", "bodyText": "IIUC, the feature usage is reported for the local node only? So in cloud with coordinating node setup, how can user get the feature usages for nodes other than the coordinating ones?", "author": "ywangd", "createdAt": "2020-07-10T05:25:49Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/license/TransportGetFeatureUsageAction.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.license;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+public class TransportGetFeatureUsageAction extends HandledTransportAction<GetFeatureUsageRequest, GetFeatureUsageResponse> {\n+\n+    public static final ActionType<GetFeatureUsageResponse> TYPE =\n+        new ActionType<>(\"cluster:admin/xpack/license/feature_usage\", GetFeatureUsageResponse::new);\n+\n+    private final XPackLicenseState licenseState;\n+\n+    @Inject\n+    public TransportGetFeatureUsageAction(TransportService transportService, ActionFilters actionFilters,\n+                                          XPackLicenseState licenseState) {\n+        super(TYPE.name(), transportService, actionFilters, GetFeatureUsageRequest::new);\n+        this.licenseState = licenseState;\n+    }\n+\n+\n+    @Override\n+    protected void doExecute(Task task, GetFeatureUsageRequest request, ActionListener<GetFeatureUsageResponse> listener) {\n+        Map<XPackLicenseState.Feature, Long> featureUsage = licenseState.getLastUsed();", "originalCommit": "5bcbfb2fc3f5e52563bccf3865d04b643cf28f7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyODU3MA==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r453028570", "bodyText": "Cloud will need to hit every node in the cluster, not just coordinating nodes. AFAIU they can do this (this would be on their backend infrastructure side, and so would not be going through eg load balancers). It would be similar to eg health checks that hit each node.", "author": "rjernst", "createdAt": "2020-07-10T19:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyODY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0NjE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r454046147", "bodyText": "Ok so this API is more geared towards Cloud internal management instead of end-users. Then it is fine.", "author": "ywangd", "createdAt": "2020-07-14T01:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyODY0Nw=="}], "type": "inlineReview"}, {"oid": "c23c2e78bbdb7c8a74d3f0536cfb2529ebaf0b54", "url": "https://github.com/elastic/elasticsearch/commit/c23c2e78bbdb7c8a74d3f0536cfb2529ebaf0b54", "message": "tests iter", "committedDate": "2020-07-10T19:09:26Z", "type": "commit"}, {"oid": "e2c04bf8012bef1eac4cf97c3a703f527abae2eb", "url": "https://github.com/elastic/elasticsearch/commit/e2c04bf8012bef1eac4cf97c3a703f527abae2eb", "message": "Merge branch 'master' into refactor_license13", "committedDate": "2020-07-13T19:30:45Z", "type": "commit"}, {"oid": "70042a7219d03b3efb76b7a001c20861d5a7e7cf", "url": "https://github.com/elastic/elasticsearch/commit/70042a7219d03b3efb76b7a001c20861d5a7e7cf", "message": "another test", "committedDate": "2020-07-13T20:35:50Z", "type": "commit"}, {"oid": "d95a4ea679c38db714143c23915c95faddc82f30", "url": "https://github.com/elastic/elasticsearch/commit/d95a4ea679c38db714143c23915c95faddc82f30", "message": "fix a bunch of missed checkFeature -> isAllowed for telmetry", "committedDate": "2020-07-13T21:37:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1MjczMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r454052731", "bodyText": "This worries me a bit since a copy can now mutate the original object. It is not an issue for the time being since no such usage exists. But might be a confusing behaviour in future?", "author": "ywangd", "createdAt": "2020-07-14T02:01:05Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java", "diffHunk": "@@ -564,7 +607,7 @@ public static boolean isAllowedByOperationMode(\n      */\n     public XPackLicenseState copyCurrentLicenseState() {\n         return executeAgainstStatus(status ->\n-            new XPackLicenseState(listeners, isSecurityEnabled, isSecurityExplicitlyEnabled, status));\n+            new XPackLicenseState(listeners, isSecurityEnabled, isSecurityExplicitlyEnabled, status, lastUsed, epochMillisProvider));", "originalCommit": "d95a4ea679c38db714143c23915c95faddc82f30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NDgzMg==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r454494832", "bodyText": "That's exactly the intention. The copy is meant for read purposes, but mutation purposes must be unified, otherwise we would would not be able to check what checks have been done across copies.", "author": "rjernst", "createdAt": "2020-07-14T16:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1MjczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1NjA2OA==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r454056068", "bodyText": "We are using both frozenLicenseState here and the original licenseState with MemoizedSupplier below. Given the current change, there is no benefit of having frozenLicenseState anymore. It can probably just be removed.", "author": "ywangd", "createdAt": "2020-07-14T02:13:10Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/interceptor/IndicesAliasesRequestInterceptor.java", "diffHunk": "@@ -52,23 +53,22 @@ public void intercept(RequestInfo requestInfo, AuthorizationEngine authorization\n             final XPackLicenseState frozenLicenseState = licenseState.copyCurrentLicenseState();\n             final AuditTrail auditTrail = auditTrailService.get();\n             if (frozenLicenseState.isSecurityEnabled()) {", "originalCommit": "d95a4ea679c38db714143c23915c95faddc82f30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1NjIwNA==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r454056204", "bodyText": "Same here for using frozenLicenseState and licenseState together.", "author": "ywangd", "createdAt": "2020-07-14T02:13:43Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/interceptor/ResizeRequestInterceptor.java", "diffHunk": "@@ -48,19 +49,18 @@ public void intercept(RequestInfo requestInfo, AuthorizationEngine authorization\n             final XPackLicenseState frozenLicenseState = licenseState.copyCurrentLicenseState();", "originalCommit": "d95a4ea679c38db714143c23915c95faddc82f30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA2MDMwNA==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r454060304", "bodyText": "This method does not seem to be used anywhere? But the inner class VotingOnlyNodeFeatureSet#UsageInfoAction also has a availabe() method which internally uses licenseState.checkFeature. But all other XPackInfoFeatureTransportAction uses licenseState.isAllowed. Is this inconsistency intended?", "author": "ywangd", "createdAt": "2020-07-14T02:27:53Z", "path": "x-pack/plugin/voting-only-node/src/main/java/org/elasticsearch/cluster/coordination/VotingOnlyNodeFeatureSet.java", "diffHunk": "@@ -43,7 +43,7 @@ public String name() {\n \n     @Override\n     public boolean available() {\n-        return licenseState != null && licenseState.isAllowed(Feature.VOTING_ONLY);\n+        return licenseState != null && licenseState.checkFeature(Feature.VOTING_ONLY);", "originalCommit": "d95a4ea679c38db714143c23915c95faddc82f30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUwNzg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/59342#discussion_r454507844", "bodyText": "I've fixed the checkFeature usage, it was incorrect. I'll address the unused class in a followup.", "author": "rjernst", "createdAt": "2020-07-14T17:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA2MDMwNA=="}], "type": "inlineReview"}, {"oid": "228d882756b3234795b651429dd97608433a09cd", "url": "https://github.com/elastic/elasticsearch/commit/228d882756b3234795b651429dd97608433a09cd", "message": "address more feedback", "committedDate": "2020-07-14T17:07:08Z", "type": "commit"}, {"oid": "fb6998d32e1ff6c005036ab4a12e970db2cef8c7", "url": "https://github.com/elastic/elasticsearch/commit/fb6998d32e1ff6c005036ab4a12e970db2cef8c7", "message": "Merge branch 'master' into refactor_license13", "committedDate": "2020-07-14T17:07:38Z", "type": "commit"}]}