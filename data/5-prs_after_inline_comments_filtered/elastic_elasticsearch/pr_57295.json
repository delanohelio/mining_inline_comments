{"pr_number": 57295, "pr_title": "ILM: add support for rolling over data streams ", "pr_createdAt": "2020-05-28T13:58:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57295", "timeline": [{"oid": "a692663899d9010560af1fe827a4e4915cbee072", "url": "https://github.com/elastic/elasticsearch/commit/a692663899d9010560af1fe827a4e4915cbee072", "message": "Lift getIndexSettingsAsMap in EsRestTestCase", "committedDate": "2020-05-28T13:53:44Z", "type": "commit"}, {"oid": "aae8ce35143445a2e767fe978b765ef00147545d", "url": "https://github.com/elastic/elasticsearch/commit/aae8ce35143445a2e767fe978b765ef00147545d", "message": "Extract rest ILM testing utilities in TimeSeriesRestDriver\n\nRelates to #53488", "committedDate": "2020-05-28T13:53:44Z", "type": "commit"}, {"oid": "ec11c9cb89a6c93bd0225d716ddb19a31f2104c1", "url": "https://github.com/elastic/elasticsearch/commit/ec11c9cb89a6c93bd0225d716ddb19a31f2104c1", "message": "ILM: add support for rolling over data streams\n\nAs the datastream information is stored in the `ClusterState.Metadata` we exposed\nthe `Metadata` to the `AsyncWaitStep#evaluateCondition` method in order for\nthe steps to be able to identify when a managed index is part of a DataStream.\n\nIf a managed index is part of a DataStream the rollover target is the DataStream\nname and the highest generation index is the write index (ie. the rolled index).", "committedDate": "2020-05-28T13:53:45Z", "type": "commit"}, {"oid": "b890e043f0f1a28e5cef016cb347330d338397dd", "url": "https://github.com/elastic/elasticsearch/commit/b890e043f0f1a28e5cef016cb347330d338397dd", "message": "Fix tests", "committedDate": "2020-05-28T14:28:58Z", "type": "commit"}, {"oid": "6fc0933b46d9fa67602bc8c5e699baf222dcee5c", "url": "https://github.com/elastic/elasticsearch/commit/6fc0933b46d9fa67602bc8c5e699baf222dcee5c", "message": "Fix line length", "committedDate": "2020-05-28T14:48:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTM0NA==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431935344", "bodyText": "Minor: this correctly identifies the data stream's write index under the current implementation of data streams. The IndexAbstraction::getWriteIndex method will always return the correct write index in the event that we change the logic around backing index names, generations, etc., and would slightly simplify the code above.", "author": "danhermann", "createdAt": "2020-05-28T15:40:57Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -64,43 +65,48 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n             return new Result(true, new Info(message));\n         }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n-                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n-        }\n-\n-        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(rolloverAlias);\n-        assert indexAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n-\n-        IndexMetadata aliasWriteIndex = indexAbstraction.getWriteIndex();\n+        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(index.getName());\n         final String rolledIndexName;\n         final String waitForActiveShardsSettingValue;\n-        if (aliasWriteIndex != null) {\n-            rolledIndexName = aliasWriteIndex.getIndex().getName();\n-            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            DataStream dataStream = indexAbstraction.getParentDataStream().getDataStream();\n+            rolledIndexName = DataStream.getBackingIndexName(dataStream.getName(), dataStream.getGeneration());", "originalCommit": "6fc0933b46d9fa67602bc8c5e699baf222dcee5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NzE0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431957146", "bodyText": "Thanks for the suggestion, Dan. Pushed a fix to change this.", "author": "andreidan", "createdAt": "2020-05-28T16:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTM0NA=="}], "type": "inlineReview"}, {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514", "url": "https://github.com/elastic/elasticsearch/commit/1aeedfd892d18e73b50d92e2ad389561ba501514", "message": "Get rolled index using the DataStream `writeIndex`", "committedDate": "2020-05-28T16:11:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5MDY0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431990647", "bodyText": "It does seem strange to pass both the Metadata and the IndexMetadata, should we instead pass Metadata and Index so it's easy to look up the index metadata?", "author": "dakrone", "createdAt": "2020-05-28T17:05:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncWaitStep.java", "diffHunk": "@@ -29,7 +30,7 @@ protected Client getClient() {\n         return client;\n     }\n \n-    public abstract void evaluateCondition(IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout);\n+    public abstract void evaluateCondition(Metadata metadata, IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout);", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3OTc3MA==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432379770", "bodyText": "Yeah, fair enough, it felt a bit odd to me too (it equally felt wasteful, in terms of CPU cycles, to re-do the lookup every time though, but given ILM is not so much about low latency I agree it makes sense to change it)", "author": "andreidan", "createdAt": "2020-05-29T09:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5MDY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5MTk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431991995", "bodyText": "Super minor, but can you add an\nassert indexAbstraction != null : \"expected the index \" + indexName + \" to exist in the lookup but it didn't\";\nafter this line? I don't think it's going to happen, but we should check it regardless. Optionally, we could make it a real error also (throw an IllegalStateException)", "author": "dakrone", "createdAt": "2020-05-28T17:07:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NDIxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431994211", "bodyText": "Just to be super paranoid, I think we should handle the case where getDataStream() returns null", "author": "dakrone", "createdAt": "2020-05-28T17:11:22Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzMTI5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432031299", "bodyText": "I think that can be changed to:\nrolloverTarget = indexAbstraction.getParentDataStream().getName();\n\nto eliminate the need for another null check.", "author": "danhermann", "createdAt": "2020-05-28T18:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NDIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NTYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431995632", "bodyText": "Should we allow this indexing complete setting regardless of whether the parent data stream exists or not? (in otherwords, moving it before the if (indexAbstraction.getParentDataStream() != null) { check)", "author": "dakrone", "createdAt": "2020-05-28T17:13:55Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();\n+        } else {\n+            boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n+            if (indexingComplete) {\n+                logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n+                listener.onResponse(true);\n+                return;\n+            }", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NzU2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431997569", "bodyText": "I think this is a chance we can improve this error message (if you agree), maybe something like:\nsetting [index.lifecycle.rollover_alias] for index [foo-1] is not defined, it must be set to the name of the alias pointing to the group of indices being rolled over\n\nI'm not stuck on the wording, maybe you have a better idea?", "author": "dakrone", "createdAt": "2020-05-28T17:17:28Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();\n+        } else {\n+            boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n+            if (indexingComplete) {\n+                logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n+                listener.onResponse(true);\n+                return;\n+            }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(indexMetadata.getSettings());\n+            String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(indexMetadata.getSettings());\n \n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,\n-                \"setting [%s] for index [%s] is empty or not defined\", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS,\n-                indexMetadata.getIndex().getName())));\n-            return;\n-        }\n+            if (Strings.isNullOrEmpty(rolloverAlias)) {\n+                listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,\n+                    \"setting [%s] for index [%s] is empty or not defined\", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS,", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5Nzg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432397889", "bodyText": "Great point, I think the wording sounds good", "author": "andreidan", "createdAt": "2020-05-29T10:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NzU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5ODcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431998706", "bodyText": "I think this can be a static method?", "author": "dakrone", "createdAt": "2020-05-28T17:19:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/UpdateRolloverLifecycleDateStep.java", "diffHunk": "@@ -76,6 +72,24 @@ public ClusterState performAction(Index index, ClusterState currentState) {\n             .put(newIndexMetadata)).build();\n     }\n \n+    private String getRolloverTarget(Index index, ClusterState currentState) {", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMDAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432000022", "bodyText": "Same comment here about null check for the getDataStream(), I also wonder if maybe we should make this a nice static helper like IndexAbstraction.streamNameOrNull(indexAbstraction)?", "author": "dakrone", "createdAt": "2020-05-28T17:21:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/UpdateRolloverLifecycleDateStep.java", "diffHunk": "@@ -76,6 +72,24 @@ public ClusterState performAction(Index index, ClusterState currentState) {\n             .put(newIndexMetadata)).build();\n     }\n \n+    private String getRolloverTarget(Index index, ClusterState currentState) {\n+        IndexAbstraction indexAbstraction = currentState.metadata().getIndicesLookup().get(index.getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwNzc2NA==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432407764", "bodyText": "The underlying dataStream is non-nullable though. The getName method that Dan recommended emphasis this so replaced it here as well. Happy to discuss if there are any situations where this could be null though (in which case I believe more null checks are needed in IndexAbstraction.DataStream)", "author": "andreidan", "createdAt": "2020-05-29T10:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMDAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMjU0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432002547", "bodyText": "Super minor, but can we use IndexMetadata.SETTING_WAIT_FOR_ACTIVE_SHARDS instead of hardcoding here?", "author": "dakrone", "createdAt": "2020-05-28T17:25:40Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -64,43 +67,50 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n             return new Result(true, new Info(message));\n         }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n-                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n-        }\n-\n-        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(rolloverAlias);\n-        assert indexAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n-\n-        IndexMetadata aliasWriteIndex = indexAbstraction.getWriteIndex();\n+        IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(index.getName());\n         final String rolledIndexName;\n         final String waitForActiveShardsSettingValue;\n-        if (aliasWriteIndex != null) {\n-            rolledIndexName = aliasWriteIndex.getIndex().getName();\n-            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n-        } else {\n-            List<IndexMetadata> indices = indexAbstraction.getIndices();\n-            int maxIndexCounter = -1;\n-            IndexMetadata rolledIndexMeta = null;\n-            for (IndexMetadata indexMetadata : indices) {\n-                int indexNameCounter = parseIndexNameCounter(indexMetadata.getIndex().getName());\n-                if (maxIndexCounter < indexNameCounter) {\n-                    maxIndexCounter = indexNameCounter;\n-                    rolledIndexMeta = indexMetadata;\n-                }\n-            }\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            DataStream dataStream = indexAbstraction.getParentDataStream().getDataStream();\n+            IndexAbstraction dataStreamAbstraction = metadata.getIndicesLookup().get(dataStream.getName());\n+            assert dataStreamAbstraction != null : dataStream.getName() + \" datastream is not present in the metadata indices lookup\";\n+            IndexMetadata rolledIndexMeta = dataStreamAbstraction.getWriteIndex();\n             if (rolledIndexMeta == null) {\n-                String errorMessage = String.format(Locale.ROOT,\n-                    \"unable to find the index that was rolled over from [%s] as part of lifecycle action [%s]\", index.getName(),\n-                    getKey().getAction());\n-\n-                // Index must have been since deleted\n-                logger.debug(errorMessage);\n-                return new Result(false, new Info(errorMessage));\n+                return getErrorResultOnNullMetadata(index);\n             }\n             rolledIndexName = rolledIndexMeta.getIndex().getName();\n             waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+            if (Strings.isNullOrEmpty(rolloverAlias)) {\n+                throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                    + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+            }\n+\n+            IndexAbstraction aliasAbstraction = metadata.getIndicesLookup().get(rolloverAlias);\n+            assert aliasAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n+\n+            IndexMetadata aliasWriteIndex = aliasAbstraction.getWriteIndex();\n+            if (aliasWriteIndex != null) {\n+                rolledIndexName = aliasWriteIndex.getIndex().getName();\n+                waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMjc1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432002757", "bodyText": "Same here about using IndexMetadata.SETTING_WAIT_FOR_ACTIVE_SHARDS", "author": "dakrone", "createdAt": "2020-05-28T17:26:03Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -64,43 +67,50 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n             return new Result(true, new Info(message));\n         }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n-                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n-        }\n-\n-        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(rolloverAlias);\n-        assert indexAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n-\n-        IndexMetadata aliasWriteIndex = indexAbstraction.getWriteIndex();\n+        IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(index.getName());\n         final String rolledIndexName;\n         final String waitForActiveShardsSettingValue;\n-        if (aliasWriteIndex != null) {\n-            rolledIndexName = aliasWriteIndex.getIndex().getName();\n-            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n-        } else {\n-            List<IndexMetadata> indices = indexAbstraction.getIndices();\n-            int maxIndexCounter = -1;\n-            IndexMetadata rolledIndexMeta = null;\n-            for (IndexMetadata indexMetadata : indices) {\n-                int indexNameCounter = parseIndexNameCounter(indexMetadata.getIndex().getName());\n-                if (maxIndexCounter < indexNameCounter) {\n-                    maxIndexCounter = indexNameCounter;\n-                    rolledIndexMeta = indexMetadata;\n-                }\n-            }\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            DataStream dataStream = indexAbstraction.getParentDataStream().getDataStream();\n+            IndexAbstraction dataStreamAbstraction = metadata.getIndicesLookup().get(dataStream.getName());\n+            assert dataStreamAbstraction != null : dataStream.getName() + \" datastream is not present in the metadata indices lookup\";\n+            IndexMetadata rolledIndexMeta = dataStreamAbstraction.getWriteIndex();\n             if (rolledIndexMeta == null) {\n-                String errorMessage = String.format(Locale.ROOT,\n-                    \"unable to find the index that was rolled over from [%s] as part of lifecycle action [%s]\", index.getName(),\n-                    getKey().getAction());\n-\n-                // Index must have been since deleted\n-                logger.debug(errorMessage);\n-                return new Result(false, new Info(errorMessage));\n+                return getErrorResultOnNullMetadata(index);\n             }\n             rolledIndexName = rolledIndexMeta.getIndex().getName();\n             waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+            if (Strings.isNullOrEmpty(rolloverAlias)) {\n+                throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                    + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+            }\n+\n+            IndexAbstraction aliasAbstraction = metadata.getIndicesLookup().get(rolloverAlias);\n+            assert aliasAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n+\n+            IndexMetadata aliasWriteIndex = aliasAbstraction.getWriteIndex();\n+            if (aliasWriteIndex != null) {\n+                rolledIndexName = aliasWriteIndex.getIndex().getName();\n+                waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+            } else {\n+                List<IndexMetadata> indices = aliasAbstraction.getIndices();\n+                int maxIndexCounter = -1;\n+                IndexMetadata rolledIndexMeta = null;\n+                for (IndexMetadata indexMetadata : indices) {\n+                    int indexNameCounter = parseIndexNameCounter(indexMetadata.getIndex().getName());\n+                    if (maxIndexCounter < indexNameCounter) {\n+                        maxIndexCounter = indexNameCounter;\n+                        rolledIndexMeta = indexMetadata;\n+                    }\n+                }\n+                if (rolledIndexMeta == null) {\n+                    return getErrorResultOnNullMetadata(index);\n+                }\n+                rolledIndexName = rolledIndexMeta.getIndex().getName();\n+                waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMzMwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432003309", "bodyText": "This can be static I think", "author": "dakrone", "createdAt": "2020-05-28T17:26:58Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -114,6 +124,16 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n         return new Result(enoughShardsActive, new ActiveShardsInfo(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n     }\n \n+    private Result getErrorResultOnNullMetadata(Index originalIndex) {", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwNzA5MA==", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432007090", "bodyText": "Same here about null check or a helper for retrieving the name :)", "author": "dakrone", "createdAt": "2020-05-28T17:33:24Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForRolloverReadyStep.java", "diffHunk": "@@ -48,73 +50,82 @@ public boolean isRetryable() {\n     }\n \n     @Override\n-    public void evaluateCondition(IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout) {\n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(indexMetadata.getSettings());\n-\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,\n-                \"setting [%s] for index [%s] is empty or not defined\", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS,\n-                indexMetadata.getIndex().getName())));\n-            return;\n-        }\n+    public void evaluateCondition(Metadata metadata, IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout) {\n+        IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        assert indexAbstraction != null : \"invalid cluster metadata. index [\" + indexMetadata.getIndex().getName() + \"] was not found\";\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();", "originalCommit": "1aeedfd892d18e73b50d92e2ad389561ba501514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2feb94509f14769531b4cde9b27c376de7babb4b", "url": "https://github.com/elastic/elasticsearch/commit/2feb94509f14769531b4cde9b27c376de7babb4b", "message": "Change AsyncWaitStep#evaluateCondition signature", "committedDate": "2020-05-29T10:14:51Z", "type": "commit"}, {"oid": "308d1b657ff5cb8c1215fdec0dba58573710239a", "url": "https://github.com/elastic/elasticsearch/commit/308d1b657ff5cb8c1215fdec0dba58573710239a", "message": "Static methods, drop hardcoded strings, cosmetics", "committedDate": "2020-05-29T10:57:27Z", "type": "commit"}, {"oid": "91a86cde25f38a3b0063c5b140f10c25a54dc815", "url": "https://github.com/elastic/elasticsearch/commit/91a86cde25f38a3b0063c5b140f10c25a54dc815", "message": "Remove unused imports", "committedDate": "2020-05-29T11:07:35Z", "type": "commit"}, {"oid": "9a6240585826cc40532b986ebbbc440f47d7e883", "url": "https://github.com/elastic/elasticsearch/commit/9a6240585826cc40532b986ebbbc440f47d7e883", "message": "Fix test", "committedDate": "2020-05-29T11:35:23Z", "type": "commit"}]}