{"pr_number": 53568, "pr_title": "add tests to SumAggregatorTests", "pr_createdAt": "2020-03-14T04:05:40Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53568", "timeline": [{"oid": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae", "url": "https://github.com/elastic/elasticsearch/commit/431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae", "message": "add tests to SumAggregatorTests\n\nThis adds tests for supported ValuesSourceTypes, unmapped fields,\nscripting, and the missing param. The tests for unmapped fields and\nscripting are migrated from the SumIT integration test", "committedDate": "2020-03-14T03:55:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NDY3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r392554672", "bodyText": "These are because this class still extends AbstractNumericTestCase - the remainder of the tests will migrate in another pr", "author": "andyb-elastic", "createdAt": "2020-03-14T04:07:23Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumIT.java", "diffHunk": "@@ -111,20 +107,9 @@ public void testEmptyAggregation() throws Exception {\n         assertThat(sum.getValue(), equalTo(0.0));\n     }\n \n+    /** This test has been moved to {@link SumAggregatorTests#testUnmapped()} */", "originalCommit": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NTM4NA==", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r392995384", "bodyText": "Personally I don't think this is an improvement.", "author": "nik9000", "createdAt": "2020-03-16T12:43:38Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "diffHunk": "@@ -25,34 +25,62 @@\n import org.apache.lucene.document.StringField;\n import org.apache.lucene.index.DirectoryReader;\n import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.MultiReader;\n import org.apache.lucene.index.RandomIndexWriter;\n import org.apache.lucene.index.Term;\n import org.apache.lucene.search.DocValuesFieldExistsQuery;\n import org.apache.lucene.search.IndexSearcher;\n-import org.apache.lucene.search.MatchAllDocsQuery;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.search.TermQuery;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.util.BytesRef;\n import org.apache.lucene.util.NumericUtils;\n import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.script.MockScriptEngine;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.search.lookup.LeafDocLookup;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n \n+import static java.util.Collections.emptyMap;\n import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static java.util.stream.Collectors.toList;\n+import static org.elasticsearch.common.lucene.search.Queries.newMatchAllQuery;", "originalCommit": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIwNzA0OA==", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r393207048", "bodyText": "Yeah it's probably a net negative on readability", "author": "andyb-elastic", "createdAt": "2020-03-16T17:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5Nzc0MA==", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r392997740", "bodyText": "I don't think this name is right. It looks like it is just a generic \"does random stuff reduce right\" kind of thing.", "author": "nik9000", "createdAt": "2020-03-16T12:46:28Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "diffHunk": "@@ -165,27 +193,193 @@ public void testSummationAccuracy() throws IOException {\n     }\n \n     private void verifySummationOfDoubles(double[] values, double expected, double delta) throws IOException {\n-        testCase(new MatchAllDocsQuery(),\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(FIELD_NAME),\n             iw -> {\n                 for (double value : values) {\n                     iw.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, NumericUtils.doubleToSortableLong(value))));\n                 }\n             },\n             result -> assertEquals(expected, result.getValue(), delta),\n-            NumberFieldMapper.NumberType.DOUBLE\n+            singleton(defaultFieldType(NumberType.DOUBLE))\n+        );\n+    }\n+\n+    public void testUnmapped() throws IOException {\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(\"unknown_field\"),\n+            writer -> {\n+                final int numDocs = randomIntBetween(10, 100);\n+                for (int i = 0; i < numDocs; i++) {\n+                    writer.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, randomLong())));\n+                }\n+            },\n+            internalSum -> {\n+                assertEquals(0d, internalSum.getValue(), 0d);\n+                assertFalse(AggregationInspectionHelper.hasValue(internalSum));\n+            },\n+            singleton(defaultFieldType())\n+        );\n+    }\n+\n+    public void testPartiallyUnmapped() throws IOException {\n+        final MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberType.LONG);\n+        fieldType.setName(FIELD_NAME);\n+        fieldType.setHasDocValues(true);\n+\n+        final SumAggregationBuilder builder = sum(\"_name\")\n+            .field(fieldType.name());\n+\n+        final int numDocs = randomIntBetween(10, 100);\n+        final List<Set<IndexableField>> docs = new ArrayList<>(numDocs);\n+        int sum = 0;\n+        for (int i = 0; i < numDocs; i++) {\n+            final long value = randomLongBetween(0, 1000);\n+            sum += value;\n+            docs.add(singleton(new NumericDocValuesField(fieldType.name(), value)));\n+        }\n+\n+        try (Directory mappedDirectory = newDirectory(); Directory unmappedDirectory = newDirectory()) {\n+            try (RandomIndexWriter mappedWriter = new RandomIndexWriter(random(), mappedDirectory)) {\n+                mappedWriter.addDocuments(docs);\n+            }\n+\n+            new RandomIndexWriter(random(), unmappedDirectory).close();\n+\n+            try (IndexReader mappedReader = DirectoryReader.open(mappedDirectory);\n+                 IndexReader unmappedReader =  DirectoryReader.open(unmappedDirectory);\n+                 MultiReader multiReader = new MultiReader(mappedReader, unmappedReader)) {\n+\n+                final IndexSearcher searcher = newSearcher(multiReader, true, true);\n+\n+                final InternalSum internalSum = search(searcher, newMatchAllQuery(), builder, fieldType);\n+                assertEquals(sum, internalSum.getValue(), 0d);\n+                assertTrue(AggregationInspectionHelper.hasValue(internalSum));\n+            }\n+        }\n+    }\n+\n+    public void testValueScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testValueScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testFieldScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    public void testFieldScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    private void scriptTestCase(int numValuesPerField, SumAggregationBuilder builder) throws IOException {", "originalCommit": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIwNzgyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r393207826", "bodyText": "Had the same thought after writing it - the script specific part is the expectedSum = sum + (numDocs * numValuesPerField); because it expects the script to increment all the fields by 1\nI'll see if I can make it less confusing", "author": "andyb-elastic", "createdAt": "2020-03-16T17:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5Nzc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r393290643", "bodyText": "I made it a little more general and moved some other test cases to it too. Still not thrilled with its readability", "author": "andyb-elastic", "createdAt": "2020-03-16T20:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5Nzc0MA=="}], "type": "inlineReview"}, {"oid": "eda3affbb5c9a592af310ff3e9a8b8ed89ad41d2", "url": "https://github.com/elastic/elasticsearch/commit/eda3affbb5c9a592af310ff3e9a8b8ed89ad41d2", "message": "generalize script test case", "committedDate": "2020-03-16T20:21:42Z", "type": "commit"}, {"oid": "7ceb965957b735980e4beca2b77044c72de3c7a9", "url": "https://github.com/elastic/elasticsearch/commit/7ceb965957b735980e4beca2b77044c72de3c7a9", "message": "use query constructor instead of convenience method", "committedDate": "2020-03-16T20:22:01Z", "type": "commit"}, {"oid": "6df1ad11afb64fac19668e9a0df5555059896883", "url": "https://github.com/elastic/elasticsearch/commit/6df1ad11afb64fac19668e9a0df5555059896883", "message": "Merge branch 'master' into feature-sum-agg-test-coverage", "committedDate": "2020-03-16T20:23:19Z", "type": "commit"}]}