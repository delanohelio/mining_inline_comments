{"pr_number": 52680, "pr_title": "Adds resiliency to read-only filesystems #45286", "pr_createdAt": "2020-02-23T11:45:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52680", "timeline": [{"oid": "569e8ccd0d729f017783b36f55872ecd4361b4fe", "url": "https://github.com/elastic/elasticsearch/commit/569e8ccd0d729f017783b36f55872ecd4361b4fe", "message": "Merge pull request #2 from elastic/master\n\nRebase from fork", "committedDate": "2019-07-04T06:45:38Z", "type": "commit"}, {"oid": "64815f13a38bb47ac0cc5188f15e0b0ba3b27ebd", "url": "https://github.com/elastic/elasticsearch/commit/64815f13a38bb47ac0cc5188f15e0b0ba3b27ebd", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-02-22T18:16:13Z", "type": "commit"}, {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78", "url": "https://github.com/elastic/elasticsearch/commit/b598944ca305f803b27c817e860133ebfd1a7d78", "message": " [Initial DRAFT] Adds a FsHealthService that periodically tries to write to all paths and emits a stats is_writable as a part of node stats API.\n FsReadOnlyMonitor pulls up the stats and tries to remove the node if not all paths are found to be writable.\n Addresses #45286.", "committedDate": "2020-02-23T11:37:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383135577", "bodyText": "This (and the extensions to ClusterInfoService) seem unnecessary. It would be preferable for the FollowersChecker to report a node as unhealthy directly.", "author": "DaveCTurner", "createdAt": "2020-02-24T08:46:40Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.*;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Monitor runs on master and listens for events from #ClusterInfoService on node stats. It checks to see if\n+ * a node has all paths writable if not removes the node from the cluster based on the setting monitor.fs.unhealthy.remove_enabled\n+ */\n+public class FsReadOnlyMonitor {", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA3MDMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411070322", "bodyText": "If I understand correctly we don't want NodeClient pulling up FS stats. Instead the FollowerChecker ping should pull the FS health info too?", "author": "Bukhtawar", "createdAt": "2020-04-20T03:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA3MDY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411070641", "bodyText": "I'll change the current implementation and use the Transport request handler. Let me know if thats what is expected", "author": "Bukhtawar", "createdAt": "2020-04-20T03:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjQxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383136412", "bodyText": "This is too weak a check IMO. It doesn't write any data or fsync anything.", "author": "DaveCTurner", "createdAt": "2020-02-24T08:48:52Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setRefreshInterval(TimeValue refreshInterval) {\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    public void setHealthcheckTimeoutInterval(TimeValue healthcheckTimeoutInterval) {\n+        this.healthcheckTimeoutInterval = healthcheckTimeoutInterval;\n+    }\n+\n+    public Boolean isWritable(Path path){\n+        if (!enabled){\n+            return null;\n+        }\n+        Status status = pathHealthStats.getOrDefault(path, Status.UNKNOWN);\n+        if (status == Status.UNHEALTHY)\n+            return Boolean.FALSE;\n+        else if (lastSuccessfulRunTimeMillis.get() < currentTimeMillisSupplier.getAsLong() - healthcheckTimeoutInterval.getMillis()){\n+            return Boolean.FALSE;\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    private class FsHealthMonitor implements Runnable {\n+\n+        private static final String TEMP_FILE_NAME = \".es_temp_file\";\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth(){\n+\n+            Map<Path, Status> pathHealthStats = new HashMap<>();\n+            try {\n+                for (Path path : nodeEnv.nodeDataPaths()) {\n+                    try {\n+                        if (Files.exists(path)) {\n+                            Path resolve = path.resolve(TEMP_FILE_NAME);\n+                            // delete any lingering file from a previous failure\n+                            Files.deleteIfExists(resolve);\n+                            Files.createFile(resolve);\n+                            Files.delete(resolve);", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2Nzg1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398067852", "bodyText": "Added fsync check", "author": "Bukhtawar", "createdAt": "2020-03-25T18:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjcyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383136724", "bodyText": "I don't understand why we don't count this as UNHEALTHY too. Can you explain?", "author": "DaveCTurner", "createdAt": "2020-02-24T08:49:45Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setRefreshInterval(TimeValue refreshInterval) {\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    public void setHealthcheckTimeoutInterval(TimeValue healthcheckTimeoutInterval) {\n+        this.healthcheckTimeoutInterval = healthcheckTimeoutInterval;\n+    }\n+\n+    public Boolean isWritable(Path path){\n+        if (!enabled){\n+            return null;\n+        }\n+        Status status = pathHealthStats.getOrDefault(path, Status.UNKNOWN);\n+        if (status == Status.UNHEALTHY)\n+            return Boolean.FALSE;\n+        else if (lastSuccessfulRunTimeMillis.get() < currentTimeMillisSupplier.getAsLong() - healthcheckTimeoutInterval.getMillis()){\n+            return Boolean.FALSE;\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    private class FsHealthMonitor implements Runnable {\n+\n+        private static final String TEMP_FILE_NAME = \".es_temp_file\";\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth(){\n+\n+            Map<Path, Status> pathHealthStats = new HashMap<>();\n+            try {\n+                for (Path path : nodeEnv.nodeDataPaths()) {\n+                    try {\n+                        if (Files.exists(path)) {\n+                            Path resolve = path.resolve(TEMP_FILE_NAME);\n+                            // delete any lingering file from a previous failure\n+                            Files.deleteIfExists(resolve);\n+                            Files.createFile(resolve);\n+                            Files.delete(resolve);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                    }catch(IOException ex){\n+                        logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                        pathHealthStats.put(path, Status.UNHEALTHY);\n+                    } catch(Exception ex){", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NzUyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398067524", "bodyText": "Removed. Initial thought was any unanticipated bug causing parent Exception", "author": "Bukhtawar", "createdAt": "2020-03-25T18:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2MTIzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383161239", "bodyText": "5 minutes seems a very long timeout to me. Do we really want to consider a node healthy if it's taking literally minutes to pass this simple check?\nI also think we should be stricter about the UNHEALTHY -> HEALTHY transition to try and avoid flapping. What about keeping the node UNHEALTHY until the check passes very quickly (~1 second?)", "author": "DaveCTurner", "createdAt": "2020-02-24T09:43:52Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NzEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398067101", "bodyText": "Done", "author": "Bukhtawar", "createdAt": "2020-03-25T18:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2MTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2NzA3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383167077", "bodyText": "I think this should not be on the SAME threadpool since it's doing IO that's potentially slow. GENERIC would be ok, but then I think we need protection to make sure there's only one check running at once.", "author": "DaveCTurner", "createdAt": "2020-02-24T09:54:56Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2Njk4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398066981", "bodyText": "Done. Also modified the scheduled checks to be one per data path to honour the 1s HEALTHY SLA", "author": "Bukhtawar", "createdAt": "2020-03-25T18:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2NzA3Nw=="}], "type": "inlineReview"}, {"oid": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "url": "https://github.com/elastic/elasticsearch/commit/d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "message": "Test case addition and PR comments", "committedDate": "2020-03-25T13:35:02Z", "type": "commit"}, {"oid": "38f1a4eabe9952b98d138322c4faa5a88b204a68", "url": "https://github.com/elastic/elasticsearch/commit/38f1a4eabe9952b98d138322c4faa5a88b204a68", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-03-25T13:56:53Z", "type": "commit"}, {"oid": "f3ac906bb0a67da98c5070a80085e3e2ab435b26", "url": "https://github.com/elastic/elasticsearch/commit/f3ac906bb0a67da98c5070a80085e3e2ab435b26", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-03-25T14:03:45Z", "type": "commit"}, {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "url": "https://github.com/elastic/elasticsearch/commit/79948f3fc5938a837696bdfda98b186d1c81d2b5", "message": "Changes for FsHealthService and tests", "committedDate": "2020-03-25T18:08:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3NTcyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398075722", "bodyText": "Accidentally removed the test. I'll add it back", "author": "Bukhtawar", "createdAt": "2020-03-25T18:24:04Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java", "diffHunk": "@@ -165,11 +184,14 @@ public void testStartsElectionIfOtherNodeIsQuorum() {\n         assertTrue(electionOccurred);\n     }\n \n-    public void testDoesNotStartsElectionIfOtherNodeIsQuorumAndDoesNotRespond() {\n+    public void testNonWritableNodeDoesNotOfferPreVote() {", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3Njk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398076966", "bodyText": "I have left out spaces assuming checkStyles would catch. But unfortunate. I'll fix white spacing", "author": "Bukhtawar", "createdAt": "2020-03-25T18:26:08Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java", "diffHunk": "@@ -1173,6 +1179,12 @@ public void run() {\n                             return;\n                         }\n \n+                        if(fsService.stats().getTotal().isWritable() == Boolean.FALSE){", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNTA1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411205051", "bodyText": "These tests are very weak, they simply override the checks that FsHealthService performs which means we're not really checking its behaviour at all.\nI would prefer to see tests that use a custom FileSystemProvider to inject failures that the real FsHealthService can detect. Most should use a DeterministicTaskQueue to verify that the checks keep on being scheduled at the right times, without needing to wait for timeouts to occur. Since we also want to detect things hanging I think we'll also need a genuinely multithreaded test with short timeouts to show that we do indeed detect that IO hangs.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:50:10Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+import static org.mockito.Mockito.mock;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNzMzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411207337", "bodyText": "This doesn't seem necessary, it's enough for followers to reject the today's health checks.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:53:42Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/NodeFsHealthChecker.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.coordination;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsRequest;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.monitor.fs.FsHealthService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.ReceiveTimeoutTransportException;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class NodeFsHealthChecker {", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412435643", "bodyText": "Agree. That simplifies a great deal", "author": "Bukhtawar", "createdAt": "2020-04-21T19:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNzMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411209403", "bodyText": "I don't think we should add this to the stats -- we aim to remove read-only nodes from the cluster, so this will effectively always be true when collecting stats.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:56:46Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsInfo.java", "diffHunk": "@@ -48,16 +48,19 @@\n         long total = -1;\n         long free = -1;\n         long available = -1;\n+        @Nullable\n+        Boolean isWritable;", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NDExMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411854113", "bodyText": "Sure but when we actually have a read-only node removed, it would still stay around unless an operator intervenes by either fixing some of the issues or replacing it. I feel /_nodes/_local/stats might still serve a good purpose and would let the system know it needs an attention.", "author": "Bukhtawar", "createdAt": "2020-04-21T04:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1MDE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411950152", "bodyText": "I think this is already handled by the cluster health API -- the faulty node will report red health when it is removed from the cluster which is a much clearer indication that action is needed, and we can record helpful details in the logs since we always check the logs in this kind of situation.", "author": "DaveCTurner", "createdAt": "2020-04-21T07:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNTQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412425479", "bodyText": "While I understand we don't want to expose the stats, is the interface FsService#stats().getTotal().isWritable()  acceptable at multiple places that I have used to reject requests @ PrevoteCollector/JoinHelper/FollowersChecker or should FsService expose another interface without touching FsInfo at all\nSimply having a RED node from health API may not be able to differentiate a N/W /GC pause/FS issue distinctly and remediations actions might differ. Having a metric may help with some automation which would otherwise need a log dive.\nLet me know your thoughts anyways.", "author": "Bukhtawar", "createdAt": "2020-04-21T19:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3OTcwNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412679704", "bodyText": "I'll change this to FsService.FsHealthService#isWritable() elsewhere I don't think we need to carry any other baggage. Do you think FsHealthService can exist independently outside MonitorService ?", "author": "Bukhtawar", "createdAt": "2020-04-22T05:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc2OTU5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412769597", "bodyText": "Yes, I don't think FsService should be involved here. FsHealthService makes sense on its own.", "author": "DaveCTurner", "createdAt": "2020-04-22T08:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDU3MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411210570", "bodyText": "I think we only need to schedule one task which loops through all paths itself. There's no need to check them in parallel like this.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:58:37Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, TimeStampedStatus> pathHealthStats;\n+    private volatile Set<Scheduler.Cancellable> scheduledFutures;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.scheduledFutures = new HashSet<>();\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        for (Path path : nodeEnv.nodeDataPaths()) {\n+            scheduledFutures.add(threadPool.scheduleWithFixedDelay(new FsPathHealthMonitor(path), refreshInterval,", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411855013", "bodyText": "The idea behind it is there is still a possibility that multiple data paths can  be mounted on separate (network) volumes and can fail independently. Since we were publishing stats per data path, it made sense to individually report the health per data path. Let me know if you think otherwise. If you don't think /_node/_local/stats adds any value we can consider alternatives", "author": "Bukhtawar", "createdAt": "2020-04-21T04:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1MTM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411951378", "bodyText": "It's true that the paths can fail independently but this doesn't matter, we will fail the node if any of the paths are broken. I see that independent checks may be useful for stats but as per my previous comment I don't think we need to expose this in stats.", "author": "DaveCTurner", "createdAt": "2020-04-21T07:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411212995", "bodyText": "This seems unnecessarily detailed. I think we only really need to keep track of the time of the last successful check.", "author": "DaveCTurner", "createdAt": "2020-04-20T09:02:05Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, TimeStampedStatus> pathHealthStats;", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNjA3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412436076", "bodyText": "Sure based on the above discussion I'll simplify further", "author": "Bukhtawar", "createdAt": "2020-04-21T19:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjk5NQ=="}], "type": "inlineReview"}, {"oid": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "url": "https://github.com/elastic/elasticsearch/commit/20d9ba2374db52764f4bff520d375d5a3aa21bec", "message": "Review comments for simplication and better tests", "committedDate": "2020-05-03T10:50:04Z", "type": "commit"}, {"oid": "fa3ed380323c163bf0131cb4193b06b671f775ef", "url": "https://github.com/elastic/elasticsearch/commit/fa3ed380323c163bf0131cb4193b06b671f775ef", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-03T10:53:08Z", "type": "commit"}, {"oid": "1646319e6613f7baef5779c62d451bca9ed0bce0", "url": "https://github.com/elastic/elasticsearch/commit/1646319e6613f7baef5779c62d451bca9ed0bce0", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-05-03T16:03:52Z", "type": "commit"}, {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a", "url": "https://github.com/elastic/elasticsearch/commit/5305ebb1b39a812f7d64dae67889750bb311355a", "message": "Fixing tests and check styles", "committedDate": "2020-05-03T23:22:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MTc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419541788", "bodyText": "Suggest collapsing UNKNOWN with HEALTHY, there's no need to distinguish these cases IMO.", "author": "DaveCTurner", "createdAt": "2020-05-04T15:55:50Z", "path": "server/src/main/java/org/elasticsearch/monitor/NodeHealthService.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor;\n+\n+@FunctionalInterface\n+public interface NodeHealthService {\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MTkzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419641932", "bodyText": "Intent was if the healthcheck hasn't yet started(not sure if thats possible) while the consumers have started to poll for health. Changed for now as suggested", "author": "Bukhtawar", "createdAt": "2020-05-04T18:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NTg1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419545856", "bodyText": "I checked a few example systems in production and it seems like it's not that unusual to see delays of a few 10s of seconds that eventually succeed. This is common enough that I think it would be bad to start failing nodes in those cases by default. I will follow up with some of my systems engineering colleagues to agree on a sensible default here, but 1s is certainly too low.\nAlso a reminder about having a shorter timeout for the UNHEALTHY -> HEALTHY transition vs the HEALTHY -> UNHEALTHY one, mentioned first here: #52680 (comment)", "author": "DaveCTurner", "createdAt": "2020-05-04T16:01:32Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjE4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419546187", "bodyText": "I think Status.HEALTHY is fine here.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:01:59Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MzMxNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419643317", "bodyText": "Changed", "author": "Bukhtawar", "createdAt": "2020-05-04T18:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0ODU3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419548573", "bodyText": "If this individual check saw no exceptions but took longer than the timeout interval then I don't think we should record it as a successful run as is done here, since that will result in a fatally-slow node still occasionally reporting itself as healthy, joining the cluster, and then failing again.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:05:34Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {\n+                logger.warn(\"Skipping Monitor for disk health as a check is already in progress\");\n+                return;\n+            }\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                        Files.delete(tempDataPath);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+                }\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> Math.max(l, currentTimeMillisSupplier.getAsLong()));", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MTkyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419791921", "bodyText": "Good point. My bad I missed this", "author": "Bukhtawar", "createdAt": "2020-05-04T23:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0ODU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419554590", "bodyText": "I would like us to log when we become unhealthy in this service rather than relying on its clients logging warnings/errors, since I am concerned that the clients' messages may be hard to interpret and they vary a lot which will make analysis a good deal harder. That means I think we'll need to schedule a timeout handler for each check. It would be mightily useful if that log message were to include which path(s) were faulty, and how long it took to check each path.\nI'd also like us to log when a check takes longer than some threshold (say, 10s by default) but not long enough to fail the node. This kind of sub-threshold warning can be a useful leading indicator of impending doom. See e.g. cluster.publish.info_timeout vs cluster.publish.timeout.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:14:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4NjAxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419786010", "bodyText": "Should we consider multiple logging levels here like separate thresholds for info/warn levels?", "author": "Bukhtawar", "createdAt": "2020-05-04T23:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA3MzE1MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r420073150", "bodyText": "I don't think we need multiple warnings before hitting the threshold for failure, but I think it's reasonable to log the warning at WARN and then log the actual failure at ERROR.", "author": "DaveCTurner", "createdAt": "2020-05-05T12:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MjcyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419562724", "bodyText": "Also why Math.max? I think that currentTimeMillisSupplier is ThreadPool#relativeTimeInMillis which is monotonic.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:26:10Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {\n+                logger.warn(\"Skipping Monitor for disk health as a check is already in progress\");\n+                return;\n+            }\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                        Files.delete(tempDataPath);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+                }\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> Math.max(l, currentTimeMillisSupplier.getAsLong()));", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419647289", "bodyText": "Ahh.. I started lastRunTimeMillis as Long.MIN_VALUE originally", "author": "Bukhtawar", "createdAt": "2020-05-04T18:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MjcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419564461", "bodyText": "Can that happen? I think threadPool.scheduleWithFixedDelay avoids this?", "author": "DaveCTurner", "createdAt": "2020-05-04T16:28:44Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MTI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419571252", "bodyText": "My bad, I asked for this in #52680 (comment) it seems.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTc2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419645761", "bodyText": ":) I added it just an additional guarantee. I too think its not needed", "author": "Bukhtawar", "createdAt": "2020-05-04T18:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419565234", "bodyText": "Nit: \"health check\" is two words:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class FsHealthcheckFailureException extends ElasticsearchException {\n          \n          \n            \n            public class FsHealthCheckFailureException extends ElasticsearchException {", "author": "DaveCTurner", "createdAt": "2020-05-04T16:29:57Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthcheckFailureException.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.coordination;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This exception is thrown if the File system is reported unhealthy by @{@link org.elasticsearch.monitor.fs.FsHealthService}\n+ * and this nodes needs to be removed from the cluster\n+ */\n+\n+public class FsHealthcheckFailureException extends ElasticsearchException {", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419566188", "bodyText": "nit: two words\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FS_HEALTHCHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthcheckFailureException.class,\n          \n          \n            \n                    FS_HEALTH_CHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthCheckFailureException.class,", "author": "DaveCTurner", "createdAt": "2020-05-04T16:31:25Z", "path": "server/src/main/java/org/elasticsearch/ElasticsearchException.java", "diffHunk": "@@ -1041,7 +1041,9 @@ public String toString() {\n                 org.elasticsearch.ingest.IngestProcessorException.class,\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n-                Version.V_7_5_0);\n+                Version.V_7_5_0),\n+        FS_HEALTHCHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthcheckFailureException.class,", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "url": "https://github.com/elastic/elasticsearch/commit/26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "message": "FsHealthService comments on slow IO", "committedDate": "2020-05-05T14:49:44Z", "type": "commit"}, {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "url": "https://github.com/elastic/elasticsearch/commit/8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "message": "Restricting FS health checks to IOExceptions", "committedDate": "2020-05-11T12:12:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5OTI5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426699290", "bodyText": "Please format this like the other declarations:\n\nmultiple lines\nfully-qualified class names rather than an import\nno trailing comma", "author": "DaveCTurner", "createdAt": "2020-05-18T15:12:11Z", "path": "server/src/main/java/org/elasticsearch/ElasticsearchException.java", "diffHunk": "@@ -1041,7 +1042,9 @@ public String toString() {\n                 org.elasticsearch.ingest.IngestProcessorException.class,\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n-                Version.V_7_5_0);\n+                Version.V_7_5_0),\n+        FS_HEALTH_CHECK_FAILURE_EXCEPTION(FsHealthCheckFailureException.class,", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMDQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426700498", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.warn(\"skip prevoting as local node is not writable: {}\",\n          \n          \n            \n                                        logger.debug(\"skip prevoting as local node is not writable: {}\",\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: local node is not writeable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:13:52Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java", "diffHunk": "@@ -1197,6 +1202,12 @@ public void run() {\n                             return;\n                         }\n \n+                        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+                            logger.warn(\"skip prevoting as local node is not writable: {}\",", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426701042", "bodyText": "An error here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n          \n          \n            \n                        logger.debug(\"Rejecting health check request {} as all data paths are not writable\", request);\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all data paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean. Possibly makes sense to construct the exception within the NodeHealthService.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:14:36Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java", "diffHunk": "@@ -160,8 +162,12 @@ public void updateFastResponseState(final long term, final Mode mode) {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        FastResponseState responder = this.fastResponseState;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3Nzg3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426777872", "bodyText": "Do you think it makes sense to change the interface to below and throwing a checked exception to all the consumers as stated above\npublic interface NodeHealthService {\n   void ensureHealthy() throws HealthCheckFailureException;", "author": "Bukhtawar", "createdAt": "2020-05-18T17:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwMTg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426801857", "bodyText": "HealthCheckFailureException  could either be a generic exception or FsHealthCheckFailureException if needed can sub-class it. Let me know what you think. @DaveCTurner your thoughts on the proposal?", "author": "Bukhtawar", "createdAt": "2020-05-18T17:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMzkzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r427423939", "bodyText": "I think its better to add more info along with status since we are not actually performing health check but returning pre-computed results. I have also changed FsHealthCheckFailureException to HealthCheckFailureException to maintain the generic interface of NodeHealthService\n@FunctionalInterface\npublic interface NodeHealthService {\n\n    StatusInfo getHealth();\n\n    enum Status { HEALTHY, UNHEALTHY }\n\n    class StatusInfo {\n        private Status status;\n        private String info;\n\n        public StatusInfo(Status status, String info) {\n            this.status = status;\n            this.info = info;\n        }\n\n        public String getInfo() {\n            return info;\n        }\n\n        public Status getStatus() {\n            return status;\n        }\n    }\n}", "author": "Bukhtawar", "createdAt": "2020-05-19T16:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMzMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426703303", "bodyText": "Suggest removing this from the message, it's not relevant for the exception.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:17:49Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java", "diffHunk": "@@ -160,8 +162,12 @@ public void updateFastResponseState(final long term, final Mode mode) {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        FastResponseState responder = this.fastResponseState;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n+            throw new FsHealthCheckFailureException(\"rejecting \" + request + \" since not all paths are writable \" + this);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMzY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426703694", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"All paths are not writable. Blocking join request\");\n          \n          \n            \n                        logger.debug(\"All paths are not writable. Blocking join request\");\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:18:27Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java", "diffHunk": "@@ -232,6 +237,10 @@ void logLastFailedJoinAttempt() {\n \n     public void sendJoinRequest(DiscoveryNode destination, long term, Optional<Join> optionalJoin) {\n         assert destination.isMasterNode() : \"trying to join master-ineligible \" + destination;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.warn(\"All paths are not writable. Blocking join request\");", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNzIyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426707227", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Reject offering pre-vote as all paths are not writable\");\n          \n          \n            \n                        logger.debug(\"Reject offering pre-vote as all paths are not writable\");\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all data paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean. Possibly makes sense to construct the exception within the NodeHealthService.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:23:31Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PreVoteCollector.java", "diffHunk": "@@ -105,6 +108,12 @@ private PreVoteResponse handlePreVoteRequest(final PreVoteRequest request) {\n         final DiscoveryNode leader = state.v1();\n         final PreVoteResponse response = state.v2();\n \n+        //TODO verify if the placement makes sense\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.warn(\"Reject offering pre-vote as all paths are not writable\");", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNTgzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426715837", "bodyText": "This spawns (and hopefully cancels) a lot of tasks each iteration. Given that we're not considering timing out here, let's just log at the end of each path's check if it was slow. This has the added advantage that we can report exactly how long it took, not just that it took >5s.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:36:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyOTkwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r427029908", "bodyText": "The reason why I think the timeout handler works better, is if the node is already stuck on IO we won't get to know till it recovers. Let me know what you think", "author": "Bukhtawar", "createdAt": "2020-05-19T04:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNjE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426716141", "bodyText": "Is this used? I think we can drop it.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:36:32Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNjU2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426716563", "bodyText": "This is only called in one place, I think we can inline it.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:37:06Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());\n+        }\n+\n+         private void cancelTimeoutHandler() {\n+             if (slowPathHealthCheckTimeoutHandler != null) {\n+                 slowPathHealthCheckTimeoutHandler.cancel();\n+             }\n+         }\n+\n+         private void logSlowDataPath(Level level, Path path, long executionStartTime) {", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNzgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426717822", "bodyText": "Suggest a message of the form checking writability of [{}] took [{}ms] which is above the warn threshold of [{}] since this is the wording used in other similar messages.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:38:52Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());\n+        }\n+\n+         private void cancelTimeoutHandler() {\n+             if (slowPathHealthCheckTimeoutHandler != null) {\n+                 slowPathHealthCheckTimeoutHandler.cancel();\n+             }\n+         }\n+\n+         private void logSlowDataPath(Level level, Path path, long executionStartTime) {\n+             final TimeValue elapsedTime = TimeValue.timeValueMillis(currentTimeMillisSupplier.getAsLong() - executionStartTime);\n+             logger.log(level, \"Slow IO detected on path [{}], FS health check elapsed time [{}]\", path, elapsedTime);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxOTg2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426719860", "bodyText": "Could we instead dynamically change a node to become unhealthy and verify that it's removed from the cluster?", "author": "DaveCTurner", "createdAt": "2020-05-18T15:41:46Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +161,48 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testNoElectedLeaderForNonWritableNodes() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n+            cluster.runRandomly();\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            final List<ClusterNode> leaders = cluster.getAllLeaders();\n+            assertThat(leaders, empty());\n+        }\n+    }\n+\n+    public void testNonWritableNodeCannotBecomeLeader() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> NodeHealthService.Status.UNHEALTHY);\n+            cluster.clusterNodes.add(nonWritableNode);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMDM5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426720399", "bodyText": "I think we can strengthen cluster.stabilise() to work correctly in the light of unhealthy nodes, so we get the benefits of all the assertions it makes that the cluster has stabilised.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:42:38Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +161,48 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testNoElectedLeaderForNonWritableNodes() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n+            cluster.runRandomly();\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            final List<ClusterNode> leaders = cluster.getAllLeaders();\n+            assertThat(leaders, empty());\n+        }\n+    }\n+\n+    public void testNonWritableNodeCannotBecomeLeader() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> NodeHealthService.Status.UNHEALTHY);\n+            cluster.clusterNodes.add(nonWritableNode);\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMTkyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426721923", "bodyText": "Suspect this comment was removed from master recently.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus); // TODO need tests that check that the max term seen is updated\n          \n          \n            \n                    }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus);", "author": "DaveCTurner", "createdAt": "2020-05-18T15:44:54Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java", "diffHunk": "@@ -112,7 +120,7 @@ public String toString() {\n             assert electionOccurred == false;\n             electionOccurred = true;\n         }, l -> {\n-        }, ElectionStrategy.DEFAULT_INSTANCE);\n+        }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus); // TODO need tests that check that the max term seen is updated", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNTQ1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426725457", "bodyText": "I'd rather not add this to the public interface of DeterministicTaskQueue and instead test the behaviour we want: if we keep on advancing time then we keep on executing this task. See e.g. ClusterFormationFailureHelperTests#testScheduling.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:49:56Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAndSlowPathLoggingPeriodically() throws Exception {\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(Settings.EMPTY, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            //schedules the first health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNjI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426726296", "bodyText": "I'd prefer that we also check the behaviour on writes and syncs, effectively to assert that we do detect failures for both of those activities too.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:51:06Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAndSlowPathLoggingPeriodically() throws Exception {\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(Settings.EMPTY, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            //schedules the first health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),\n+                FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis());\n+            deterministicTaskQueue.advanceTime();\n+            deterministicTaskQueue.runAllRunnableTasks();\n+\n+            //schedules the next health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getNextDeferredExecutionTime(),\n+                (FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis()) * 2);\n+\n+            //We schedule a slow logging timeout handler per path\n+            assertEquals(deterministicTaskQueue.getDeferredTasks().size(), env.nodeDataPaths().length + 1);\n+\n+            //Verify schedules slow path logging at the timeout\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),\n+                (FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis() +\n+                    FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()));\n+\n+            deterministicTaskQueue.advanceTime();\n+            deterministicTaskQueue.runAllRunnableTasks();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            fsHealthService.doStop();\n+            // run deferred tasks\n+            while (deterministicTaskQueue.hasDeferredTasks()) {\n+                deterministicTaskQueue.advanceTime();\n+                deterministicTaskQueue.runAllRunnableTasks();\n+            }\n+            // no tasks post service stop\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem current = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(current);\n+        PathUtilsForTesting.installMock(disruptFileSystemProvider.getFileSystem(null));\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.HEALTHY);\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.UNHEALTHY);\n+        } finally {\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+            disruptFileSystemProvider.injectIOException.set(false);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathIOException() throws IOException {\n+        FileSystem current = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(current);\n+        PathUtilsForTesting.installMock(disruptFileSystemProvider.getFileSystem(null));\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.HEALTHY);\n+\n+            //disrupt file system on single path\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            disruptFileSystemProvider.restrictPathPrefix(randomFrom(paths).toString());\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.UNHEALTHY);\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), 1);\n+\n+        } finally {\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+            disruptFileSystemProvider.injectIOException.set(false);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            if (injectIOException.get()){", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "url": "https://github.com/elastic/elasticsearch/commit/c9dd1a7934c8f88903882a6405196da04be9e9c8", "message": "Addressing comments on logging and tests", "committedDate": "2020-05-20T12:23:29Z", "type": "commit"}, {"oid": "c99a68eef519e60740b594897cebdeba41217624", "url": "https://github.com/elastic/elasticsearch/commit/c99a68eef519e60740b594897cebdeba41217624", "message": "Minor edits", "committedDate": "2020-05-20T14:31:03Z", "type": "commit"}, {"oid": "545eaf5328fedf536c7882cfdc5ff98e4251d5b1", "url": "https://github.com/elastic/elasticsearch/commit/545eaf5328fedf536c7882cfdc5ff98e4251d5b1", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-05-27T05:57:11Z", "type": "commit"}, {"oid": "86fa7c9501e46d814428612975e4627ff827f81c", "url": "https://github.com/elastic/elasticsearch/commit/86fa7c9501e46d814428612975e4627ff827f81c", "message": "Updated the exception id", "committedDate": "2020-05-27T06:01:29Z", "type": "commit"}, {"oid": "8102c819c467bb42ff06752e0a785e58842db0ca", "url": "https://github.com/elastic/elasticsearch/commit/8102c819c467bb42ff06752e0a785e58842db0ca", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-06-04T04:48:26Z", "type": "commit"}, {"oid": "043db9301654ecc42de863c18571dfe9afc72bef", "url": "https://github.com/elastic/elasticsearch/commit/043db9301654ecc42de863c18571dfe9afc72bef", "message": "Fix merge conflict", "committedDate": "2020-06-16T08:14:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440675012", "bodyText": "This needs some synchronisation since it's accessed on multiple threads.\nI suggest making this field volatile, constructing a new local object on each check and then assigning the local object to this field at the end of the check.\nI also suggest a Set<Path> of unhealthy paths rather than tracking them all -- the healthy ones are never used here. We could even mark this as @Nullable and use null instead of an empty set if we wanted to save on long-lived objects.", "author": "DaveCTurner", "createdAt": "2020-06-16T08:25:47Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NjYzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440676631", "bodyText": "I think the default frequency should be a lot more relaxed; an fsync per node per second is going to cause problems on slower disks. Let's align this with the lag detector:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n          \n          \n            \n                    Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(120), TimeValue.timeValueMillis(1),", "author": "DaveCTurner", "createdAt": "2020-06-16T08:28:23Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3OTM0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440679349", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private volatile TimeValue refreshInterval;\n          \n          \n            \n                private final TimeValue refreshInterval;", "author": "DaveCTurner", "createdAt": "2020-06-16T08:32:39Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4MDI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440680278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    static final String TEMP_FILE_NAME = \".es_temp_file\";\n          \n          \n            \n                    private static final String TEMP_FILE_NAME = \".es_temp_file\";", "author": "DaveCTurner", "createdAt": "2020-06-16T08:34:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"FS health checks are disabled\");\n+        }\n+        else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n+            String info = \"Path(s) \" + pathHealthStats.entrySet()\n+                .stream().filter(v -> v.getValue() == UNHEALTHY)\n+                .map(k -> k.getKey().toString())\n+                .collect(Collectors.joining(\",\")) + \" have failed writability checks\";\n+\n+            statusInfo = new StatusInfo(UNHEALTHY, info);\n+        }\n+        else {\n+            statusInfo = new StatusInfo(HEALTHY, \"All paths have passed writabililty checks\");\n+        }\n+        return statusInfo;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjg3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440682875", "bodyText": "Is there a shorter time-bound for stabilisation here?", "author": "DaveCTurner", "createdAt": "2020-06-16T08:38:10Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +162,50 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testUnhealthyNodesGetsRemoved() {\n+        AtomicReference<StatusInfo> healthStatusInfo = new AtomicReference<>(\n+            new StatusInfo(HEALTHY, \"healthy-info\"));\n+        try (Cluster cluster = new Cluster(3)) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            logger.info(\"--> adding two new healthy nodes\");\n+            ClusterNode newNode1 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            ClusterNode newNode2 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            cluster.clusterNodes.add(newNode1);\n+            cluster.clusterNodes.add(newNode2);\n+            cluster.stabilise();\n+\n+            {\n+                assertThat(leader.coordinator.getMode(), is(Mode.LEADER));\n+                final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();\n+                assertThat(lastCommittedConfiguration + \" should be all nodes\", lastCommittedConfiguration.getNodeIds(),\n+                    equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));\n+            }\n+\n+            logger.info(\"setting auto-shrink reconfiguration to true\");\n+            leader.submitSetAutoShrinkVotingConfiguration(true);\n+            cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);\n+            assertTrue(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));\n+\n+            logger.info(\"--> changing health of newly added nodes to unhealthy\");\n+            healthStatusInfo.getAndSet(new StatusInfo(UNHEALTHY, \"unhealthy-info\"));\n+\n+            cluster.stabilise();", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYzNzQ0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442637449", "bodyText": "Yes.. maybe", "author": "Bukhtawar", "createdAt": "2020-06-19T05:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4MzA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440683079", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"unhealthy-info\"));\n          \n          \n            \n                    }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"healthy-info\"));", "author": "DaveCTurner", "createdAt": "2020-06-16T08:38:30Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java", "diffHunk": "@@ -105,12 +109,11 @@ protected void onSendRequest(long requestId, String action, TransportRequest req\n             TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundTransportAddress -> localNode, null, emptySet());\n         transportService.start();\n         transportService.acceptIncomingRequests();\n-\n         final FollowersChecker followersChecker = new FollowersChecker(settings, transportService, fcr -> {\n             assert false : fcr;\n         }, (node, reason) -> {\n             assert false : node;\n-        });\n+        }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"unhealthy-info\"));", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5NjY2OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440696668", "bodyText": "Could we do this with a fake clock (e.g. a DeterministicTaskQueue) rather than a sleep of a few hundred milliseconds?", "author": "DaveCTurner", "createdAt": "2020-06-16T08:59:22Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            for (Path path : env.nodeDataPaths()) {\n+                assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n+            }\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+        } finally {\n+            disruptFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @TestLogging(value = \"org.elasticsearch.monitor.fs:WARN\", reason = \"to ensure that we log on hung IO at WARN level\")\n+    public void testLoggingOnHungIO() throws Exception {\n+        long slowLogThreshold = randomLongBetween(100, 200);\n+        final Settings settings = Settings.builder().put(FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.getKey(),\n+            slowLogThreshold + \"ms\").build();\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncHungProvider disruptFileSystemProvider = new FileSystemFsyncHungProvider(fileSystem,\n+            randomLongBetween(slowLogThreshold + 1 , 400));\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+\n+        MockLogAppender mockAppender = new MockLogAppender();\n+        mockAppender.start();\n+\n+        Logger logger = LogManager.getLogger(FsHealthService.class);\n+        Loggers.addAppender(logger, mockAppender);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            int counter = 0;\n+            for(Path path : env.nodeDataPaths()){\n+                mockAppender.addExpectation(\n+                    new MockLogAppender.SeenEventExpectation(\n+                        \"test\"+ ++counter,\n+                        FsHealthService.class.getCanonicalName(),\n+                        Level.WARN,\n+                        \"checking writability of [\" + path.toString() + \"]\"));\n+            }\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertBusy(mockAppender::assertAllExpectationsMatched);\n+        } finally {\n+            Loggers.removeAppender(logger, mockAppender);\n+            mockAppender.stop();\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathFsyncFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncIOExceptionProvider disruptFsyncFileSystemProvider = new FileSystemFsyncIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFsyncFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system fsync on single path\n+            disruptFsyncFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptFsyncFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"Path(s) \"+ String.join(\",\", disruptedPath)\n+                + \" have failed writability checks\"));\n+            assertEquals(disruptFsyncFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptFsyncFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathWriteFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptWritesFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptWritesFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system writes on single path\n+            disruptWritesFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptWritesFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"Path(s) \"+ String.join(\",\", disruptedPath)\n+                + \" have failed writability checks\"));\n+            assertEquals(disruptWritesFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptWritesFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+            if (injectIOException.get()){\n+                if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                    injectedPaths.incrementAndGet();\n+                    throw new IOException(\"fake IOException\");\n+                }\n+            }\n+            return super.newOutputStream(path, options);\n+        }\n+    }\n+\n+    private static class FileSystemFsyncIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemFsyncIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            throw new IOException(\"fake IOException\");\n+                        }\n+                    }\n+                    super.force(metaData);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class FileSystemFsyncHungProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+        private long delay;\n+\n+        FileSystemFsyncHungProvider(FileSystem inner, long delay) {\n+            super(\"disrupt_fs_health://\", inner);\n+            this.delay = delay;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            try {\n+                                Thread.sleep(delay);", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbf55176ba89d6ab097e9ddfb87ebef23ef67d70", "url": "https://github.com/elastic/elasticsearch/commit/bbf55176ba89d6ab097e9ddfb87ebef23ef67d70", "message": "Fix spacing in StatusInfo#toString", "committedDate": "2020-06-18T10:53:46Z", "type": "commit"}, {"oid": "1459937cf7763892b346b23eab4893805f7a7331", "url": "https://github.com/elastic/elasticsearch/commit/1459937cf7763892b346b23eab4893805f7a7331", "message": "Tidy 'skip prevoting' log message", "committedDate": "2020-06-18T10:54:04Z", "type": "commit"}, {"oid": "8eb5e2087b37eac9fb71b03308c4ca8ded70d6dc", "url": "https://github.com/elastic/elasticsearch/commit/8eb5e2087b37eac9fb71b03308c4ca8ded70d6dc", "message": "Tidy response messages in FollowersChecker", "committedDate": "2020-06-18T11:00:21Z", "type": "commit"}, {"oid": "2095d82b3c1cd9eaa21401030845f745f2a46fcf", "url": "https://github.com/elastic/elasticsearch/commit/2095d82b3c1cd9eaa21401030845f745f2a46fcf", "message": "Tidy log message in JoinHelper", "committedDate": "2020-06-18T11:02:05Z", "type": "commit"}, {"oid": "39a0565941f9cb7eed461e161a39a16bf0695097", "url": "https://github.com/elastic/elasticsearch/commit/39a0565941f9cb7eed461e161a39a16bf0695097", "message": "Tidy message in PreVoteCollector", "committedDate": "2020-06-18T11:04:03Z", "type": "commit"}, {"oid": "136bc441feebcb5be4d377ebd5480878b6770ae4", "url": "https://github.com/elastic/elasticsearch/commit/136bc441feebcb5be4d377ebd5480878b6770ae4", "message": "Tidy info messages", "committedDate": "2020-06-18T11:08:59Z", "type": "commit"}, {"oid": "1ab13b26dce3bb3bc8fa086f2c0b48ce27889d73", "url": "https://github.com/elastic/elasticsearch/commit/1ab13b26dce3bb3bc8fa086f2c0b48ce27889d73", "message": "Tidy tracing messages", "committedDate": "2020-06-18T11:09:28Z", "type": "commit"}, {"oid": "4143f8f378e7cfec487e88162887495cad0e7e2f", "url": "https://github.com/elastic/elasticsearch/commit/4143f8f378e7cfec487e88162887495cad0e7e2f", "message": "Tidy warn/error messages", "committedDate": "2020-06-18T11:10:57Z", "type": "commit"}, {"oid": "1d9a7abdb2c27a0ba661657a9a8ceba3dc046874", "url": "https://github.com/elastic/elasticsearch/commit/1d9a7abdb2c27a0ba661657a9a8ceba3dc046874", "message": "Fix up tests", "committedDate": "2020-06-18T11:19:47Z", "type": "commit"}, {"oid": "f2225299287205e5b0050d8c6e551c2642130eab", "url": "https://github.com/elastic/elasticsearch/commit/f2225299287205e5b0050d8c6e551c2642130eab", "message": "Fix too-short delay", "committedDate": "2020-06-18T11:27:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1NzcxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442157715", "bodyText": "Can this happen? Looks to me that we already catch and log all exceptions in monitorFSHealth.", "author": "DaveCTurner", "createdAt": "2020-06-18T11:29:05Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n+        }\n+        else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n+            String info = \"health check failed on [\" + pathHealthStats.entrySet()\n+                .stream().filter(v -> v.getValue() == UNHEALTHY)\n+                .map(k -> k.getKey().toString())\n+                .collect(Collectors.joining(\",\")) + \"]\";\n+\n+            statusInfo = new StatusInfo(UNHEALTHY, info);\n+        }\n+        else {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n+        }\n+        return statusInfo;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"health check succeeded: {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"health check failed\", e);", "originalCommit": "f2225299287205e5b0050d8c6e551c2642130eab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMwNzc0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442307742", "bodyText": "Can happen if nodeEnv.nodeDataPaths() fails with lock assertions", "author": "Bukhtawar", "createdAt": "2020-06-18T15:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1NzcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMzAxNg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442703016", "bodyText": "Ohh yes so it can, thanks. For now this is fine but I'll follow up internally to discuss whether we should consider a failure here to be fatal too.", "author": "DaveCTurner", "createdAt": "2020-06-19T08:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1NzcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1ODU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442158591", "bodyText": "All these usages of assertEquals are backwards: it's assertEquals(expected, actual) but you've put the expected value second.", "author": "DaveCTurner", "createdAt": "2020-06-18T11:30:46Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);", "originalCommit": "f2225299287205e5b0050d8c6e551c2642130eab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyMjE2NA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442622164", "bodyText": "Done", "author": "Bukhtawar", "createdAt": "2020-06-19T04:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1ODU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1OTA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442159064", "bodyText": "NB this needed a loop as a simple Thread.sleep() isn't enough to guarantee that the threadpool's clock has advanced.", "author": "DaveCTurner", "createdAt": "2020-06-18T11:31:42Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            for (Path path : env.nodeDataPaths()) {\n+                assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n+            }\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+        } finally {\n+            disruptFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @TestLogging(value = \"org.elasticsearch.monitor.fs:WARN\", reason = \"to ensure that we log on hung IO at WARN level\")\n+    public void testLoggingOnHungIO() throws Exception {\n+        long slowLogThreshold = randomLongBetween(100, 200);\n+        final Settings settings = Settings.builder().put(FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.getKey(),\n+            slowLogThreshold + \"ms\").build();\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        FileSystemFsyncHungProvider disruptFileSystemProvider = new FileSystemFsyncHungProvider(fileSystem,\n+            randomLongBetween(slowLogThreshold + 1 , 400), testThreadPool);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+\n+        MockLogAppender mockAppender = new MockLogAppender();\n+        mockAppender.start();\n+\n+        Logger logger = LogManager.getLogger(FsHealthService.class);\n+        Loggers.addAppender(logger, mockAppender);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            int counter = 0;\n+            for(Path path : env.nodeDataPaths()){\n+                mockAppender.addExpectation(\n+                    new MockLogAppender.SeenEventExpectation(\n+                        \"test\" + ++counter,\n+                        FsHealthService.class.getCanonicalName(),\n+                        Level.WARN,\n+                        \"health check of [\" + path + \"] took [*ms] which is above the warn threshold*\"));\n+            }\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertBusy(mockAppender::assertAllExpectationsMatched);\n+        } finally {\n+            Loggers.removeAppender(logger, mockAppender);\n+            mockAppender.stop();\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathFsyncFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncIOExceptionProvider disruptFsyncFileSystemProvider = new FileSystemFsyncIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFsyncFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system fsync on single path\n+            disruptFsyncFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptFsyncFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"health check failed on [\" + disruptedPath + \"]\"));\n+            assertEquals(disruptFsyncFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptFsyncFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathWriteFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptWritesFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptWritesFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system writes on single path\n+            disruptWritesFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptWritesFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"health check failed on [\" + disruptedPath + \"]\"));\n+            assertEquals(disruptWritesFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptWritesFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+            if (injectIOException.get()){\n+                if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                    injectedPaths.incrementAndGet();\n+                    throw new IOException(\"fake IOException\");\n+                }\n+            }\n+            return super.newOutputStream(path, options);\n+        }\n+    }\n+\n+    private static class FileSystemFsyncIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemFsyncIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            throw new IOException(\"fake IOException\");\n+                        }\n+                    }\n+                    super.force(metaData);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class FileSystemFsyncHungProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+        private long delay;\n+        private final ThreadPool threadPool;\n+\n+        FileSystemFsyncHungProvider(FileSystem inner, long delay, ThreadPool threadPool) {\n+            super(\"disrupt_fs_health://\", inner);\n+            this.delay = delay;\n+            this.threadPool = threadPool;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            final long startTimeMillis = threadPool.relativeTimeInMillis();\n+                            do {\n+                                try {\n+                                    Thread.sleep(delay);\n+                                } catch (InterruptedException e) {\n+                                    throw new AssertionError(e);\n+                                }\n+                            } while (threadPool.relativeTimeInMillis() <= startTimeMillis + delay);", "originalCommit": "f2225299287205e5b0050d8c6e551c2642130eab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyNDM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442324398", "bodyText": "Got it thanks", "author": "Bukhtawar", "createdAt": "2020-06-18T15:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1OTA2NA=="}], "type": "inlineReview"}, {"oid": "befd8228ac2995653fdb618bf3c17bc57bf283cc", "url": "https://github.com/elastic/elasticsearch/commit/befd8228ac2995653fdb618bf3c17bc57bf283cc", "message": "Minor fixes to Follower and FsHealthService", "committedDate": "2020-06-18T15:18:49Z", "type": "commit"}, {"oid": "061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "url": "https://github.com/elastic/elasticsearch/commit/061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "message": "Fix assertions", "committedDate": "2020-06-18T15:30:38Z", "type": "commit"}, {"oid": "cda2179f9da031607e7ddd3426d0b03a561d47f8", "url": "https://github.com/elastic/elasticsearch/commit/cda2179f9da031607e7ddd3426d0b03a561d47f8", "message": "Leader checks", "committedDate": "2020-06-18T17:34:28Z", "type": "commit"}, {"oid": "4d83de02f19a4d35effdefce93b49b024569bf01", "url": "https://github.com/elastic/elasticsearch/commit/4d83de02f19a4d35effdefce93b49b024569bf01", "message": "Leader check tests", "committedDate": "2020-06-19T05:13:05Z", "type": "commit"}, {"oid": "e41392fc12363ff5383551516490cd3e9238a086", "url": "https://github.com/elastic/elasticsearch/commit/e41392fc12363ff5383551516490cd3e9238a086", "message": "cluster reduce stabilization time after unhealthy node", "committedDate": "2020-06-19T06:49:59Z", "type": "commit"}, {"oid": "67d49bb5fbf3b3f76910439c6f78fb486a884bc2", "url": "https://github.com/elastic/elasticsearch/commit/67d49bb5fbf3b3f76910439c6f78fb486a884bc2", "message": "Minor fix up", "committedDate": "2020-06-19T06:57:20Z", "type": "commit"}, {"oid": "fa3cc697fdabf23e4d1007ea0decc90c51f9beab", "url": "https://github.com/elastic/elasticsearch/commit/fa3cc697fdabf23e4d1007ea0decc90c51f9beab", "message": "ClusterFormationFailureHelper changes and more tests", "committedDate": "2020-06-19T11:55:50Z", "type": "commit"}, {"oid": "89035fb50b690c171859d1c9cd2345329b79d752", "url": "https://github.com/elastic/elasticsearch/commit/89035fb50b690c171859d1c9cd2345329b79d752", "message": "Minor changes to LeaderChecker", "committedDate": "2020-06-21T08:42:57Z", "type": "commit"}, {"oid": "adbe670e530c1be18278c9156da17f5a05261c4c", "url": "https://github.com/elastic/elasticsearch/commit/adbe670e530c1be18278c9156da17f5a05261c4c", "message": "Pass StatusInfo to ClusterFormationState and simplify message", "committedDate": "2020-06-24T15:30:25Z", "type": "commit"}, {"oid": "fdcdf45bad1d1dc71da4487beab8937b4e5938a4", "url": "https://github.com/elastic/elasticsearch/commit/fdcdf45bad1d1dc71da4487beab8937b4e5938a4", "message": "Whitespace", "committedDate": "2020-06-24T15:37:55Z", "type": "commit"}, {"oid": "deafeca4a0a3197389bb4728a25c7f4dca74dd74", "url": "https://github.com/elastic/elasticsearch/commit/deafeca4a0a3197389bb4728a25c7f4dca74dd74", "message": "Imports", "committedDate": "2020-06-24T15:55:43Z", "type": "commit"}, {"oid": "1120428f20792607767d89cb9da69e0d9fa9fddb", "url": "https://github.com/elastic/elasticsearch/commit/1120428f20792607767d89cb9da69e0d9fa9fddb", "message": "Fixing Random", "committedDate": "2020-06-24T17:40:02Z", "type": "commit"}, {"oid": "23bc4e5ceae2cac7f9603e35685b4b60f63f9d48", "url": "https://github.com/elastic/elasticsearch/commit/23bc4e5ceae2cac7f9603e35685b4b60f63f9d48", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-06-24T17:41:10Z", "type": "commit"}, {"oid": "06b14b8435569b7032047fc518b2d2aa387b331e", "url": "https://github.com/elastic/elasticsearch/commit/06b14b8435569b7032047fc518b2d2aa387b331e", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-06-24T17:44:00Z", "type": "commit"}, {"oid": "56fb9b3e21cae8fa4dce8fbbfbd49dbf440d10b0", "url": "https://github.com/elastic/elasticsearch/commit/56fb9b3e21cae8fa4dce8fbbfbd49dbf440d10b0", "message": "ForbiddenApis for charset", "committedDate": "2020-06-24T17:55:23Z", "type": "commit"}, {"oid": "0d7b72f69e3afaf3409fa1c4fe4bab8bf3448c24", "url": "https://github.com/elastic/elasticsearch/commit/0d7b72f69e3afaf3409fa1c4fe4bab8bf3448c24", "message": "Fix logger", "committedDate": "2020-06-24T18:21:46Z", "type": "commit"}, {"oid": "f390ed875090811dde3eb3da5c66c9009bcf4859", "url": "https://github.com/elastic/elasticsearch/commit/f390ed875090811dde3eb3da5c66c9009bcf4859", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-06-24T19:21:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r446914720", "bodyText": "This could yield a NullPointerException if unhealthyPaths were set to null since the previous time we read it. Suggest performing a single read of the volatile field into a local variable and then using that instead.", "author": "DaveCTurner", "createdAt": "2020-06-29T11:59:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private final TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    @Nullable\n+    private volatile Set<Path> unhealthyPaths;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(120), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n+        } else if (unhealthyPaths == null) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n+        } else {\n+            String info = \"health check failed on [\" + unhealthyPaths.stream()", "originalCommit": "f390ed875090811dde3eb3da5c66c9009bcf4859", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNDA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r446934065", "bodyText": "Thanks @DaveCTurner  nice catch fixed!!", "author": "Bukhtawar", "createdAt": "2020-06-29T12:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcyMA=="}], "type": "inlineReview"}, {"oid": "f44cf0d658ebb6e3c9f5e4950dff0bade0dd9f0f", "url": "https://github.com/elastic/elasticsearch/commit/f44cf0d658ebb6e3c9f5e4950dff0bade0dd9f0f", "message": "NPE handling", "committedDate": "2020-06-29T12:31:08Z", "type": "commit"}, {"oid": "97a4c02a9eafbea0122e1226cf64042eba8c48b2", "url": "https://github.com/elastic/elasticsearch/commit/97a4c02a9eafbea0122e1226cf64042eba8c48b2", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-06-29T13:20:36Z", "type": "commit"}, {"oid": "54d7c98fc4f0ee6fe1a27e64eb5ec1a6e9f7503a", "url": "https://github.com/elastic/elasticsearch/commit/54d7c98fc4f0ee6fe1a27e64eb5ec1a6e9f7503a", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-07-02T05:31:35Z", "type": "commit"}, {"oid": "aae514278d14d9c5a56903b5c18df54def23db95", "url": "https://github.com/elastic/elasticsearch/commit/aae514278d14d9c5a56903b5c18df54def23db95", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-07-03T11:25:52Z", "type": "commit"}]}