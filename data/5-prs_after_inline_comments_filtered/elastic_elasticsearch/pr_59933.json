{"pr_number": 59933, "pr_title": "Add double script fields", "pr_createdAt": "2020-07-20T21:06:01Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59933", "timeline": [{"oid": "b7a1c8182aae742babfca8794e8dfe3deaf1f164", "url": "https://github.com/elastic/elasticsearch/commit/b7a1c8182aae742babfca8794e8dfe3deaf1f164", "message": "Add double script fields\n\nThis adds support for `double` typed `script` fields.", "committedDate": "2020-07-20T21:03:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NTY0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458195645", "bodyText": "I was wondering, would it make sense to add tests for the unsupported queries, to verify that they throw error?", "author": "javanna", "createdAt": "2020-07-21T15:39:31Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptDoubleMappedFieldType.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import com.carrotsearch.hppc.LongHashSet;\n+import com.carrotsearch.hppc.LongSet;\n+\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.lucene.search.Queries;\n+import org.elasticsearch.common.time.DateMathParser;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.DoubleScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.fielddata.ScriptDoubleFieldData;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldExistsQuery;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldRangeQuery;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldTermQuery;\n+import org.elasticsearch.xpack.runtimefields.query.DoubleScriptFieldTermsQuery;\n+\n+import java.time.ZoneId;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ScriptDoubleMappedFieldType extends AbstractScriptMappedFieldType {\n+    private final DoubleScriptFieldScript.Factory scriptFactory;\n+\n+    ScriptDoubleMappedFieldType(String name, Script script, DoubleScriptFieldScript.Factory scriptFactory, Map<String, String> meta) {\n+        super(name, script, meta);\n+        this.scriptFactory = scriptFactory;\n+    }\n+\n+    @Override\n+    protected String runtimeType() {\n+        return NumberType.DOUBLE.typeName();\n+    }\n+\n+    @Override\n+    public Object valueForDisplay(Object value) {\n+        return value; // These should come back as a Double\n+    }\n+\n+    @Override\n+    public ScriptDoubleFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+        // TODO once we get SearchLookup as an argument, we can already call scriptFactory.newFactory here and pass through the result\n+        return new ScriptDoubleFieldData.Builder(script, scriptFactory);\n+    }\n+\n+    private DoubleScriptFieldScript.LeafFactory leafFactory(QueryShardContext context) {\n+        return scriptFactory.newFactory(script.getParams(), context.lookup());\n+    }\n+\n+    @Override\n+    public Query existsQuery(QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);\n+        return new DoubleScriptFieldExistsQuery(script, leafFactory(context), name());\n+    }\n+\n+    @Override\n+    public Query rangeQuery(\n+        Object lowerTerm,\n+        Object upperTerm,\n+        boolean includeLower,\n+        boolean includeUpper,\n+        ShapeRelation relation,\n+        ZoneId timeZone,\n+        DateMathParser parser,\n+        QueryShardContext context\n+    ) {\n+        checkAllowExpensiveQueries(context);\n+        return NumberType.doubleRangeQuery(\n+            lowerTerm,\n+            upperTerm,\n+            includeLower,\n+            includeUpper,\n+            (l, u) -> new DoubleScriptFieldRangeQuery(script, leafFactory(context), name(), l, u)\n+        );\n+    }\n+\n+    @Override\n+    public Query termQuery(Object value, QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);\n+        return new DoubleScriptFieldTermQuery(script, leafFactory(context), name(), NumberType.objectToDouble(value));\n+    }\n+\n+    @Override\n+    public Query termsQuery(List<?> values, QueryShardContext context) {\n+        if (values.isEmpty()) {\n+            return Queries.newMatchAllQuery();\n+        }\n+        LongSet terms = new LongHashSet(values.size());\n+        for (Object value : values) {\n+            terms.add(Double.doubleToLongBits(NumberType.objectToDouble(value)));\n+        }\n+        checkAllowExpensiveQueries(context);\n+        return new DoubleScriptFieldTermsQuery(script, leafFactory(context), name(), terms);\n+    }", "originalCommit": "b7a1c8182aae742babfca8794e8dfe3deaf1f164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDY2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458210669", "bodyText": "I can do that!", "author": "nik9000", "createdAt": "2020-07-21T16:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5NTY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5ODY2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59933#discussion_r458198669", "bodyText": "I think that most of these methods could be static, not that it matters a lot though :)", "author": "javanna", "createdAt": "2020-07-21T15:43:39Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptDoubleMappedFieldTypeTests.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.Collector;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.LeafCollector;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.Scorable;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessPlugin;\n+import org.elasticsearch.plugins.ExtensiblePlugin.ExtensionLoader;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.xpack.runtimefields.DoubleScriptFieldScript;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFieldsPainlessExtension;\n+import org.elasticsearch.xpack.runtimefields.fielddata.ScriptDoubleFieldData;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class ScriptDoubleMappedFieldTypeTests extends AbstractScriptMappedFieldTypeTestCase {\n+    public void testDocValues() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [1.0]}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [3.14, 1.4]}\"))));\n+            List<Double> results = new ArrayList<>();\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                ScriptDoubleMappedFieldType ft = build(\"for (def v : source.foo) {value(v + params.param)}\", Map.of(\"param\", 1));\n+                IndexMetadata imd = IndexMetadata.builder(\"test\")\n+                    .settings(Settings.builder().put(\"index.version.created\", Version.CURRENT))\n+                    .numberOfShards(1)\n+                    .numberOfReplicas(1)\n+                    .build();\n+                ScriptDoubleFieldData ifd = ft.fielddataBuilder(\"test\").build(new IndexSettings(imd, Settings.EMPTY), ft, null, null, null);\n+                ifd.setSearchLookup(mockContext().lookup());\n+                searcher.search(new MatchAllDocsQuery(), new Collector() {\n+                    @Override\n+                    public ScoreMode scoreMode() {\n+                        return ScoreMode.COMPLETE_NO_SCORES;\n+                    }\n+\n+                    @Override\n+                    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n+                        SortedNumericDoubleValues dv = ifd.load(context).getDoubleValues();\n+                        return new LeafCollector() {\n+                            @Override\n+                            public void setScorer(Scorable scorer) throws IOException {}\n+\n+                            @Override\n+                            public void collect(int doc) throws IOException {\n+                                if (dv.advanceExact(doc)) {\n+                                    for (int i = 0; i < dv.docValueCount(); i++) {\n+                                        results.add(dv.nextValue());\n+                                    }\n+                                }\n+                            }\n+                        };\n+                    }\n+                });\n+                assertThat(results, equalTo(List.of(2.0, 2.4, 4.140000000000001)));\n+            }\n+        }\n+    }\n+\n+    public void testExistsQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": [1]}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": []}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(searcher.count(build(\"for (def v : source.foo) {value(v)}\").existsQuery(mockContext())), equalTo(1));\n+            }\n+        }\n+    }\n+\n+    public void testExistsQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery(ScriptDoubleMappedFieldType::existsQuery);\n+    }\n+\n+    public void testRangeQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 1}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2.5}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(\"2\", \"3\", true, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2, 3, true, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(1.1, 3, true, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(1.1, 3, false, true, null, null, null, mockContext())),\n+                    equalTo(2)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2, 3, false, true, null, null, null, mockContext())),\n+                    equalTo(1)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2.5, 3, true, true, null, null, null, mockContext())),\n+                    equalTo(1)\n+                );\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo)\").rangeQuery(2.5, 3, false, true, null, null, null, mockContext())),\n+                    equalTo(0)\n+                );\n+            }\n+        }\n+    }\n+\n+    public void testRangeQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery(\n+            (ft, ctx) -> ft.rangeQuery(randomLong(), randomLong(), randomBoolean(), randomBoolean(), null, null, null, ctx)\n+        );\n+    }\n+\n+    public void testTermQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 1}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(searcher.count(build(\"value(source.foo)\").termQuery(\"1\", mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termQuery(1, mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termQuery(1.1, mockContext())), equalTo(0));\n+                assertThat(\n+                    searcher.count(build(\"value(source.foo + params.param)\", Map.of(\"param\", 1)).termQuery(2, mockContext())),\n+                    equalTo(1)\n+                );\n+            }\n+        }\n+    }\n+\n+    public void testTermQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery((ft, ctx) -> ft.termQuery(randomLong(), ctx));\n+    }\n+\n+    public void testTermsQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 1}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": 2.1}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(\"1\"), mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(1), mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(1.1), mockContext())), equalTo(0));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(1.1, 2.1), mockContext())), equalTo(1));\n+                assertThat(searcher.count(build(\"value(source.foo)\").termsQuery(List.of(2.1, 1), mockContext())), equalTo(2));\n+            }\n+        }\n+    }\n+\n+    public void testTermsQueryIsExpensive() throws IOException {\n+        checkExpensiveQuery((ft, ctx) -> ft.termsQuery(List.of(randomLong()), ctx));\n+    }\n+\n+    private ScriptDoubleMappedFieldType build(String code) throws IOException {", "originalCommit": "b7a1c8182aae742babfca8794e8dfe3deaf1f164", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4155e9c329d1feef5a3a9a71233611b51beb24eb", "url": "https://github.com/elastic/elasticsearch/commit/4155e9c329d1feef5a3a9a71233611b51beb24eb", "message": "Merge branch 'feature/runtime_fields' into script_field_double", "committedDate": "2020-07-21T16:39:05Z", "type": "commit"}, {"oid": "491728b66d8751a641b96b601a85ebdcd63c5922", "url": "https://github.com/elastic/elasticsearch/commit/491728b66d8751a641b96b601a85ebdcd63c5922", "message": "Add tests for error from unimplemented queries", "committedDate": "2020-07-21T17:05:16Z", "type": "commit"}, {"oid": "0dd624a36d2c4372a97424b94aea3210b816e169", "url": "https://github.com/elastic/elasticsearch/commit/0dd624a36d2c4372a97424b94aea3210b816e169", "message": "WIP", "committedDate": "2020-07-21T17:53:35Z", "type": "commit"}, {"oid": "f29bd64d89d5b358165773686fdd6440084a8478", "url": "https://github.com/elastic/elasticsearch/commit/f29bd64d89d5b358165773686fdd6440084a8478", "message": "WIP", "committedDate": "2020-07-21T17:59:47Z", "type": "commit"}, {"oid": "bdd3dbe7894f77c68e4c8fda2d0101b8f3e02efd", "url": "https://github.com/elastic/elasticsearch/commit/bdd3dbe7894f77c68e4c8fda2d0101b8f3e02efd", "message": "Merge branch 'feature/runtime_fields' into script_field_double", "committedDate": "2020-07-21T19:48:08Z", "type": "commit"}, {"oid": "fa2af2ee1f5d537552f1dd6c1270bb56443afb67", "url": "https://github.com/elastic/elasticsearch/commit/fa2af2ee1f5d537552f1dd6c1270bb56443afb67", "message": "Merge branch 'feature/runtime_fields' into script_field_double", "committedDate": "2020-07-21T19:49:24Z", "type": "commit"}, {"oid": "76d9ee2a108e9668e79313b707028937f3d93e6f", "url": "https://github.com/elastic/elasticsearch/commit/76d9ee2a108e9668e79313b707028937f3d93e6f", "message": "precommit", "committedDate": "2020-07-21T20:02:57Z", "type": "commit"}]}