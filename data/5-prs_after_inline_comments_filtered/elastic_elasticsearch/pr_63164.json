{"pr_number": 63164, "pr_title": "geo_point runtime field implementation", "pr_createdAt": "2020-10-02T09:12:33Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63164", "timeline": [{"oid": "fd9eff366b8c83acc85d398a65677ba495696e21", "url": "https://github.com/elastic/elasticsearch/commit/fd9eff366b8c83acc85d398a65677ba495696e21", "message": "geo_point runtime implementation", "committedDate": "2020-10-02T09:05:22Z", "type": "commit"}, {"oid": "47e4eb36c6009787a65d89a7841262135ef16567", "url": "https://github.com/elastic/elasticsearch/commit/47e4eb36c6009787a65d89a7841262135ef16567", "message": "Add geo_distance sort yaml test", "committedDate": "2020-10-02T09:32:25Z", "type": "commit"}, {"oid": "767d39806e2715a475600f37b65519a7d820edd3", "url": "https://github.com/elastic/elasticsearch/commit/767d39806e2715a475600f37b65519a7d820edd3", "message": "iter", "committedDate": "2020-10-02T09:37:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxOTE2MA==", "url": "https://github.com/elastic/elasticsearch/pull/63164#discussion_r498719160", "bodyText": "This is horrible but I didn't want to fix it until getting feedback.", "author": "iverase", "createdAt": "2020-10-02T09:38:46Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/GeoPointScriptMappedFieldTypeTests.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.Collector;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.LeafCollector;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.Scorable;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.geo.GeoPoint;\n+import org.elasticsearch.common.lucene.search.function.ScriptScoreQuery;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.geo.GeometryTestUtils;\n+import org.elasticsearch.index.fielddata.MultiGeoPointValues;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.plugins.ScriptPlugin;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.search.MultiValueMode;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+import org.elasticsearch.xpack.runtimefields.fielddata.GeoPointScriptFieldData;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class GeoPointScriptMappedFieldTypeTests extends AbstractScriptFieldTypeTestCase {\n+\n+    @Override\n+    public void testDocValues() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": {\\\"lat\\\": 45.0, \\\"lon\\\" : 45.0}}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": {\\\"lat\\\": 0.0, \\\"lon\\\" : 0.0}}\"))));\n+            List<Object> results = new ArrayList<>();\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                GeoPointScriptMappedFieldType ft = build(\"fromLatLon\", Map.of());\n+                GeoPointScriptFieldData ifd = ft.fielddataBuilder(\"test\", mockContext()::lookup).build(null, null, null);\n+                searcher.search(new MatchAllDocsQuery(), new Collector() {\n+                    @Override\n+                    public ScoreMode scoreMode() {\n+                        return ScoreMode.COMPLETE_NO_SCORES;\n+                    }\n+\n+                    @Override\n+                    public LeafCollector getLeafCollector(LeafReaderContext context) {\n+                        MultiGeoPointValues dv = ifd.load(context).getGeoPointValues();\n+                        return new LeafCollector() {\n+                            @Override\n+                            public void setScorer(Scorable scorer) {}\n+\n+                            @Override\n+                            public void collect(int doc) throws IOException {\n+                                if (dv.advanceExact(doc)) {\n+                                    for (int i = 0; i < dv.docValueCount(); i++) {\n+                                        final GeoPoint point = dv.nextValue();\n+                                        results.add(new GeoPoint(point.lat(), point.lon()));\n+                                    }\n+                                }\n+                            }\n+                        };\n+                    }\n+                });\n+                assertThat(results, equalTo(List.of(new GeoPoint(45.0, 45.0), new GeoPoint(0.0, 0.0))));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void testSort() throws IOException {\n+        GeoPointScriptFieldData ifd = simpleMappedFieldType().fielddataBuilder(\"test\", mockContext()::lookup).build(null, null, null);\n+        Exception e = expectThrows(IllegalArgumentException.class, () -> ifd.sortField(null, MultiValueMode.MIN, null, false));\n+        assertThat(e.getMessage(), equalTo(\"can't sort on geo_point field without using specific sorting feature, like geo_distance\"));\n+    }\n+\n+    @Override\n+    public void testUsedInScript() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": {\\\"lat\\\": 45.0, \\\"lon\\\" : 45.0}}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": {\\\"lat\\\": 0.0, \\\"lon\\\" : 0.0}}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                QueryShardContext qsc = mockContext(true, simpleMappedFieldType());\n+                assertThat(searcher.count(new ScriptScoreQuery(new MatchAllDocsQuery(), new Script(\"test\"), new ScoreScript.LeafFactory() {\n+                    @Override\n+                    public boolean needs_score() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public ScoreScript newInstance(LeafReaderContext ctx) {\n+                        return new ScoreScript(Map.of(), qsc.lookup(), ctx) {\n+                            @Override\n+                            public double execute(ExplanationHolder explanation) {\n+                                ScriptDocValues.GeoPoints points = (ScriptDocValues.GeoPoints) getDoc().get(\"test\");\n+                                return (int) points.get(0).lat() + 1;\n+                            }\n+                        };\n+                    }\n+                }, 2.5f, \"test\", 0, Version.CURRENT)), equalTo(1));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void testExistsQuery() throws IOException {\n+        try (Directory directory = newDirectory(); RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": {\\\"lat\\\": 45.0, \\\"lon\\\" : 45.0}}\"))));\n+            iw.addDocument(List.of(new StoredField(\"_source\", new BytesRef(\"{\\\"foo\\\": {\\\"lat\\\": 0.0, \\\"lon\\\" : 0.0}}\"))));\n+            try (DirectoryReader reader = iw.getReader()) {\n+                IndexSearcher searcher = newSearcher(reader);\n+                assertThat(searcher.count(simpleMappedFieldType().existsQuery(mockContext())), equalTo(2));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void testRangeQuery() throws IOException {\n+        Exception e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> simpleMappedFieldType().rangeQuery(\"0.0\", \"45.0\", false, false, null, null, null, mockContext())\n+        );\n+        assertThat(e.getMessage(), equalTo(\"Field [test] of type [runtime] does not support range queries\"));\n+    }\n+\n+    @Override\n+    protected Query randomRangeQuery(MappedFieldType ft, QueryShardContext ctx) {\n+        return ft.rangeQuery(\"0.0\", \"45.0\", false, false, null, null, null, mockContext());\n+    }\n+\n+    @Override\n+    public void testTermQuery() throws IOException {\n+        Exception e = expectThrows(IllegalArgumentException.class, () -> simpleMappedFieldType().termQuery(\"0.0,0.0\", mockContext()));\n+        assertThat(\n+            e.getMessage(),\n+            equalTo(\"Geometry fields do not support exact searching, use dedicated geometry queries instead: [test]\")\n+        );\n+    }\n+\n+    @Override\n+    protected Query randomTermQuery(MappedFieldType ft, QueryShardContext ctx) {\n+        return ft.termQuery(GeometryTestUtils.randomPoint(), mockContext());\n+    }\n+\n+    @Override\n+    public void testTermsQuery() {\n+        Exception e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> simpleMappedFieldType().termsQuery(List.of(\"0.0,0.0\", \"45.0,45.0\"), mockContext())\n+        );\n+\n+        assertThat(\n+            e.getMessage(),\n+            equalTo(\"Geometry fields do not support exact searching, use dedicated geometry queries instead: [test]\")\n+        );\n+\n+    }\n+\n+    @Override\n+    protected Query randomTermsQuery(MappedFieldType ft, QueryShardContext ctx) {\n+        return ft.termsQuery(randomList(100, () -> GeometryTestUtils.randomPoint()), mockContext());\n+    }\n+\n+    @Override\n+    @AwaitsFix(bugUrl = \"Not supported\")\n+    public void testRangeQueryWithShapeRelationIsError() {}", "originalCommit": "767d39806e2715a475600f37b65519a7d820edd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2a6509ab53f5af619c62f9aa54ea3a6fbe766a3d", "url": "https://github.com/elastic/elasticsearch/commit/2a6509ab53f5af619c62f9aa54ea3a6fbe766a3d", "message": "Shorten field type class name", "committedDate": "2020-10-02T09:46:13Z", "type": "commit"}, {"oid": "5a88e14db65b3215367b4f28ed7e5e271175b943", "url": "https://github.com/elastic/elasticsearch/commit/5a88e14db65b3215367b4f28ed7e5e271175b943", "message": "cleanup tests", "committedDate": "2020-10-05T12:48:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY0ODg4OA==", "url": "https://github.com/elastic/elasticsearch/pull/63164#discussion_r499648888", "bodyText": "These were in alphabetical order I think.", "author": "nik9000", "createdAt": "2020-10-05T14:39:09Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/RuntimeFields.java", "diffHunk": "@@ -38,7 +39,8 @@\n             DoubleFieldScript.CONTEXT,\n             IpFieldScript.CONTEXT,\n             LongFieldScript.CONTEXT,\n-            StringFieldScript.CONTEXT\n+            StringFieldScript.CONTEXT,\n+            GeoPointFieldScript.CONTEXT", "originalCommit": "5a88e14db65b3215367b4f28ed7e5e271175b943", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1MzY1OA==", "url": "https://github.com/elastic/elasticsearch/pull/63164#discussion_r499653658", "bodyText": "Is this something we can move into core? It looks like something we'd have there already?", "author": "nik9000", "createdAt": "2020-10-05T14:45:23Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/GeoPointScriptFieldType.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeUtils;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.time.DateMathParser;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeQueryable;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.xpack.runtimefields.fielddata.GeoPointScriptFieldData;\n+import org.elasticsearch.xpack.runtimefields.query.GeoPointScriptFieldExistsQuery;\n+import org.elasticsearch.xpack.runtimefields.query.GeoPointScriptFieldGeoShapeQuery;\n+\n+import java.time.ZoneId;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public final class GeoPointScriptFieldType extends AbstractScriptFieldType<GeoPointFieldScript.LeafFactory> implements GeoShapeQueryable {\n+\n+    GeoPointScriptFieldType(String name, Script script, GeoPointFieldScript.Factory scriptFactory, Map<String, String> meta) {\n+        super(name, script, scriptFactory::newFactory, meta);\n+    }\n+\n+    @Override\n+    protected String runtimeType() {\n+        return GeoPointFieldMapper.CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected Query rangeQuery(\n+        Object lowerTerm,\n+        Object upperTerm,\n+        boolean includeLower,\n+        boolean includeUpper,\n+        ZoneId timeZone,\n+        DateMathParser parser,\n+        QueryShardContext context\n+    ) {\n+        throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support range queries\");\n+    }\n+\n+    @Override\n+    public Query termQuery(Object value, QueryShardContext context) {\n+        throw new IllegalArgumentException(\n+            \"Geometry fields do not support exact searching, use dedicated geometry queries instead: [\" + name() + \"]\"\n+        );\n+    }\n+\n+    @Override\n+    public GeoPointScriptFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName, Supplier<SearchLookup> searchLookup) {\n+        return new GeoPointScriptFieldData.Builder(name(), leafFactory(searchLookup.get()));\n+    }\n+\n+    @Override\n+    public Query existsQuery(QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);\n+        return new GeoPointScriptFieldExistsQuery(script, leafFactory(context), name());\n+    }\n+\n+    @Override\n+    public Query geoShapeQuery(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        if (shape == null) {\n+            return new MatchNoDocsQuery();\n+        }\n+        final LatLonGeometry[] geometries = toLuceneGeometry(fieldName, context, shape);\n+        return new GeoPointScriptFieldGeoShapeQuery(script, leafFactory(context), fieldName, geometries);\n+    }\n+\n+    private static LatLonGeometry[] toLuceneGeometry(String name, QueryShardContext context, Geometry geometry) {", "originalCommit": "5a88e14db65b3215367b4f28ed7e5e271175b943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwNzkzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63164#discussion_r499707931", "bodyText": "Thats is my plan but it seems more difficult that it looks at first sight as every time we need to map a geometry to a Lucene geometry, it seems to be slightly different. As part of that effort I opened  https://issues.apache.org/jira/browse/LUCENE-9552 but I didn't have much support so far. I try to move it.", "author": "iverase", "createdAt": "2020-10-05T16:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1MzY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NTM0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63164#discussion_r499655345", "bodyText": "Maybe it'd be better to make a new superclass that doesn't have these methods?", "author": "nik9000", "createdAt": "2020-10-05T14:47:34Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldTypeTestCase.java", "diffHunk": "@@ -67,6 +67,14 @@ protected static QueryShardContext mockContext(boolean allowExpensiveQueries) {\n         return mockContext(allowExpensiveQueries, null);\n     }\n \n+    protected boolean supportsTermQueries() {", "originalCommit": "5a88e14db65b3215367b4f28ed7e5e271175b943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNjY3OA==", "url": "https://github.com/elastic/elasticsearch/pull/63164#discussion_r499716678", "bodyText": "The problem is that we already have AbstractNonTextScriptFieldTypeTestCase that extends this class. Those methods are worthy running so adding a superclass you will miss that. My feeling is that we need an abstract class for every type of query and field types will implement all the ones they support?", "author": "iverase", "createdAt": "2020-10-05T16:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NTM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4ODU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63164#discussion_r499788599", "bodyText": "So instead of an abstract superclass for the type of field it is per query? I could see that being better, maybe. I'm ok with this as is if we plan to refactor it soon enough anyway.", "author": "nik9000", "createdAt": "2020-10-05T18:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NTM0NQ=="}], "type": "inlineReview"}, {"oid": "9117fd9c1fcc9e8019c455303ca9e25dbc76c0aa", "url": "https://github.com/elastic/elasticsearch/commit/9117fd9c1fcc9e8019c455303ca9e25dbc76c0aa", "message": "iter", "committedDate": "2020-10-05T16:16:43Z", "type": "commit"}, {"oid": "d94874c2fcd638571ebb050f1485ebd505f56ce7", "url": "https://github.com/elastic/elasticsearch/commit/d94874c2fcd638571ebb050f1485ebd505f56ce7", "message": "iter", "committedDate": "2020-10-05T17:08:29Z", "type": "commit"}, {"oid": "f53b662c3014fc168c3e3d4d5b176009ffbd4cc5", "url": "https://github.com/elastic/elasticsearch/commit/f53b662c3014fc168c3e3d4d5b176009ffbd4cc5", "message": "Move creation of LatLonGeometries to GeoShapeUtils", "committedDate": "2020-10-06T08:50:01Z", "type": "commit"}, {"oid": "bb6cab1af1e6d282500266fab35fae3a2de7fa00", "url": "https://github.com/elastic/elasticsearch/commit/bb6cab1af1e6d282500266fab35fae3a2de7fa00", "message": "Merge branch 'master' into runtime_geopoint", "committedDate": "2020-10-06T08:51:10Z", "type": "commit"}, {"oid": "e7d84ca69b9cd0d5bf0bba798b5991b066a5bff4", "url": "https://github.com/elastic/elasticsearch/commit/e7d84ca69b9cd0d5bf0bba798b5991b066a5bff4", "message": "compile errors", "committedDate": "2020-10-06T10:39:49Z", "type": "commit"}, {"oid": "2e9ec53f0ba13be8faa5d7b29c11f27fddc54d8c", "url": "https://github.com/elastic/elasticsearch/commit/2e9ec53f0ba13be8faa5d7b29c11f27fddc54d8c", "message": "precommit", "committedDate": "2020-10-06T10:46:10Z", "type": "commit"}, {"oid": "8af770cfd5ca636b599a294475d6762b7d67b3f1", "url": "https://github.com/elastic/elasticsearch/commit/8af770cfd5ca636b599a294475d6762b7d67b3f1", "message": "Merge branch 'master' into runtime_geopoint", "committedDate": "2020-10-08T12:07:18Z", "type": "commit"}, {"oid": "a77aaa2a69d51bd7c58df5dc7836477d2d133786", "url": "https://github.com/elastic/elasticsearch/commit/a77aaa2a69d51bd7c58df5dc7836477d2d133786", "message": "remove copy/paste nosense", "committedDate": "2020-10-08T12:09:36Z", "type": "commit"}, {"oid": "c983c00de7004fd9c323aec35c7b81f28e67bf36", "url": "https://github.com/elastic/elasticsearch/commit/c983c00de7004fd9c323aec35c7b81f28e67bf36", "message": "Merge branch 'master' into runtime_geopoint", "committedDate": "2020-10-19T12:54:17Z", "type": "commit"}, {"oid": "503d33216f86fba71c15be3cbbb4d1ad2f5ded5c", "url": "https://github.com/elastic/elasticsearch/commit/503d33216f86fba71c15be3cbbb4d1ad2f5ded5c", "message": "Merge branch 'master' into runtime_geopoint", "committedDate": "2020-10-21T06:45:47Z", "type": "commit"}]}