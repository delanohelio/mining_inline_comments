{"pr_number": 66022, "pr_title": "QL: Simplify arithmetic operations in binary comps", "pr_createdAt": "2020-12-08T13:04:34Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66022", "timeline": [{"oid": "c931ef8dd4c54f34a6af260b9af440cbc0753826", "url": "https://github.com/elastic/elasticsearch/commit/c931ef8dd4c54f34a6af260b9af440cbc0753826", "message": "Simplify arithmetic operations in binary comps\n\nThis commit adds an optimizer rule to simplify the arithmetic operations\nin binary comparison expressions, which in turn will allow for further\nexpression compounding by the optimiser.\n\nOnly the negation and plus, minus, multiplication and division are\ncurrently considered and only when two of the operands are a literal.\n\nFor instance `((a + 1) / 2 - 3) * 4 >= 14` becomes `a >= 12`.", "committedDate": "2020-12-08T12:47:17Z", "type": "commit"}, {"oid": "0db90e4457b32e85954126ec5a565850661b0535", "url": "https://github.com/elastic/elasticsearch/commit/0db90e4457b32e85954126ec5a565850661b0535", "message": "Undo unintentional change\n\nRevert unintentional change of a source file.", "committedDate": "2020-12-08T13:00:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyMjEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538422136", "bodyText": "Why do you identify multiplication with wildcard symbol and not with an instanceof?", "author": "astefan", "createdAt": "2020-12-08T14:17:53Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTY5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239697", "bodyText": "The SQL ops aren't available as deps in the QL package.", "author": "bpintea", "createdAt": "2020-12-14T09:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyMjEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMDg4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538430883", "bodyText": "Add javadoc regarding the purpose of the method.", "author": "costin", "createdAt": "2020-12-08T14:26:22Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/comparison/BinaryComparison.java", "diffHunk": "@@ -49,4 +49,6 @@ protected Pipe makePipe() {\n     public static Integer compare(Object left, Object right) {\n         return Comparisons.compare(left, right);\n     }\n+\n+    public abstract BinaryComparison reverse();", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239775", "bodyText": "javadoc added.", "author": "bpintea", "createdAt": "2020-12-14T09:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMDg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538431266", "bodyText": "return Div instead of ArithmeticOperation.", "author": "costin", "createdAt": "2020-12-08T14:26:47Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mul.java", "diffHunk": "@@ -52,4 +52,9 @@ protected Mul replaceChildren(Expression newLeft, Expression newRight) {\n     public Mul swapLeftAndRight() {\n         return new Mul(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239807", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2020-12-14T09:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTM4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538431386", "bodyText": "return Add instead of ArithmeticOperation", "author": "costin", "createdAt": "2020-12-08T14:26:53Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Sub.java", "diffHunk": "@@ -27,4 +27,9 @@ public Sub(Source source, Expression left, Expression right) {\n     protected Sub replaceChildren(Expression newLeft, Expression newRight) {\n         return new Sub(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239831", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2020-12-14T09:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjc3MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538432770", "bodyText": "The exception type is wrong. And we rarely thrown an exception on methods that are forced to be implemented - that indicates either the code is incomplete (as here) or that the contract is too broad.", "author": "costin", "createdAt": "2020-12-08T14:28:19Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -30,4 +30,10 @@ public Mod(Source source, Expression left, Expression right) {\n     protected Mod replaceChildren(Expression newLeft, Expression newRight) {\n         return new Mod(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        // TODO: Modular Multiplicative Inverse, if ever needed?\n+        throw new UnsupportedOperationException(\"inverting modulo operation is not supported\");\n+    }", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTkzOA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239938", "bodyText": "Fixed, adopted the same strategy as ArithmeticOperation#swapLeftAndRight().", "author": "bpintea", "createdAt": "2020-12-14T09:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538432969", "bodyText": "return Mul instead of ArithmeticOperation", "author": "costin", "createdAt": "2020-12-08T14:28:32Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Div.java", "diffHunk": "@@ -34,4 +34,9 @@ protected Div replaceChildren(Expression newLeft, Expression newRight) {\n     public DataType dataType() {\n         return DataTypeConverter.commonType(left().dataType(), right().dataType());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239994", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2020-12-14T09:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzE5OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538433198", "bodyText": "Javadoc on what this does.", "author": "costin", "createdAt": "2020-12-08T14:28:47Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,6 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    public abstract ArithmeticOperation inverse(Source source, Expression left, Expression right);", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240040", "bodyText": "Added a description.", "author": "bpintea", "createdAt": "2020-12-14T09:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzQwMg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538433402", "bodyText": "return Sub instead of ArithmeticOperation", "author": "costin", "createdAt": "2020-12-08T14:28:58Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDA5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240099", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2020-12-14T09:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzNzEzNw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538437137", "bodyText": "The test only cares about the expression so you can just use parser.createExpression (see tests inside ExpressionTests).", "author": "costin", "createdAt": "2020-12-08T14:32:41Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {\n+        // i >= 12\n+        doTestBinaryComparisonReduction(\"((int + 1) / 2 - 3) * 4 >= 14\", GreaterThanOrEqual.class, 12d);\n+    }\n+\n+    public void testReducedBinaryComYparisonLessThen() {\n+        // i < -5/6\n+        doTestBinaryComparisonReduction(\"12 * (-int / 5) > (8 + 12) / 10\", LessThan.class, -5d / 6);\n+    }\n+\n+    public void testReducedBinaryComYparisonNotEquals() {\n+        // i != 7000\n+        doTestBinaryComparisonReduction(\"-3600 != (int - 200) / 2\", NotEquals.class, -7000);\n+    }\n+\n+    public void testReducedBinaryComparisonEquals() {\n+        // i = -12\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithConjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 AND int >= -12\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithDisjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 OR int > -12\", GreaterThanOrEqual.class, -12d);\n+    }\n+\n+    private void doTestBinaryComparisonReduction(String expression, Class<? extends BinaryComparison> binaryComparisonClass,\n+                                                 Number bound) {\n+        LogicalPlan plan = plan(\"SELECT some.string FROM test WHERE \" + expression);\n+\n+        assertTrue(plan instanceof UnaryPlan);\n+        UnaryPlan unaryPlan = (UnaryPlan) plan;\n+        assertTrue(unaryPlan.child() instanceof Filter);\n+        Filter filter = (Filter) unaryPlan.child();\n+        assertEquals(binaryComparisonClass, filter.condition().getClass());\n+        BinaryComparison bc = (BinaryComparison) filter.condition();\n+\n+        assertTrue(bc.left() instanceof FieldAttribute);\n+        FieldAttribute attribute = (FieldAttribute) bc.left();\n+        assertEquals(\"int\", attribute.name());\n+\n+        assertTrue(bc.right() instanceof Literal);", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDE3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240172", "bodyText": "I've employed parser.createExpression(), thanks.", "author": "bpintea", "createdAt": "2020-12-14T09:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzNzEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0MjE1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538442156", "bodyText": "I'd like to see more tests that the behavior regarding commutative vs non-commutative expressions:\na + 2 > 3\n2 + a > 3\na - 2 > 3\n2 - a > 3\na * 2 > 3\n2 * a > 3\na / 2 > 3\n2 / a > 3\n1 / (a - 2) > 3\n1 / (2 - a) > 3\n1 / (2 + (2 - a) > 3", "author": "costin", "createdAt": "2020-12-08T14:37:14Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDIwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240209", "bodyText": "Added all these tests.", "author": "bpintea", "createdAt": "2020-12-14T09:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0MjE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NDc5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538444797", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (e instanceof BinaryComparison) {\n          \n          \n            \n                            return reduce((BinaryComparison) e);\n          \n          \n            \n                        }\n          \n          \n            \n                        return e;\n          \n          \n            \n                        if (e instanceof BinaryComparison) {\n          \n          \n            \n                            e = reduce((BinaryComparison) e);\n          \n          \n            \n                        }\n          \n          \n            \n                        return e;", "author": "costin", "createdAt": "2020-12-08T14:39:32Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240366", "bodyText": "Refactored.", "author": "bpintea", "createdAt": "2020-12-14T09:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NDc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NjAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538446002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n          \n          \n            \n                        // optimize only once the expression looks like `Expression [ArithmeticOp] Expression [BinaryComp] Literal`", "author": "costin", "createdAt": "2020-12-08T14:40:43Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDU0NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240544", "bodyText": "Rephrased.", "author": "bpintea", "createdAt": "2020-12-14T09:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NjAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1NzgzMw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538457833", "bodyText": "Try to avoid using strings for type matching. Assuming there's no other either way move use a string reference to indicate its source, such as DefaultBinaryArithmeticOperation.MUL.symbol() instead of *.\nAlso please add some comments to explain what's going on - if the symbol is Mul, force double division by promoting the right literal to a double?", "author": "costin", "createdAt": "2020-12-08T14:51:32Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDcxNw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240717", "bodyText": "such as DefaultBinaryArithmeticOperation.MUL.symbol() instead of *.\n\nThanks, fixed.\n\nif the symbol is Mul, force double division by promoting the right literal to a double?\n\nYes, that was the logic. But this got now removed, as a potentially unsafe optimisation.", "author": "bpintea", "createdAt": "2020-12-14T09:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1NzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwNTMyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538605325", "bodyText": "Precision loss might cause some issues here. a + b == c is mathematically the same as a == c - b, except when you take into account the potential precision loss.\nFor example:\na = 1.0E-15\nb = 1.0E15\nc = 1.0E15\n\na + b == c\n1.0E-15 + 1.0E15 == 1.0E15\n1.0E15 == 1.0E15\ntrue\n\na == c - b\n1.0E-15 == 1.0E15 - 1.0E15\n1.0E-15 == 0.0\nfalse\n\nSo even though the query before and after the optimization might be mathematically equivalent, it still won't return the same result after the optimization is applied. This might have unintended consequences after a version upgrade. I think we should discuss this before moving ahead with the PR.", "author": "palesz", "createdAt": "2020-12-08T17:01:31Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul\n+                        bcRight = new Literal(bcRight.source(), ((Number) bcRight.value()).doubleValue(), DOUBLE);\n+                    }\n+                    return bc.replaceChildren(List.of(opLeft.left(), opLeft.inverse(bcRight.source(), bcRight, opLeft.right())));", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDgwNA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240804", "bodyText": "Thanks, good point. Addressed, along with the similar DIV/MUL concern.", "author": "bpintea", "createdAt": "2020-12-14T09:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwNTMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwODM4OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538608388", "bodyText": "I would add some tests for testing with numbers where overflow or precision loss can occur.", "author": "palesz", "createdAt": "2020-12-08T17:04:17Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "originalCommit": "0db90e4457b32e85954126ec5a565850661b0535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240890", "bodyText": "I've added more tests.", "author": "bpintea", "createdAt": "2020-12-14T09:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwODM4OA=="}], "type": "inlineReview"}, {"oid": "abc632d2f043832f3d0d63b1ea50906fc1b8fb31", "url": "https://github.com/elastic/elasticsearch/commit/abc632d2f043832f3d0d63b1ea50906fc1b8fb31", "message": "Refactor the optimisation. Adress review comments\n\nThe optimisation is now refactor splitting the logic by add-sub and\nmul-div operations.\nFurther restictions are put in place, to prevent the\noptimiser from chaning the outcome of the filtering.\nMore tests have been added.", "committedDate": "2020-12-14T09:14:20Z", "type": "commit"}, {"oid": "b031dfbcd348117b01ff89712af9b55bd1882398", "url": "https://github.com/elastic/elasticsearch/commit/b031dfbcd348117b01ff89712af9b55bd1882398", "message": "Merge branch 'master' into enh/optimize_arithm_in_bc", "committedDate": "2020-12-14T09:17:16Z", "type": "commit"}, {"oid": "4d641e45fe7faea9d2aaa635fec272521788bb1e", "url": "https://github.com/elastic/elasticsearch/commit/4d641e45fe7faea9d2aaa635fec272521788bb1e", "message": "Style fix\n\nRemoved now unused import.", "committedDate": "2020-12-14T09:36:09Z", "type": "commit"}, {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "url": "https://github.com/elastic/elasticsearch/commit/1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "message": "Test fix\n\n- update test condition to remove (non-optimisable) integer division.", "committedDate": "2020-12-14T10:32:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5NTYwNA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r545995604", "bodyText": "Why not mark it as abstract? In case we add a new operation, silently using this inverse might have unintended consequences, while with abstract the compiler will force you to think about it.", "author": "palesz", "createdAt": "2020-12-18T17:57:02Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**\n+     * Returns the opposite of this operation.\n+     */\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        return this;\n+    }", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjM4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452382", "bodyText": "This had been implemented as abstract initially (and have Mod throw an exception, as you were also proposing below), but got refactored not to throw an exception (see #66022 (comment)).\nAnd after #66022 (comment) it got a second refactoring, as that comment addresses the approach.", "author": "bpintea", "createdAt": "2021-01-07T16:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5NTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546007285", "bodyText": "Extract symbol check into a separate function.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (child instanceof ArithmeticOperation) {\n          \n          \n            \n                                ArithmeticOperation operation = (ArithmeticOperation) child;\n          \n          \n            \n                                String opSymbol = operation.symbol();\n          \n          \n            \n                                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n          \n          \n            \n                            if (isMulOrDiv(child)) {\n          \n          \n            \n                                ArithmeticOperation operation = (ArithmeticOperation) child;", "author": "palesz", "createdAt": "2020-12-18T18:18:25Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjQzMA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452430", "bodyText": "Extracted, thanks.", "author": "bpintea", "createdAt": "2021-01-07T16:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546008307", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n          \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) e;\n          \n          \n            \n                            String opSymbol = operation.symbol();\n          \n          \n            \n                            if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n          \n          \n            \n                        } else if (isMulOrDiv(e)) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n          \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) e;", "author": "palesz", "createdAt": "2020-12-18T18:20:04Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjQ3MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452470", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2021-01-07T16:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMDczNw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546010737", "bodyText": "I would use the field() method that already abstracts out the children access.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n          \n          \n            \n                                        return operation.replaceChildren(List.of(((Neg)operation.left()).field(), operation.right()));", "author": "palesz", "createdAt": "2020-12-18T18:24:45Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjU4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452585", "bodyText": "Good point, thanks.", "author": "bpintea", "createdAt": "2021-01-07T16:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMDczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTI0OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546011248", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (operation.right() instanceof Neg) {\n          \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n          \n          \n            \n                                    }\n          \n          \n            \n                                    if (operation.right() instanceof Neg) {\n          \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left(), ((Neg)operation.right()).field()));\n          \n          \n            \n                                    }", "author": "palesz", "createdAt": "2020-12-18T18:25:44Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjYyMA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452620", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2021-01-07T16:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546012969", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    Neg neg = (Neg) operation.left();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n          \n          \n            \n                                    Expression newLeft = ((Neg) operation.left()).field();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(newLeft, operation.right())));", "author": "palesz", "createdAt": "2020-12-18T18:28:53Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjY2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452663", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2021-01-07T16:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDM0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546014349", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    Neg neg = (Neg) operation.right();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n          \n          \n            \n                                    Expression newRight = ((Neg) operation.right()).field();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), newRight)));", "author": "palesz", "createdAt": "2020-12-18T18:31:38Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452693", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2021-01-07T16:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxOTE4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546019183", "bodyText": "What about double Neg? Do we already have a rule that changes NEG - NEG - x to x?", "author": "palesz", "createdAt": "2020-12-18T18:41:14Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1Mjg2MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452860", "bodyText": "Double negation is taken care of by SimplifyComparisonsArithmetics#reduceNegation() -- the point of this rule is really to surface the negations, not necessarily simplify them (which however happens as a by product).\nHowever, at Costin's suggestion I'll extract this rule in separate PR, which clearly warrants having this simplification part of the rule.", "author": "bpintea", "createdAt": "2021-01-07T16:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxOTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNTAxNg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546035016", "bodyText": "Some renaming and inlining would make this easier to read and reason about. The safeMaybeFold is just a really simple try-catch that you kind of mimic with the null check anyways.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private static Expression reduceNegation(BinaryComparison bc) {\n          \n          \n            \n                        Literal bcLiteral = (Literal) bc.right();\n          \n          \n            \n                        Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n          \n          \n            \n                        return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n          \n          \n            \n                    }\n          \n          \n            \n                    private static Expression reduceNegation(BinaryComparison bc) {\n          \n          \n            \n                        Literal oldRight = (Literal) bc.right();\n          \n          \n            \n                        Neg newRight = new Neg(oldRight.source(), oldRight);\n          \n          \n            \n                        Expression newLeft = ((Neg) bc.left()).field();\n          \n          \n            \n                        try {\n          \n          \n            \n                            newRight = new Literal(newRight.source(), newRight.fold(), newRight.dataType());\n          \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                            // cannot optimize the negation, either ArithmeticException or DateTimeException\n          \n          \n            \n                            // but safe to just turn off the optmisation should any exception arise\n          \n          \n            \n                            return bc;\n          \n          \n            \n                        }\n          \n          \n            \n                        return bc.reverse().replaceChildren(List.of(newLeft, newRight));\n          \n          \n            \n                    }", "author": "palesz", "createdAt": "2020-12-18T19:09:11Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjkwMw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452903", "bodyText": "safeMaybeFold performs an additional check too and is called from other places too, so I'd personally prefer the existing more compact and code reusing way.", "author": "bpintea", "createdAt": "2021-01-07T16:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1MjI1OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546052258", "bodyText": "Remove the explicit check on the not handled cases (MUL), just to stay on the safe side in case we add any sort of magic Arithmetic operators (so any possible new operation won't be treated as Add/Sub by default).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n          \n          \n            \n                            // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n          \n          \n            \n                            String opSymbol = operation.symbol();\n          \n          \n            \n                            // Modulo can't be simplified.\n          \n          \n            \n                            if (MOD.symbol().equals(opSymbol)) {\n          \n          \n            \n                                return comparison;\n          \n          \n            \n                            }\n          \n          \n            \n                            SimplifyOperation simplification = (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol))\n          \n          \n            \n                                ? new SimplifyMulDiv(comparison)\n          \n          \n            \n                                : new SimplifyAddSub(comparison);\n          \n          \n            \n                            SimplifyOperation simplification = null;\n          \n          \n            \n                            if (isMulOrDiv(comparison.left()) {\n          \n          \n            \n                                simplification = new SimplifyMulDiv(comparison);\n          \n          \n            \n                            } else if (isAddOrSub(comparison.left()) {\n          \n          \n            \n                                simplification = new SimpliAddSub(comparison);\n          \n          \n            \n                            }\n          \n          \n            \n                            if (simplification == null) {\n          \n          \n            \n                                return comparison;\n          \n          \n            \n                            }", "author": "palesz", "createdAt": "2020-12-18T19:37:29Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation\n+                    // should any exception arise.\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplification = (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol))\n+                    ? new SimplifyMulDiv(comparison)\n+                    : new SimplifyAddSub(comparison);", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzA5NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453094", "bodyText": "I was wrongly thinking mostly at SQL (and less at QL) and assuming we won't add operators (without at least breaking these tests), but sure, it absolutely makes sense to expand the check.", "author": "bpintea", "createdAt": "2021-01-07T16:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1MjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546054013", "bodyText": "I think the inverse should throw an exception in this class.", "author": "palesz", "createdAt": "2020-12-18T19:41:15Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * <a href=\"https://en.wikipedia.org/wiki/Modulo_operation\">Modulo</a>\n  * function ({@code a % b}).\n- * \n+ *\n  * Note this operator is also registered as a function (needed for ODBC/SQL) purposes.\n  */\n public class Mod extends ArithmeticOperation {", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzIxNg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453216", "bodyText": "See above comment.", "author": "bpintea", "createdAt": "2021-01-07T16:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NDAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMjk1NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552012954", "bodyText": "What does opposite mean? And why is the opposite called inverse?\nFurther more is a bit of a stretch to define this method on the current instance - from what I can tell this method is about finding the method opposite operation for the given operation WITHOUT reusing its arguments. That is this is about Add not Add(3,1).\nThis can be better conveyed by returning a BiFunction and thus returning a Factory instead of the final product or moving somewhere else considering you pass a Source object as well.\nThe result also might not be an ArithmeticOperation, see Mod which is an integral operation and thus something we should strive to support.", "author": "costin", "createdAt": "2021-01-05T15:42:18Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453360", "bodyText": "Indeed, this makes sense, thanks.\nI've removed the inverse() method from the ArithmeticOperation class and added a clearer interface implemented only by those operations that are actually invertible in relation to the binary comparison.", "author": "bpintea", "createdAt": "2021-01-07T16:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMjk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMzc2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552013769", "bodyText": "I'm not sure this is correct. Add is a commutative operation but Sub is not. 3 + 1 is the same as 1 +3 but 1 -3 ! 3 - 1.", "author": "costin", "createdAt": "2021-01-05T15:43:30Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzM5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453392", "bodyText": "Refactored.", "author": "bpintea", "createdAt": "2021-01-07T16:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxOTg4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552019882", "bodyText": "Let's catch just those expections then - otherwise we might catch accidently and swallow other exceptions that we should not.", "author": "costin", "createdAt": "2021-01-05T15:52:39Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzQyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453421", "bodyText": "Fixed.", "author": "bpintea", "createdAt": "2021-01-07T16:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxOTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552024006", "bodyText": "Why is the script still used? there's no point in moving the interval to the right if it is not added to the given literal.", "author": "costin", "createdAt": "2021-01-05T15:58:37Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2074,15 +2074,15 @@ public void testNoCountDoesNotTrackHits() {\n \n     public void testZonedDateTimeInScripts() {\n         PhysicalPlan p = optimizeAndPlan(\n-                \"SELECT date FROM test WHERE date + INTERVAL 1 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n+                \"SELECT date FROM test WHERE date - INTERVAL 999999999 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec eqe = (EsQueryExec) p;\n         assertThat(eqe.queryContainer().toString().replaceAll(\"\\\\s+\", \"\"), containsString(\n                 \"\\\"script\\\":{\\\"script\\\":{\\\"source\\\":\\\"InternalQlScriptUtils.nullSafeFilter(\"\n-                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.add(InternalQlScriptUtils.docValue(doc,params.v0),\"\n+                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.sub(InternalQlScriptUtils.docValue(doc,params.v0),\"", "originalCommit": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzUzMA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453530", "bodyText": "I've changed the test from an addition to a subtraction, as well as used a max value, so that the optimisation is prevented. Consequently the translation had to be adjusted.", "author": "bpintea", "createdAt": "2021-01-07T16:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NzY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557697643", "bodyText": "Could you then add a test where the optimization is applied? I'm confused since in this instance, I expect the PR to add tests not modify existing ones.", "author": "costin", "createdAt": "2021-01-14T21:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzOTIyMw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565239223", "bodyText": ":-) Sure, tests have been added.\nThis test however still needs to be changed (as is now), as it meant to test testZonedDateTimeInScripts, not optimisations. What it did was the integer similar of x + 2  > 3 which the new optimisation rule would translate to x > 1; so it would simplify the test, reducing its testing value. My change only made sure the literals non-field values are such that the optimisation won't take place, so that the test retains its original intention (sort of x - MAX > 3, just like here).", "author": "bpintea", "createdAt": "2021-01-27T11:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg=="}], "type": "inlineReview"}, {"oid": "e74b697a5aefb1050961cd28b016577c14af471d", "url": "https://github.com/elastic/elasticsearch/commit/e74b697a5aefb1050961cd28b016577c14af471d", "message": "Address review comments\n\n- add isMulOrDiv and isAddOrSub methods;\n- add a new factory if'ace for the arithmetic operations invertible in\n  relation to a binary comparison;\n- simplify NEG - NEG tree structures;\n- more tests.", "committedDate": "2021-01-07T15:42:47Z", "type": "commit"}, {"oid": "25becef5051ed502f1f600abcdbd16c057c01409", "url": "https://github.com/elastic/elasticsearch/commit/25becef5051ed502f1f600abcdbd16c057c01409", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-07T15:44:52Z", "type": "commit"}, {"oid": "92c74c98b6aeb4ae5ca79ba5dc8bd0bb46d45605", "url": "https://github.com/elastic/elasticsearch/commit/92c74c98b6aeb4ae5ca79ba5dc8bd0bb46d45605", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-11T16:30:08Z", "type": "commit"}, {"oid": "06fea9ca1e0d45fbad6bf731fe4fd0d36a7dfa8b", "url": "https://github.com/elastic/elasticsearch/commit/06fea9ca1e0d45fbad6bf731fe4fd0d36a7dfa8b", "message": "Remove negation optmisations\n\nThese are unsafe, see\nhttps://github.com/elastic/elasticsearch/pull/67278", "committedDate": "2021-01-12T12:03:05Z", "type": "commit"}, {"oid": "fa5059917d544e4e4faa1c3ff21a6963861766c5", "url": "https://github.com/elastic/elasticsearch/commit/fa5059917d544e4e4faa1c3ff21a6963861766c5", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-12T12:04:07Z", "type": "commit"}, {"oid": "6e9d04b63c4012dcd44dece07482e8dc5ff1440c", "url": "https://github.com/elastic/elasticsearch/commit/6e9d04b63c4012dcd44dece07482e8dc5ff1440c", "message": "Reintroduce negation reduction\n\n* `NEG - x < Literal` becomes `x > -Literal` if folding can be done.\n* add more tests", "committedDate": "2021-01-12T15:56:15Z", "type": "commit"}, {"oid": "0c9c088e024e0a7fff43678dfd2b773683c373a4", "url": "https://github.com/elastic/elasticsearch/commit/0c9c088e024e0a7fff43678dfd2b773683c373a4", "message": "Revert WS-only changes\n\nRevert changes in files where only WS was updated.", "committedDate": "2021-01-12T15:59:50Z", "type": "commit"}, {"oid": "e28e9a69b933ef31b32f553cf0b5da0fe30aa3cd", "url": "https://github.com/elastic/elasticsearch/commit/e28e9a69b933ef31b32f553cf0b5da0fe30aa3cd", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-12T16:00:54Z", "type": "commit"}, {"oid": "32cefb8a296a57a9e9aeccee05fef27cce5432a7", "url": "https://github.com/elastic/elasticsearch/commit/32cefb8a296a57a9e9aeccee05fef27cce5432a7", "message": "CSV spec test\n\n- add test on negation handling with integer limit value.", "committedDate": "2021-01-12T18:27:27Z", "type": "commit"}, {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "url": "https://github.com/elastic/elasticsearch/commit/9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-13T14:39:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3NDY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557674690", "bodyText": "Invertible is typically used in the context of matrices. How about inversion or inverse or inversible? Essentially use inverse instead of invert.", "author": "costin", "createdAt": "2021-01-14T20:20:18Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * Addition function ({@code a + b}).\n  */\n-public class Add extends DateTimeArithmeticOperation {\n+public class Add extends DateTimeArithmeticOperation implements BinaryComparisonInvertible {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMDc4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565230781", "bodyText": "I've changed it to Inversible..\nSince the interface is meant to convey the action intent, I find -ble needed. But FTR, invertible might still be more appropriate since \"inversible\" isn't really a word and a word already exists: that's why a matrix^-1 is \"inverted\" and so are also indexes/indices (\"inverted index\" not \"inversed index\").", "author": "bpintea", "createdAt": "2021-01-27T11:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3NDY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3Njc5NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557676794", "bodyText": "Why is this check required? Are there any doubts on what type of code is being received and if so, why not do the filtering before hand?\nI'm not a fan of this defensive programming since it promotes uncertainty to a degree. This is our own code, our own system, working in synch - no need to double check the code flow.", "author": "costin", "createdAt": "2021-01-14T20:24:19Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1284,7 +1246,12 @@ Expression doSimplify() {\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMDk1MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565230950", "bodyText": "I've removed the check.\nOfftopic:\n\nno need to double check the code flow\n\nExtensive testing should definitely help. I believe assertions exist still because code has a (life) cycle and effects of later changes can't always be exhaustively checked/predicted or coded in (see the many instanceofs or comment).", "author": "bpintea", "createdAt": "2021-01-27T11:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3Njc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3ODA4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557678083", "bodyText": "The code is a bit messy and could use some comments on what are the cases the rules tries to optimize - some basic examples of input vs output are enough.", "author": "costin", "createdAt": "2021-01-14T20:26:57Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1148,46 +1152,6 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n-    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n-\n-        public BubbleUpNegations() {\n-            super(TransformDirection.DOWN);\n-        }\n-\n-        @Override\n-        protected Expression rule(Expression e) {\n-            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n-                Expression child = e.children().get(0);\n-                if (child instanceof ArithmeticOperation) {\n-                    ArithmeticOperation operation = (ArithmeticOperation) child;\n-                    String opSymbol = operation.symbol();\n-                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                        if (operation.left() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n-                        }\n-                        if (operation.right() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n-                        }\n-                    }\n-                }\n-            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n-                ArithmeticOperation operation = (ArithmeticOperation) e;\n-                String opSymbol = operation.symbol();\n-                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                    if (operation.left() instanceof Neg) {\n-                        Neg neg = (Neg) operation.left();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n-                    }\n-                    if (operation.right() instanceof Neg) {\n-                        Neg neg = (Neg) operation.right();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n-                    }\n-                }\n-            }\n-            return e;\n-        }\n-    }\n-\n     // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n     public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTA4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231087", "bodyText": "Code refactored and comments added.", "author": "bpintea", "createdAt": "2021-01-27T11:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3ODA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4MzQ0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557683449", "bodyText": "tryFolding vs safeMaybeFold.", "author": "costin", "createdAt": "2021-01-14T20:37:05Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTExNw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231117", "bodyText": "Suggestion applied.", "author": "bpintea", "createdAt": "2021-01-27T11:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4MzQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557684735", "bodyText": "use asList for backporting. Also literalNeg should preserve the right origin so maybe rightNegated?", "author": "costin", "createdAt": "2021-01-14T20:39:25Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTIxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231211", "bodyText": "Right, thanks.", "author": "bpintea", "createdAt": "2021-01-27T11:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557684944", "bodyText": "foldNegation vs reduce (different terminology).", "author": "costin", "createdAt": "2021-01-14T20:39:50Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTkyMg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231922", "bodyText": "Suggestion applied.", "author": "bpintea", "createdAt": "2021-01-27T11:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NTc5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557685799", "bodyText": "What's the use of this class? The name is fairly generic. Also can it be used by itself ? if not making abstract.", "author": "costin", "createdAt": "2021-01-14T20:41:33Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjAzMA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232030", "bodyText": "It's been made abstract.", "author": "bpintea", "createdAt": "2021-01-27T11:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NTc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NjE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557686188", "bodyText": "The constructor makes a lot of assumptions here, are these safe?", "author": "costin", "createdAt": "2021-01-14T20:42:20Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232122", "bodyText": "Yes, all are checked upstream.", "author": "bpintea", "createdAt": "2021-01-27T11:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NjE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557688266", "bodyText": "Why is this static method defined in this class? It's confusing to see the class Simplify being called both as an instance and its static method.", "author": "costin", "createdAt": "2021-01-14T20:46:24Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjc0OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232748", "bodyText": "The intention was to have the (previously called) SimplifyOperation be self-contained: deal with simplification operations entirely and not leak details into the outer class, that should not care if it's a AddSub or DivMul operation.\nAnyways, I've extracted it out.", "author": "bpintea", "createdAt": "2021-01-27T11:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557688901", "bodyText": "It's better to do a switch on the operation enum as that will cover all cases.", "author": "costin", "createdAt": "2021-01-14T20:47:33Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjkxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232911", "bodyText": "The SQL operations that this code also acts on aren't available (in the current package) -- there's a comment on the line right before the first in the snippet above. So I don't know how else it can be done.", "author": "bpintea", "createdAt": "2021-01-27T11:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MTk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557691948", "bodyText": "Why not Math.signum (see MathOperation.SIGN)?", "author": "costin", "createdAt": "2021-01-14T20:52:56Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // Integer divisions are not safe to optimise: x / 5 > 1 <=/=> x > 5 for x in [6, 9]; same for the `==` comp\n+                return operation.dataType().isInteger() && isDiv || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                // If current operation is a multiplication, it's inverse will be a division: safe only if outcome is still integral.\n+                if (isDiv == false && opLeft.dataType().isInteger()) {\n+                    long opLiteralValue = ((Number) opLiteral.value()).longValue();\n+                    if (opLiteralValue == 0 || ((Number) bcLiteral.value()).longValue() % opLiteralValue != 0) {\n+                        return comparison;\n+                    }\n+                }\n+                // negative multiplication/division changes the direction of the comparison\n+                int sign = sign(opRight);\n+                if (sign == 0) {\n+                    return comparison;\n+                }\n+                BinaryComparison bc = (BinaryComparison) super.doSimplify();\n+                return sign < 0 ? bc.reverse() : bc;\n+            }\n+\n+            private int sign(Object obj) {\n+                int sign = 1;\n+                if (obj instanceof Number) {\n+                    double d = ((Number) obj).doubleValue();\n+                    sign = d == 0 ? 0 : (d < 0 ? -1 : 1);", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjk1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232957", "bodyText": "Thanks, fixed.", "author": "bpintea", "createdAt": "2021-01-27T11:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557695106", "bodyText": "Since submethods keep calling the super method, instead of overriding it declare a separate method that is empty in the base class which subclasses can call:\ncheckSimplification() {\n  ...code...\n  extraChecks()\n}\n\nprotected extraChecks() {}\n\nNaming could be improved though.", "author": "costin", "createdAt": "2021-01-14T20:59:02Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMzIxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565233215", "bodyText": "Separate methods declared.", "author": "bpintea", "createdAt": "2021-01-27T11:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557695737", "bodyText": "Check the enums directly, don't use their names.", "author": "costin", "createdAt": "2021-01-14T21:00:14Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NjA2OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557696068", "bodyText": "Also is this condition correct? the else (parent doSimplify) is picked if it is a sub but the opRight is a literal", "author": "costin", "createdAt": "2021-01-14T21:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMzU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565233590", "bodyText": "Check the enums directly, don't use their names.\n\nSee above.\n\nAlso is this condition correct? the else (parent doSimplify) is picked if it is a sub but the opRight is a literal\n\nIt is correct: in the else-case the literal has simply been \"normalised\" to the right and the simplification can be attempted.\nThe check you're referring to (in the child SimplifyAddSub) is there to avoid transforming the expression that ultimately still can't be simplified; ex.: for 1 - x > -MAX, w/o the check, the next transformation would be x - MAX < 1 and then it would stop there, since MAX + 1 would overflow. That's what the comment on the first line below the last in the snippet above indicates.\nBut if the literal is on the right already (x - 1 ...), the optimisation can be attempted in the parent doSimplify (as per previous naming).", "author": "bpintea", "createdAt": "2021-01-27T11:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5Njc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557696747", "bodyText": "Looks like this method is never called in this form, subclasses always override it and enhance it. If that's the case, simply declare the method as is and declare a separate one as abstract which subclasses are forced to override and in where they can call this method.", "author": "costin", "createdAt": "2021-01-14T21:02:27Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNDEwNA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565234104", "bodyText": "The method was called in that form, but anyways, code got refactored as per the feedback.", "author": "bpintea", "createdAt": "2021-01-27T11:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5Njc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMzUwNg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557703506", "bodyText": "typesCompatible -> typeCheck", "author": "costin", "createdAt": "2021-01-14T21:15:37Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNDI4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565234289", "bodyText": "Before I change it, just to 2x check: the passed arguments are DataTypes::areCompatible and SqlDataTypes::areCompatible.\nThe code using the var also looks like return typesCompatible.apply([type1], [type2]) == false;.\nNot sure if the change would bring more clarity (\"what's checked?\"), so asking.", "author": "bpintea", "createdAt": "2021-01-27T11:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559977054", "bodyText": "I don't particularly like this method and, imo, it doesn't help much understanding the code. I think the return null inside the catch block bothers me.\nI would have kept the original (no separate method used) block of code, as I find it easier to read.\n        private static Expression reduceNegation(BinaryComparison bc) {\n            Literal bcLiteral = (Literal) bc.right();\n            Expression expression = new Neg(bcLiteral.source(), bcLiteral);\n            if (expression.foldable()) {\n                try {\n                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n                    return bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), expression));\n                } catch (ArithmeticException | DateTimeException e) {\n                    // implicitly return the original BinaryComparison in case the folding results in scenarios where,\n                    // for example, we have Long.MAX_VALUE+1 to fold. In this case, we skip the optimization.\n                }\n            }\n            return bc;\n        }", "author": "astefan", "createdAt": "2021-01-19T08:00:46Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNTEwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565235109", "bodyText": "I think the return null inside the catch block bothers me.\n\nThe null isn't returned from the catch block, it's just assigned to the var to return.\nBut this still being a detail, would you mind expanding what's troubling / how it could be improved?\n\nI would have kept the original (no separate method used)\n\nThe code is extracted as a method since it's reused. It should be acceptably concise too: \"if the expression is foldable, attempt to do so. Return either folded outcome, original (if not foldable) or null (if foldable, but unsafely; i.e. exception wud be thrown)\".\nAn alternative could be for the caller to save the input expression (as in your example), the function to return the original input, if folding is unsafe, and for caller to check returned value against the original input. But this would be more verbose (as in your example) and this pattern to be applied multiple times.\nFor now I've taken Costin's suggestion, but still open for change if needed.", "author": "bpintea", "createdAt": "2021-01-27T11:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTkxMDQ1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565910457", "bodyText": "Can be left as is I guess. My initial suggestion seems to be just a personal preference. If there will be other changes to this PR, I'd add a comment similar to the one I made in the catch (ArithmeticException | DateTimeException e) { to explain the catch block \"ignoring\" the math failure.", "author": "astefan", "createdAt": "2021-01-28T08:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3OTU4NA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559979584", "bodyText": "I think only if (bc.left().... is enough. else if doesn't necessarily help here.", "author": "astefan", "createdAt": "2021-01-19T08:05:52Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNzI0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565237249", "bodyText": "I've changed it.\n(Particularly here, the if[-else] is practically a switch, on a type that's not switchable in Java, so the change makes sense.\nGenerally I'm in favour of the if-else format when:\n\na return is involved, whose later replacement by a non-jumping statement, could make the next if branch eligible; i.e. less error-prone.\nis more compact.)", "author": "bpintea", "createdAt": "2021-01-27T11:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3OTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk5NzEzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559997135", "bodyText": "I think here equals is not needed for this String comparison. == should be enough. There are other similar uses in this class as well.", "author": "astefan", "createdAt": "2021-01-19T08:36:26Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNzMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565237323", "bodyText": "Indeed, == should be safe for as long as we don't assign dynamic values to operations' symbols. I've changed them.", "author": "bpintea", "createdAt": "2021-01-27T11:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk5NzEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwODM5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r560008396", "bodyText": "\ud83d\udc4d", "author": "astefan", "createdAt": "2021-01-19T08:54:03Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/predicate/operator/arithmetic/SqlBinaryArithmeticOperation.java", "diffHunk": "@@ -52,7 +52,7 @@\n             return IntervalArithmetics.add((Temporal) r, ((IntervalDayTime) l).interval());\n         }\n \n-        throw new QlIllegalArgumentException(\"Cannot compute [+] between [{}] [{}]\", l.getClass().getSimpleName(),\n+        throw new QlIllegalArgumentException(\"Cannot compute [+] between [{}] and [{}]\", l.getClass().getSimpleName(),", "originalCommit": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6dadbeb84481202b65d536e9a42b0730d89ecc4c", "url": "https://github.com/elastic/elasticsearch/commit/6dadbeb84481202b65d536e9a42b0730d89ecc4c", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-26T16:10:13Z", "type": "commit"}, {"oid": "70df9813a1eff54774acc46a66d0e4bfd4de6862", "url": "https://github.com/elastic/elasticsearch/commit/70df9813a1eff54774acc46a66d0e4bfd4de6862", "message": "Address feedback\n\n- rename methods for more clarify;\n- regroup simplification checks;\n- eliminate calling super class' methods;\n- use == for static string comps;\n- use Math.signum instead of inlining the calculation.", "committedDate": "2021-01-27T10:46:02Z", "type": "commit"}, {"oid": "f74d627df0f7afb8a8294f0774db71635c52ff66", "url": "https://github.com/elastic/elasticsearch/commit/f74d627df0f7afb8a8294f0774db71635c52ff66", "message": "Merge branch 'master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-27T10:50:27Z", "type": "commit"}, {"oid": "99f08c1f30aafe63f8e03237c3197510d4c58eb6", "url": "https://github.com/elastic/elasticsearch/commit/99f08c1f30aafe63f8e03237c3197510d4c58eb6", "message": "Address review comments\n\nUpdate QA test.", "committedDate": "2021-01-27T11:19:34Z", "type": "commit"}, {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed", "url": "https://github.com/elastic/elasticsearch/commit/a3b66c85e72e691520e1ef01a02425165a4c04ed", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-27T11:20:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NTI5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566085299", "bodyText": "If this method necessary? I only see it used in one place and the check can check can be directly just life for ADD and SUB.", "author": "costin", "createdAt": "2021-01-28T13:17:06Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1170,21 +1171,44 @@ private Expression simplify(BinaryComparison bc) {\n             // optimize only once the expression has a literal on the right side of the binary comparison\n             if (bc.right() instanceof Literal) {\n                 if (bc.left() instanceof ArithmeticOperation) {\n-                    return SimplifyOperation.simplify(bc, typesCompatible);\n-                } else if (bc.left() instanceof Neg) {\n-                    return reduceNegation(bc);\n+                    return simplifyBinaryComparison(bc);\n+                }\n+                if (bc.left() instanceof Neg) {\n+                    return foldNegation(bc);\n                 }\n             }\n             return bc;\n         }\n \n-        private static Expression reduceNegation(BinaryComparison bc) {\n+        private Expression simplifyBinaryComparison(BinaryComparison comparison) {\n+            ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+            // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+            String opSymbol = operation.symbol();\n+            // Modulo can't be simplified.\n+            if (opSymbol == MOD.symbol()) {\n+                return comparison;\n+            }\n+            OperationSimplifier simplification = null;\n+            if (isMulOrDiv(opSymbol)) {\n+                simplification = new MulDivSimplifier(comparison);\n+            } else if (opSymbol == ADD.symbol() || opSymbol == SUB.symbol()) {\n+                simplification = new AddSubSimplifier(comparison);\n+            }\n+\n+            return (simplification == null || simplification.isUnsafe(typesCompatible)) ? comparison : simplification.apply();\n+        }\n+\n+        private static boolean isMulOrDiv(String opSymbol) {", "originalCommit": "a3b66c85e72e691520e1ef01a02425165a4c04ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1MzA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566353091", "bodyText": "It's being used twice. I'm on the fence tbh - it makes things easier to read in sign(), but looks unbalanced in the if-else explicit ADD/SUB check - but would leave it as is now.", "author": "bpintea", "createdAt": "2021-01-28T19:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4Njk3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566086979", "bodyText": "postApply or postProcess. opSpecific is somewhat meaningless.", "author": "costin", "createdAt": "2021-01-28T13:19:46Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();\n             }\n \n-            Expression doSimplify() {\n+            Expression apply() {\n                 // force float point folding for FlP field\n                 Literal bcl = operation.dataType().isRational()\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n-                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n-                }\n-                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                Expression bcRightExpression = ((BinaryComparisonInversible) operation).binaryComparisonInverse()\n                     .create(bcl.source(), bcl, opRight);\n-                bcRightExpression = safeMaybeFold(bcRightExpression);\n-                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+                bcRightExpression = tryFolding(bcRightExpression);\n+                return bcRightExpression != null\n+                    ? opSpecificPostApply((BinaryComparison) comparison.replaceChildren(List.of(opLeft, bcRightExpression)))\n+                    : comparison;\n             }\n \n-            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n-                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n-                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n-                String opSymbol = operation.symbol();\n-                // Modulo can't be simplified.\n-                if (MOD.symbol().equals(opSymbol)) {\n-                    return comparison;\n-                }\n-                SimplifyOperation simplify = null;\n-                if (isMulOrDiv(opSymbol)) {\n-                    simplify = new SimplifyMulDiv(comparison);\n-                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n-                    simplify = new SimplifyAddSub(comparison);\n-                }\n-\n-                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n-            }\n+            // operation-specific operations:\n+            //  - fast-tracking of simplification unsafety\n+            abstract boolean opSpecificIsUnsafe();\n \n-            static boolean isMulOrDiv(String opSymbol) {\n-                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            //  - post adjustments\n+            Expression opSpecificPostApply(BinaryComparison binaryComparison) {", "originalCommit": "a3b66c85e72e691520e1ef01a02425165a4c04ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1MzA1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566353057", "bodyText": "I went for postProcess.", "author": "bpintea", "createdAt": "2021-01-28T19:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4Njk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NzU4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566087586", "bodyText": "If you don't this to be subclass because of the dedicated method, consider making it final.", "author": "costin", "createdAt": "2021-01-28T13:20:43Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1221,7 +1245,7 @@ static Expression safeMaybeFold(Expression expression) {\n             }\n \n             // can it be quickly fast-tracked that the operation can't be reduced?\n-            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            boolean isUnsafe(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "originalCommit": "a3b66c85e72e691520e1ef01a02425165a4c04ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1Mjk4OA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566352988", "bodyText": "Right, thanks, applied! Applicable to both class' main methods.", "author": "bpintea", "createdAt": "2021-01-28T19:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NzU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4ODQ0MA==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566088440", "bodyText": "how about check, doCheck without opSpecific?", "author": "costin", "createdAt": "2021-01-28T13:22:09Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();", "originalCommit": "a3b66c85e72e691520e1ef01a02425165a4c04ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1MzAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566353022", "bodyText": "Updated.", "author": "bpintea", "createdAt": "2021-01-28T19:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4ODQ0MA=="}], "type": "inlineReview"}, {"oid": "8eee4eab81b3a49a39ba31319e2b75169e5892e9", "url": "https://github.com/elastic/elasticsearch/commit/8eee4eab81b3a49a39ba31319e2b75169e5892e9", "message": "Address review comments\n\n- rename methods;\n- add comments.", "committedDate": "2021-01-28T19:21:23Z", "type": "commit"}, {"oid": "053fcde61acadf9e05883696608268495813eaaa", "url": "https://github.com/elastic/elasticsearch/commit/053fcde61acadf9e05883696608268495813eaaa", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-01-28T19:23:32Z", "type": "commit"}, {"oid": "1c7781f78703f6bbe35e7d9ef7f4358f6cf488b7", "url": "https://github.com/elastic/elasticsearch/commit/1c7781f78703f6bbe35e7d9ef7f4358f6cf488b7", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc", "committedDate": "2021-02-01T17:03:22Z", "type": "commit"}, {"oid": "28ba3e53c69ac9f3ab2e5d68f7e682d580c91f35", "url": "https://github.com/elastic/elasticsearch/commit/28ba3e53c69ac9f3ab2e5d68f7e682d580c91f35", "message": "Adjust merging outcome for one test\n\nBoth upstream and current branch updated line in the same way\n(incrementing a count), so merging left it unchanged. However the net\nresult needs to reflect both modifications (i.e. inc by two).", "committedDate": "2021-02-01T17:33:10Z", "type": "commit"}, {"oid": "18c11be501c87c8a9e6c0e74b589ccc33fe91563", "url": "https://github.com/elastic/elasticsearch/commit/18c11be501c87c8a9e6c0e74b589ccc33fe91563", "message": "Merge branch 'master' into enh/optimize_arithm_in_bc", "committedDate": "2021-02-01T17:35:24Z", "type": "commit"}]}