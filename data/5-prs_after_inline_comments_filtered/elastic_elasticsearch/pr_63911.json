{"pr_number": 63911, "pr_title": "Make Searchable Snapshot's CacheFile Lock less", "pr_createdAt": "2020-10-20T08:34:29Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63911", "timeline": [{"oid": "f0127feb19a38c4a9e9e7ecc09c3a44dd58cd190", "url": "https://github.com/elastic/elasticsearch/commit/f0127feb19a38c4a9e9e7ecc09c3a44dd58cd190", "message": "Make Searchable Snapshot's CacheFile Lock less\n\nReplacing the mechanism for eviction and listener references via a read-write lock by\na reference counting implementation.\nThis fixes a bug that caused test failure #63586 in which concurrently trying to acquire or release\nan eviction listener while doing a file operation would sometimes lead to throwing an exception\nsince the `tryLock` call on the read lock would fail in this case.\nAlso this removes the possibility of blocking cluster state updates as a result of them waiting\non the write-lock which might take a long time if a slow read operation executes concurrently.\n\nCloses #63586", "committedDate": "2020-10-20T08:32:19Z", "type": "commit"}, {"oid": "bb98de30e1bb7f80b57b695c802b75520639306a", "url": "https://github.com/elastic/elasticsearch/commit/bb98de30e1bb7f80b57b695c802b75520639306a", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking", "committedDate": "2020-10-20T09:17:43Z", "type": "commit"}, {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49", "url": "https://github.com/elastic/elasticsearch/commit/b9e909544ab8e3fe245e22b87f6e48310ae29d49", "message": "nicer", "committedDate": "2020-10-20T09:21:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MjIyOA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508352228", "bodyText": "By moving access to the file channel to a ref-counted basis and giving the channel its own life-cycle, we can remove all need for locking when dealing with file closing and opening.\nBackground operations running for index inputs that get closed concurrently are tied to a specific instance of this reference and will simply fail once all references to the channel have been released since they won't be able to acquire a reference to the channel again.", "author": "original-brownbear", "createdAt": "2020-10-20T09:32:26Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -42,37 +40,60 @@\n         StandardOpenOption.CREATE,\n         StandardOpenOption.SPARSE };\n \n+    /**\n+     * Reference counter that counts the number of eviction listeners referencing to this cache file. Once this instance has been evicted\n+     * and all listeners notified it makes sure to delete the physical file backing this cache.\n+     */\n     private final AbstractRefCounted refCounter = new AbstractRefCounted(\"CacheFile\") {\n         @Override\n         protected void closeInternal() {\n-            CacheFile.this.finishEviction();\n+            assert assertNoPendingListeners();\n+            try {\n+                Files.deleteIfExists(file);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n         }\n     };\n \n-    private final ReentrantReadWriteLock.WriteLock evictionLock;\n-    private final ReentrantReadWriteLock.ReadLock readLock;\n-\n     private final SparseFileTracker tracker;\n     private final String description;\n     private final Path file;\n \n-    private volatile Set<EvictionListener> listeners;\n-    private volatile boolean evicted;\n+    private final Set<EvictionListener> listeners = new HashSet<>();\n+\n+    /**\n+     * A reference counted holder for the current channel to the physical file backing this cache file instance.\n+     */\n+    private static final class FileChannelReference extends AbstractRefCounted {", "originalCommit": "b9e909544ab8e3fe245e22b87f6e48310ae29d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMDAzNw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508430037", "bodyText": "Would you like to add your comment to the Javadoc?", "author": "tlrx", "createdAt": "2020-10-20T11:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MjIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MDk1MA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508560950", "bodyText": "Sure done :)", "author": "original-brownbear", "createdAt": "2020-10-20T14:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MjIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1NDA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508354091", "bodyText": "There's no need for a volatile and immutable set of listeners here. We never accessed the listeners outside of the lock so we can simply mutate them in place.\nI made this clearer now by using the listeners set as the mutex for all operations that apply to the set and the channel opening/closing that is a result of the set size.", "author": "original-brownbear", "createdAt": "2020-10-20T09:35:16Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -113,22 +117,20 @@ public boolean acquire(final EvictionListener listener) throws IOException {\n         ensureOpen();\n         boolean success = false;\n         if (refCounter.tryIncRef()) {\n-            evictionLock.lock();\n             try {\n-                ensureOpen();\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean added = newListeners.add(listener);\n-                assert added : \"listener already exists \" + listener;\n-                maybeOpenFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n+                synchronized (listeners) {\n+                    ensureOpen();\n+                    final boolean added = listeners.add(listener);", "originalCommit": "b9e909544ab8e3fe245e22b87f6e48310ae29d49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1NTI0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508355242", "bodyText": "I found this a lot cleaner and easier to reason about than checking the value of this boolean twice with tricky locking and the cost of the atomic reference relative to the volatile boolean should be trivial.", "author": "original-brownbear", "createdAt": "2020-10-20T09:37:00Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -140,96 +142,63 @@ public boolean release(final EvictionListener listener) {\n         assert listener != null;\n \n         boolean success = false;\n-        evictionLock.lock();\n         try {\n-            try {\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean removed = newListeners.remove(Objects.requireNonNull(listener));\n+            synchronized (listeners) {\n+                final boolean removed = listeners.remove(Objects.requireNonNull(listener));\n                 assert removed : \"listener does not exist \" + listener;\n                 if (removed == false) {\n                     throw new IllegalStateException(\"Cannot remove an unknown listener\");\n                 }\n-                maybeCloseFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n-                success = true;\n-            } finally {\n-                if (success) {\n-                    refCounter.decRef();\n+                if (listeners.isEmpty()) {\n+                    // nobody is using this file so we close the channel\n+                    channelRef.decRef();\n+                    channelRef = null;\n                 }\n             }\n+            success = true;\n         } finally {\n-            evictionLock.unlock();\n+            if (success) {\n+                refCounter.decRef();\n+            }\n         }\n         assert invariant();\n         return success;\n     }\n \n-    private void finishEviction() {\n-        assert evictionLock.isHeldByCurrentThread();\n-        assert listeners.isEmpty();\n-        assert channel == null;\n-        try {\n-            Files.deleteIfExists(file);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+    private boolean assertNoPendingListeners() {\n+        synchronized (listeners) {\n+            assert listeners.isEmpty();\n+            assert channelRef == null;\n         }\n+        return true;\n     }\n \n+    /**\n+     * Evicts this file from the cache. Once this method has been called, subsequent use of this class with throw exceptions.\n+     */\n     public void startEviction() {\n-        if (evicted == false) {\n-            final Set<EvictionListener> evictionListeners = new HashSet<>();\n-            evictionLock.lock();\n-            try {\n-                if (evicted == false) {\n-                    evicted = true;\n-                    evictionListeners.addAll(listeners);\n-                    refCounter.decRef();\n-                }\n-            } finally {\n-                evictionLock.unlock();\n+        if (evicted.compareAndSet(false, true)) {", "originalCommit": "b9e909544ab8e3fe245e22b87f6e48310ae29d49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0b02e74c58d86017c46495aab1536cc97955c2fb", "url": "https://github.com/elastic/elasticsearch/commit/0b02e74c58d86017c46495aab1536cc97955c2fb", "message": "missing comment", "committedDate": "2020-10-20T09:39:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1ODYzMw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508358633", "bodyText": "This lock seems pointless to me and was causing trouble. If an eviction of the current file is concurrently started, all that happened here was that we would block that eviction when as far as I can tell we should simply fail the cache population as it's just wasted effort anyway as soon as the eviction hits?", "author": "original-brownbear", "createdAt": "2020-10-20T09:42:13Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -498,34 +496,19 @@ public void prefetchPart(final int part) throws IOException {\n                     // We do not actually read anything, but we want to wait for the write to complete before proceeding.\n                     // noinspection UnnecessaryLocalVariable\n                     final Tuple<Long, Long> rangeToRead = rangeToWrite;\n-\n-                    try (Releasable ignored = cacheFile.fileLock()) {", "originalCommit": "0b02e74c58d86017c46495aab1536cc97955c2fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1OTM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508359398", "bodyText": "Same argument as in the other spot where I removed use of this method, what's the point of locking here when all we do is make the cache file be used after eviction has already been started, meaning all the writes going into it are wasted anyway?", "author": "original-brownbear", "createdAt": "2020-10-20T09:43:22Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -164,193 +164,191 @@ protected void readInternal(ByteBuffer b) throws IOException {\n \n         try {\n             final CacheFile cacheFile = getCacheFileSafe();\n-            try (Releasable ignored = cacheFile.fileLock()) {", "originalCommit": "0b02e74c58d86017c46495aab1536cc97955c2fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NzE3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508457171", "bodyText": "The point was to keep the file around in order to be able to process any concurrent read operation (if any) that would have required a gap to be filled. But there was no reason to prevent other listeners to be acquired nor an eviction to kick in. Your change improves all of that.", "author": "tlrx", "createdAt": "2020-10-20T12:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1OTM5OA=="}], "type": "inlineReview"}, {"oid": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b", "url": "https://github.com/elastic/elasticsearch/commit/b90b9cba3e54eb130575ad1f2548dae1df4aba1b", "message": "even better", "committedDate": "2020-10-20T09:54:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMDQ2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508430467", "bodyText": "Can you add the current file path to the description?", "author": "tlrx", "createdAt": "2020-10-20T11:41:35Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -42,37 +40,60 @@\n         StandardOpenOption.CREATE,\n         StandardOpenOption.SPARSE };\n \n+    /**\n+     * Reference counter that counts the number of eviction listeners referencing to this cache file. Once this instance has been evicted\n+     * and all listeners notified it makes sure to delete the physical file backing this cache.\n+     */\n     private final AbstractRefCounted refCounter = new AbstractRefCounted(\"CacheFile\") {\n         @Override\n         protected void closeInternal() {\n-            CacheFile.this.finishEviction();\n+            assert assertNoPendingListeners();\n+            try {\n+                Files.deleteIfExists(file);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n         }\n     };\n \n-    private final ReentrantReadWriteLock.WriteLock evictionLock;\n-    private final ReentrantReadWriteLock.ReadLock readLock;\n-\n     private final SparseFileTracker tracker;\n     private final String description;\n     private final Path file;\n \n-    private volatile Set<EvictionListener> listeners;\n-    private volatile boolean evicted;\n+    private final Set<EvictionListener> listeners = new HashSet<>();\n+\n+    /**\n+     * A reference counted holder for the current channel to the physical file backing this cache file instance.\n+     */\n+    private static final class FileChannelReference extends AbstractRefCounted {\n+\n+        private final FileChannel fileChannel;\n+\n+        FileChannelReference(Path file) throws IOException {\n+            super(\"FileChannel\");", "originalCommit": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MDgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508560823", "bodyText": "done", "author": "original-brownbear", "createdAt": "2020-10-20T14:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMDQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMTE2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508431161", "bodyText": "Can you make this method package protected and add a comment indicating that it is just used in test now?", "author": "tlrx", "createdAt": "2020-10-20T11:42:52Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -84,27 +105,10 @@ public Path getFile() {\n         return file;\n     }\n \n-    Releasable fileLock() {\n-        boolean success = false;\n-        readLock.lock();\n-        try {\n-            ensureOpen();\n-            // check if we have a channel while holding the read lock\n-            if (channel == null) {\n-                throw new AlreadyClosedException(\"Cache file channel has been released and closed\");\n-            }\n-            success = true;\n-            return readLock::unlock;\n-        } finally {\n-            if (success == false) {\n-                readLock.unlock();\n-            }\n-        }\n-    }\n-\n     @Nullable\n     public FileChannel getChannel() {", "originalCommit": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODI3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508438279", "bodyText": "I'm not sure why this ensureOpen() has been added here? It could be added before the for loop so that we fail all gaps directly, otherwise it should be included within the next try/catch block but it's already present there.", "author": "tlrx", "createdAt": "2020-10-20T11:55:29Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -306,21 +276,18 @@ private void ensureOpen() {\n                     @Override\n                     protected void doRun() {\n                         for (SparseFileTracker.Gap gap : gaps) {\n+                            ensureOpen();", "originalCommit": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1ODQzNA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508558434", "bodyText": "My bad, this was a leftover from a previous attempt to fix the implementation that used locking. Will remove :)", "author": "original-brownbear", "createdAt": "2020-10-20T14:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODI3OQ=="}], "type": "inlineReview"}, {"oid": "5046e52484462c64372f0c66ee63c80fa299a2cd", "url": "https://github.com/elastic/elasticsearch/commit/5046e52484462c64372f0c66ee63c80fa299a2cd", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking", "committedDate": "2020-10-20T14:22:55Z", "type": "commit"}, {"oid": "84331a07ec617e8f7574b23d5579f76f28ca7b44", "url": "https://github.com/elastic/elasticsearch/commit/84331a07ec617e8f7574b23d5579f76f28ca7b44", "message": "CR: comments", "committedDate": "2020-10-20T14:31:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMDA5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508600095", "bodyText": "Add assert channelRef.recCount() == 0?", "author": "henningandersen", "createdAt": "2020-10-20T15:19:38Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -140,96 +149,63 @@ public boolean release(final EvictionListener listener) {\n         assert listener != null;\n \n         boolean success = false;\n-        evictionLock.lock();\n         try {\n-            try {\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean removed = newListeners.remove(Objects.requireNonNull(listener));\n+            synchronized (listeners) {\n+                final boolean removed = listeners.remove(Objects.requireNonNull(listener));\n                 assert removed : \"listener does not exist \" + listener;\n                 if (removed == false) {\n                     throw new IllegalStateException(\"Cannot remove an unknown listener\");\n                 }\n-                maybeCloseFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n-                success = true;\n-            } finally {\n-                if (success) {\n-                    refCounter.decRef();\n+                if (listeners.isEmpty()) {\n+                    // nobody is using this file so we close the channel\n+                    channelRef.decRef();\n+                    channelRef = null;", "originalCommit": "84331a07ec617e8f7574b23d5579f76f28ca7b44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzODY0MA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508638640", "bodyText": "We can't assert that. We could still be using that specific channel in a background operation. This fact is to some degree at the heart of what motivated this PR: we don't want to lock here and wait for all the background fetchers/warmers etc. to be done with the file so we don't have to block and instead have the last of them to finish its work close it.", "author": "original-brownbear", "createdAt": "2020-10-20T15:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMDA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNjE4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509116187", "bodyText": "Thanks, I wonder if we should then just change the comment a few lines up to not say \"close\" (or just remove the comment), at least that is what confused me.", "author": "henningandersen", "createdAt": "2020-10-21T09:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMDA5NQ=="}], "type": "inlineReview"}, {"oid": "41b2c2fd0d93eb9aa1dd3ba5e95a676737263c8f", "url": "https://github.com/elastic/elasticsearch/commit/41b2c2fd0d93eb9aa1dd3ba5e95a676737263c8f", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking", "committedDate": "2020-10-21T02:36:22Z", "type": "commit"}, {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "url": "https://github.com/elastic/elasticsearch/commit/3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "message": "better test and fix", "committedDate": "2020-10-21T04:57:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzOTYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509039629", "bodyText": "This could potentially be a stale value since we read it un-synchronized.", "author": "henningandersen", "createdAt": "2020-10-21T07:11:44Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -244,7 +227,7 @@ public String toString() {\n             + \", length=\"\n             + tracker.getLength()\n             + \", channel=\"\n-            + (channel != null ? \"yes\" : \"no\")\n+            + (channelRef != null ? \"yes\" : \"no\")\n             + \", listeners=\"\n             + listeners.size()", "originalCommit": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE5NDI4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509194282", "bodyText": "I think that's fine, it's a volatile field so it's not going to be totally out of whack and the behavior is the same we had so far? Not great maybe but even if we sync on listeners I think we won't get a completely consistent view of things as we have no lock over all the fields used here (the evicted can still change async) so maybe it's not worth it? (my main contention with adding locking is that it would mess with debugging in potentially by introducing a new barrier depending on log settings)", "author": "original-brownbear", "createdAt": "2020-10-21T11:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzOTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxNjE2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510416169", "bodyText": "I believe listeners is no longer volatile with this PR? So could in theory be unboundedly wrong.\nAlso in theory, HashSet implementation could evolve in ways that make this fail in bad ways when concurrently modifying the listeners set (though hard to imagine it would ever do so).\nIt is fine that it is out of sync with the rest of the fields.\nAn option is to copy out the size to a separate volatile variable when modifying the set, this avoids the need to lock in toString.", "author": "henningandersen", "createdAt": "2020-10-22T19:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzOTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYzNTQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510635439", "bodyText": "Urgh you're right I totally forgot that listeners isn't volatile any longer. I'll just synchronize this method on listeners for now as we do in all other spots where we touch listeners, it's just the only consistent way of doing things with the way it's implemented now IMO. It's probably not too necessary to do anything more complicated just for debugging purposes?", "author": "original-brownbear", "createdAt": "2020-10-23T05:54:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzOTYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0ODAyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509048029", "bodyText": "I believe this will silently ignore exceptions from reference.decRef. While that is currently only fileChannel.close(), it does look trappy, in particular because we keenly rethrow IOException in FileChannelReference.closeInternal.\nI wonder if it was more intuitive to \"just\" ensure we decRef the FileChannelReference appropriately in the two call-sites?\nAs a side-note, it would be nice to let populateAndRead just return a Future, makes it more easy to reason about the code, since then the callers cannot complete the future.", "author": "henningandersen", "createdAt": "2020-10-21T07:26:43Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -374,6 +356,27 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    /**\n+     * Get the reference to the currently open file channel for this cache file for a read operation\n+     *\n+     * @param future completable future to complete after the read operation finished\n+     * @return file channel reference\n+     */\n+    private FileChannelReference getFileChannelReference(CompletableFuture<Integer> future) {\n+        final FileChannelReference reference;\n+        synchronized (listeners) {\n+            ensureOpen();\n+            reference = channelRef;\n+            assert reference.refCount() > 0 : \"impossible to run into a fully released channel reference under the listeners mutex\";\n+            reference.incRef();\n+            future.handle((res, t) -> {", "originalCommit": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxMjYwNg==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509212606", "bodyText": "I wonder if it was more intuitive to \"just\" ensure we decRef the FileChannelReference appropriately in the two call-sites?\n\nYea it's quite annoying to code this up (just adds a lot of random code) actually but let's do it for correctness :)", "author": "original-brownbear", "createdAt": "2020-10-21T11:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0ODAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyOTE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509229157", "bodyText": "Refactored this in d5eb341 now to manually release the ref instead of using the future. Let me know what you think. I was able to keep it reasonably dry and clean I hope :)", "author": "original-brownbear", "createdAt": "2020-10-21T12:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0ODAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTI0OA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509055248", "bodyText": "nit: This is already checked inside getFileChannelReference (and must be).\nHaving it twice means we could get the exception either directly or on the future. I would prefer to just leave it out here, but is a small thing.", "author": "henningandersen", "createdAt": "2020-10-21T07:38:52Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -285,11 +268,12 @@ private void ensureOpen() {\n         final RangeMissingHandler writer,\n         final Executor executor\n     ) {\n+        ensureOpen();", "originalCommit": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA2NDkyMw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509064923", "bodyText": "also assert that reference != null and refCounter.refCount() > 0?", "author": "henningandersen", "createdAt": "2020-10-21T07:54:35Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -374,6 +356,27 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    /**\n+     * Get the reference to the currently open file channel for this cache file for a read operation\n+     *\n+     * @param future completable future to complete after the read operation finished\n+     * @return file channel reference\n+     */\n+    private FileChannelReference getFileChannelReference(CompletableFuture<Integer> future) {\n+        final FileChannelReference reference;\n+        synchronized (listeners) {\n+            ensureOpen();\n+            reference = channelRef;\n+            assert reference.refCount() > 0 : \"impossible to run into a fully released channel reference under the listeners mutex\";", "originalCommit": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyMjE3MA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509222170", "bodyText": "++", "author": "original-brownbear", "createdAt": "2020-10-21T12:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA2NDkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNzg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509117844", "bodyText": "nit: I think this can go outside the synchronized block? Not that I have a case where it makes a difference though...", "author": "henningandersen", "createdAt": "2020-10-21T09:11:39Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -140,96 +156,63 @@ public boolean release(final EvictionListener listener) {\n         assert listener != null;\n \n         boolean success = false;\n-        evictionLock.lock();\n         try {\n-            try {\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean removed = newListeners.remove(Objects.requireNonNull(listener));\n+            synchronized (listeners) {\n+                final boolean removed = listeners.remove(Objects.requireNonNull(listener));\n                 assert removed : \"listener does not exist \" + listener;\n                 if (removed == false) {\n                     throw new IllegalStateException(\"Cannot remove an unknown listener\");\n                 }\n-                maybeCloseFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n-                success = true;\n-            } finally {\n-                if (success) {\n-                    refCounter.decRef();\n+                if (listeners.isEmpty()) {\n+                    // nobody is using this file so we close the channel\n+                    channelRef.decRef();\n+                    channelRef = null;\n                 }\n             }\n+            success = true;\n         } finally {\n-            evictionLock.unlock();\n+            if (success) {\n+                refCounter.decRef();\n+            }\n         }\n         assert invariant();\n         return success;\n     }\n \n-    private void finishEviction() {\n-        assert evictionLock.isHeldByCurrentThread();\n-        assert listeners.isEmpty();\n-        assert channel == null;\n-        try {\n-            Files.deleteIfExists(file);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+    private boolean assertNoPendingListeners() {\n+        synchronized (listeners) {\n+            assert listeners.isEmpty();\n+            assert channelRef == null;\n         }\n+        return true;\n     }\n \n+    /**\n+     * Evicts this file from the cache. Once this method has been called, subsequent use of this class with throw exceptions.\n+     */\n     public void startEviction() {\n-        if (evicted == false) {\n-            final Set<EvictionListener> evictionListeners = new HashSet<>();\n-            evictionLock.lock();\n-            try {\n-                if (evicted == false) {\n-                    evicted = true;\n-                    evictionListeners.addAll(listeners);\n-                    refCounter.decRef();\n-                }\n-            } finally {\n-                evictionLock.unlock();\n+        if (evicted.compareAndSet(false, true)) {\n+            final Set<EvictionListener> evictionListeners;\n+            synchronized (listeners) {\n+                evictionListeners = new HashSet<>(listeners);\n+                refCounter.decRef();", "originalCommit": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyMDI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509220270", "bodyText": "Right :) ... always good to not do some potentially long running file delete under a lock I guess :)", "author": "original-brownbear", "createdAt": "2020-10-21T12:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNzg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyNTI2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509125265", "bodyText": "This seems unchanged, but I find it slightly odd to have both the option of returning false from this method as well as throwing AlreadyClosedException when this CacheFile is being evicted. Am I missing something here?", "author": "henningandersen", "createdAt": "2020-10-21T09:22:16Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -113,22 +131,20 @@ public boolean acquire(final EvictionListener listener) throws IOException {\n         ensureOpen();\n         boolean success = false;\n         if (refCounter.tryIncRef()) {", "originalCommit": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyNjUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509226531", "bodyText": "Yea I'm not sure about this either. I think we should just always throw here, since the only way we could conceivably return false is if we evict between ensureOpen() and trying to increment the ref counter (which is close to impossible).\nMaybe change that in a follow-up though, could simplify this and also the release method which always returns true currently as well and can be simplified to a void.", "author": "original-brownbear", "createdAt": "2020-10-21T12:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyNTI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIzMzQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509233499", "bodyText": "Yes, I think this is a left over when the IndexInput tried to re-acquire a cache file if it failed to add itself as a listener. I guess we were just returning false at that time in case of eviction.\nAnyway, I'm +1 on throwing.", "author": "tlrx", "createdAt": "2020-10-21T12:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyNTI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyODUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509128516", "bodyText": "Can we also (sometimes, randomly) call readIfAvailableOrPending?", "author": "henningandersen", "createdAt": "2020-10-21T09:27:01Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -124,9 +130,40 @@ public void testDeleteOnCloseAfterLastRelease() throws Exception {\n         assertFalse(Files.exists(file));\n     }\n \n-    class TestEvictionListener implements EvictionListener {\n+    public void testConcurrentAccess() throws Exception {\n+        final Path file = createTempDir().resolve(\"file.cache\");\n+        final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(1, 100), file);\n+\n+        final TestEvictionListener evictionListener = new TestEvictionListener();\n+        assertTrue(cacheFile.acquire(evictionListener));\n+        final long length = cacheFile.getLength();\n+        final DeterministicTaskQueue deterministicTaskQueue = new DeterministicTaskQueue(\n+            builder().put(NODE_NAME_SETTING.getKey(), getTestName()).build(),\n+            random()\n+        );\n+        final ThreadPool threadPool = deterministicTaskQueue.getThreadPool();\n+        final CompletableFuture<Integer> readFuture = cacheFile.populateAndRead(", "originalCommit": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyNDg5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509224891", "bodyText": "sure thing adding it :)", "author": "original-brownbear", "createdAt": "2020-10-21T12:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyODUxNg=="}], "type": "inlineReview"}, {"oid": "bfa669f91c6a80bd10d0791e97d00f9bdd89b62f", "url": "https://github.com/elastic/elasticsearch/commit/bfa669f91c6a80bd10d0791e97d00f9bdd89b62f", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking", "committedDate": "2020-10-21T10:59:57Z", "type": "commit"}, {"oid": "fb4d8805ddfe111a0de930d1f72964ed11f8ef85", "url": "https://github.com/elastic/elasticsearch/commit/fb4d8805ddfe111a0de930d1f72964ed11f8ef85", "message": "drop pointless check", "committedDate": "2020-10-21T11:18:40Z", "type": "commit"}, {"oid": "d5eb341a775fdb05f9cb8f3c07e81dd07252e034", "url": "https://github.com/elastic/elasticsearch/commit/d5eb341a775fdb05f9cb8f3c07e81dd07252e034", "message": "CR: comments", "committedDate": "2020-10-21T12:17:03Z", "type": "commit"}, {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f", "url": "https://github.com/elastic/elasticsearch/commit/bd547ee8aeeca878340d34b10119eed33f34600f", "message": "spotless", "committedDate": "2020-10-21T12:18:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MjM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510242350", "bodyText": "Looking at this again I think that gap.onCompletion(); should be executed within the try/finally block, before the reference is decremented, as completing the gap might trigger the execution of some listeners.", "author": "tlrx", "createdAt": "2020-10-22T15:11:48Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -307,20 +289,16 @@ private void ensureOpen() {\n                     protected void doRun() {\n                         for (SparseFileTracker.Gap gap : gaps) {\n                             try {\n-                                ensureOpen();\n-                                if (readLock.tryLock() == false) {\n-                                    throw new AlreadyClosedException(\"Cache file channel is being evicted, writing attempt cancelled\");\n+                                if (reference.tryIncRef() == false) {\n+                                    throw new AlreadyClosedException(\"Cache file channel has been released and closed\");\n                                 }\n                                 try {\n                                     ensureOpen();\n-                                    if (channel == null) {\n-                                        throw new AlreadyClosedException(\"Cache file channel has been released and closed\");\n-                                    }\n-                                    writer.fillCacheRange(channel, gap.start(), gap.end(), gap::onProgress);\n-                                    gap.onCompletion();\n+                                    writer.fillCacheRange(reference.fileChannel, gap.start(), gap.end(), gap::onProgress);\n                                 } finally {\n-                                    readLock.unlock();\n+                                    reference.decRef();\n                                 }\n+                                gap.onCompletion();", "originalCommit": "bd547ee8aeeca878340d34b10119eed33f34600f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MDAzNw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510250037", "bodyText": "I think we have this covered by the fact that we increment the reference by one anyway in getFileChannelReference so unless we are in some broken state where the overall listener got failed async (maybe that's impossible even?) the ref counting here is actually redundant.\nI actually added the ref counting in getFileChannelReference to cover this exact spot so we're not without a reference when completing the listener. (I suppose we could do away with the incrementing in getFileChannelReference and decrementing after if we made this change, but it seemed easier to reason about the way it currently is but maybe that's just me?)", "author": "original-brownbear", "createdAt": "2020-10-22T15:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MjM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1OTAyNg==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510259026", "bodyText": "Yes, sorry, I've been puzzled a minute by the decRef following by the gap's completion instead of the other way around... sorry for the noise you can ignore my comment.", "author": "tlrx", "createdAt": "2020-10-22T15:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MjM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxOTMyMA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510419320", "bodyText": "nit: Maybe we should call this acquireFileChannelReference to make it excplicit that it does incRef, requiring the caller to decRef?", "author": "henningandersen", "createdAt": "2020-10-22T19:55:13Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -349,31 +327,72 @@ public void onFailure(Exception e) {\n      *         target range is neither available nor pending.\n      */\n     @Nullable\n-    CompletableFuture<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n+    Future<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n         final CompletableFuture<Integer> future = new CompletableFuture<>();\n+        Releasable decrementRef = null;\n         try {\n-            ensureOpen();\n-            if (tracker.waitForRangeIfPending(rangeToRead, ActionListener.wrap(success -> {\n-                final int read = reader.onRangeAvailable(channel);\n-                assert read == rangeToRead.v2() - rangeToRead.v1() : \"partial read [\"\n-                    + read\n-                    + \"] does not match the range to read [\"\n-                    + rangeToRead.v2()\n-                    + '-'\n-                    + rangeToRead.v1()\n-                    + ']';\n-                future.complete(read);\n-            }, future::completeExceptionally))) {\n+            final FileChannelReference reference = getFileChannelReference();\n+            decrementRef = Releasables.releaseOnce(reference::decRef);\n+            if (tracker.waitForRangeIfPending(rangeToRead, rangeListener(rangeToRead, reader, future, reference, decrementRef))) {\n                 return future;\n             } else {\n+                // complete the future to release the channel reference\n+                decrementRef.close();\n                 return null;\n             }\n         } catch (Exception e) {\n-            future.completeExceptionally(e);\n+            releaseAndFail(future, decrementRef, e);\n             return future;\n         }\n     }\n \n+    private static void releaseAndFail(CompletableFuture<Integer> future, Releasable decrementRef, Exception e) {\n+        try {\n+            Releasables.close(decrementRef);\n+        } catch (Exception ex) {\n+            e.addSuppressed(ex);\n+        }\n+        future.completeExceptionally(e);\n+    }\n+\n+    private static ActionListener<Void> rangeListener(\n+        Tuple<Long, Long> rangeToRead,\n+        RangeAvailableHandler reader,\n+        CompletableFuture<Integer> future,\n+        FileChannelReference reference,\n+        Releasable releasable\n+    ) {\n+        return ActionListener.runAfter(ActionListener.wrap(success -> {\n+            final int read = reader.onRangeAvailable(reference.fileChannel);\n+            assert read == rangeToRead.v2() - rangeToRead.v1() : \"partial read [\"\n+                + read\n+                + \"] does not match the range to read [\"\n+                + rangeToRead.v2()\n+                + '-'\n+                + rangeToRead.v1()\n+                + ']';\n+            future.complete(read);\n+        }, future::completeExceptionally), releasable::close);\n+    }\n+\n+    /**\n+     * Get the reference to the currently open file channel for this cache file for a read operation\n+     *\n+     * @return file channel reference\n+     */\n+    private FileChannelReference getFileChannelReference() {", "originalCommit": "bd547ee8aeeca878340d34b10119eed33f34600f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYzNTk3NA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510635974", "bodyText": "++", "author": "original-brownbear", "createdAt": "2020-10-23T05:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxOTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxOTY4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510419682", "bodyText": "This comment should be removed now.", "author": "henningandersen", "createdAt": "2020-10-22T19:55:57Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -349,31 +327,72 @@ public void onFailure(Exception e) {\n      *         target range is neither available nor pending.\n      */\n     @Nullable\n-    CompletableFuture<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n+    Future<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n         final CompletableFuture<Integer> future = new CompletableFuture<>();\n+        Releasable decrementRef = null;\n         try {\n-            ensureOpen();\n-            if (tracker.waitForRangeIfPending(rangeToRead, ActionListener.wrap(success -> {\n-                final int read = reader.onRangeAvailable(channel);\n-                assert read == rangeToRead.v2() - rangeToRead.v1() : \"partial read [\"\n-                    + read\n-                    + \"] does not match the range to read [\"\n-                    + rangeToRead.v2()\n-                    + '-'\n-                    + rangeToRead.v1()\n-                    + ']';\n-                future.complete(read);\n-            }, future::completeExceptionally))) {\n+            final FileChannelReference reference = getFileChannelReference();\n+            decrementRef = Releasables.releaseOnce(reference::decRef);\n+            if (tracker.waitForRangeIfPending(rangeToRead, rangeListener(rangeToRead, reader, future, reference, decrementRef))) {\n                 return future;\n             } else {\n+                // complete the future to release the channel reference", "originalCommit": "bd547ee8aeeca878340d34b10119eed33f34600f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzMjU2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510432565", "bodyText": "It would be nice in this case to randomly first invoke populateAndRead too - in order to get into the more interesting part of readIfAvailableOrPending involving the listener callback.", "author": "henningandersen", "createdAt": "2020-10-22T20:19:41Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -124,9 +130,47 @@ public void testDeleteOnCloseAfterLastRelease() throws Exception {\n         assertFalse(Files.exists(file));\n     }\n \n-    class TestEvictionListener implements EvictionListener {\n+    public void testConcurrentAccess() throws Exception {\n+        final Path file = createTempDir().resolve(\"file.cache\");\n+        final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(1, 100), file);\n+\n+        final TestEvictionListener evictionListener = new TestEvictionListener();\n+        assertTrue(cacheFile.acquire(evictionListener));\n+        final long length = cacheFile.getLength();\n+        final DeterministicTaskQueue deterministicTaskQueue = new DeterministicTaskQueue(\n+            builder().put(NODE_NAME_SETTING.getKey(), getTestName()).build(),\n+            random()\n+        );\n+        final ThreadPool threadPool = deterministicTaskQueue.getThreadPool();\n+        final Future<Integer> readFuture;\n+        if (randomBoolean()) {\n+            readFuture = cacheFile.readIfAvailableOrPending(Tuple.tuple(0L, length), channel -> Math.toIntExact(length));", "originalCommit": "bd547ee8aeeca878340d34b10119eed33f34600f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY0Mzc1NA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510643754", "bodyText": "++, added that and ran a few 10k iterations with it without failure :)", "author": "original-brownbear", "createdAt": "2020-10-23T06:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzMjU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MTExMw==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510441113", "bodyText": "Related to your discussion below I believe we could add:\nassert false : \"expected a non-closed channel reference\"", "author": "henningandersen", "createdAt": "2020-10-22T20:36:09Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -307,20 +289,16 @@ private void ensureOpen() {\n                     protected void doRun() {\n                         for (SparseFileTracker.Gap gap : gaps) {\n                             try {\n-                                ensureOpen();\n-                                if (readLock.tryLock() == false) {\n-                                    throw new AlreadyClosedException(\"Cache file channel is being evicted, writing attempt cancelled\");\n+                                if (reference.tryIncRef() == false) {\n+                                    throw new AlreadyClosedException(\"Cache file channel has been released and closed\");", "originalCommit": "bd547ee8aeeca878340d34b10119eed33f34600f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYzNjU5NA==", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510636594", "bodyText": "Yea that seems like a safe thing to try :) thanks!", "author": "original-brownbear", "createdAt": "2020-10-23T05:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MTExMw=="}], "type": "inlineReview"}, {"oid": "d2a66df5c05366f0d01f63fd1ee5a1cececbeefb", "url": "https://github.com/elastic/elasticsearch/commit/d2a66df5c05366f0d01f63fd1ee5a1cececbeefb", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking", "committedDate": "2020-10-23T05:50:11Z", "type": "commit"}, {"oid": "a9e58008c2f97e67fcd5811bf7e44bf705da7b4c", "url": "https://github.com/elastic/elasticsearch/commit/a9e58008c2f97e67fcd5811bf7e44bf705da7b4c", "message": "CR: comments", "committedDate": "2020-10-23T08:31:12Z", "type": "commit"}]}