{"pr_number": 66310, "pr_title": "Improve reusability of the invalidation counting cache wrapper", "pr_createdAt": "2020-12-15T01:33:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66310", "timeline": [{"oid": "d40782bcc3718fa08961c593275d74ae02c3faca", "url": "https://github.com/elastic/elasticsearch/commit/d40782bcc3718fa08961c593275d74ae02c3faca", "message": "WIP", "committedDate": "2020-12-15T00:53:20Z", "type": "commit"}, {"oid": "f9c21f48c4bcb4dbc41f98d77637c0898703e63d", "url": "https://github.com/elastic/elasticsearch/commit/f9c21f48c4bcb4dbc41f98d77637c0898703e63d", "message": "fix linting", "committedDate": "2020-12-15T01:37:14Z", "type": "commit"}, {"oid": "07e980456fc9222c4f2cc417cf0a8cd316095f62", "url": "https://github.com/elastic/elasticsearch/commit/07e980456fc9222c4f2cc417cf0a8cd316095f62", "message": "clean up", "committedDate": "2020-12-15T01:41:23Z", "type": "commit"}, {"oid": "b0ffa3f3f2f81be7159ada69c8efe601868af3b3", "url": "https://github.com/elastic/elasticsearch/commit/b0ffa3f3f2f81be7159ada69c8efe601868af3b3", "message": "checkstyle", "committedDate": "2020-12-15T01:44:00Z", "type": "commit"}, {"oid": "b8b4f35d6de66bb88771c43b016d7422f4e240cc", "url": "https://github.com/elastic/elasticsearch/commit/b8b4f35d6de66bb88771c43b016d7422f4e240cc", "message": "fix test", "committedDate": "2020-12-15T02:04:42Z", "type": "commit"}, {"oid": "0dbf16ec9fd02d3489734fbced5f51638ba0b0a1", "url": "https://github.com/elastic/elasticsearch/commit/0dbf16ec9fd02d3489734fbced5f51638ba0b0a1", "message": "Merge remote-tracking branch 'origin/master' into cache-clearing-refactor-privilege-store", "committedDate": "2020-12-15T02:04:55Z", "type": "commit"}, {"oid": "8696de5bf25c6137b7c41a2b913df9b4577e3e11", "url": "https://github.com/elastic/elasticsearch/commit/8696de5bf25c6137b7c41a2b913df9b4577e3e11", "message": "Merge remote-tracking branch 'origin/master' into cache-clearing-refactor-privilege-store", "committedDate": "2020-12-16T00:44:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODYyNDU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r568624577", "bodyText": "I think it would be easier to read if the count were the first parameter.", "author": "albertzaharovits", "createdAt": "2021-02-02T14:03:18Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CountingRunner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.util.concurrent.ReleasableLock;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * An utility class that keeps a counter when executing runnables.\n+ * It is designed to help minimizing the possibility of caching stable results in a {@link Cache}.\n+ */\n+public class CountingRunner {\n+\n+    private static final Logger logger = LogManager.getLogger(CountingRunner.class);\n+\n+    private final AtomicLong counter = new AtomicLong();\n+    private final ReadWriteLock countingLock = new ReentrantReadWriteLock();\n+    private final ReleasableLock countingReadLock = new ReleasableLock(countingLock.readLock());\n+    private final ReleasableLock countingWriteLock = new ReleasableLock(countingLock.writeLock());\n+\n+    public long getCount() {\n+        return counter.get();\n+    }\n+\n+    /**\n+     * Execute the given runnable if the internal counter matches the given count.\n+     * The counter check is performed inside a read-locking block to prevent incrementing of\n+     * the counter, i.e. call to {@link CountingRunner#incrementAndRun} will be blocked.\n+     * But it does *not* block other invocations of {@link CountingRunner#runIfCountMatches}.\n+     *\n+     * @return true if the runnable is executed, other false.\n+     */\n+    public boolean runIfCountMatches(Runnable runnable, long count) {", "originalCommit": "8696de5bf25c6137b7c41a2b913df9b4577e3e11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY1NzE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r568657159", "bodyText": "Maybe rename to compareAndRun? I think this name helps with the intuition from \"compare and swap\".\n\"counter\" is used too much so maybe drop it if there's a parameter with the name counter already.", "author": "albertzaharovits", "createdAt": "2021-02-02T14:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODYyNDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY1OTc5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r568659792", "bodyText": "Runnable -> CheckedRunnable, to avoid worrying about the checked/unchecked exceptions at this low level.", "author": "albertzaharovits", "createdAt": "2021-02-02T14:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODYyNDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY2NjIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r570666234", "bodyText": "Your analogy of AtomicInteger makes sense. The name compareAndRun also sounds good and to the point. The count parameter naturally should become the first parameter after the method name change to follow the convention of compareAndSet. Thanks!\nI decided to keep Runnable instead of changing it to CheckedRunnable. In fact, I started with CheckedRunnable, but I think it has a few disadvantages:\n\nIf we don't handle the exception of CheckedRunnable, the method would have a signature like:\npublic <E extends Exception> boolean compareAndRun(long count, CheckedRunnable<E> runnable) throws E\nIt forces its caller to handle exceptions even when the Runnable may not throw any exception (as in the NativePrivilegesStore case)\nIf we handle the exception inside the method and only bubble up RuntimeException, it will make the method easier to call because no exception handling is forced onto the caller. However, the method itself has no knowledge about he Runnable so it cannot perform meaningful handling other than maybe wrap it with a RuntimeException. It works, but makes it hard if the caller cares about the real exception and wants to handle it.\n\nMy understanding is that CheckedRunnable is better when possible exception types are limited and the method knows well how to handle (or ignore) them. Therefore, I prefer to just using Runnable. It works similar to above item 2, but giving caller full control of how exception should or should not be handled.", "author": "ywangd", "createdAt": "2021-02-05T01:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODYyNDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjA3OTU5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r576079592", "bodyText": "Okay, sounds good to me. It's not going to be a big difference in practice anyway.", "author": "albertzaharovits", "createdAt": "2021-02-15T10:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODYyNDU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY2MTk1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r568661955", "bodyText": "Executing the runnable parameter like this feels forced. I would simplify it by renaming this increment with no parameters.", "author": "albertzaharovits", "createdAt": "2021-02-02T14:50:04Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CountingRunner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.util.concurrent.ReleasableLock;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * An utility class that keeps a counter when executing runnables.\n+ * It is designed to help minimizing the possibility of caching stable results in a {@link Cache}.\n+ */\n+public class CountingRunner {\n+\n+    private static final Logger logger = LogManager.getLogger(CountingRunner.class);\n+\n+    private final AtomicLong counter = new AtomicLong();\n+    private final ReadWriteLock countingLock = new ReentrantReadWriteLock();\n+    private final ReleasableLock countingReadLock = new ReleasableLock(countingLock.readLock());\n+    private final ReleasableLock countingWriteLock = new ReleasableLock(countingLock.writeLock());\n+\n+    public long getCount() {\n+        return counter.get();\n+    }\n+\n+    /**\n+     * Execute the given runnable if the internal counter matches the given count.\n+     * The counter check is performed inside a read-locking block to prevent incrementing of\n+     * the counter, i.e. call to {@link CountingRunner#incrementAndRun} will be blocked.\n+     * But it does *not* block other invocations of {@link CountingRunner#runIfCountMatches}.\n+     *\n+     * @return true if the runnable is executed, other false.\n+     */\n+    public boolean runIfCountMatches(Runnable runnable, long count) {\n+        assert count >= 0 : \"Count must be non-negative\";\n+        try (ReleasableLock ignored = countingReadLock.acquire()) {\n+            if (count == counter.get()) {\n+                logger.debug(\"Count matches [{}], executing runnable\", count);\n+                runnable.run();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Increment the internal counter before executing the given runnable.\n+     * The counter is incremented in a write-locking block so that no other runnable\n+     * can be executed by methods of the same manager when the counter is being incremented.\n+     */\n+    public void incrementAndRun(Runnable runnable) {\n+        try (ReleasableLock ignored = countingWriteLock.acquire()) {\n+            counter.incrementAndGet();\n+        }\n+        runnable.run();", "originalCommit": "8696de5bf25c6137b7c41a2b913df9b4577e3e11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY2NjQyNg==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r570666426", "bodyText": "Good point! Updated!", "author": "ywangd", "createdAt": "2021-02-05T01:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY2MTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY5ODA2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r568698066", "bodyText": "As discussed, we both agree that encapsulating a cache inside this class is the wrong abstraction (which is InvalidationCountingCacheWrapper), although I struggle to put it in words in a comment.\nI still tend to have more ambitious hopes for this cache invalidation pattern, but I very much fear we can sunk in it and not achieve much.\nOverall, I think abstraction here is good enough!\nBut its rich history is showing in the description and in the names. We should polish these.\nI would think about this class as a special type of atomic integer, which has a fancy method \"run if integer constant\", such that the run block of code cannot overlap with changes (increments) to the integer.\nIt's hard to explain it's usage in the caching context, so I would steer away from it completely.\nFor example, we rely that changes to the underlying data (eg api key docs) are performed before calling increment and that we call getCount before we retrieve the underlying data, so that we ensure the sequence modify data -> increment -> getCount -> read data -> cache data .\nMy explicit suggestion is to rename to CounterCompare, or anythign else that inspires that the runnable and the counter cannot overlap.", "author": "albertzaharovits", "createdAt": "2021-02-02T15:33:43Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CountingRunner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.util.concurrent.ReleasableLock;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * An utility class that keeps a counter when executing runnables.\n+ * It is designed to help minimizing the possibility of caching stable results in a {@link Cache}.\n+ */\n+public class CountingRunner {", "originalCommit": "8696de5bf25c6137b7c41a2b913df9b4577e3e11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODcwMDM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r568700394", "bodyText": "Another suggestion, if you think this is unlikely to be used outside of caching contexts, it might be useful to make it a static inner class of Cache.", "author": "albertzaharovits", "createdAt": "2021-02-02T15:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY5ODA2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY3MDU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r570670543", "bodyText": "After some thoughts and taking your advice onboard, I came up with the name LockingAtomicCounter. It is an unexciting name, but I think it conveys the major idea here: a counter with RWLock to ensure its value stays the same until the reading side finishes its task.\nI think your analogy of AtomicInteger is a great one. In concept, compareAndSet and compareAndRun are very similiar. They are both executing some operation if the counter value matches the expectation. The only difference is that the operation of the former is a single setValue, but the later can have an arbitrary Runnable. This is also the reason that I went with the name of LockingAtomicCounter, which I hope makes its behaviour easier to understand.\nI updated the comments accordingly.\nAs for the location of this class, I'd prefer to have it stay inside xpack security for the time being because:\n\nThe usages that I can think of for now are security caches\nIt in theory operates at a higher level than a single cache, e.g. ApiKeyDocCache is a wrapper for two vanila caches.\nThe way it ends right now really does not say anything about caching anymore. So I have hope that it could still be useful elsewhere.", "author": "ywangd", "createdAt": "2021-02-05T02:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY5ODA2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjA3OTg2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/66310#discussion_r576079862", "bodyText": "I came up with the name LockingAtomicCounter\n\nSGTM", "author": "albertzaharovits", "createdAt": "2021-02-15T10:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODY5ODA2Ng=="}], "type": "inlineReview"}, {"oid": "07f6ae013b83a9f7bee21cca1bff32549d951808", "url": "https://github.com/elastic/elasticsearch/commit/07f6ae013b83a9f7bee21cca1bff32549d951808", "message": "Merge remote-tracking branch 'origin/master' into cache-clearing-refactor-privilege-store", "committedDate": "2021-02-05T00:22:40Z", "type": "commit"}, {"oid": "56a8c65b867b7d420d81ab70d05067fe18cb18fe", "url": "https://github.com/elastic/elasticsearch/commit/56a8c65b867b7d420d81ab70d05067fe18cb18fe", "message": "address feedback", "committedDate": "2021-02-05T01:49:24Z", "type": "commit"}, {"oid": "26e90fc2a94485721eb4447b34bb01c0a1eb8a12", "url": "https://github.com/elastic/elasticsearch/commit/26e90fc2a94485721eb4447b34bb01c0a1eb8a12", "message": "checkstyle", "committedDate": "2021-02-05T02:02:12Z", "type": "commit"}, {"oid": "ac12e786fc4063a7cdcb3aa704750261d99ecf68", "url": "https://github.com/elastic/elasticsearch/commit/ac12e786fc4063a7cdcb3aa704750261d99ecf68", "message": "Merge remote-tracking branch 'origin/master' into cache-clearing-refactor-privilege-store", "committedDate": "2021-02-15T22:19:52Z", "type": "commit"}, {"oid": "d21854e853a5b7b28f94d0db67d15ba80f06f510", "url": "https://github.com/elastic/elasticsearch/commit/d21854e853a5b7b28f94d0db67d15ba80f06f510", "message": "Merge remote-tracking branch 'origin/master' into cache-clearing-refactor-privilege-store", "committedDate": "2021-04-14T02:49:57Z", "type": "commit"}, {"oid": "48b1fee1b9ea9feb08a150bc074ed3271426e91b", "url": "https://github.com/elastic/elasticsearch/commit/48b1fee1b9ea9feb08a150bc074ed3271426e91b", "message": "Merge branch 'master' into cache-clearing-refactor-privilege-store", "committedDate": "2021-04-14T11:44:10Z", "type": "commit"}, {"oid": "934460964a223567f79c9a755e6c24d619498cc9", "url": "https://github.com/elastic/elasticsearch/commit/934460964a223567f79c9a755e6c24d619498cc9", "message": "Merge branch 'master' into cache-clearing-refactor-privilege-store", "committedDate": "2021-04-14T22:05:22Z", "type": "commit"}]}