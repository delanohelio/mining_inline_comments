{"pr_number": 53860, "pr_title": "Uncouple CacheDirectory from SearchableSnapshotDirectory", "pr_createdAt": "2020-03-20T12:04:23Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53860", "timeline": [{"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "url": "https://github.com/elastic/elasticsearch/commit/61c890780e746dbc9aa050a0e776908b8c7ebff3", "message": "CacheDirectory", "committedDate": "2020-03-20T10:29:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5MzM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395593350", "bodyText": "This abstract class has been introduced in order to contain common attributes of existing directories and in order to unify the existing constructors. It should become a concrete SearchableSnapshotDirectory when the cache logic and the searchable snapshot logic will be merged together.", "author": "tlrx", "createdAt": "2020-03-20T12:06:07Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotDirectory.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.index.store;\n+\n+import org.apache.lucene.store.BaseDirectory;\n+import org.apache.lucene.store.IOContext;\n+import org.apache.lucene.store.IndexOutput;\n+import org.apache.lucene.store.SingleInstanceLockFactory;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public abstract class BaseSearchableSnapshotDirectory extends BaseDirectory {", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDA1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395594055", "bodyText": "With this pull request, CacheDirectory reads blobs using the BlobContainer and does not need to wrap the SearchableSnapshotDirectory anymore.", "author": "tlrx", "createdAt": "2020-03-20T12:07:44Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -158,11 +79,13 @@ public static Directory create(RepositoriesService repositories,\n             SNAPSHOT_SNAPSHOT_ID_SETTING.get(indexSettings.getSettings()));\n         final BlobStoreIndexShardSnapshot snapshot = blobStoreRepository.loadShardSnapshot(blobContainer, snapshotId);\n \n-        Directory directory = new SearchableSnapshotDirectory(snapshot, blobContainer);\n+        final Directory directory;\n         if (SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings.getSettings())) {\n             final Path cacheDir = shardPath.getDataPath().resolve(\"snapshots\").resolve(snapshotId.getUUID());\n-            directory = new CacheDirectory(directory, cache, cacheDir, snapshotId, indexId, shardPath.getShardId(),\n+            directory = new CacheDirectory(snapshot, blobContainer, cache, cacheDir, snapshotId, indexId, shardPath.getShardId(),", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395644641", "bodyText": "\ud83d\udc4d", "author": "DaveCTurner", "createdAt": "2020-03-20T13:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDI1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395594259", "bodyText": "I'll revert this spotless formatting", "author": "tlrx", "createdAt": "2020-03-20T12:08:08Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotIndexInput.java", "diffHunk": "@@ -61,17 +60,21 @@\n     private static final long NO_SEQUENTIAL_READ_OPTIMIZATION = 0L;\n \n \n-    SearchableSnapshotIndexInput(final BlobContainer blobContainer, final FileInfo fileInfo, long sequentialReadSize, int bufferSize) {\n-        this(\"SearchableSnapshotIndexInput(\" + fileInfo.physicalName() + \")\", blobContainer, fileInfo, 0L, 0L, fileInfo.length(),\n+    SearchableSnapshotIndexInput(", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyMDQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395620498", "bodyText": "I for one welcome our new spotless overlords \ud83d\udc1c", "author": "DaveCTurner", "createdAt": "2020-03-20T13:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDUyMg==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395594522", "bodyText": "This is the main purpose of this pull request :)", "author": "tlrx", "createdAt": "2020-03-20T12:08:37Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -39,7 +43,7 @@\n /**\n  * {@link CacheDirectory} uses a {@link CacheService} to cache Lucene files provided by another {@link Directory}.\n  */\n-public class CacheDirectory extends FilterDirectory {\n+public class CacheDirectory extends BaseSearchableSnapshotDirectory {", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NTg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395595841", "bodyText": "There is an important change here: by reading the range to cache on disk using the BlobContainer only the required bytes are downloaded in a (usually) single request (unless the range spans over multiple blob parts) and there is no read ahead engaged here.", "author": "tlrx", "createdAt": "2020-03-20T12:11:25Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -287,23 +293,21 @@ int readCacheFile(FileChannel fc, long end, long position, byte[] buffer, int of\n         @SuppressForbidden(reason = \"Use positional writes on purpose\")\n         void writeCacheFile(FileChannel fc, long start, long end) throws IOException {\n             assert assertFileChannelOpen(fc);\n-            final byte[] copyBuffer = new byte[Math.toIntExact(Math.min(COPY_BUFFER_SIZE, end - start))];\n+            final long length = end - start;\n+            final byte[] copyBuffer = new byte[Math.toIntExact(Math.min(COPY_BUFFER_SIZE, length))];\n             logger.trace(() -> new ParameterizedMessage(\"writing range [{}-{}] to cache file [{}]\", start, end, cacheFileReference));\n \n             int bytesCopied = 0;\n-            try (IndexInput input = in.openInput(cacheFileReference.getFileName(), ioContext)) {\n+            final long startTimeNanos = currentTimeNanosSupplier.getAsLong();\n+            try (InputStream input = openInputStream(start, length)) {", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyMTEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395621101", "bodyText": "\ud83d\udc4d", "author": "DaveCTurner", "createdAt": "2020-03-20T13:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NTg0MQ=="}], "type": "inlineReview"}, {"oid": "6fa4928481988f2ad00463c319515a784cecc3be", "url": "https://github.com/elastic/elasticsearch/commit/6fa4928481988f2ad00463c319515a784cecc3be", "message": "Merge branch 'feature/searchable-snapshots' into cache-directory-use-blob-container", "committedDate": "2020-03-20T12:56:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYwODE2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395608161", "bodyText": "Can we assert false here too?", "author": "DaveCTurner", "createdAt": "2020-03-20T12:37:46Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotDirectory.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.index.store;\n+\n+import org.apache.lucene.store.BaseDirectory;\n+import org.apache.lucene.store.IOContext;\n+import org.apache.lucene.store.IndexOutput;\n+import org.apache.lucene.store.SingleInstanceLockFactory;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public abstract class BaseSearchableSnapshotDirectory extends BaseDirectory {\n+\n+    protected final BlobStoreIndexShardSnapshot snapshot;\n+    protected final BlobContainer blobContainer;\n+    private final AtomicBoolean closed;\n+\n+    public BaseSearchableSnapshotDirectory(BlobContainer blobContainer, BlobStoreIndexShardSnapshot snapshot) {\n+        super(new SingleInstanceLockFactory());\n+        this.snapshot = Objects.requireNonNull(snapshot);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.closed = new AtomicBoolean(false);\n+    }\n+\n+    protected final FileInfo fileInfo(final String name) throws FileNotFoundException {\n+        return snapshot.indexFiles()\n+            .stream()\n+            .filter(fileInfo -> fileInfo.physicalName().equals(name))\n+            .findFirst()\n+            .orElseThrow(() -> new FileNotFoundException(name));\n+    }\n+\n+    @Override\n+    public final String[] listAll() {\n+        ensureOpen();\n+        return snapshot.indexFiles().stream().map(FileInfo::physicalName).sorted(String::compareTo).toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public final long fileLength(final String name) throws IOException {\n+        ensureOpen();\n+        return fileInfo(name).length();\n+    }\n+\n+    @Override\n+    public Set<String> getPendingDeletions() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void sync(Collection<String> names) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void syncMetaData() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void deleteFile(String name) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createOutput(String name, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void rename(String source, String dest) {\n+        throw unsupportedException();\n+    }\n+\n+    private static UnsupportedOperationException unsupportedException() {\n+        return new UnsupportedOperationException(\"Searchable snapshot directory does not support this operation\");", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYwOTU5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395609594", "bodyText": "Could we do this already? Seems like it'd be nicer to use a ByteArrayIndexInput straight away.", "author": "DaveCTurner", "createdAt": "2020-03-20T12:40:49Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotIndexInput.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.index.store;\n+\n+import org.apache.lucene.store.BufferedIndexInput;\n+import org.apache.lucene.store.IOContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n+import org.elasticsearch.index.snapshots.blobstore.SlicedInputStream;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Objects;\n+\n+public abstract class BaseSearchableSnapshotIndexInput extends BufferedIndexInput {\n+\n+    protected final BlobContainer blobContainer;\n+    protected final FileInfo fileInfo;\n+    protected final IOContext context;\n+\n+    public BaseSearchableSnapshotIndexInput(String resourceDesc, BlobContainer blobContainer, FileInfo fileInfo, IOContext context) {\n+        super(resourceDesc, context);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.fileInfo = Objects.requireNonNull(fileInfo);\n+        this.context = Objects.requireNonNull(context);\n+    }\n+\n+    public BaseSearchableSnapshotIndexInput(\n+        String resourceDesc,\n+        BlobContainer blobContainer,\n+        FileInfo fileInfo,\n+        IOContext context,\n+        int bufferSize\n+    ) {\n+        this(resourceDesc, blobContainer, fileInfo, context);\n+        setBufferSize(bufferSize);\n+    }\n+\n+    protected InputStream openInputStream(final long position, final long length) throws IOException {\n+        // TODO move this at the Directory level", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDI1NA==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395644254", "bodyText": "We discussed this in another channel and decided to leave it for a followup in which we consolidate how we choose between all the different IndexInput implementations.", "author": "DaveCTurner", "createdAt": "2020-03-20T13:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYwOTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxODIzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395618231", "bodyText": "Can we assert that this isn't called and throw UnsupportedOperationException if it is? getBlobLength() looks expensive, and I don't think we actually call this do we?", "author": "DaveCTurner", "createdAt": "2020-03-20T12:58:00Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheBufferedIndexInputTests.java", "diffHunk": "@@ -56,145 +69,110 @@ public void testRandomReads() throws IOException {\n                     }\n                 }\n \n-                if (directory instanceof CountingDirectory) {\n+                if (blobContainer instanceof CountingBlobContainer) {\n                     long numberOfRanges = numberOfRanges(input.length, cacheService.getRangeSize());\n                     assertThat(\"Expected \" + numberOfRanges + \" ranges fetched from the source\",\n-                        ((CountingDirectory) directory).totalOpens.sum(), equalTo(numberOfRanges));\n+                        ((CountingBlobContainer) blobContainer).totalOpens.sum(), equalTo(numberOfRanges));\n                     assertThat(\"All bytes should have been read from source\",\n-                        ((CountingDirectory) directory).totalBytes.sum(), equalTo((long) input.length));\n+                        ((CountingBlobContainer) blobContainer).totalBytes.sum(), equalTo((long) input.length));\n                 }\n-\n-                directory.close();\n             }\n         }\n     }\n \n-    /**\n-     * FilterDirectory that provides a single IndexInput with a given name and content.\n-     */\n-    private static class SingleFileDirectory  extends FilterDirectory {\n-\n-        private final String fileName;\n-        private final byte[] fileContent;\n-\n-        SingleFileDirectory(final String fileName, final byte[] fileContent) {\n-            super(null);\n-            this.fileName = Objects.requireNonNull(fileName);\n-            this.fileContent = Objects.requireNonNull(fileContent);\n-        }\n-\n-        @Override\n-        public String[] listAll() {\n-            return new String[]{fileName};\n-        }\n-\n-        @Override\n-        public long fileLength(String name) throws IOException {\n-            if (name.equals(fileName)) {\n-                return fileContent.length;\n-            }\n-            throw new FileNotFoundException(name);\n-        }\n-\n-        @Override\n-        public IndexInput openInput(String name, IOContext context) throws IOException {\n-            if (name.equals(fileName)) {\n-                return new ByteArrayIndexInput(fileName, fileContent);\n-            }\n-            throw new FileNotFoundException(name);\n-        }\n-\n-        @Override\n-        public void close() {\n-        }\n-    }\n \n     /**\n-     * FilterDirectory that counts the number of IndexInput it opens, as well as the\n+     * BlobContainer that counts the number of {@link java.io.InputStream} it opens, as well as the\n      * total number of bytes read from them.\n      */\n-    private static class CountingDirectory extends FilterDirectory {\n+    private static class CountingBlobContainer extends BlobContainerWrapper {\n \n         private final LongAdder totalBytes = new LongAdder();\n         private final LongAdder totalOpens = new LongAdder();\n \n         private final int rangeSize;\n \n-        CountingDirectory(Directory in, int rangeSize) {\n+        CountingBlobContainer(BlobContainer in, int rangeSize) {\n             super(in);\n             this.rangeSize = rangeSize;\n         }\n \n         @Override\n-        public IndexInput openInput(String name, IOContext context) throws IOException {\n-            return new CountingIndexInput(this, super.openInput(name, context), rangeSize);\n+        public InputStream readBlob(String name) throws IOException {\n+            return new CountingInputStream(this, super.readBlob(name), getBlobLength(name), rangeSize);", "originalCommit": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0OTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395649147", "bodyText": "Sure", "author": "tlrx", "createdAt": "2020-03-20T13:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxODIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxOTk1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395619957", "bodyText": "This is only used if index.store.snapshot.cache.enabled is false. Maybe we can remove that setting and this whole class?", "author": "DaveCTurner", "createdAt": "2020-03-20T13:01:16Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -50,95 +42,24 @@\n  * shard files and what it stored in the snapshot the {@link BlobStoreIndexShardSnapshot} is used to map a physical file name as expected by\n  * Lucene with the one (or the ones) corresponding blob(s) in the snapshot.\n  */\n-public class SearchableSnapshotDirectory extends BaseDirectory {\n-\n-    private final BlobStoreIndexShardSnapshot snapshot;\n-    private final BlobContainer blobContainer;\n+public class SearchableSnapshotDirectory extends BaseSearchableSnapshotDirectory {", "originalCommit": "6fa4928481988f2ad00463c319515a784cecc3be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDUyMg==", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395644522", "bodyText": "We discussed this in another channel and agreed to defer this to a followup.", "author": "DaveCTurner", "createdAt": "2020-03-20T13:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxOTk1Nw=="}], "type": "inlineReview"}, {"oid": "e62549aa974de96e50464f0e5f74c1a335a0b9e1", "url": "https://github.com/elastic/elasticsearch/commit/e62549aa974de96e50464f0e5f74c1a335a0b9e1", "message": "apply feedback", "committedDate": "2020-03-20T13:52:25Z", "type": "commit"}]}