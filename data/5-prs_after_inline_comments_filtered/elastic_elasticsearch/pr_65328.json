{"pr_number": 65328, "pr_title": "Introduce an additional hasher (PBKDF2_STRETCH)", "pr_createdAt": "2020-11-20T18:43:52Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65328", "timeline": [{"oid": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "url": "https://github.com/elastic/elasticsearch/commit/1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "message": "Introduce an additional hasher that is PBKDF2 but pads the input to > 14 chars before hashing to comply with FIPS Approve Only mode", "committedDate": "2020-11-20T18:31:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4MTA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528181059", "bodyText": "Since we're modifying the method's signature, I think it's preferrable to always pass the prefix from the caller of this method, instead of allowing null and doing the comparison here.", "author": "jkakavas", "createdAt": "2020-11-21T10:46:28Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -497,12 +608,13 @@ public static boolean verifyHash(SecureString data, char[] hash) {\n         return hasher.verify(data, hash);\n     }\n \n-    private static char[] getPbkdf2Hash(SecureString data, int cost) {\n+    private static char[] getPbkdf2Hash(SecureString data, int cost, @Nullable String prefix) {", "originalCommit": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM4NDU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528384543", "bodyText": "Changed it before saw your comment :)", "author": "BigPandaToo", "createdAt": "2020-11-22T18:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4MTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4MTQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528181499", "bodyText": "Suggestion for the ENUMs here:\nreturn getPbkdf2Hash(data, PBKDF2_DEFAULT_COST, PBKDF2_APPROVED_ONLY_PREFIX );\n\nIf you think this is a good idea,  we don't need the getPbkdf2ApprovedOnlyHash() and getPbkdf2ApprovedOnlyHash() ones any more.", "author": "jkakavas", "createdAt": "2020-11-21T10:51:25Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -185,90 +186,181 @@ public boolean verify(SecureString text, char[] hash) {\n     PBKDF2() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, PBKDF2_DEFAULT_COST);\n+            return getPbkdf2Hash(data, PBKDF2_DEFAULT_COST, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_1000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 1000);\n+            return getPbkdf2Hash(data, 1000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_10000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 10000);\n+            return getPbkdf2Hash(data, 10000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_50000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 50000);\n+            return getPbkdf2Hash(data, 50000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_100000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 100000);\n+            return getPbkdf2Hash(data, 100000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_500000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 500000);\n+            return getPbkdf2Hash(data, 500000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_1000000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 1000000);\n+            return getPbkdf2Hash(data, 1000000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n+        }\n+\n+    },\n+\n+    PBKDF2_APPROVED_ONLY() {\n+        @Override\n+        public char[] hash(SecureString data) {\n+            return getPbkdf2ApprovedOnlyHash(data, PBKDF2_DEFAULT_COST);", "originalCommit": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4MTY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528181686", "bodyText": "I'll echo Fabio's comment here. We need a name that's indicative of what this hasher does and not something that alludes to where it can be used, as I think this will be clearer for the users. We have been referring to this as pbkdf2_stretch in our initial discussions and I think it's a good name, but I'm open to suggested alternatives.", "author": "jkakavas", "createdAt": "2020-11-21T10:53:43Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -185,90 +186,181 @@ public boolean verify(SecureString text, char[] hash) {\n     PBKDF2() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, PBKDF2_DEFAULT_COST);\n+            return getPbkdf2Hash(data, PBKDF2_DEFAULT_COST, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_1000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 1000);\n+            return getPbkdf2Hash(data, 1000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_10000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 10000);\n+            return getPbkdf2Hash(data, 10000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_50000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 50000);\n+            return getPbkdf2Hash(data, 50000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_100000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 100000);\n+            return getPbkdf2Hash(data, 100000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_500000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 500000);\n+            return getPbkdf2Hash(data, 500000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n         }\n \n     },\n \n     PBKDF2_1000000() {\n         @Override\n         public char[] hash(SecureString data) {\n-            return getPbkdf2Hash(data, 1000000);\n+            return getPbkdf2Hash(data, 1000000, null);\n         }\n \n         @Override\n         public boolean verify(SecureString data, char[] hash) {\n-            return verifyPbkdf2Hash(data, hash);\n+            return verifyPbkdf2Hash(data, hash, null);\n+        }\n+\n+    },\n+\n+    PBKDF2_APPROVED_ONLY() {", "originalCommit": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM4NDc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528384747", "bodyText": "Sounds good!", "author": "BigPandaToo", "createdAt": "2020-11-22T18:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4MTY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4NTU0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528185542", "bodyText": "Suggestion: PBKDF2_STRETCH_MIN_CHARS", "author": "jkakavas", "createdAt": "2020-11-21T11:33:49Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -388,10 +480,12 @@ public boolean verify(SecureString text, char[] hash) {\n     private static final String MD5_PREFIX = \"{MD5}\";\n     private static final String SSHA256_PREFIX = \"{SSHA256}\";\n     private static final String PBKDF2_PREFIX = \"{PBKDF2}\";\n+    private static final String PBKDF2_APPROVED_ONLY_PREFIX = \"{PBKDF2_APPROVED_ONLY}\";\n     private static final int PBKDF2_DEFAULT_COST = 10000;\n     private static final int PBKDF2_KEY_LENGTH = 256;\n     private static final int BCRYPT_DEFAULT_COST = 10;\n     private static final SecureRandom SECURE_RANDOM = new SecureRandom();\n+    private static final int PBKDF2_APPROVED_ONLY_PWD_LIMIT = 14;", "originalCommit": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4NzEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528187122", "bodyText": "s/getPadedPassword/getPaddedPassword\nAlso can we add a test in HasherTests to ensure that short inputs get padded to 14 while larger ones are unaffected?", "author": "jkakavas", "createdAt": "2020-11-21T11:49:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -597,4 +718,16 @@ private static boolean verifyBcryptHash(SecureString text, char[] hash) {\n         SECURE_RANDOM.nextBytes(salt);\n         return salt;\n     }\n+\n+    private static SecureString getPadedPassword(SecureString data) {", "originalCommit": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM4NDM5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528384397", "bodyText": "May be irrelevant if we decide to pad the password regardless the length", "author": "BigPandaToo", "createdAt": "2020-11-22T18:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4NzEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4NzkzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528187931", "bodyText": "This is slightly more nuanced. The \"> 14 chars\" that we used while discussing included some amount of hand waiving.\nThe security providers, according to FIPS 140 limitations will actually enforce that any password used must encode to at least 14 bytes (112 bits), not that it has a lenght of 14 characters. For instance, for UTF-8 strings , a character encodes to 2 bytes. i.e. \"\u03ba\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1\" is a perfectly fine password to be used for PBKDF2 under FIPS 140 because it encodes to 16 bytes even though the CharArray you'd get with toCharArray() has a length of 8.\nThat said, I see no benefit of trying to handle this here. Worst case scenario is that we unecessarily pad input that would be otherwise fine. Since this should be transparent to any consumers of this hasher, I see no issues with that but I'm bringing this up in case it raises any bells/warnings. At least, we should add some javadoc here to mark that this has been considered and that we're padding based on char length as a good enough measure.", "author": "jkakavas", "createdAt": "2020-11-21T11:57:40Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -597,4 +718,16 @@ private static boolean verifyBcryptHash(SecureString text, char[] hash) {\n         SECURE_RANDOM.nextBytes(salt);\n         return salt;\n     }\n+\n+    private static SecureString getPadedPassword(SecureString data) {", "originalCommit": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM4NDIyMA==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528384220", "bodyText": "I will add some appropriate javadoc", "author": "BigPandaToo", "createdAt": "2020-11-22T18:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE4NzkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5MjUwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528192502", "bodyText": "Stretching done this way effectively means that there are at least two passwords that can be verified against a single entry. For example, if the user password is 123456, it will be stretched to 12345612345612. So you can use either of them to login. It is worse when the actual legit password is the longer version, i.e. 12345612345612, but we allow the much shorter version, 123456, to verified for it. In addtion, 123456123456 is also equivalent.\nThe chance of this happening may be low. But this is essentially hash collision and given how sensitive this part of data is, I suggest we should employ a more robust padding mechanism, something similar to PKCS#7 padding, essentially add padding for all passwords regardless of its length.", "author": "ywangd", "createdAt": "2020-11-21T12:45:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -597,4 +718,16 @@ private static boolean verifyBcryptHash(SecureString text, char[] hash) {\n         SECURE_RANDOM.nextBytes(salt);\n         return salt;\n     }\n+\n+    private static SecureString getPadedPassword(SecureString data) {\n+        if (data.length() < PBKDF2_APPROVED_ONLY_PWD_LIMIT) {\n+            final int size = data.length();\n+            final char[] paddedPassword = new char[PBKDF2_APPROVED_ONLY_PWD_LIMIT];\n+            for (int i = 0; i < PBKDF2_APPROVED_ONLY_PWD_LIMIT; i++) {\n+                paddedPassword[i] = data.getChars()[i%size];\n+            }\n+            data = new SecureString(paddedPassword);", "originalCommit": "1a8e14025c1c6616501dcc8ae58b5b6cee5015aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNzk1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528237953", "bodyText": "I like the PKCS7 padding idea too. An alternative could be a single round of a sha family algorithm before feeding the output (hex encoded chars) to the pbkdf2.  By virtue of the properties of the hash function, it doesnt harm pre-image resistance. Even if sha (let's say sha512) could be a surjective function, a single round does not reduce the search space enough to be considered problematic, especially since a potential attacker only controls the pre-hashed input.", "author": "jkakavas", "createdAt": "2020-11-21T20:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM4NDA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528384059", "bodyText": "I like both PKCS7 and adding a round of sha hashing before pbkdf2. The simplest however seems to be just tripling the password before feeding it to pbkdf2 regardless of the length and character set. Since we have password min length 6 (correct me if I am wrong) it guarantees to be > 14.\nAny objections/thoughts?", "author": "BigPandaToo", "createdAt": "2020-11-22T18:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1ODMwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528458301", "bodyText": "Overall I think I prefer hashing before pbkdf2. It feels more standardish since pbkdf2 internally uses sha512 (though pbkdf2's usage of sha512 is a bit more involved compared to ours). I agree with Ioannis's analysis that it should not cause any practical problem. A single round of sha512 reduces the search space from essentially inifinity to 2^512. This is still a huge number. If an attacker gets access to the final hashed result from pbkdf2 of cost 1000 (lowest we support), brute force a password requires searching through 2^512 entries (assuming a rainbow table is available to lookup the actual password once its sha512 value is known). Based on @albertzaharovits's hashing benchmark, this means more than 10^141 year of computation time on GPU or roughly 10^144 dollar value with current price of Cloud offerings. Both numbers are rather impractical.\nAlso we probably need to document how the hashing works since the PutUser API can take externally computed hashes. In this case, an extra sha512 is straighforward for us to document and easier for users to implement.\nPadding or stretching feels more arbitrary. Even if we follow pkcs#7 standard, it would be our own implementation and add an extra thing to worry about (maintence, testing etc). Also they feel like we are designing our own crypto \"related\" algorithm whose implication may be unknown.", "author": "ywangd", "createdAt": "2020-11-23T03:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMTAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528621002", "bodyText": "A single round of sha512 reduces the search space from essentially infinity to 2^512\n\nFor exhaustive key search attacks\nKeeping in mind that most use cases concern human selected passwords or randomly generated passwords of a certain length from a specific pool, it makes it even easier to argument in favor of the one hash round, granted that the search space for a 12 char password with lower/uppercase letters, numbers and special characters is 12^95 ~~= 2^79.\nFor dictionary attacks\nNothing changes as the password dictionary would most probably contain pre-hashed common passwords.", "author": "jkakavas", "createdAt": "2020-11-23T11:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc1MzE0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r528753148", "bodyText": "Added SHA-512 Message Digest and a round of hashing using it as the stretch method", "author": "BigPandaToo", "createdAt": "2020-11-23T14:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5MjUwMg=="}], "type": "inlineReview"}, {"oid": "79e163c0e56c49b35256f029ab68a599aa9a0065", "url": "https://github.com/elastic/elasticsearch/commit/79e163c0e56c49b35256f029ab68a599aa9a0065", "message": "Introduce an additional hasher that is PBKDF2 but pads the input to > 14 chars before hashing to comply with FIPS Approve Only mode", "committedDate": "2020-11-23T12:07:15Z", "type": "commit"}, {"oid": "f2ed61f751a06ea1098e9bbd9656925075672492", "url": "https://github.com/elastic/elasticsearch/commit/f2ed61f751a06ea1098e9bbd9656925075672492", "message": "Merge branch 'master' into FIBS_AO_PSW", "committedDate": "2020-11-23T13:07:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3MDYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r529070609", "bodyText": "Nit: I understand this follows an existing pattern for pbkdf2. But strictly speaking I think it is incorrect. We have an explicit entry of PBKDF2_STRETCH_10000 and it should be returned here. This currently works because default cost is 10K. But the PBKDF2_DEFAULT_COST parameter has no inherent connection to the string of \"pbkdf2_stretch_10000\". That is, if someone updates PBKDF2_DEFAULT_COST, there is no guarantee or enforcement that this part of code would be updated accordingly as well.", "author": "ywangd", "createdAt": "2020-11-23T23:49:35Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -442,6 +552,20 @@ public static Hasher resolve(String name) {\n                 return PBKDF2_500000;\n             case \"pbkdf2_1000000\":\n                 return PBKDF2_1000000;\n+            case \"pbkdf2_stretch\":\n+                return PBKDF2_STRETCH;\n+            case \"pbkdf2_stretch_1000\":\n+                return PBKDF2_STRETCH_1000;\n+            case \"pbkdf2_stretch_10000\":\n+                return PBKDF2_STRETCH;", "originalCommit": "f2ed61f751a06ea1098e9bbd9656925075672492", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2Nzc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r529167793", "bodyText": "Personally, I think our fixed strings & Hasher enum has outlived its usefulness.\nI would prefer we moved to something like:\nhasher:cost or hasher+options:cost\nSo we could have\n\"pbkdf2:10000\" but also \"pbkdf2:15000\" or even \"pbkdf2:12345\".\nAnd then\n\"pbkdf2+sha512:10000\"\nBut, I think that's too much change to push into this PR. I just think we should think about revisiting this in the future.", "author": "tvernum", "createdAt": "2020-11-24T02:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3MDYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU5NTQ0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r529595444", "bodyText": "Agreed with Tim, but also +1 to change this line as Yang suggests.", "author": "jkakavas", "createdAt": "2020-11-24T14:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3MDYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU5MzkzNg==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r529593936", "bodyText": "I don't think we need this introduced here as part of the ENUM. There is no use for it and it might confuse someone to actually use it for password hashing while they should not. I suggest a private method for the hashing ( we don't need the verification part ) and calling that from the hash() and verify() of the newly introduced hasher.  We should probably remove the SHA256 from here and I shouldn't have added it in the first place. ( Can do the latter in an unrelated PR )\nUnless we feel there is need/value in exposing unsalted SHA256 / SHA512 for caching hash algorithms but I don't think we should.", "author": "jkakavas", "createdAt": "2020-11-24T14:38:42Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -370,6 +461,24 @@ public boolean verify(SecureString text, char[] hash) {\n             return CharArrays.constantTimeEquals(Base64.getUrlEncoder().withoutPadding().encodeToString(md.digest()).toCharArray(), hash);\n         }\n     },\n+    /*\n+     * Unsalted SHA-512 , not suited for password storage.\n+     */\n+    SHA512() {", "originalCommit": "f2ed61f751a06ea1098e9bbd9656925075672492", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0ODU2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r529848563", "bodyText": "Changed", "author": "BigPandaToo", "createdAt": "2020-11-24T20:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU5MzkzNg=="}], "type": "inlineReview"}, {"oid": "b9dd1c93cef7f6d64ad35e2e61362505c752956d", "url": "https://github.com/elastic/elasticsearch/commit/b9dd1c93cef7f6d64ad35e2e61362505c752956d", "message": "Addressing the PR feedback\nadding doc changes", "committedDate": "2020-11-24T20:25:18Z", "type": "commit"}, {"oid": "c58ba67ab0cca2fd8e66d040949cae7257b7ff0d", "url": "https://github.com/elastic/elasticsearch/commit/c58ba67ab0cca2fd8e66d040949cae7257b7ff0d", "message": "Merge branch 'FIBS_AO_PSW' of github.com:BigPandaToo/elasticsearch into FIBS_AO_PSW", "committedDate": "2020-11-24T20:27:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2MzgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r529863807", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static char[] hashSha512NoSalt(SecureString text) {\n          \n          \n            \n                private static char[] sha512Hash(SecureString text) {\n          \n      \n    \n    \n  \n\n(hashing doesn't inherently include a salt, so it feels strange calling it out in the method name )", "author": "jkakavas", "createdAt": "2020-11-24T20:39:36Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -724,4 +706,10 @@ private static boolean verifyBcryptHash(SecureString text, char[] hash) {\n         SECURE_RANDOM.nextBytes(salt);\n         return salt;\n     }\n+\n+    private static char[] hashSha512NoSalt(SecureString text) {", "originalCommit": "c58ba67ab0cca2fd8e66d040949cae7257b7ff0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b2e901a1afdc486201f2ae0a97e00222f5f64d1", "url": "https://github.com/elastic/elasticsearch/commit/4b2e901a1afdc486201f2ae0a97e00222f5f64d1", "message": "Merge branch 'master' into FIBS_AO_PSW", "committedDate": "2020-11-25T10:12:55Z", "type": "commit"}, {"oid": "3779f1a04c09849805907035375122bfc178d70c", "url": "https://github.com/elastic/elasticsearch/commit/3779f1a04c09849805907035375122bfc178d70c", "message": "Merge branch 'master' into FIBS_AO_PSW", "committedDate": "2020-11-25T14:25:38Z", "type": "commit"}, {"oid": "2b611ca33085ae95f3a09a5326afaa543a7c355d", "url": "https://github.com/elastic/elasticsearch/commit/2b611ca33085ae95f3a09a5326afaa543a7c355d", "message": "Renaming the hash function + rephrasing the doc descriptions", "committedDate": "2020-11-25T14:27:06Z", "type": "commit"}, {"oid": "583f01fcbdcba0fdc3d4cf0227498e24bae4f71f", "url": "https://github.com/elastic/elasticsearch/commit/583f01fcbdcba0fdc3d4cf0227498e24bae4f71f", "message": "Merge branch 'FIBS_AO_PSW' of github.com:BigPandaToo/elasticsearch into FIBS_AO_PSW", "committedDate": "2020-11-25T14:27:46Z", "type": "commit"}, {"oid": "806131075e01180f27a3449cc20ae8023a61ff01", "url": "https://github.com/elastic/elasticsearch/commit/806131075e01180f27a3449cc20ae8023a61ff01", "message": "Removing leftover from the doc", "committedDate": "2020-11-25T15:02:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1MzA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r530453096", "bodyText": "This will start failing in FIPS 140 mode in the CI, when #64024 is merged, if a PBKDF2 hasher is passed and randomAlphaOfLength returns anything less than 14. I can also take care of this as part of #64024", "author": "jkakavas", "createdAt": "2020-11-25T15:21:54Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/support/HasherTests.java", "diffHunk": "@@ -132,11 +146,35 @@ public void testResolveFromHash() {\n         assertThat(Hasher.resolveFromHash(\n             \"{PBKDF2}1000000$UuyhtjDEzWmE2wyY80akZKPWWpy2r2X50so41YML82U=$WFasYLelqbjQwt3EqFlUcwHiC38EZC45Iu/Iz0xL1GQ=\".toCharArray()),\n             sameInstance(Hasher.PBKDF2_1000000));\n+        assertThat(Hasher.resolveFromHash(\n+            \"{PBKDF2_STRETCH}1000$sTyix9e0zNINzq2aDZ+GD5+QlO94xVyf/bv4pWNhBxo=$4KuzGPy9HXnhY3ANHn8rcIRQuJHPB6cEtLwnOhDI5d4=\"\n+                .toCharArray()),\n+            sameInstance(Hasher.PBKDF2_STRETCH_1000));\n+        assertThat(Hasher.resolveFromHash(\n+            \"{PBKDF2_STRETCH}10000$8M9+Ww0xkdY250CROEutsd8UP6CrJESw7ZAFu1NGORo=$ai0gxBPtHTfZU/nbNGwL5zjC+eo2/ANQM17L/tllVeo=\"\n+                .toCharArray()),\n+            sameInstance(Hasher.PBKDF2_STRETCH));\n+        assertThat(Hasher.resolveFromHash(\n+            \"{PBKDF2_STRETCH}50000$uupwXiq8W0+jrLtC3/aqzuvyZlRarlmx1+CQGEnomlk=$by8q/+oRPPWwDE6an7B9/ndz7UZ1UQpaGY4CGurtPTI=\"\n+                .toCharArray()),\n+            sameInstance(Hasher.PBKDF2_STRETCH_50000));\n+        assertThat(Hasher.resolveFromHash(\n+            \"{PBKDF2_STRETCH}100000$E9VqtV76PcrQuCZ6wOMMNvs4CMPcANTpzRw8Wjd24PU=$j56uKUvwbvmgQgNFkbV7SRQVZ2QOarokAgBeA8xcFD8=\"\n+                .toCharArray()),\n+            sameInstance(Hasher.PBKDF2_STRETCH_100000));\n+        assertThat(Hasher.resolveFromHash(\n+            \"{PBKDF2_STRETCH}500000$4dpTEbu4jfjhDOjWY6xdsnxuQs4dg4QbNzZJ0Z1Tm4s=$Us/yrlCxVaW7mz0go1qIygFqGgcfUMgCZfIl2AvI4I8=\"\n+                .toCharArray()),\n+            sameInstance(Hasher.PBKDF2_STRETCH_500000));\n+        assertThat(Hasher.resolveFromHash(\n+            \"{PBKDF2_STRETCH}1000000$eKeQvMztiIcqBynTNDFBseOBww3GBpHDZI6EPPVHYUw=$4587yrxUa02RZ1jeW1WOaMjRn5qT9iQ5/DIHk0nW2bE=\"\n+                .toCharArray()),\n+            sameInstance(Hasher.PBKDF2_STRETCH_1000000));\n         assertThat(Hasher.resolveFromHash(\"notavalidhashformat\".toCharArray()), sameInstance(Hasher.NOOP));\n     }\n \n     private static void testHasherSelfGenerated(Hasher hasher) {\n-        SecureString passwd = new SecureString(randomAlphaOfLength(10).toCharArray());\n+        SecureString passwd = new SecureString(randomAlphaOfLength(between(6, 15)).toCharArray());", "originalCommit": "806131075e01180f27a3449cc20ae8023a61ff01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5OTE3NA==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r530699174", "bodyText": "This is probably minor, but I'd prefer to use return MessageDigests.toHexCharArray(md.digest());, the reasons being:\n\nIt is an intermediate result which does not need a storage friendly base64 format. toHexCharArray should also be marginally more efficient.\nBase64 encoding gives a char array of length 86, while toHexCharArray give a char array of length 128. A trivial security gain.\ntoHexCharArray avoids creating an intermediate String. This is probably not as critical since this is a hashed result anyway. But given the purpose of SecureString is to avoid creating an actual string, it makes more sense if we don't create one before it. Also I believe pbkdf2 implementation internally does not use any String either, so it might be better if we do the same.", "author": "ywangd", "createdAt": "2020-11-25T23:56:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/support/Hasher.java", "diffHunk": "@@ -597,4 +706,10 @@ private static boolean verifyBcryptHash(SecureString text, char[] hash) {\n         SECURE_RANDOM.nextBytes(salt);\n         return salt;\n     }\n+\n+    private static char[] hashSha512(SecureString text) {\n+        MessageDigest md = MessageDigests.sha512();\n+        md.update(CharArrays.toUtf8Bytes(text.getChars()));\n+        return Base64.getUrlEncoder().withoutPadding().encodeToString(md.digest()).toCharArray();", "originalCommit": "806131075e01180f27a3449cc20ae8023a61ff01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxNzIxMg==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r530717212", "bodyText": "Base64 encoding gives a char array of length 86, while toHexCharArray give a char array of length 128. A trivial security gain.\n\nCan you clarify your thinking here? The quantity of meaningful data is the same, it's just the encoding that's different - I don't think that actually affects the security properties.", "author": "tvernum", "createdAt": "2020-11-26T01:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5OTE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcyNjMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r530726307", "bodyText": "The quantity of meaningful data is the same\n\nThis is true. The length of result from toHexCharArray is longer, but its valid character selections are smaller (16) compared to base64. So in theory they should provide exact the same search space.\nThe \"trivial\" security gain is to assume:\n\nA blind enumeration through all possible chars/bits without considering its valid char range, i.e. instead of trying only hexdecimal for the 1024 bits output of toHexCharArray, it would try all combination of 0s and 1s.\nOriginal password is longer than 128 chars. So it is more effecitive to enumerate the hash instead of the original password.", "author": "ywangd", "createdAt": "2020-11-26T01:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5OTE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc3MDY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r530770673", "bodyText": "My reasoning for not making a comment on this is that:\n\nfor online attacks, it doesn't make any difference. Attacker can only control the pre - hashed version\nfor offline attacks, and given our code is public what matters is the search space of the input to pbkdf2 and these are equivalent in both cases .\n\nThat said, your comment about String makes sense ( protecting hashes of common passwords to be dumped from memory) and there's no argument in favor of keeping the base64\nSo +1", "author": "jkakavas", "createdAt": "2020-11-26T04:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5OTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwMDQ0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r530700447", "bodyText": "Technically we don't block the use of PBKDF2_STRETCH for non-FIPS clusters. So it seems to me that we should test it regardlessly, i.e. add it to the randomFrom list when inFipsJvm() is false as well.", "author": "ywangd", "createdAt": "2020-11-26T00:01:21Z", "path": "x-pack/qa/security-tools-tests/src/test/java/org/elasticsearch/xpack/security/authc/file/tool/UsersToolTests.java", "diffHunk": "@@ -70,7 +70,7 @@ public void setupHome() throws IOException {\n         IOUtils.rm(homeDir);\n         confDir = homeDir.resolve(\"config\");\n         Files.createDirectories(confDir);\n-        hasher = inFipsJvm() ? randomFrom(Hasher.PBKDF2, Hasher.PBKDF2_1000)\n+        hasher = inFipsJvm() ? randomFrom(Hasher.PBKDF2, Hasher.PBKDF2_1000, Hasher.PBKDF2_STRETCH)", "originalCommit": "806131075e01180f27a3449cc20ae8023a61ff01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2ODQzMg==", "url": "https://github.com/elastic/elasticsearch/pull/65328#discussion_r530768432", "bodyText": "These are not meant to provide extensive test hashing coverage. We do that in HasherTests. Iirc this was added when I changed the behaviour of the cli tool to throw a useful error when in fips but using an algorithm that's not pbkdf2 based .\nI'm saying that in the sense that if we do that here ,then we might as well go and add the stretched variant as a possibility in all test cases where hashing a user pwd is part of the test setup. But I dont think we'd gain something by doing so", "author": "jkakavas", "createdAt": "2020-11-26T04:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwMDQ0Nw=="}], "type": "inlineReview"}, {"oid": "34eb3c0777898485c05ed97748ef588f38945e41", "url": "https://github.com/elastic/elasticsearch/commit/34eb3c0777898485c05ed97748ef588f38945e41", "message": "Return HexCharArray instead of Base64 encoding and avoid intermediate\nString", "committedDate": "2020-11-26T11:19:15Z", "type": "commit"}]}