{"pr_number": 51529, "pr_title": "[ML] add _cat/ml/trained_models API", "pr_createdAt": "2020-01-28T13:02:48Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51529", "timeline": [{"oid": "250a1147634825bd8921bc3c3ad7844ddad9e112", "url": "https://github.com/elastic/elasticsearch/commit/250a1147634825bd8921bc3c3ad7844ddad9e112", "message": "[ML] add _cat/ml/trained_models API", "committedDate": "2020-01-28T12:58:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzMjQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51529#discussion_r373432453", "bodyText": "This is the only cat action that supports paging", "author": "davidkyle", "createdAt": "2020-01-31T11:20:10Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/rest/cat/RestCatTrainedModelsAction.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.rest.cat;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.Table;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+import org.elasticsearch.rest.action.cat.AbstractCatAction;\n+import org.elasticsearch.rest.action.cat.RestTable;\n+import org.elasticsearch.xpack.core.action.util.PageParams;\n+import org.elasticsearch.xpack.core.ml.action.GetDataFrameAnalyticsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsStatsAction;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfig;\n+import org.elasticsearch.xpack.core.ml.inference.TrainedModelConfig;\n+import org.elasticsearch.xpack.core.security.user.XPackUser;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+import static org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction.Request.ALLOW_NO_MATCH;\n+\n+public class RestCatTrainedModelsAction extends AbstractCatAction {\n+\n+    private static final Logger logger = LogManager.getLogger(RestCatTrainedModelsAction.class);\n+\n+    public RestCatTrainedModelsAction(RestController controller) {\n+        controller.registerHandler(GET, \"_cat/ml/trained_models/{\" + TrainedModelConfig.MODEL_ID.getPreferredName() + \"}\", this);\n+        controller.registerHandler(GET, \"_cat/ml/trained_models\", this);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"cat_ml_get_trained_models_action\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer doCatRequest(RestRequest restRequest, NodeClient client) {\n+        String modelId = restRequest.param(TrainedModelConfig.MODEL_ID.getPreferredName());\n+        if (Strings.isNullOrEmpty(modelId)) {\n+            modelId = MetaData.ALL;\n+        }\n+        GetTrainedModelsStatsAction.Request statsRequest = new GetTrainedModelsStatsAction.Request(modelId);\n+        GetTrainedModelsAction.Request modelsAction = new GetTrainedModelsAction.Request(modelId, false, null);\n+        if (restRequest.hasParam(PageParams.FROM.getPreferredName()) || restRequest.hasParam(PageParams.SIZE.getPreferredName())) {", "originalCommit": "250a1147634825bd8921bc3c3ad7844ddad9e112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NDk5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51529#discussion_r373444992", "bodyText": "Correct, and it probably should as there is a limit of 10K when reading configs from an index.\nOur _cat APIs are the only ones that return data that are stored in indices (i think)", "author": "benwtrent", "createdAt": "2020-01-31T11:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzMjQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzNDU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/51529#discussion_r373434590", "bodyText": "I think we want a better way of differentiating user models and DFA models in the future. Maybe a reserved tag for DFA models", "author": "davidkyle", "createdAt": "2020-01-31T11:25:55Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/rest/cat/RestCatTrainedModelsAction.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.rest.cat;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.Table;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+import org.elasticsearch.rest.action.cat.AbstractCatAction;\n+import org.elasticsearch.rest.action.cat.RestTable;\n+import org.elasticsearch.xpack.core.action.util.PageParams;\n+import org.elasticsearch.xpack.core.ml.action.GetDataFrameAnalyticsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsStatsAction;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfig;\n+import org.elasticsearch.xpack.core.ml.inference.TrainedModelConfig;\n+import org.elasticsearch.xpack.core.security.user.XPackUser;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+import static org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction.Request.ALLOW_NO_MATCH;\n+\n+public class RestCatTrainedModelsAction extends AbstractCatAction {\n+\n+    private static final Logger logger = LogManager.getLogger(RestCatTrainedModelsAction.class);\n+\n+    public RestCatTrainedModelsAction(RestController controller) {\n+        controller.registerHandler(GET, \"_cat/ml/trained_models/{\" + TrainedModelConfig.MODEL_ID.getPreferredName() + \"}\", this);\n+        controller.registerHandler(GET, \"_cat/ml/trained_models\", this);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"cat_ml_get_trained_models_action\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer doCatRequest(RestRequest restRequest, NodeClient client) {\n+        String modelId = restRequest.param(TrainedModelConfig.MODEL_ID.getPreferredName());\n+        if (Strings.isNullOrEmpty(modelId)) {\n+            modelId = MetaData.ALL;\n+        }\n+        GetTrainedModelsStatsAction.Request statsRequest = new GetTrainedModelsStatsAction.Request(modelId);\n+        GetTrainedModelsAction.Request modelsAction = new GetTrainedModelsAction.Request(modelId, false, null);\n+        if (restRequest.hasParam(PageParams.FROM.getPreferredName()) || restRequest.hasParam(PageParams.SIZE.getPreferredName())) {\n+            statsRequest.setPageParams(new PageParams(restRequest.paramAsInt(PageParams.FROM.getPreferredName(), PageParams.DEFAULT_FROM),\n+                restRequest.paramAsInt(PageParams.SIZE.getPreferredName(), PageParams.DEFAULT_SIZE)));\n+            modelsAction.setPageParams(new PageParams(restRequest.paramAsInt(PageParams.FROM.getPreferredName(), PageParams.DEFAULT_FROM),\n+                restRequest.paramAsInt(PageParams.SIZE.getPreferredName(), PageParams.DEFAULT_SIZE)));\n+        }\n+        statsRequest.setAllowNoResources(restRequest.paramAsBoolean(ALLOW_NO_MATCH.getPreferredName(),\n+            statsRequest.isAllowNoResources()));\n+        modelsAction.setAllowNoResources(restRequest.paramAsBoolean(ALLOW_NO_MATCH.getPreferredName(),\n+            statsRequest.isAllowNoResources()));\n+\n+        return channel -> {\n+            final ActionListener<Table> listener = ActionListener.notifyOnce(new RestResponseListener<>(channel) {\n+                @Override\n+                public RestResponse buildResponse(final Table table) throws Exception {\n+                    return RestTable.buildResponse(table, channel);\n+                }\n+            });\n+\n+            client.execute(GetTrainedModelsAction.INSTANCE, modelsAction, ActionListener.wrap(\n+                trainedModels -> {\n+                    final List<TrainedModelConfig> trainedModelConfigs = trainedModels.getResources().results();\n+\n+                    Set<String> potentialAnalyticsIds = new HashSet<>();\n+                    // Analytics Configs are created by the XPackUser\n+                    trainedModelConfigs.stream()\n+                        .filter(c -> XPackUser.NAME.equals(c.getCreatedBy()))", "originalCommit": "250a1147634825bd8921bc3c3ad7844ddad9e112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0ODc0OA==", "url": "https://github.com/elastic/elasticsearch/pull/51529#discussion_r373448748", "bodyText": "@davidkyle possibly. Users cannot set the created_by, and XPackUser.NAME is a reserved name.\nBut I see your point for models we provide as a resource. Those weren't created by a DFA.", "author": "benwtrent", "createdAt": "2020-01-31T12:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzNDU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51529#discussion_r373439479", "bodyText": "Do you need the wrap?", "author": "davidkyle", "createdAt": "2020-01-31T11:39:49Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/rest/cat/RestCatTrainedModelsAction.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.rest.cat;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.Table;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+import org.elasticsearch.rest.action.cat.AbstractCatAction;\n+import org.elasticsearch.rest.action.cat.RestTable;\n+import org.elasticsearch.xpack.core.action.util.PageParams;\n+import org.elasticsearch.xpack.core.ml.action.GetDataFrameAnalyticsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsStatsAction;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfig;\n+import org.elasticsearch.xpack.core.ml.inference.TrainedModelConfig;\n+import org.elasticsearch.xpack.core.security.user.XPackUser;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+import static org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction.Request.ALLOW_NO_MATCH;\n+\n+public class RestCatTrainedModelsAction extends AbstractCatAction {\n+\n+    private static final Logger logger = LogManager.getLogger(RestCatTrainedModelsAction.class);\n+\n+    public RestCatTrainedModelsAction(RestController controller) {\n+        controller.registerHandler(GET, \"_cat/ml/trained_models/{\" + TrainedModelConfig.MODEL_ID.getPreferredName() + \"}\", this);\n+        controller.registerHandler(GET, \"_cat/ml/trained_models\", this);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"cat_ml_get_trained_models_action\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer doCatRequest(RestRequest restRequest, NodeClient client) {\n+        String modelId = restRequest.param(TrainedModelConfig.MODEL_ID.getPreferredName());\n+        if (Strings.isNullOrEmpty(modelId)) {\n+            modelId = MetaData.ALL;\n+        }\n+        GetTrainedModelsStatsAction.Request statsRequest = new GetTrainedModelsStatsAction.Request(modelId);\n+        GetTrainedModelsAction.Request modelsAction = new GetTrainedModelsAction.Request(modelId, false, null);\n+        if (restRequest.hasParam(PageParams.FROM.getPreferredName()) || restRequest.hasParam(PageParams.SIZE.getPreferredName())) {\n+            statsRequest.setPageParams(new PageParams(restRequest.paramAsInt(PageParams.FROM.getPreferredName(), PageParams.DEFAULT_FROM),\n+                restRequest.paramAsInt(PageParams.SIZE.getPreferredName(), PageParams.DEFAULT_SIZE)));\n+            modelsAction.setPageParams(new PageParams(restRequest.paramAsInt(PageParams.FROM.getPreferredName(), PageParams.DEFAULT_FROM),\n+                restRequest.paramAsInt(PageParams.SIZE.getPreferredName(), PageParams.DEFAULT_SIZE)));\n+        }\n+        statsRequest.setAllowNoResources(restRequest.paramAsBoolean(ALLOW_NO_MATCH.getPreferredName(),\n+            statsRequest.isAllowNoResources()));\n+        modelsAction.setAllowNoResources(restRequest.paramAsBoolean(ALLOW_NO_MATCH.getPreferredName(),\n+            statsRequest.isAllowNoResources()));\n+\n+        return channel -> {\n+            final ActionListener<Table> listener = ActionListener.notifyOnce(new RestResponseListener<>(channel) {\n+                @Override\n+                public RestResponse buildResponse(final Table table) throws Exception {\n+                    return RestTable.buildResponse(table, channel);\n+                }\n+            });\n+\n+            client.execute(GetTrainedModelsAction.INSTANCE, modelsAction, ActionListener.wrap(\n+                trainedModels -> {\n+                    final List<TrainedModelConfig> trainedModelConfigs = trainedModels.getResources().results();\n+\n+                    Set<String> potentialAnalyticsIds = new HashSet<>();\n+                    // Analytics Configs are created by the XPackUser\n+                    trainedModelConfigs.stream()\n+                        .filter(c -> XPackUser.NAME.equals(c.getCreatedBy()))\n+                        .forEach(c -> potentialAnalyticsIds.addAll(c.getTags()));\n+\n+\n+                    // Find the related DataFrameAnalyticsConfigs\n+                    String requestIdPattern = Strings.collectionToDelimitedString(potentialAnalyticsIds, \"*,\") + \"*\";\n+\n+                    final GroupedActionListener<ActionResponse> groupedListener = createGroupedListener(restRequest,\n+                        2,\n+                        trainedModels.getResources().results(),\n+                        listener);\n+\n+                    client.execute(GetTrainedModelsStatsAction.INSTANCE,\n+                        statsRequest,\n+                        ActionListener.wrap(groupedListener::onResponse, groupedListener::onFailure));", "originalCommit": "250a1147634825bd8921bc3c3ad7844ddad9e112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1Mzc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51529#discussion_r373453775", "bodyText": "Yes, generic types get upset if there is no wrapper.", "author": "benwtrent", "createdAt": "2020-01-31T12:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0MTA4OA==", "url": "https://github.com/elastic/elasticsearch/pull/51529#discussion_r373441088", "bodyText": "left over debug?", "author": "davidkyle", "createdAt": "2020-01-31T11:44:50Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/rest/cat/RestCatTrainedModelsAction.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.rest.cat;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.Table;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+import org.elasticsearch.rest.action.cat.AbstractCatAction;\n+import org.elasticsearch.rest.action.cat.RestTable;\n+import org.elasticsearch.xpack.core.action.util.PageParams;\n+import org.elasticsearch.xpack.core.ml.action.GetDataFrameAnalyticsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction;\n+import org.elasticsearch.xpack.core.ml.action.GetTrainedModelsStatsAction;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfig;\n+import org.elasticsearch.xpack.core.ml.inference.TrainedModelConfig;\n+import org.elasticsearch.xpack.core.security.user.XPackUser;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+import static org.elasticsearch.xpack.core.ml.action.GetTrainedModelsAction.Request.ALLOW_NO_MATCH;\n+\n+public class RestCatTrainedModelsAction extends AbstractCatAction {\n+\n+    private static final Logger logger = LogManager.getLogger(RestCatTrainedModelsAction.class);\n+\n+    public RestCatTrainedModelsAction(RestController controller) {\n+        controller.registerHandler(GET, \"_cat/ml/trained_models/{\" + TrainedModelConfig.MODEL_ID.getPreferredName() + \"}\", this);\n+        controller.registerHandler(GET, \"_cat/ml/trained_models\", this);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"cat_ml_get_trained_models_action\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer doCatRequest(RestRequest restRequest, NodeClient client) {\n+        String modelId = restRequest.param(TrainedModelConfig.MODEL_ID.getPreferredName());\n+        if (Strings.isNullOrEmpty(modelId)) {\n+            modelId = MetaData.ALL;\n+        }\n+        GetTrainedModelsStatsAction.Request statsRequest = new GetTrainedModelsStatsAction.Request(modelId);\n+        GetTrainedModelsAction.Request modelsAction = new GetTrainedModelsAction.Request(modelId, false, null);\n+        if (restRequest.hasParam(PageParams.FROM.getPreferredName()) || restRequest.hasParam(PageParams.SIZE.getPreferredName())) {\n+            statsRequest.setPageParams(new PageParams(restRequest.paramAsInt(PageParams.FROM.getPreferredName(), PageParams.DEFAULT_FROM),\n+                restRequest.paramAsInt(PageParams.SIZE.getPreferredName(), PageParams.DEFAULT_SIZE)));\n+            modelsAction.setPageParams(new PageParams(restRequest.paramAsInt(PageParams.FROM.getPreferredName(), PageParams.DEFAULT_FROM),\n+                restRequest.paramAsInt(PageParams.SIZE.getPreferredName(), PageParams.DEFAULT_SIZE)));\n+        }\n+        statsRequest.setAllowNoResources(restRequest.paramAsBoolean(ALLOW_NO_MATCH.getPreferredName(),\n+            statsRequest.isAllowNoResources()));\n+        modelsAction.setAllowNoResources(restRequest.paramAsBoolean(ALLOW_NO_MATCH.getPreferredName(),\n+            statsRequest.isAllowNoResources()));\n+\n+        return channel -> {\n+            final ActionListener<Table> listener = ActionListener.notifyOnce(new RestResponseListener<>(channel) {\n+                @Override\n+                public RestResponse buildResponse(final Table table) throws Exception {\n+                    return RestTable.buildResponse(table, channel);\n+                }\n+            });\n+\n+            client.execute(GetTrainedModelsAction.INSTANCE, modelsAction, ActionListener.wrap(\n+                trainedModels -> {\n+                    final List<TrainedModelConfig> trainedModelConfigs = trainedModels.getResources().results();\n+\n+                    Set<String> potentialAnalyticsIds = new HashSet<>();\n+                    // Analytics Configs are created by the XPackUser\n+                    trainedModelConfigs.stream()\n+                        .filter(c -> XPackUser.NAME.equals(c.getCreatedBy()))\n+                        .forEach(c -> potentialAnalyticsIds.addAll(c.getTags()));\n+\n+\n+                    // Find the related DataFrameAnalyticsConfigs\n+                    String requestIdPattern = Strings.collectionToDelimitedString(potentialAnalyticsIds, \"*,\") + \"*\";\n+\n+                    final GroupedActionListener<ActionResponse> groupedListener = createGroupedListener(restRequest,\n+                        2,\n+                        trainedModels.getResources().results(),\n+                        listener);\n+\n+                    client.execute(GetTrainedModelsStatsAction.INSTANCE,\n+                        statsRequest,\n+                        ActionListener.wrap(groupedListener::onResponse, groupedListener::onFailure));\n+\n+                    GetDataFrameAnalyticsAction.Request dataFrameAnalyticsRequest =\n+                        new GetDataFrameAnalyticsAction.Request(requestIdPattern);\n+                    dataFrameAnalyticsRequest.setAllowNoResources(true);\n+                    dataFrameAnalyticsRequest.setPageParams(new PageParams(0, potentialAnalyticsIds.size()));\n+                    client.execute(GetDataFrameAnalyticsAction.INSTANCE,\n+                        dataFrameAnalyticsRequest,\n+                        ActionListener.wrap(groupedListener::onResponse, groupedListener::onFailure));\n+                },\n+                listener::onFailure\n+            ));\n+        };\n+    }\n+\n+    @Override\n+    protected void documentation(StringBuilder sb) {\n+        sb.append(\"/_cat/ml/trained_models\\n\");\n+        sb.append(\"/_cat/ml/trained_models/{model_id}\\n\");\n+    }\n+\n+    @Override\n+    protected Table getTableWithHeader(RestRequest request) {\n+        Table table = new Table();\n+        table.startHeaders();\n+\n+        // Trained Model Info\n+        table.addCell(\"id\", TableColumnAttributeBuilder.builder().setDescription(\"the trained model id\").build());\n+        table.addCell(\"created_by\", TableColumnAttributeBuilder.builder(\"who created the model\", false)\n+            .setAliases(\"c\", \"createdBy\")\n+            .setTextAlignment(TableColumnAttributeBuilder.TextAlign.RIGHT)\n+            .build());\n+        table.addCell(\"heap_size\", TableColumnAttributeBuilder.builder()\n+            .setDescription(\"the estimated heap size to keep the model in memory\")\n+            .setAliases(\"hs\",\"modelHeapSize\")\n+            .build());\n+        table.addCell(\"operations\", TableColumnAttributeBuilder.builder()\n+            .setDescription(\"the estimated number of operations to use the model\")\n+            .setAliases(\"o\", \"modelOperations\")\n+            .build());\n+        table.addCell(\"license\", TableColumnAttributeBuilder.builder(\"The license level of the model\", false)\n+            .setAliases(\"l\")\n+            .build());\n+        table.addCell(\"create_time\", TableColumnAttributeBuilder.builder(\"The time the model was created\", false)\n+            .setAliases(\"ct\")\n+            .build());\n+        table.addCell(\"version\", TableColumnAttributeBuilder.builder(\"The version of Elasticsearch when the model was created\", false)\n+            .setAliases(\"v\")\n+            .build());\n+        table.addCell(\"description\", TableColumnAttributeBuilder.builder(\"The model description\", false)\n+            .setAliases(\"d\")\n+            .build());\n+        table.addCell(\"data_frame_analytics_id\", TableColumnAttributeBuilder.builder(\n+            \"The data frame analytics config id that created the model (if still available)\",\n+            false)\n+            .setAliases(\"df\", \"dataFrameAnalytics\")\n+            .build());\n+\n+        // Trained Model Stats\n+        table.addCell(\"ingest.pipelines\", TableColumnAttributeBuilder.builder(\"The number of pipelines referencing the model\")\n+            .setAliases(\"ip\", \"ingestPipelines\")\n+            .build());\n+        table.addCell(\"ingest.count\", TableColumnAttributeBuilder.builder(\"The total number of docs processed by the model\", false)\n+            .setAliases(\"ic\", \"ingestCount\")\n+            .build());\n+        table.addCell(\"ingest.time\", TableColumnAttributeBuilder.builder(\n+            \"The total time spent processing docs with this model\",\n+            false)\n+            .setAliases(\"it\", \"ingestTime\")\n+            .build());\n+        table.addCell(\"ingest.current\", TableColumnAttributeBuilder.builder(\n+            \"The total documents currently being handled by the model\",\n+            false)\n+            .setAliases(\"icurr\", \"ingestCurrent\")\n+            .build());\n+        table.addCell(\"ingest.failed\", TableColumnAttributeBuilder.builder(\n+            \"The total count of failed ingest attempts with this model\",\n+            false)\n+            .setAliases(\"if\", \"ingestFailed\")\n+            .build());\n+\n+        table.endHeaders();\n+        return table;\n+    }\n+\n+    private GroupedActionListener<ActionResponse> createGroupedListener(final RestRequest request,\n+                                                                        final int size,\n+                                                                        final List<TrainedModelConfig> configs,\n+                                                                        final ActionListener<Table> listener) {\n+        return new GroupedActionListener<>(new ActionListener<>() {\n+            @Override\n+            public void onResponse(final Collection<ActionResponse> responses) {\n+                GetTrainedModelsStatsAction.Response statsResponse = extractResponse(responses, GetTrainedModelsStatsAction.Response.class);\n+                GetDataFrameAnalyticsAction.Response analytics = extractResponse(responses, GetDataFrameAnalyticsAction.Response.class);\n+                listener.onResponse(buildTable(request,\n+                    statsResponse.getResources().results(),\n+                    configs,\n+                    analytics == null ? Collections.emptyList() : analytics.getResources().results()));\n+            }\n+\n+            @Override\n+            public void onFailure(final Exception e) {\n+                listener.onFailure(e);\n+            }\n+        }, size);\n+    }\n+\n+\n+    private Table buildTable(RestRequest request,\n+                             List<GetTrainedModelsStatsAction.Response.TrainedModelStats> stats,\n+                             List<TrainedModelConfig> configs,\n+                             List<DataFrameAnalyticsConfig> analyticsConfigs) {\n+        Table table = getTableWithHeader(request);\n+        assert configs.size() == stats.size();\n+\n+        Map<String, String> analyticsMap = analyticsConfigs.stream()\n+            .map(DataFrameAnalyticsConfig::getId)\n+            .collect(Collectors.toMap(Function.identity(), Function.identity()));\n+        logger.warn(\"ANALYTICS MAP  \" + analyticsMap);", "originalCommit": "250a1147634825bd8921bc3c3ad7844ddad9e112", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a93c6d48c53c0f3989c962617e9b76f9aa0ea42", "url": "https://github.com/elastic/elasticsearch/commit/4a93c6d48c53c0f3989c962617e9b76f9aa0ea42", "message": "adding more dfa columns", "committedDate": "2020-01-31T13:01:27Z", "type": "commit"}, {"oid": "5a63dfdadeb181916e59ee4c64530ea680816819", "url": "https://github.com/elastic/elasticsearch/commit/5a63dfdadeb181916e59ee4c64530ea680816819", "message": "fixing yaml test", "committedDate": "2020-01-31T14:26:52Z", "type": "commit"}, {"oid": "b833f8f13368a4289c12df4905f2d6d11c596f56", "url": "https://github.com/elastic/elasticsearch/commit/b833f8f13368a4289c12df4905f2d6d11c596f56", "message": "removing unused imports", "committedDate": "2020-01-31T14:34:59Z", "type": "commit"}, {"oid": "33175e82cc28bc74a9c0c3e2a0a638afbefcbbb1", "url": "https://github.com/elastic/elasticsearch/commit/33175e82cc28bc74a9c0c3e2a0a638afbefcbbb1", "message": "Merge branch 'master' into feature/ml-_cat-trainedmodels-api", "committedDate": "2020-01-31T14:59:49Z", "type": "commit"}, {"oid": "75cf793b52e047e1a0013969e285c09520461d48", "url": "https://github.com/elastic/elasticsearch/commit/75cf793b52e047e1a0013969e285c09520461d48", "message": "adjusting default columns", "committedDate": "2020-02-04T13:37:34Z", "type": "commit"}, {"oid": "7936ae38e4027a7130f44607e4c5b5eb1d199a5b", "url": "https://github.com/elastic/elasticsearch/commit/7936ae38e4027a7130f44607e4c5b5eb1d199a5b", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-_cat-trainedmodels-api", "committedDate": "2020-02-04T13:44:48Z", "type": "commit"}]}