{"pr_number": 58885, "pr_title": "Implement rejections in `WriteMemoryLimits`", "pr_createdAt": "2020-07-02T00:51:30Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58885", "timeline": [{"oid": "397f78de76c38d0ed26fda0aaeccc3aa37d79b1b", "url": "https://github.com/elastic/elasticsearch/commit/397f78de76c38d0ed26fda0aaeccc3aa37d79b1b", "message": "WIP", "committedDate": "2020-07-01T20:23:08Z", "type": "commit"}, {"oid": "00d7057034ba73bef8b56ca6c7143c6c1f7e44c8", "url": "https://github.com/elastic/elasticsearch/commit/00d7057034ba73bef8b56ca6c7143c6c1f7e44c8", "message": "Tests", "committedDate": "2020-07-02T00:48:49Z", "type": "commit"}, {"oid": "57fab742edaba0700f263b31198f85af97f21912", "url": "https://github.com/elastic/elasticsearch/commit/57fab742edaba0700f263b31198f85af97f21912", "message": "Fix tests", "committedDate": "2020-07-02T01:58:05Z", "type": "commit"}, {"oid": "1292822b9404500b188df1c14c8f5c9c0b520cfa", "url": "https://github.com/elastic/elasticsearch/commit/1292822b9404500b188df1c14c8f5c9c0b520cfa", "message": "Changes", "committedDate": "2020-07-02T16:39:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ5NzMzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r449497339", "bodyText": "While I think that this should be ok for now, it's critical to confirm though that our accounting is not completely off with some tests/benchmarks.\nA first test to ensure that we are not vastly underaccounting should have a high indices.write.limit (e.g. 80%) and check that we don't hit the real-memory circuit breaker when we are filling up the node (should probably block requests from being processed), but rather the indices.write.limit instead.\nA second test to ensure that we are not vastly overaccounting should have a low indices.write.limit, for example (e.g. 100MB), and show that we can still put a decently large number of requests to the system (i.e. send bulks that are in total making up 80MB in input size) without reaching the limit.\nThird we need to check what the overhead of primaries is to wait on replica responses (i.e. memory consumed by listeners etc.). For that we should block processing on a replica, and fill up a primary and see how much memory is being consumed.", "author": "ywelsch", "createdAt": "2020-07-03T10:00:41Z", "path": "server/src/main/java/org/elasticsearch/action/index/IndexRequest.java", "diffHunk": "@@ -697,6 +697,6 @@ public long getAutoGeneratedTimestamp() {\n \n     @Override\n     public long ramBytesUsed() {\n-        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(id) + (source == null ? 0 : source.ramBytesUsed());\n+        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(id) + (source == null ? 0 : source.length());", "originalCommit": "1292822b9404500b188df1c14c8f5c9c0b520cfa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ5OTM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r449499360", "bodyText": "I discussed this with Henning, and we think that a second replica limit would be useful here (e.g. defaulting to 1,5 times the indices.write.limit). In the past we have been rejecting replica operations at the real-memory circuit breaker limit (i.e. 95%), which can have adverse effects on the rest of the system. We should have another limit for replicas much lower than that. It won't solve all problems with handling primary vs replica bytes, but it puts an additional safeguard into the system.", "author": "ywelsch", "createdAt": "2020-07-03T10:04:51Z", "path": "server/src/main/java/org/elasticsearch/action/bulk/WriteMemoryLimits.java", "diffHunk": "@@ -20,17 +20,50 @@\n package org.elasticsearch.action.bulk;\n \n import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n \n import java.util.concurrent.atomic.AtomicLong;\n \n public class WriteMemoryLimits {\n \n+    // TODO: Adjust\n+    public static final Setting<ByteSizeValue> MAX_INDEXING_BYTES =\n+        Setting.memorySizeSetting(\"indices.write.limit\", \"10%\", Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n     private final AtomicLong writeBytes = new AtomicLong(0);\n     private final AtomicLong replicaWriteBytes = new AtomicLong(0);\n+    private volatile long writeLimits;\n+\n+    public WriteMemoryLimits(Settings settings, ClusterSettings clusterSettings) {\n+        this.writeLimits = MAX_INDEXING_BYTES.get(settings).getBytes();\n+        clusterSettings.addSettingsUpdateConsumer(MAX_INDEXING_BYTES, value -> writeLimits = value.getBytes());\n+    }\n \n     public Releasable markWriteOperationStarted(long bytes) {\n-        writeBytes.addAndGet(bytes);\n-        return () -> writeBytes.getAndAdd(-bytes);\n+        return markWriteOperationStarted(bytes, false);\n+    }\n+\n+    public Releasable markWriteOperationStarted(long bytes, boolean forceExecution) {\n+        long writeBytes = this.writeBytes.addAndGet(bytes);\n+        long replicaWriteBytes = this.replicaWriteBytes.get();\n+        long totalBytes = writeBytes + replicaWriteBytes;\n+        long localWriteLimits = this.writeLimits;\n+        if (forceExecution == false && totalBytes > localWriteLimits) {", "originalCommit": "1292822b9404500b188df1c14c8f5c9c0b520cfa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUwMDIyNw==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r449500227", "bodyText": "10% can be quite a lot for a system with a big heap (i.e. 3GB for a 32GB heap). Should we put an upper bound on this number? Can we run some benchmarks to determine what a good limit would look like (e.g. by checking the lowest limit we can get away with using our current Rally benchmarks).", "author": "ywelsch", "createdAt": "2020-07-03T10:06:47Z", "path": "server/src/main/java/org/elasticsearch/action/bulk/WriteMemoryLimits.java", "diffHunk": "@@ -20,17 +20,50 @@\n package org.elasticsearch.action.bulk;\n \n import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n \n import java.util.concurrent.atomic.AtomicLong;\n \n public class WriteMemoryLimits {\n \n+    // TODO: Adjust\n+    public static final Setting<ByteSizeValue> MAX_INDEXING_BYTES =\n+        Setting.memorySizeSetting(\"indices.write.limit\", \"10%\", Setting.Property.NodeScope, Setting.Property.Dynamic);", "originalCommit": "1292822b9404500b188df1c14c8f5c9c0b520cfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyMTI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r450521272", "bodyText": "I'm not sure what rally benchmarks you are referring to? All of the rally benchmarks by default are going to use very little indexing memory since they don't use many clients.\nI ran some benchmarks today with 10K clients per node and have some numbers. But those a pretty specific to the security use case. We can talk about them tomorrow. But generally the CPUs were saturated with indexing and write queue latency was pretty high (ranging from 50ms - 2s through the benchmark.) In these benchmarks the write limits tended to be 200-300MB and the replica limits tended to be 10-80MB.", "author": "tbrooks8", "createdAt": "2020-07-06T22:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUwMDIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzNDAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r450534008", "bodyText": "I'm not exactly sure what specific benchmarks you want here. I have run this with some concurrent security benchmarks and have a good idea about the write limits under various load. But our normally nightly rally benchmarks use very few clients and will not consume significant indexing memory.", "author": "tbrooks8", "createdAt": "2020-07-06T23:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUwMDIyNw=="}], "type": "inlineReview"}, {"oid": "c75598990254b65185cf01d5286ebc86dc6cd534", "url": "https://github.com/elastic/elasticsearch/commit/c75598990254b65185cf01d5286ebc86dc6cd534", "message": "Merge remote-tracking branch 'upstream/master' into reject_based_on_write_limits", "committedDate": "2020-07-06T15:57:01Z", "type": "commit"}, {"oid": "dbab82ffa81d1e8e780333f74674ef00190d1ad8", "url": "https://github.com/elastic/elasticsearch/commit/dbab82ffa81d1e8e780333f74674ef00190d1ad8", "message": "Changes", "committedDate": "2020-07-06T17:12:01Z", "type": "commit"}, {"oid": "cba3bb15fe1e7c61727574f6c296d9f0f85ab656", "url": "https://github.com/elastic/elasticsearch/commit/cba3bb15fe1e7c61727574f6c296d9f0f85ab656", "message": "Change", "committedDate": "2020-07-06T23:04:10Z", "type": "commit"}, {"oid": "40b1eb786546f38e755152aa7cd6b10869a757c6", "url": "https://github.com/elastic/elasticsearch/commit/40b1eb786546f38e755152aa7cd6b10869a757c6", "message": "Merge remote-tracking branch 'upstream/master' into reject_based_on_write_limits", "committedDate": "2020-07-08T13:56:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1MzQ0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r451553445", "bodyText": "As discussed, let's make this a non-dynamic node setting. We also need to discuss whether we should white-list this setting in Cloud (so that users can change it there).\nI think that we should not pick a setting name that is under the  \"indices\" namespace, but perhaps introduce something completely new, for example indexing_limits.memory.limit", "author": "ywelsch", "createdAt": "2020-07-08T13:42:20Z", "path": "server/src/main/java/org/elasticsearch/action/bulk/WriteMemoryLimits.java", "diffHunk": "@@ -20,26 +20,68 @@\n package org.elasticsearch.action.bulk;\n \n import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n \n import java.util.concurrent.atomic.AtomicLong;\n \n public class WriteMemoryLimits {\n \n+    // TODO: Adjust\n+    public static final Setting<ByteSizeValue> MAX_INDEXING_BYTES =\n+        Setting.memorySizeSetting(\"indices.write.limit\", \"10%\", Setting.Property.NodeScope, Setting.Property.Dynamic);", "originalCommit": "cba3bb15fe1e7c61727574f6c296d9f0f85ab656", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3NTk3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r451575975", "bodyText": "I changed the name and made it non-dynamic.", "author": "tbrooks8", "createdAt": "2020-07-08T14:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1MzQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1ODQyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r451558421", "bodyText": "As we discussed, we eventually want to have a test that also covers the rest layer.", "author": "ywelsch", "createdAt": "2020-07-08T13:49:08Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/action/bulk/WriteMemoryLimitsIT.java", "diffHunk": "@@ -210,16 +185,242 @@ public void testWriteBytesAreIncremented() throws Exception {\n             if (replicationSendPointReached.getCount() > 0) {\n                 replicationSendPointReached.countDown();\n             }\n-            while (newActionsSendPointReached.getCount() > 0) {\n-                newActionsSendPointReached.countDown();\n-            }\n+            replicaRelease.close();\n             if (latchBlockingReplicationSend.getCount() > 0) {\n                 latchBlockingReplicationSend.countDown();\n             }\n-            if (latchBlockingReplication.getCount() > 0) {\n-                latchBlockingReplication.countDown();\n-            }\n+            replicaRelease.close();\n             primaryTransportService.clearAllRules();\n         }\n     }\n+\n+    public void testWriteCanBeRejectedAtCoordinatingLevel() throws Exception {", "originalCommit": "cba3bb15fe1e7c61727574f6c296d9f0f85ab656", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3NTc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58885#discussion_r451575747", "bodyText": "I added a comment.", "author": "tbrooks8", "createdAt": "2020-07-08T14:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1ODQyMQ=="}], "type": "inlineReview"}, {"oid": "cde58b93f8e91939ef75a2fcc37a022712216a52", "url": "https://github.com/elastic/elasticsearch/commit/cde58b93f8e91939ef75a2fcc37a022712216a52", "message": "Setting", "committedDate": "2020-07-08T14:10:39Z", "type": "commit"}, {"oid": "243de3592f8a7a4c6495329dba9ea5a9cf6b51b0", "url": "https://github.com/elastic/elasticsearch/commit/243de3592f8a7a4c6495329dba9ea5a9cf6b51b0", "message": "Fix tests", "committedDate": "2020-07-08T15:53:26Z", "type": "commit"}]}