{"pr_number": 63644, "pr_title": "EQL: [Tests] Add correctness integration tests", "pr_createdAt": "2020-10-13T23:05:45Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63644", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNzA1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504517052", "bodyText": "These can be externalized into a properties file.\nThe \"matriv-gcs\" should be changed to something more generic.", "author": "costin", "createdAt": "2020-10-14T09:00:42Z", "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n+import org.apache.http.HttpHost;\n+import org.apache.lucene.util.TimeUnits;\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.client.HttpAsyncResponseConsumerFactory;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.ResponseException;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.eql.EqlSearchRequest;\n+import org.elasticsearch.client.eql.EqlSearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.TestUtils.assertNoSearchContexts;\n+\n+@TimeoutSuite(millis = 60 * TimeUnits.MINUTE)\n+public class EsEQLCorrectnessIT extends ESRestTestCase {\n+\n+    private static final String PARAM_FORMATTING = \"%1$s\";\n+    private static final String QUERIES_FILENAME = \"queries.toml\";\n+    private static final String INDEX_NAME = \"mitre\";\n+    private static final int FETCH_SIZE = 10000;\n+    private static final String GCS_REPO_NAME = \"eql_correctness_gcs_repo\";\n+    private static final String SNAPSHOT_NAME = \"mitre-snapshot\";\n+    private static final String GCS_BUCKET_NAME = \"matriv-gcs\";\n+    private static final String GCS_BASE_PATH = \"mitre-data\";\n+    private static final String GCS_CLIENT_NAME = \"eql_test\";", "originalCommit": "75a827feb13d29422d5e09a991a18e780892d8e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyOTIzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504529239", "bodyText": "I'd be meaning to do it, but let's get this in as is, and I will rename the bucket soon.", "author": "matriv", "createdAt": "2020-10-14T09:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNzkyNg==", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504517926", "bodyText": "This should be moved into a separate method and be guarded by an if statement for a bool flag which can be turned on/off if needed.", "author": "costin", "createdAt": "2020-10-14T09:02:01Z", "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n+import org.apache.http.HttpHost;\n+import org.apache.lucene.util.TimeUnits;\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.client.HttpAsyncResponseConsumerFactory;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.ResponseException;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.eql.EqlSearchRequest;\n+import org.elasticsearch.client.eql.EqlSearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.TestUtils.assertNoSearchContexts;\n+\n+@TimeoutSuite(millis = 60 * TimeUnits.MINUTE)\n+public class EsEQLCorrectnessIT extends ESRestTestCase {\n+\n+    private static final String PARAM_FORMATTING = \"%1$s\";\n+    private static final String QUERIES_FILENAME = \"queries.toml\";\n+    private static final String INDEX_NAME = \"mitre\";\n+    private static final int FETCH_SIZE = 10000;\n+    private static final String GCS_REPO_NAME = \"eql_correctness_gcs_repo\";\n+    private static final String SNAPSHOT_NAME = \"mitre-snapshot\";\n+    private static final String GCS_BUCKET_NAME = \"matriv-gcs\";\n+    private static final String GCS_BASE_PATH = \"mitre-data\";\n+    private static final String GCS_CLIENT_NAME = \"eql_test\";\n+    private static RestHighLevelClient highLevelClient;\n+    private static RequestOptions COMMON_REQUEST_OPTIONS;\n+\n+    @BeforeClass\n+    public static void init() {\n+        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();\n+        builder.setHttpAsyncResponseConsumerFactory(\n+            new HttpAsyncResponseConsumerFactory.HeapBufferedResponseConsumerFactory(1000 * 1024 * 1024)\n+        );\n+        COMMON_REQUEST_OPTIONS = builder.build();\n+    }\n+\n+    @Before\n+    public void restoreDataFromGcsRepo() throws Exception {\n+        if (client().performRequest(new Request(\"HEAD\", \"/\" + INDEX_NAME)).getStatusLine().getStatusCode() == 404) {\n+            highLevelClient().snapshot()\n+                .createRepository(\n+                    new PutRepositoryRequest(GCS_REPO_NAME).type(\"gcs\")\n+                        .settings(\n+                            Settings.builder()\n+                                .put(\"bucket\", GCS_BUCKET_NAME)\n+                                .put(\"base_path\", GCS_BASE_PATH)\n+                                .put(\"client\", GCS_CLIENT_NAME)\n+                                .build()\n+                        ),\n+                    RequestOptions.DEFAULT\n+                );\n+            highLevelClient().snapshot()\n+                .restore(new RestoreSnapshotRequest(GCS_REPO_NAME, SNAPSHOT_NAME).waitForCompletion(true), RequestOptions.DEFAULT);\n+        }\n+    }\n+\n+    @After\n+    public void checkSearchContent() throws Exception {\n+        assertNoSearchContexts(client());\n+    }\n+\n+    @AfterClass\n+    public static void wipeTestData() throws IOException {\n+        try {\n+            adminClient().performRequest(new Request(\"DELETE\", \"/*\"));\n+        } catch (ResponseException e) {\n+            // 404 here just means we had no indexes\n+            if (e.getResponse().getStatusLine().getStatusCode() != 404) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterUponCompletion() {\n+        // Need to preserve data between parameterized tests runs\n+        return true;\n+    }\n+\n+    @Override\n+    protected RestClient buildClient(Settings settings, HttpHost[] hosts) throws IOException {\n+        RestClientBuilder builder = RestClient.builder(hosts);\n+        configureClient(builder, settings);\n+        builder.setRequestConfigCallback(\n+            requestConfigBuilder -> requestConfigBuilder.setConnectTimeout(30000000)\n+                .setConnectionRequestTimeout(30000000)\n+                .setSocketTimeout(30000000)\n+        );\n+        builder.setStrictDeprecationMode(true);\n+        return builder.build();\n+    }\n+\n+    private EqlSpec spec;\n+\n+    public EsEQLCorrectnessIT(EqlSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    private RestHighLevelClient highLevelClient() {\n+        if (highLevelClient == null) {\n+            highLevelClient = new RestHighLevelClient(client(), ignore -> {}, Collections.emptyList()) {\n+            };\n+        }\n+        return highLevelClient;\n+    }\n+\n+    @ParametersFactory(shuffle = false, argumentFormatting = PARAM_FORMATTING)\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        Collection<EqlSpec> specs;\n+        try (InputStream is = EsEQLCorrectnessIT.class.getClassLoader().getResourceAsStream(QUERIES_FILENAME)) {\n+            specs = EqlSpecLoader.readFromStream(is);\n+        }\n+        assertFalse(\"Found 0 queries for testing\", specs.isEmpty());\n+\n+        List<Object[]> params = new ArrayList<>(specs.size());\n+        for (EqlSpec spec : specs) {\n+            params.add(new Object[] { spec });\n+        }\n+        return params;\n+    }\n+\n+    public void test() throws Exception {\n+        long totalTime = 0;\n+        int queryNo = spec.queryNo();\n+        /* For debugging\n+        for (int i = 0; i < spec.filters().length; i++) {\n+            String filterQuery = spec.filters()[i];\n+            EqlSearchRequest eqlSearchRequest = new EqlSearchRequest(INDEX_NAME, filterQuery);\n+            eqlSearchRequest.eventCategoryField(\"event_type\");\n+            eqlSearchRequest.size(100000);\n+            EqlSearchResponse response = client.eql().search(eqlSearchRequest, commonRequestOptions);\n+            assertEquals(\"Failed to match filter counts for query No: \" + queryNo + \" filterCount: \" + i,\n+                    spec.filterCounts()[i], response.hits().events().size());\n+        } */", "originalCommit": "75a827feb13d29422d5e09a991a18e780892d8e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxODE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504518168", "bodyText": "These should be extracted as well to constants to make it easy to tweak.", "author": "costin", "createdAt": "2020-10-14T09:02:23Z", "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n+import org.apache.http.HttpHost;\n+import org.apache.lucene.util.TimeUnits;\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.client.HttpAsyncResponseConsumerFactory;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.ResponseException;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.eql.EqlSearchRequest;\n+import org.elasticsearch.client.eql.EqlSearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.TestUtils.assertNoSearchContexts;\n+\n+@TimeoutSuite(millis = 60 * TimeUnits.MINUTE)\n+public class EsEQLCorrectnessIT extends ESRestTestCase {\n+\n+    private static final String PARAM_FORMATTING = \"%1$s\";\n+    private static final String QUERIES_FILENAME = \"queries.toml\";\n+    private static final String INDEX_NAME = \"mitre\";\n+    private static final int FETCH_SIZE = 10000;\n+    private static final String GCS_REPO_NAME = \"eql_correctness_gcs_repo\";\n+    private static final String SNAPSHOT_NAME = \"mitre-snapshot\";\n+    private static final String GCS_BUCKET_NAME = \"matriv-gcs\";\n+    private static final String GCS_BASE_PATH = \"mitre-data\";\n+    private static final String GCS_CLIENT_NAME = \"eql_test\";\n+    private static RestHighLevelClient highLevelClient;\n+    private static RequestOptions COMMON_REQUEST_OPTIONS;\n+\n+    @BeforeClass\n+    public static void init() {\n+        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();\n+        builder.setHttpAsyncResponseConsumerFactory(\n+            new HttpAsyncResponseConsumerFactory.HeapBufferedResponseConsumerFactory(1000 * 1024 * 1024)\n+        );\n+        COMMON_REQUEST_OPTIONS = builder.build();\n+    }\n+\n+    @Before\n+    public void restoreDataFromGcsRepo() throws Exception {\n+        if (client().performRequest(new Request(\"HEAD\", \"/\" + INDEX_NAME)).getStatusLine().getStatusCode() == 404) {\n+            highLevelClient().snapshot()\n+                .createRepository(\n+                    new PutRepositoryRequest(GCS_REPO_NAME).type(\"gcs\")\n+                        .settings(\n+                            Settings.builder()\n+                                .put(\"bucket\", GCS_BUCKET_NAME)\n+                                .put(\"base_path\", GCS_BASE_PATH)\n+                                .put(\"client\", GCS_CLIENT_NAME)\n+                                .build()\n+                        ),\n+                    RequestOptions.DEFAULT\n+                );\n+            highLevelClient().snapshot()\n+                .restore(new RestoreSnapshotRequest(GCS_REPO_NAME, SNAPSHOT_NAME).waitForCompletion(true), RequestOptions.DEFAULT);\n+        }\n+    }\n+\n+    @After\n+    public void checkSearchContent() throws Exception {\n+        assertNoSearchContexts(client());\n+    }\n+\n+    @AfterClass\n+    public static void wipeTestData() throws IOException {\n+        try {\n+            adminClient().performRequest(new Request(\"DELETE\", \"/*\"));\n+        } catch (ResponseException e) {\n+            // 404 here just means we had no indexes\n+            if (e.getResponse().getStatusLine().getStatusCode() != 404) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterUponCompletion() {\n+        // Need to preserve data between parameterized tests runs\n+        return true;\n+    }\n+\n+    @Override\n+    protected RestClient buildClient(Settings settings, HttpHost[] hosts) throws IOException {\n+        RestClientBuilder builder = RestClient.builder(hosts);\n+        configureClient(builder, settings);\n+        builder.setRequestConfigCallback(\n+            requestConfigBuilder -> requestConfigBuilder.setConnectTimeout(30000000)\n+                .setConnectionRequestTimeout(30000000)\n+                .setSocketTimeout(30000000)\n+        );\n+        builder.setStrictDeprecationMode(true);\n+        return builder.build();\n+    }\n+\n+    private EqlSpec spec;\n+\n+    public EsEQLCorrectnessIT(EqlSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    private RestHighLevelClient highLevelClient() {\n+        if (highLevelClient == null) {\n+            highLevelClient = new RestHighLevelClient(client(), ignore -> {}, Collections.emptyList()) {\n+            };\n+        }\n+        return highLevelClient;\n+    }\n+\n+    @ParametersFactory(shuffle = false, argumentFormatting = PARAM_FORMATTING)\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        Collection<EqlSpec> specs;\n+        try (InputStream is = EsEQLCorrectnessIT.class.getClassLoader().getResourceAsStream(QUERIES_FILENAME)) {\n+            specs = EqlSpecLoader.readFromStream(is);\n+        }\n+        assertFalse(\"Found 0 queries for testing\", specs.isEmpty());\n+\n+        List<Object[]> params = new ArrayList<>(specs.size());\n+        for (EqlSpec spec : specs) {\n+            params.add(new Object[] { spec });\n+        }\n+        return params;\n+    }\n+\n+    public void test() throws Exception {\n+        long totalTime = 0;\n+        int queryNo = spec.queryNo();\n+        /* For debugging\n+        for (int i = 0; i < spec.filters().length; i++) {\n+            String filterQuery = spec.filters()[i];\n+            EqlSearchRequest eqlSearchRequest = new EqlSearchRequest(INDEX_NAME, filterQuery);\n+            eqlSearchRequest.eventCategoryField(\"event_type\");\n+            eqlSearchRequest.size(100000);\n+            EqlSearchResponse response = client.eql().search(eqlSearchRequest, commonRequestOptions);\n+            assertEquals(\"Failed to match filter counts for query No: \" + queryNo + \" filterCount: \" + i,\n+                    spec.filterCounts()[i], response.hits().events().size());\n+        } */\n+\n+        EqlSearchRequest eqlSearchRequest = new EqlSearchRequest(INDEX_NAME, spec.query());\n+        eqlSearchRequest.eventCategoryField(\"event_type\");\n+        eqlSearchRequest.tiebreakerField(\"serial_id\");\n+        eqlSearchRequest.size(2000);\n+        eqlSearchRequest.fetchSize(FETCH_SIZE);", "originalCommit": "75a827feb13d29422d5e09a991a18e780892d8e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9e5e7f59f986c8a37b47969334ccc6732799cba", "url": "https://github.com/elastic/elasticsearch/commit/e9e5e7f59f986c8a37b47969334ccc6732799cba", "message": "EQL: [Tests] Add correctness integration tests", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "18f96f16d946e746030b336ca14eaccca4a00353", "url": "https://github.com/elastic/elasticsearch/commit/18f96f16d946e746030b336ca14eaccca4a00353", "message": "various fixes", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "4675c74075a4653c2b58475b172a7435bd4f894a", "url": "https://github.com/elastic/elasticsearch/commit/4675c74075a4653c2b58475b172a7435bd4f894a", "message": "increase timeouts", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "4c245d96c6b2a1b3fdd714bf377eba5bd57fb6de", "url": "https://github.com/elastic/elasticsearch/commit/4c245d96c6b2a1b3fdd714bf377eba5bd57fb6de", "message": "fix query", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "a0dfef6fd99aa64168643d9d98a5bba71dc81a78", "url": "https://github.com/elastic/elasticsearch/commit/a0dfef6fd99aa64168643d9d98a5bba71dc81a78", "message": "Externalize credentials file location", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "11e1d5662d741c92776d262c4ee064afdea23017", "url": "https://github.com/elastic/elasticsearch/commit/11e1d5662d741c92776d262c4ee064afdea23017", "message": "use properties file for configuration parameters", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "6f37fd2b5f2c3cca29960aa7aa11a2e95c5dc9fd", "url": "https://github.com/elastic/elasticsearch/commit/6f37fd2b5f2c3cca29960aa7aa11a2e95c5dc9fd", "message": "enable debugging of subqueries", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "f3172218dbde389142d495404f27f8885c9f3d60", "url": "https://github.com/elastic/elasticsearch/commit/f3172218dbde389142d495404f27f8885c9f3d60", "message": "Reduce required heap size", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "f7f0ffbe77e0f678d096cf7b7bdac6b5e44eff0d", "url": "https://github.com/elastic/elasticsearch/commit/f7f0ffbe77e0f678d096cf7b7bdac6b5e44eff0d", "message": "Comment out failing test query", "committedDate": "2020-10-14T19:26:19Z", "type": "commit"}, {"oid": "f7f0ffbe77e0f678d096cf7b7bdac6b5e44eff0d", "url": "https://github.com/elastic/elasticsearch/commit/f7f0ffbe77e0f678d096cf7b7bdac6b5e44eff0d", "message": "Comment out failing test query", "committedDate": "2020-10-14T19:26:19Z", "type": "forcePushed"}, {"oid": "d3e32ddb5ffa667c545c9c7de0b81460bb1fe0a3", "url": "https://github.com/elastic/elasticsearch/commit/d3e32ddb5ffa667c545c9c7de0b81460bb1fe0a3", "message": "Add documentation", "committedDate": "2020-10-15T09:21:09Z", "type": "commit"}, {"oid": "ecbca65b809169d6f0f488b81a43175f17d22476", "url": "https://github.com/elastic/elasticsearch/commit/ecbca65b809169d6f0f488b81a43175f17d22476", "message": "Merge remote-tracking branch 'upstream/master' into eql-correctness-tests", "committedDate": "2020-10-15T09:21:25Z", "type": "commit"}, {"oid": "c038173131091c4cfb3eb2257e247febcd999f80", "url": "https://github.com/elastic/elasticsearch/commit/c038173131091c4cfb3eb2257e247febcd999f80", "message": "fix docs and log of query execution time", "committedDate": "2020-10-15T11:56:13Z", "type": "commit"}]}