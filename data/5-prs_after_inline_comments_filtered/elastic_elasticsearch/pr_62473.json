{"pr_number": 62473, "pr_title": "Build local unreleased bwc versions more efficient for tests", "pr_createdAt": "2020-09-16T15:18:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62473", "timeline": [{"oid": "60a2c55508206909cba2d8481dafacb59be9e8df", "url": "https://github.com/elastic/elasticsearch/commit/60a2c55508206909cba2d8481dafacb59be9e8df", "message": "fix bwc jdbc build", "committedDate": "2020-09-21T16:11:03Z", "type": "forcePushed"}, {"oid": "f544a08bf99cc8f92c0b3437702901e42a75b9b2", "url": "https://github.com/elastic/elasticsearch/commit/f544a08bf99cc8f92c0b3437702901e42a75b9b2", "message": "Minor refactoring of the plugin and fixing path calculations", "committedDate": "2020-09-23T13:25:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzOTUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496939515", "bodyText": "What does the entirety of the lifecycle output look like? This comment on its own would be pretty cryptic", "author": "rjernst", "createdAt": "2020-09-29T18:09:01Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzOTM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497339348", "bodyText": "The overall lifecycle output here hasn't changed in this PR and would look e.g. like this:\n> Task :distribution:bwc:bugfix:checkoutBwcBranch\nCommit date of current: 'Wed, 30 Sep 2020 10:33:41 +0200'\nPerforming checkout of elastic/7.9...\nCheckout hash for :distribution:bwc:bugfix is c9534e03e8beae7e9b566cda7236532665c376e9", "author": "breskeby", "createdAt": "2020-09-30T08:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzOTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MjIzNg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942236", "bodyText": "We can just use Files.write:\nFiles.writeString(file.toPath(), content);", "author": "rjernst", "createdAt": "2020-09-29T18:13:41Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTcwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498079701", "bodyText": "done", "author": "breskeby", "createdAt": "2020-10-01T08:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MjIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0Mjg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942844", "bodyText": "Let's not swallow any exceptions. This should cause the build to fail. If we can't let it propagate as is, then wrap it with UncheckedIOException?", "author": "rjernst", "createdAt": "2020-09-29T18:14:42Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062022", "bodyText": "fixed", "author": "breskeby", "createdAt": "2020-10-01T08:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0Mjg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943521", "bodyText": "If we need a git specific method, then the spec should set the executable to git? Otherwise how is this different than just a generic exec helper?", "author": "rjernst", "createdAt": "2020-09-29T18:15:51Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private String execGit(Action<ExecSpec> execSpecConfig) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062263", "bodyText": "I removed the git part of it. at the end its just about using the common working dir", "author": "breskeby", "createdAt": "2020-10-01T08:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkzNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943937", "bodyText": "nit: These -> these", "author": "rjernst", "createdAt": "2020-09-29T18:16:35Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062329", "bodyText": "fixed", "author": "breskeby", "createdAt": "2020-10-01T08:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzczMA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497063730", "bodyText": "Will this go away when these changes are backported?", "author": "mark-vieira", "createdAt": "2020-09-29T21:14:40Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java", "diffHunk": "@@ -94,14 +94,22 @@ private void registerInternalDistributionResolutions(NamedDomainObjectContainer<\n                             + \"without a bundled JDK is not supported.\"\n                     );\n                 }\n+                String distributionProjectName = distributionProjectName(distribution);\n+                String projectConfig = getProjectConfig(distributionProjectName, unreleasedInfo);\n                 return new ProjectBasedDistributionDependency(\n-                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, distributionProjectName(distribution))\n+                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, projectConfig)\n                 );\n             }\n             return null;\n         }));\n     }\n \n+    private static String getProjectConfig(String distributionProjectName, BwcVersions.UnreleasedVersionInfo info) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM2NDg2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497364866", "bodyText": "yes, adding a not. Though I think we can only backport this down to 7.x we will live with that for a while till bugfix and minor is actually taken from that branch.", "author": "breskeby", "createdAt": "2020-09-30T09:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497064898", "bodyText": "Can't this be injected as a constructor arg?", "author": "mark-vieira", "createdAt": "2020-09-29T21:17:02Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2Mjc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062787", "bodyText": "done", "author": "breskeby", "createdAt": "2020-10-01T08:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzAzMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497067033", "bodyText": "Does this only technically \"work\" since we are lazily configuring these tasks?", "author": "mark-vieira", "createdAt": "2020-09-29T21:21:10Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4NTM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497385398", "bodyText": "yes. One clean solution could be to change the implementation of LoggedExec to not rely on the Exec Task", "author": "breskeby", "createdAt": "2020-09-30T09:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497068154", "bodyText": "Can we leverage Util.getBooleanProperty() here?", "author": "mark-vieira", "createdAt": "2020-09-29T21:23:30Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4NzM3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497387371", "bodyText": "Ideally we should move away from just using System.getProperty and therefore Util.getBooleanProperty as is as this is discouraged by gradle in order to support --configuration-cache. IMO we should actually deprecate Util.getBooleanProperty  or change its implementation to take a ProviderFactory", "author": "breskeby", "createdAt": "2020-09-30T09:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497654145", "bodyText": "Understood. Yeah, we do this pattern a lot so maybe we should later add some helper for returning a provider.", "author": "mark-vieira", "createdAt": "2020-09-30T16:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NTkxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497655917", "bodyText": "Why not turn Util.getBooleanProperty() into that helper?", "author": "rjernst", "createdAt": "2020-09-30T16:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NjgwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497656801", "bodyText": "I don't believe everywhere we use that is setup to consume a Provider as-is. We'd have to do some refactoring there and it's significant to probably address in a separate PR.", "author": "mark-vieira", "createdAt": "2020-09-30T16:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY2NzI5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497667299", "bodyText": "Sorry, I was not suggesting changing in this PR, only changing the implementation of that method in a followup, rather than continuing to add any more uses of this pattern.", "author": "rjernst", "createdAt": "2020-09-30T17:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NDY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497074649", "bodyText": "Looks like we aren't using bwcProject for anything?", "author": "mark-vieira", "createdAt": "2020-09-29T21:36:24Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4ODczOA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497388738", "bodyText": "removed", "author": "breskeby", "createdAt": "2020-09-30T09:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497077188", "bodyText": "What's the purpose of passing unreleaseVersionInfo to the extension and then just grabbing it back out? Do we need the getUnreleaseVersionInfo() method on the extensions since we already have a handle to that here?", "author": "mark-vieira", "createdAt": "2020-09-29T21:42:06Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM5NjcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497396723", "bodyText": "actually just an oversight from refactoring. fixed", "author": "breskeby", "createdAt": "2020-09-30T10:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497080013", "bodyText": "I'm not sure ArchiveProject is the right name here since this includes deb and rpm packages. Our packaging nomenclature uses \"archive\" to mean specifically zip and tar.", "author": "mark-vieira", "createdAt": "2020-09-29T21:47:31Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MzY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498063680", "bodyText": "changed to DistributionProject", "author": "breskeby", "createdAt": "2020-10-01T08:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MDAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497081919", "bodyText": "I think we can remove this condition given that we will never build a bwc branch prior to this version since the oldest active branch is 6.8.", "author": "mark-vieira", "createdAt": "2020-09-29T21:51:46Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {\n+            projects.addAll(asList(\"zip\"));\n+        }\n+\n+        return projects.stream().map(name -> {\n+            String baseDir = \"distribution\";\n+            if (bwcVersion.onOrAfter(\"6.3.0\")) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExNzMwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497117308", "bodyText": "In master that is true, though we should be sure to add it back then in the backport to 7.x", "author": "rjernst", "createdAt": "2020-09-29T23:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyNTg3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497125873", "bodyText": "The oldest version of ES that 7.x will ever build from source is 6.8.x. This is definitely legacy logic that is no longer needed in any active development branch.", "author": "mark-vieira", "createdAt": "2020-09-29T23:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyODg1OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497128858", "bodyText": "Doh, you are absolutely right. Ignore me!", "author": "rjernst", "createdAt": "2020-09-29T23:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497082406", "bodyText": "I think we can ditch this conditional branch. As mentioned below, we no longer will ever build versions prior to 6.8 from source for bwc.", "author": "mark-vieira", "createdAt": "2020-09-29T21:52:54Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MzczMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498063733", "bodyText": "removed", "author": "breskeby", "createdAt": "2020-10-01T08:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTU5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497085593", "bodyText": "Here we zero out the task dependencies but above we actually disable the task. Should we do one or the other?", "author": "mark-vieira", "createdAt": "2020-09-29T22:00:04Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzNzUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497537525", "bodyText": "actually I took that over from the original bwc build.gradle script but I don't see the point. Assemble should build all artefacts of that project. if its referenced somewhere were we do not want that. we should fix it there. I'll remove this. Also I think the distribution plugin is not needed.", "author": "breskeby", "createdAt": "2020-09-30T14:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTU5Mw=="}], "type": "inlineReview"}, {"oid": "aa2ac780e895911fd352a98a290ecb286e767626", "url": "https://github.com/elastic/elasticsearch/commit/aa2ac780e895911fd352a98a290ecb286e767626", "message": "Start porting bwc distribution setup into plugin", "committedDate": "2020-09-30T08:33:37Z", "type": "commit"}, {"oid": "0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "url": "https://github.com/elastic/elasticsearch/commit/0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "message": "Move git checkout logic into its own plugin", "committedDate": "2020-09-30T08:33:37Z", "type": "commit"}, {"oid": "27decd8d692f49640205923064472798c2ae444f", "url": "https://github.com/elastic/elasticsearch/commit/27decd8d692f49640205923064472798c2ae444f", "message": "Fix spotless", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "876be3303e61ad8ce1366d23a10132e24812ca1e", "url": "https://github.com/elastic/elasticsearch/commit/876be3303e61ad8ce1366d23a10132e24812ca1e", "message": "Port more bwc setup into binary plugin", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "c490dbe281e85c53a9d97a01919154dd5517999c", "url": "https://github.com/elastic/elasticsearch/commit/c490dbe281e85c53a9d97a01919154dd5517999c", "message": "Cleanup", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "0473bd731f336227259dc60a908d912d70dd53c9", "url": "https://github.com/elastic/elasticsearch/commit/0473bd731f336227259dc60a908d912d70dd53c9", "message": "Fix minor issues in bwc setup", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "2a16102ced91dd3745d780841bbed4fc73aa87fd", "url": "https://github.com/elastic/elasticsearch/commit/2a16102ced91dd3745d780841bbed4fc73aa87fd", "message": "Formatting", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "c19484aea04a9d7e5211013f0db8931d96f7fadf", "url": "https://github.com/elastic/elasticsearch/commit/c19484aea04a9d7e5211013f0db8931d96f7fadf", "message": "Extract specific logic from plugin", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "url": "https://github.com/elastic/elasticsearch/commit/584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "message": "Fix expected artifact paths", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "url": "https://github.com/elastic/elasticsearch/commit/3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "message": "fix bwc jdbc build", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "url": "https://github.com/elastic/elasticsearch/commit/e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "message": "Add initial test coverage for general bwc setup", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "url": "https://github.com/elastic/elasticsearch/commit/20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "message": "Tweak func tests for bwc build setup", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "4b274baebaf6f2eb908cc1998760ab731216dfee", "url": "https://github.com/elastic/elasticsearch/commit/4b274baebaf6f2eb908cc1998760ab731216dfee", "message": "Add todo", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "fb6caff2525584d10577d8e164a008697673454b", "url": "https://github.com/elastic/elasticsearch/commit/fb6caff2525584d10577d8e164a008697673454b", "message": "Minor refactoring of the plugin and fixing path calculations", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "5a5fb669575dea27c04bba1646bb9a5464b53814", "url": "https://github.com/elastic/elasticsearch/commit/5a5fb669575dea27c04bba1646bb9a5464b53814", "message": "Expose exploded dists as artifacts", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "0f40234e245834e81d9da285999b3544c92f5f75", "url": "https://github.com/elastic/elasticsearch/commit/0f40234e245834e81d9da285999b3544c92f5f75", "message": "Fix spotless", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "9d523e134481093d3ebc0e0db3f85a8c38f288e7", "url": "https://github.com/elastic/elasticsearch/commit/9d523e134481093d3ebc0e0db3f85a8c38f288e7", "message": "fix bwc setup plugin func test", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "fe55986f5fe630ad737f9f7cef806562abc68f59", "url": "https://github.com/elastic/elasticsearch/commit/fe55986f5fe630ad737f9f7cef806562abc68f59", "message": "Resolve exploded dist for bwc versions > 7.10", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "32684c93f5c564fee3df1fbbd294b73d373e10d9", "url": "https://github.com/elastic/elasticsearch/commit/32684c93f5c564fee3df1fbbd294b73d373e10d9", "message": "Fix bwc tests against current", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "1be13123c054d2bb3d9d8499543b21343e94ae57", "url": "https://github.com/elastic/elasticsearch/commit/1be13123c054d2bb3d9d8499543b21343e94ae57", "message": "Fix formatting", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "9a1b2278739ccd360262227cc3463987972dd970", "url": "https://github.com/elastic/elasticsearch/commit/9a1b2278739ccd360262227cc3463987972dd970", "message": "Polishing\n\n- unify namings\n- use provider api", "committedDate": "2020-09-30T08:33:41Z", "type": "commit"}, {"oid": "4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "url": "https://github.com/elastic/elasticsearch/commit/4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "message": "Fix jdbc driver bwc build", "committedDate": "2020-09-30T08:33:41Z", "type": "commit"}, {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "message": "Apply review feedback", "committedDate": "2020-09-30T15:20:25Z", "type": "commit"}, {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "message": "Apply review feedback", "committedDate": "2020-09-30T15:20:25Z", "type": "forcePushed"}]}