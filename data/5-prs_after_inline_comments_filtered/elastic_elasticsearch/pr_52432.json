{"pr_number": 52432, "pr_title": "EQL: transform query AST into queryDSL", "pr_createdAt": "2020-02-17T18:14:35Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52432", "timeline": [{"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb", "url": "https://github.com/elastic/elasticsearch/commit/0e994203ba9aa346f11413e773caaa252a71ffbb", "message": "First draft of creating the actual QueryDSL and its extractor", "committedDate": "2020-02-17T18:12:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r380821303", "bodyText": "I'm assuming this is intentional and will be uncommented out later?", "author": "rw-access", "createdAt": "2020-02-18T17:24:51Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryFolder.java", "diffHunk": "@@ -19,6 +26,60 @@ PhysicalPlan fold(PhysicalPlan plan) {\n \n     @Override\n     protected Iterable<RuleExecutor<PhysicalPlan>.Batch> batches() {\n+        Batch fold = new Batch(\"Fold queries\",\n+                new FoldFilter()\n+        );\n+        Batch finish = new Batch(\"Finish query\", Limiter.ONCE,\n+                new PlanOutputToQueryRef()\n+        );\n+        \n+        //return Arrays.asList(fold, finish);", "originalCommit": "0e994203ba9aa346f11413e773caaa252a71ffbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyMjcyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r383822721", "bodyText": "Yes.", "author": "costin", "createdAt": "2020-02-25T11:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NzYyOA==", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381047628", "bodyText": "nit: empty line, ocd kicks in :-)", "author": "aleksmaus", "createdAt": "2020-02-19T02:34:57Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryFolder.java", "diffHunk": "@@ -19,6 +26,60 @@ PhysicalPlan fold(PhysicalPlan plan) {\n \n     @Override\n     protected Iterable<RuleExecutor<PhysicalPlan>.Batch> batches() {\n+        Batch fold = new Batch(\"Fold queries\",\n+                new FoldFilter()\n+        );\n+        Batch finish = new Batch(\"Finish query\", Limiter.ONCE,\n+                new PlanOutputToQueryRef()\n+        );\n+        \n+        //return Arrays.asList(fold, finish);\n         return emptyList();\n     }\n-}\n+    \n+    private static class FoldFilter extends FoldingRule<FilterExec> {\n+        @Override\n+        protected PhysicalPlan rule(FilterExec plan) {\n+", "originalCommit": "0e994203ba9aa346f11413e773caaa252a71ffbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MTIyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381051224", "bodyText": "assuming fullFieldName is going to be used when topHitFieldRef impl is complete", "author": "aleksmaus", "createdAt": "2020-02-19T02:50:16Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -5,9 +5,164 @@\n  */\n package org.elasticsearch.xpack.eql.querydsl.container;\n \n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.AttributeMap;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.querydsl.query.Query;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.emptyList;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.combine;\n+\n public class QueryContainer {\n \n+    private final Query query;\n+    // attributes found in the tree\n+    private final AttributeMap<Expression> attributes;\n+    // list of fields available in the output\n+    private final List<Tuple<FieldExtraction, String>> fields;\n+\n+    private final boolean trackHits;\n+    private final boolean includeFrozen;\n+\n+    public QueryContainer() {\n+        this(null, emptyList(), AttributeMap.emptyAttributeMap(), false, false);\n+    }\n+\n+    private QueryContainer(Query query, List<Tuple<FieldExtraction, String>> fields, AttributeMap<Expression> attributes, boolean trackHits,\n+                           boolean includeFrozen) {\n+        this.query = query;\n+        this.fields = fields;\n+        this.attributes = attributes;\n+        this.trackHits = trackHits;\n+        this.includeFrozen = includeFrozen;\n+    }\n+\n     public QueryContainer withFrozen() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    public Query query() {\n+        return query;\n+    }\n+\n+    public List<Tuple<FieldExtraction, String>> fields() {\n+        return fields;\n+    }\n+\n+    public boolean shouldTrackHits() {\n+        return trackHits;\n+    }\n+\n+    public QueryContainer with(Query q) {\n+        return new QueryContainer(q, fields, attributes, trackHits, includeFrozen);\n+    }\n+\n+    public QueryContainer addColumn(Attribute attr) {\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+        Tuple<QueryContainer, FieldExtraction> tuple = asFieldExtraction(attr);\n+        return tuple.v1().addColumn(tuple.v2(), Expressions.id(expression));\n+    }\n+\n+    private Tuple<QueryContainer, FieldExtraction> asFieldExtraction(Attribute attr) {\n+        // resolve it Expression\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+\n+        if (expression instanceof FieldAttribute) {\n+            FieldAttribute fa = (FieldAttribute) expression;\n+            if (fa.isNested()) {\n+                throw new UnsupportedOperationException(\"Nested not yet supported\");\n+            }\n+            return new Tuple<>(this, topHitFieldRef(fa));\n+        }\n+\n+        throw new QlIllegalArgumentException(\"Unknown output attribute {}\", attr);\n+    }\n+\n+    //\n+    // reference methods\n+    //\n+    private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {\n+        FieldAttribute actualField = fieldAttr;\n+        FieldAttribute rootField = fieldAttr;\n+        StringBuilder fullFieldName = new StringBuilder(fieldAttr.field().getName());\n+        \n+        // Only if the field is not an alias (in which case it will be taken out from docvalue_fields if it's isAggregatable()),\n+        // go up the tree of parents until a non-object (and non-nested) type of field is found and use that specific parent\n+        // as the field to extract data from, from _source. We do it like this because sub-fields are not in the _source, only\n+        // the root field to which those sub-fields belong to, are. Instead of \"text_field.keyword_subfield\" for _source extraction,\n+        // we use \"text_field\", because there is no source for \"keyword_subfield\".\n+        /*\n+         *    \"text_field\": {\n+         *       \"type\": \"text\",\n+         *       \"fields\": {\n+         *         \"keyword_subfield\": {\n+         *           \"type\": \"keyword\"\n+         *         }\n+         *       }\n+         *     }\n+         */\n+        if (fieldAttr.field().isAlias() == false) {\n+            while (actualField.parent() != null\n+                    && actualField.parent().field().getDataType() != DataTypes.OBJECT\n+                    && actualField.parent().field().getDataType() != DataTypes.NESTED\n+                    && actualField.field().getDataType().hasDocValues() == false) {\n+                actualField = actualField.parent();\n+            }\n+        }\n+        while (rootField.parent() != null) {\n+            fullFieldName.insert(0, \".\").insert(0, rootField.parent().field().getName());", "originalCommit": "0e994203ba9aa346f11413e773caaa252a71ffbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MTcwNA==", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381051704", "bodyText": "do we care about the rest of members of QueryContainer for hashCode and equals?", "author": "aleksmaus", "createdAt": "2020-02-19T02:52:20Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -5,9 +5,164 @@\n  */\n package org.elasticsearch.xpack.eql.querydsl.container;\n \n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.AttributeMap;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.querydsl.query.Query;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.emptyList;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.combine;\n+\n public class QueryContainer {\n \n+    private final Query query;\n+    // attributes found in the tree\n+    private final AttributeMap<Expression> attributes;\n+    // list of fields available in the output\n+    private final List<Tuple<FieldExtraction, String>> fields;\n+\n+    private final boolean trackHits;\n+    private final boolean includeFrozen;\n+\n+    public QueryContainer() {\n+        this(null, emptyList(), AttributeMap.emptyAttributeMap(), false, false);\n+    }\n+\n+    private QueryContainer(Query query, List<Tuple<FieldExtraction, String>> fields, AttributeMap<Expression> attributes, boolean trackHits,\n+                           boolean includeFrozen) {\n+        this.query = query;\n+        this.fields = fields;\n+        this.attributes = attributes;\n+        this.trackHits = trackHits;\n+        this.includeFrozen = includeFrozen;\n+    }\n+\n     public QueryContainer withFrozen() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    public Query query() {\n+        return query;\n+    }\n+\n+    public List<Tuple<FieldExtraction, String>> fields() {\n+        return fields;\n+    }\n+\n+    public boolean shouldTrackHits() {\n+        return trackHits;\n+    }\n+\n+    public QueryContainer with(Query q) {\n+        return new QueryContainer(q, fields, attributes, trackHits, includeFrozen);\n+    }\n+\n+    public QueryContainer addColumn(Attribute attr) {\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+        Tuple<QueryContainer, FieldExtraction> tuple = asFieldExtraction(attr);\n+        return tuple.v1().addColumn(tuple.v2(), Expressions.id(expression));\n+    }\n+\n+    private Tuple<QueryContainer, FieldExtraction> asFieldExtraction(Attribute attr) {\n+        // resolve it Expression\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+\n+        if (expression instanceof FieldAttribute) {\n+            FieldAttribute fa = (FieldAttribute) expression;\n+            if (fa.isNested()) {\n+                throw new UnsupportedOperationException(\"Nested not yet supported\");\n+            }\n+            return new Tuple<>(this, topHitFieldRef(fa));\n+        }\n+\n+        throw new QlIllegalArgumentException(\"Unknown output attribute {}\", attr);\n+    }\n+\n+    //\n+    // reference methods\n+    //\n+    private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {\n+        FieldAttribute actualField = fieldAttr;\n+        FieldAttribute rootField = fieldAttr;\n+        StringBuilder fullFieldName = new StringBuilder(fieldAttr.field().getName());\n+        \n+        // Only if the field is not an alias (in which case it will be taken out from docvalue_fields if it's isAggregatable()),\n+        // go up the tree of parents until a non-object (and non-nested) type of field is found and use that specific parent\n+        // as the field to extract data from, from _source. We do it like this because sub-fields are not in the _source, only\n+        // the root field to which those sub-fields belong to, are. Instead of \"text_field.keyword_subfield\" for _source extraction,\n+        // we use \"text_field\", because there is no source for \"keyword_subfield\".\n+        /*\n+         *    \"text_field\": {\n+         *       \"type\": \"text\",\n+         *       \"fields\": {\n+         *         \"keyword_subfield\": {\n+         *           \"type\": \"keyword\"\n+         *         }\n+         *       }\n+         *     }\n+         */\n+        if (fieldAttr.field().isAlias() == false) {\n+            while (actualField.parent() != null\n+                    && actualField.parent().field().getDataType() != DataTypes.OBJECT\n+                    && actualField.parent().field().getDataType() != DataTypes.NESTED\n+                    && actualField.field().getDataType().hasDocValues() == false) {\n+                actualField = actualField.parent();\n+            }\n+        }\n+        while (rootField.parent() != null) {\n+            fullFieldName.insert(0, \".\").insert(0, rootField.parent().field().getName());\n+            rootField = rootField.parent();\n+        }\n+\n+        throw new UnsupportedOperationException(\"Extraction pending\");\n+    }\n+\n+    public QueryContainer addColumn(FieldExtraction ref, String id) {\n+        return new QueryContainer(query, combine(fields, new Tuple<>(ref, id)), attributes, trackHits, includeFrozen);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(query);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        QueryContainer other = (QueryContainer) obj;\n+        return Objects.equals(query, other.query);\n+    }", "originalCommit": "0e994203ba9aa346f11413e773caaa252a71ffbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNTUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r383905527", "bodyText": "Fixed", "author": "costin", "createdAt": "2020-02-25T14:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MjIyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381052223", "bodyText": "maybe something derived from RuntimeException? or is it fine for a draft for now?", "author": "aleksmaus", "createdAt": "2020-02-19T02:54:28Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -5,9 +5,164 @@\n  */\n package org.elasticsearch.xpack.eql.querydsl.container;\n \n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.AttributeMap;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.querydsl.query.Query;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.emptyList;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.combine;\n+\n public class QueryContainer {\n \n+    private final Query query;\n+    // attributes found in the tree\n+    private final AttributeMap<Expression> attributes;\n+    // list of fields available in the output\n+    private final List<Tuple<FieldExtraction, String>> fields;\n+\n+    private final boolean trackHits;\n+    private final boolean includeFrozen;\n+\n+    public QueryContainer() {\n+        this(null, emptyList(), AttributeMap.emptyAttributeMap(), false, false);\n+    }\n+\n+    private QueryContainer(Query query, List<Tuple<FieldExtraction, String>> fields, AttributeMap<Expression> attributes, boolean trackHits,\n+                           boolean includeFrozen) {\n+        this.query = query;\n+        this.fields = fields;\n+        this.attributes = attributes;\n+        this.trackHits = trackHits;\n+        this.includeFrozen = includeFrozen;\n+    }\n+\n     public QueryContainer withFrozen() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    public Query query() {\n+        return query;\n+    }\n+\n+    public List<Tuple<FieldExtraction, String>> fields() {\n+        return fields;\n+    }\n+\n+    public boolean shouldTrackHits() {\n+        return trackHits;\n+    }\n+\n+    public QueryContainer with(Query q) {\n+        return new QueryContainer(q, fields, attributes, trackHits, includeFrozen);\n+    }\n+\n+    public QueryContainer addColumn(Attribute attr) {\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+        Tuple<QueryContainer, FieldExtraction> tuple = asFieldExtraction(attr);\n+        return tuple.v1().addColumn(tuple.v2(), Expressions.id(expression));\n+    }\n+\n+    private Tuple<QueryContainer, FieldExtraction> asFieldExtraction(Attribute attr) {\n+        // resolve it Expression\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+\n+        if (expression instanceof FieldAttribute) {\n+            FieldAttribute fa = (FieldAttribute) expression;\n+            if (fa.isNested()) {\n+                throw new UnsupportedOperationException(\"Nested not yet supported\");\n+            }\n+            return new Tuple<>(this, topHitFieldRef(fa));\n+        }\n+\n+        throw new QlIllegalArgumentException(\"Unknown output attribute {}\", attr);\n+    }\n+\n+    //\n+    // reference methods\n+    //\n+    private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {\n+        FieldAttribute actualField = fieldAttr;\n+        FieldAttribute rootField = fieldAttr;\n+        StringBuilder fullFieldName = new StringBuilder(fieldAttr.field().getName());\n+        \n+        // Only if the field is not an alias (in which case it will be taken out from docvalue_fields if it's isAggregatable()),\n+        // go up the tree of parents until a non-object (and non-nested) type of field is found and use that specific parent\n+        // as the field to extract data from, from _source. We do it like this because sub-fields are not in the _source, only\n+        // the root field to which those sub-fields belong to, are. Instead of \"text_field.keyword_subfield\" for _source extraction,\n+        // we use \"text_field\", because there is no source for \"keyword_subfield\".\n+        /*\n+         *    \"text_field\": {\n+         *       \"type\": \"text\",\n+         *       \"fields\": {\n+         *         \"keyword_subfield\": {\n+         *           \"type\": \"keyword\"\n+         *         }\n+         *       }\n+         *     }\n+         */\n+        if (fieldAttr.field().isAlias() == false) {\n+            while (actualField.parent() != null\n+                    && actualField.parent().field().getDataType() != DataTypes.OBJECT\n+                    && actualField.parent().field().getDataType() != DataTypes.NESTED\n+                    && actualField.field().getDataType().hasDocValues() == false) {\n+                actualField = actualField.parent();\n+            }\n+        }\n+        while (rootField.parent() != null) {\n+            fullFieldName.insert(0, \".\").insert(0, rootField.parent().field().getName());\n+            rootField = rootField.parent();\n+        }\n+\n+        throw new UnsupportedOperationException(\"Extraction pending\");\n+    }\n+\n+    public QueryContainer addColumn(FieldExtraction ref, String id) {\n+        return new QueryContainer(query, combine(fields, new Tuple<>(ref, id)), attributes, trackHits, includeFrozen);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(query);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        QueryContainer other = (QueryContainer) obj;\n+        return Objects.equals(query, other.query);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n+            builder.humanReadable(true).prettyPrint();\n+            SourceGenerator.sourceBuilder(this, null, null).toXContent(builder, ToXContent.EMPTY_PARAMS);\n+            return Strings.toString(builder);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"error rendering\", e);", "originalCommit": "0e994203ba9aa346f11413e773caaa252a71ffbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f7921cf461bf0ee9758742431621489dc42f7fa0", "url": "https://github.com/elastic/elasticsearch/commit/f7921cf461bf0ee9758742431621489dc42f7fa0", "message": "Merge remote-tracking branch 'remotes/upstream/master' into eql/query-fold", "committedDate": "2020-02-25T10:13:57Z", "type": "commit"}, {"oid": "3f9b1714e2d35c5f288ed5b54d55a5df4ee2547b", "url": "https://github.com/elastic/elasticsearch/commit/3f9b1714e2d35c5f288ed5b54d55a5df4ee2547b", "message": "wrap up implementation", "committedDate": "2020-02-25T14:11:50Z", "type": "commit"}]}