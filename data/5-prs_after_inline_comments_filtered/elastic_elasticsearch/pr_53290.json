{"pr_number": 53290, "pr_title": "Add ComponentTemplate to MetaData", "pr_createdAt": "2020-03-09T15:49:52Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53290", "timeline": [{"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "url": "https://github.com/elastic/elasticsearch/commit/506ea640f4ba6462c844e7e8d8a7f860c40efca8", "message": "Add ComponentTemplate to MetaData\n\nThis adds a `ComponentTemplate` datastructure that will be used as part of #53101 (Index Templates\nv2) to the `MetaData` class. Currently there are no APIs for interacting with this class, so it will\nalways be an empty map (other than in tests). This infrastructure will be built upon to add APIs in\na subsequent commit.\n\nA `ComponentTemplate` is made up of a `Template`, a version, and an arbitrary metadata map. The\n`Template` contains similar information to an `IndexTemplateMetaData` object\u2014 settings, mappings,\nand alias configuration.", "committedDate": "2020-03-09T15:18:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTA2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390009067", "bodyText": "nit: this is not needed, but can be left if you think it's more readable that way", "author": "probakowski", "createdAt": "2020-03-09T23:06:16Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }", "originalCommit": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ5OTk4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390499981", "bodyText": "It is required because settings above is final, and required to be set (even if just to null) in the constructor", "author": "dakrone", "createdAt": "2020-03-10T17:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODg3NA==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390528874", "bodyText": "Ah right, I missed that", "author": "probakowski", "createdAt": "2020-03-10T18:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTEwOA==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390009108", "bodyText": "same as above", "author": "probakowski", "createdAt": "2020-03-09T23:06:25Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.mappings = CompressedXContent.readCompressedString(in);\n+            } else {\n+                this.mappings = null;\n+            }", "originalCommit": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTE2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390009161", "bodyText": "same here", "author": "probakowski", "createdAt": "2020-03-09T23:06:34Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.mappings = CompressedXContent.readCompressedString(in);\n+            } else {\n+                this.mappings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.aliases = in.readMap(StreamInput::readString, AliasMetaData::new);\n+            } else {\n+                this.aliases = null;\n+            }", "originalCommit": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTc5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390011797", "bodyText": "If we have empty settings or mappings section we still have corresponding field but we skip it in case of mappings, any reason for that?", "author": "probakowski", "createdAt": "2020-03-09T23:14:47Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.mappings = CompressedXContent.readCompressedString(in);\n+            } else {\n+                this.mappings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.aliases = in.readMap(StreamInput::readString, AliasMetaData::new);\n+            } else {\n+                this.aliases = null;\n+            }\n+        }\n+\n+        public Settings settings() {\n+            return settings;\n+        }\n+\n+        public CompressedXContent mappings() {\n+            return mappings;\n+        }\n+\n+        public Map<String, AliasMetaData> aliases() {\n+            return aliases;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            if (this.settings == null) {\n+                out.writeBoolean(false);\n+            } else {\n+                out.writeBoolean(true);\n+                Settings.writeSettingsToStream(this.settings, out);\n+            }\n+            if (this.mappings == null) {\n+                out.writeBoolean(false);\n+            } else {\n+                out.writeBoolean(true);\n+                this.mappings.writeTo(out);\n+            }\n+            if (this.aliases == null) {\n+                out.writeBoolean(false);\n+            } else {\n+                out.writeBoolean(true);\n+                out.writeMap(this.aliases, StreamOutput::writeString, (stream, aliasMetaData) -> aliasMetaData.writeTo(stream));\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(settings, mappings, aliases);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (obj.getClass() != getClass()) {\n+                return false;\n+            }\n+            Template other = (Template) obj;\n+            return Objects.equals(settings, other.settings) &&\n+                Objects.equals(mappings, other.mappings) &&\n+                Objects.equals(aliases, other.aliases);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Strings.toString(this);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            if (this.settings != null) {\n+                builder.startObject(SETTINGS.getPreferredName());\n+                this.settings.toXContent(builder, params);\n+                builder.endObject();\n+            }\n+            if (this.mappings != null) {\n+                Map<String, Object> uncompressedMapping =\n+                    XContentHelper.convertToMap(new BytesArray(this.mappings.uncompressed()), true, XContentType.JSON).v2();\n+                if (uncompressedMapping.size() > 0) {\n+                    builder.field(MAPPINGS.getPreferredName());", "originalCommit": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYzMzk2NA==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390633964", "bodyText": "No specific reason, this was copied to mimic the existing behavior of for index templates", "author": "dakrone", "createdAt": "2020-03-10T21:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390147643", "bodyText": "I think that component templates should be stored as custom metadata (like stored scripts or ingest pipelines). This way a lot of the repetitive serialization / diffable code is not needed.", "author": "martijnvg", "createdAt": "2020-03-10T08:11:56Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -171,6 +171,7 @@\n     private final DiffableStringMap hashesOfConsistentSettings;\n     private final ImmutableOpenMap<String, IndexMetaData> indices;\n     private final ImmutableOpenMap<String, IndexTemplateMetaData> templates;\n+    private final ImmutableOpenMap<String, ComponentTemplate> componentTemplates;", "originalCommit": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwMTg3NA==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390501874", "bodyText": "Hmm... I don't think that we have too much serialization code, but I think I'd rather treat component templates as a First Class object, and store it right next to the regular templates (rather than have templates be part of the metadata and component templates be part of \"custom\" metadata)\n@martijnvg do you feel strongly about them needing to be Custom metadata instead of stored next to the regular templates?", "author": "dakrone", "createdAt": "2020-03-10T17:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwMzg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390803879", "bodyText": "If component templates implement MetaData.Custom then no changes are required to this file and the DiffableUtils.java  file. I have a strong preference to implement component templates as custom metadata.\nI think we can add a getter to the MetaData class and a setter to the MetaData.Builder class (next to the methods for index templates) in order to advertise component templates as first class concept in cluster metadata.\nIngest pipelines and stored stored scripts are first class concepts too and these are stored as custom metadata too. I think if index templates were coded today then I would have the same strong preference as well.", "author": "martijnvg", "createdAt": "2020-03-11T08:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MTIzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r391041236", "bodyText": "That sounds good to me then, good point about just making the getter first-class. I'll change it to be Custom-based", "author": "dakrone", "createdAt": "2020-03-11T15:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4MDQ2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r391180463", "bodyText": "Okay, this required about 200 more lines of code, but switched this to use MetaData.Custom", "author": "dakrone", "createdAt": "2020-03-11T18:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0ODkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390148901", "bodyText": "maybe move this class to its own file (with its own test)? This can then also be reused in the index templates v2 format.", "author": "martijnvg", "createdAt": "2020-03-10T08:15:19Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {", "originalCommit": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUwMjU2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390502563", "bodyText": "I'll keep it in for now, and eventually probably extract it, if that's okay with you", "author": "dakrone", "createdAt": "2020-03-10T17:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0ODkwMQ=="}], "type": "inlineReview"}, {"oid": "85dfb14a6a3a0fe6b01ece3eb3c2fe1d44d11281", "url": "https://github.com/elastic/elasticsearch/commit/85dfb14a6a3a0fe6b01ece3eb3c2fe1d44d11281", "message": "Introduce ComponentTemplateMetadata as MetaData.Custom class", "committedDate": "2020-03-11T18:29:51Z", "type": "commit"}, {"oid": "51e744b14e67b3c3407ac0504f946574fbac17f0", "url": "https://github.com/elastic/elasticsearch/commit/51e744b14e67b3c3407ac0504f946574fbac17f0", "message": "Undo line formatting in MetaData", "committedDate": "2020-03-11T18:31:05Z", "type": "commit"}, {"oid": "faadfd501ee7dff7f4135e3e2d578b8cc7c4b91b", "url": "https://github.com/elastic/elasticsearch/commit/faadfd501ee7dff7f4135e3e2d578b8cc7c4b91b", "message": "Merge branch 'master' into itv2-component-templates", "committedDate": "2020-03-11T18:45:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQzMzkzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r391433935", "bodyText": "I don't think this change is needed in the file? Because the new method isn't used?", "author": "martijnvg", "createdAt": "2020-03-12T07:07:58Z", "path": "server/src/main/java/org/elasticsearch/cluster/DiffableUtils.java", "diffHunk": "@@ -148,6 +149,15 @@ private DiffableUtils() {\n         return new ImmutableOpenMapDiff<>(in, keySerializer, new DiffableValueReader<>(reader, diffReader));\n     }\n \n+    /**\n+     * Returns an empty diff for the given key and value serializers\n+     */\n+    public static <K, T extends Diffable<T>> MapDiff<K, T, ImmutableOpenMap<K, T>> emptyOpenMapDiff(KeySerializer<K> keySerializer,", "originalCommit": "faadfd501ee7dff7f4135e3e2d578b8cc7c4b91b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyNzE4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r391627189", "bodyText": "Yep, this is a leftover I forgot to remove. I'll remove it!", "author": "dakrone", "createdAt": "2020-03-12T13:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQzMzkzNQ=="}], "type": "inlineReview"}, {"oid": "6c6d6653a6bc56acc7459924ba370ea228138b6f", "url": "https://github.com/elastic/elasticsearch/commit/6c6d6653a6bc56acc7459924ba370ea228138b6f", "message": "Remove unneeded emptyOpenMapDiff", "committedDate": "2020-03-12T14:08:44Z", "type": "commit"}, {"oid": "188f4793d957fa2893fee7cb5f95f8554e76d382", "url": "https://github.com/elastic/elasticsearch/commit/188f4793d957fa2893fee7cb5f95f8554e76d382", "message": "Merge branch 'master' into itv2-component-templates", "committedDate": "2020-03-12T14:21:18Z", "type": "commit"}]}