{"pr_number": 59039, "pr_title": "Extract recovery files details to its own class", "pr_createdAt": "2020-07-05T11:18:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59039", "timeline": [{"oid": "815be65516cef21bb44dfb7d1efd64479496bd0d", "url": "https://github.com/elastic/elasticsearch/commit/815be65516cef21bb44dfb7d1efd64479496bd0d", "message": "Extract recovery files details to its own class.", "committedDate": "2020-07-05T11:14:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1NzQwMA==", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450057400", "bodyText": "Think it'd be better to move this to a constructor RecoveryFilesDetails(StreamInput in), and similarly implement RecoveryFileDetails#writeTo instead of implementing the serialization here.", "author": "DaveCTurner", "createdAt": "2020-07-06T08:17:08Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -716,7 +749,7 @@ public Index(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n-                fileDetails.put(file.name, file);\n+                fileDetails.addFileDetails(file.name, file);", "originalCommit": "815be65516cef21bb44dfb7d1efd64479496bd0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1NzY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450057667", "bodyText": "This feels like it should belong to RecoveryFilesDetails too?", "author": "DaveCTurner", "createdAt": "2020-07-06T08:17:36Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,9 +699,41 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails {\n         private final Map<String, File> fileDetails = new HashMap<>();\n+\n+        public File addFileDetails(String name, File file) {\n+            return fileDetails.put(name, file);\n+        }\n+\n+        public void addRecoveredBytesToFile(String name, long bytes) {\n+            File file = fileDetails.get(name);\n+            file.addRecoveredBytes(bytes);\n+        }\n+\n+        public File get(String name) {\n+            return fileDetails.get(name);\n+        }\n+\n+        public int size() {\n+            return fileDetails.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return fileDetails.isEmpty();\n+        }\n+\n+        public void clear() {\n+            fileDetails.clear();\n+        }\n+\n+        public Collection<File> values() {\n+            return fileDetails.values();\n+        }\n+    }\n+\n+    public static class Index extends Timer implements ToXContentFragment, Writeable {\n+        private final RecoveryFilesDetails fileDetails = new RecoveryFilesDetails();\n         private boolean fileDetailsComplete;", "originalCommit": "815be65516cef21bb44dfb7d1efd64479496bd0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1ODU3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450058575", "bodyText": "This assertion feels like it belongs in RecoveryFileDetails too, as does the one that asserts fileDetailsComplete == false.", "author": "DaveCTurner", "createdAt": "2020-07-06T08:19:13Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -761,7 +794,7 @@ public synchronized void reset() {\n         public synchronized void addFileDetail(String name, long length, boolean reused) {\n             assert fileDetailsComplete == false : \"addFileDetail for [\" + name + \"] when file details are already complete\";\n             File file = new File(name, length, reused);\n-            File existing = fileDetails.put(name, file);\n+            File existing = fileDetails.addFileDetails(name, file);\n             assert existing == null : \"file [\" + name + \"] is already reported\";", "originalCommit": "815be65516cef21bb44dfb7d1efd64479496bd0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3NTUyMg==", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450075522", "bodyText": "Can we instantiate the File - and check that it does not previously existed - directly within this method?", "author": "tlrx", "createdAt": "2020-07-06T08:49:05Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,9 +699,41 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails {\n         private final Map<String, File> fileDetails = new HashMap<>();\n+\n+        public File addFileDetails(String name, File file) {", "originalCommit": "815be65516cef21bb44dfb7d1efd64479496bd0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fef55be0ae020442a28ff76aa36151f36c8cdb2c", "url": "https://github.com/elastic/elasticsearch/commit/fef55be0ae020442a28ff76aa36151f36c8cdb2c", "message": "Move logic to RecoveryFilesDetails (serialization, invariants)", "committedDate": "2020-07-06T09:59:14Z", "type": "commit"}, {"oid": "bc92cdb4740ea17b003b166f6fb5657f9c06b037", "url": "https://github.com/elastic/elasticsearch/commit/bc92cdb4740ea17b003b166f6fb5657f9c06b037", "message": "Minor refactor", "committedDate": "2020-07-06T10:02:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzODU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450138577", "bodyText": "can we assert that file is not null and prints the name if it is?", "author": "tlrx", "createdAt": "2020-07-06T10:46:06Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,50 +699,123 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails implements ToXContentFragment, Writeable {\n         private final Map<String, File> fileDetails = new HashMap<>();\n-        private boolean fileDetailsComplete;\n-\n-        public static final long UNKNOWN = -1L;\n+        private boolean complete;\n \n-        private long sourceThrottlingInNanos = UNKNOWN;\n-        private long targetThrottleTimeInNanos = UNKNOWN;\n-\n-        public Index() {\n+        RecoveryFilesDetails() {\n         }\n \n-        public Index(StreamInput in) throws IOException {\n-            super(in);\n+        RecoveryFilesDetails(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n                 fileDetails.put(file.name, file);\n             }\n             if (in.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                fileDetailsComplete = in.readBoolean();\n+                complete = in.readBoolean();\n             } else {\n                 // This flag is used by disk-based allocation to decide whether the remaining bytes measurement is accurate or not; if not\n                 // then it falls back on an estimate. There's only a very short window in which the file details are present but incomplete\n                 // so this is a reasonable approximation, and the stats reported to the disk-based allocator don't hit this code path\n                 // anyway since they always use IndexShard#getRecoveryState which is never transported over the wire.\n-                fileDetailsComplete = fileDetails.isEmpty() == false;\n+                complete = fileDetails.isEmpty() == false;\n             }\n-            sourceThrottlingInNanos = in.readLong();\n-            targetThrottleTimeInNanos = in.readLong();\n         }\n \n         @Override\n-        public synchronized void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            final File[] files = fileDetails.values().toArray(new File[0]);\n+        public void writeTo(StreamOutput out) throws IOException {\n+            final File[] files = values().toArray(new File[0]);\n             out.writeVInt(files.length);\n             for (File file : files) {\n                 file.writeTo(out);\n             }\n             if (out.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                out.writeBoolean(fileDetailsComplete);\n+                out.writeBoolean(complete);\n             }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (params.paramAsBoolean(\"detailed\", false)) {\n+                builder.startArray(Fields.DETAILS);\n+                for (File file : values()) {\n+                    file.toXContent(builder, params);\n+                }\n+                builder.endArray();\n+            }\n+\n+            return builder;\n+        }\n+\n+        public void addFileDetails(String name, long length, boolean reused) {\n+            addFileDetails(name, new File(name, length, reused));\n+        }\n+\n+        public void addFileDetails(String name, File file) {\n+            assert complete == false : \"addFileDetail for [\" + name + \"] when file details are already complete\";\n+            File existing = fileDetails.put(name, file);\n+            assert existing == null : \"file [\" + name + \"] is already reported\";\n+        }\n+\n+        public void addRecoveredBytesToFile(String name, long bytes) {\n+            File file = fileDetails.get(name);\n+            file.addRecoveredBytes(bytes);", "originalCommit": "bc92cdb4740ea17b003b166f6fb5657f9c06b037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzOTg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450139879", "bodyText": "We're not consistent in the codebase about this, but I'd prefer isComplete() as we have setComplete()", "author": "tlrx", "createdAt": "2020-07-06T10:49:06Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,50 +699,123 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails implements ToXContentFragment, Writeable {\n         private final Map<String, File> fileDetails = new HashMap<>();\n-        private boolean fileDetailsComplete;\n-\n-        public static final long UNKNOWN = -1L;\n+        private boolean complete;\n \n-        private long sourceThrottlingInNanos = UNKNOWN;\n-        private long targetThrottleTimeInNanos = UNKNOWN;\n-\n-        public Index() {\n+        RecoveryFilesDetails() {\n         }\n \n-        public Index(StreamInput in) throws IOException {\n-            super(in);\n+        RecoveryFilesDetails(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n                 fileDetails.put(file.name, file);\n             }\n             if (in.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                fileDetailsComplete = in.readBoolean();\n+                complete = in.readBoolean();\n             } else {\n                 // This flag is used by disk-based allocation to decide whether the remaining bytes measurement is accurate or not; if not\n                 // then it falls back on an estimate. There's only a very short window in which the file details are present but incomplete\n                 // so this is a reasonable approximation, and the stats reported to the disk-based allocator don't hit this code path\n                 // anyway since they always use IndexShard#getRecoveryState which is never transported over the wire.\n-                fileDetailsComplete = fileDetails.isEmpty() == false;\n+                complete = fileDetails.isEmpty() == false;\n             }\n-            sourceThrottlingInNanos = in.readLong();\n-            targetThrottleTimeInNanos = in.readLong();\n         }\n \n         @Override\n-        public synchronized void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            final File[] files = fileDetails.values().toArray(new File[0]);\n+        public void writeTo(StreamOutput out) throws IOException {\n+            final File[] files = values().toArray(new File[0]);\n             out.writeVInt(files.length);\n             for (File file : files) {\n                 file.writeTo(out);\n             }\n             if (out.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                out.writeBoolean(fileDetailsComplete);\n+                out.writeBoolean(complete);\n             }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (params.paramAsBoolean(\"detailed\", false)) {\n+                builder.startArray(Fields.DETAILS);\n+                for (File file : values()) {\n+                    file.toXContent(builder, params);\n+                }\n+                builder.endArray();\n+            }\n+\n+            return builder;\n+        }\n+\n+        public void addFileDetails(String name, long length, boolean reused) {\n+            addFileDetails(name, new File(name, length, reused));\n+        }\n+\n+        public void addFileDetails(String name, File file) {\n+            assert complete == false : \"addFileDetail for [\" + name + \"] when file details are already complete\";\n+            File existing = fileDetails.put(name, file);\n+            assert existing == null : \"file [\" + name + \"] is already reported\";\n+        }\n+\n+        public void addRecoveredBytesToFile(String name, long bytes) {\n+            File file = fileDetails.get(name);\n+            file.addRecoveredBytes(bytes);\n+        }\n+\n+        public File get(String name) {\n+            return fileDetails.get(name);\n+        }\n+\n+        public void setComplete() {\n+            complete = true;\n+        }\n+\n+        public int size() {\n+            return fileDetails.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return fileDetails.isEmpty();\n+        }\n+\n+        public void clear() {\n+            fileDetails.clear();\n+            complete = false;\n+        }\n+\n+        public Collection<File> values() {\n+            return fileDetails.values();\n+        }\n+\n+        public boolean complete() {", "originalCommit": "bc92cdb4740ea17b003b166f6fb5657f9c06b037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0MTIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450141230", "bodyText": "Can we merge the two addFileDetails() together?", "author": "tlrx", "createdAt": "2020-07-06T10:51:54Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,50 +699,123 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails implements ToXContentFragment, Writeable {\n         private final Map<String, File> fileDetails = new HashMap<>();\n-        private boolean fileDetailsComplete;\n-\n-        public static final long UNKNOWN = -1L;\n+        private boolean complete;\n \n-        private long sourceThrottlingInNanos = UNKNOWN;\n-        private long targetThrottleTimeInNanos = UNKNOWN;\n-\n-        public Index() {\n+        RecoveryFilesDetails() {\n         }\n \n-        public Index(StreamInput in) throws IOException {\n-            super(in);\n+        RecoveryFilesDetails(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n                 fileDetails.put(file.name, file);\n             }\n             if (in.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                fileDetailsComplete = in.readBoolean();\n+                complete = in.readBoolean();\n             } else {\n                 // This flag is used by disk-based allocation to decide whether the remaining bytes measurement is accurate or not; if not\n                 // then it falls back on an estimate. There's only a very short window in which the file details are present but incomplete\n                 // so this is a reasonable approximation, and the stats reported to the disk-based allocator don't hit this code path\n                 // anyway since they always use IndexShard#getRecoveryState which is never transported over the wire.\n-                fileDetailsComplete = fileDetails.isEmpty() == false;\n+                complete = fileDetails.isEmpty() == false;\n             }\n-            sourceThrottlingInNanos = in.readLong();\n-            targetThrottleTimeInNanos = in.readLong();\n         }\n \n         @Override\n-        public synchronized void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            final File[] files = fileDetails.values().toArray(new File[0]);\n+        public void writeTo(StreamOutput out) throws IOException {\n+            final File[] files = values().toArray(new File[0]);\n             out.writeVInt(files.length);\n             for (File file : files) {\n                 file.writeTo(out);\n             }\n             if (out.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                out.writeBoolean(fileDetailsComplete);\n+                out.writeBoolean(complete);\n             }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (params.paramAsBoolean(\"detailed\", false)) {\n+                builder.startArray(Fields.DETAILS);\n+                for (File file : values()) {\n+                    file.toXContent(builder, params);\n+                }\n+                builder.endArray();\n+            }\n+\n+            return builder;\n+        }\n+\n+        public void addFileDetails(String name, long length, boolean reused) {", "originalCommit": "bc92cdb4740ea17b003b166f6fb5657f9c06b037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34ff2ad9aa07c585f77f9ba95e1d6c562748a398", "url": "https://github.com/elastic/elasticsearch/commit/34ff2ad9aa07c585f77f9ba95e1d6c562748a398", "message": "Address review comments.", "committedDate": "2020-07-06T11:07:28Z", "type": "commit"}, {"oid": "d9a219d29d7f6e04a41b86e71d3623e295dd2e46", "url": "https://github.com/elastic/elasticsearch/commit/d9a219d29d7f6e04a41b86e71d3623e295dd2e46", "message": "Merge branch 'master' into extract-recovery-file-details-to-class", "committedDate": "2020-07-06T16:59:54Z", "type": "commit"}]}