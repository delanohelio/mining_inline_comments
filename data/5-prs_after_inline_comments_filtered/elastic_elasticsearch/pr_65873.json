{"pr_number": 65873, "pr_title": "Expose timestamp field type on coordinator node", "pr_createdAt": "2020-12-04T10:26:57Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65873", "timeline": [{"oid": "4c59e2301a0e6c7f072e6fb8fd27d0351145e275", "url": "https://github.com/elastic/elasticsearch/commit/4c59e2301a0e6c7f072e6fb8fd27d0351145e275", "message": "Expose timestamp field type on coordinator node\n\nToday a coordinating node does not have (easy) access to the mappings\nfor the indices for the searches it wishes to coordinate. This means it\ncan't properly interpret a timestamp range filter in a query and must\ninvolve a copy of every shard in at least the `can_match` phase. It\ntherefore cannot cope with cases when shards are temporarily not started\neven if those shards are irrelevant to the search.\n\nThis commit captures the mapping of the `@timestamp` field for indices\nwhich expose a timestamp range in their index metadata.", "committedDate": "2020-12-04T10:25:06Z", "type": "commit"}, {"oid": "d44afc085f0d038f77189490c895b57a545713ab", "url": "https://github.com/elastic/elasticsearch/commit/d44afc085f0d038f77189490c895b57a545713ab", "message": "Don't block, just return null if not known", "committedDate": "2020-12-04T10:34:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwNTEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536005122", "bodyText": "There remains a question of whether we should block here or not (and if so, for how long).\nOn reflection I think we shouldn't block. Returning null sooner will allow the search coordination to proceed normally, ignoring any timestamp filter and deferring any skipping to the individual shards. This means we'll see shard failures if the coordinating node falls behind on extracting these mappings AND some of the shards are unassigned, which is hopefully rare.\nAs a follow-up we could in theory add another more patient getter to support a workflow that goes:\n\nwe call getTimestampFieldType which returns null\nsome shards are unavailable for the can_match phase\nwe call getTimestampFieldTypePatiently to see for whether those shard failures can be ignored or not", "author": "DaveCTurner", "createdAt": "2020-12-04T10:42:19Z", "path": "server/src/main/java/org/elasticsearch/indices/TimestampFieldMapperService.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateApplier;\n+import org.elasticsearch.cluster.metadata.DataStream;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.index.shard.IndexLongFieldRange;\n+import org.elasticsearch.node.Node;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.elasticsearch.common.util.concurrent.EsExecutors.daemonThreadFactory;\n+\n+/**\n+ * Tracks the mapping of the {@code @timestamp} field of immutable indices that expose their timestamp range in their index metadata.\n+ * Coordinating nodes do not have (easy) access to mappings for all indices, so we extract the type of this one field from the mapping here.\n+ */\n+public class TimestampFieldMapperService extends AbstractLifecycleComponent implements ClusterStateApplier {\n+\n+    private static final Logger logger = LogManager.getLogger(TimestampFieldMapperService.class);\n+\n+    private final IndicesService indicesService;\n+    private final ExecutorService executor; // single thread to construct mapper services async as needed\n+\n+    /**\n+     * The type of the {@code @timestamp} field keyed by index. Futures may be completed with {@code null} to indicate that there is\n+     * no usable {@code @timestamp} field.\n+     */\n+    private final Map<Index, PlainActionFuture<DateFieldMapper.DateFieldType>> fieldTypesByIndex = ConcurrentCollections.newConcurrentMap();\n+\n+    public TimestampFieldMapperService(Settings settings, ThreadPool threadPool, IndicesService indicesService) {\n+        this.indicesService = indicesService;\n+\n+        final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+        final String threadName = \"TimestampFieldMapperService#updateTask\";\n+        executor = EsExecutors.newScaling(nodeName + \"/\" + threadName, 0, 1, 0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, threadName), threadPool.getThreadContext());\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        ThreadPool.terminate(executor, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+    }\n+\n+    @Override\n+    public void applyClusterState(ClusterChangedEvent event) {\n+        final Metadata metadata = event.state().metadata();\n+\n+        // clear out mappers for indices that no longer exist or whose timestamp range is no longer known\n+        fieldTypesByIndex.keySet().removeIf(index -> hasUsefulTimestampField(metadata.index(index)) == false);\n+\n+        // capture mappers for indices that do exist\n+        for (ObjectCursor<IndexMetadata> cursor : metadata.indices().values()) {\n+            final IndexMetadata indexMetadata = cursor.value;\n+            final Index index = indexMetadata.getIndex();\n+\n+            if (hasUsefulTimestampField(indexMetadata) && fieldTypesByIndex.containsKey(index) == false) {\n+                logger.trace(\"computing timestamp mapping for {}\", index);\n+                final PlainActionFuture<DateFieldMapper.DateFieldType> future = new PlainActionFuture<>();\n+                fieldTypesByIndex.put(index, future);\n+\n+                final IndexService indexService = indicesService.indexService(index);\n+                if (indexService == null) {\n+                    logger.trace(\"computing timestamp mapping for {} async\", index);\n+                    executor.execute(new AbstractRunnable() {\n+                        @Override\n+                        public void onFailure(Exception e) {\n+                            logger.debug(new ParameterizedMessage(\"failed to compute mapping for {}\", index), e);\n+                            future.onResponse(null); // no need to propagate a failure to create the mapper service to searches\n+                        }\n+\n+                        @Override\n+                        protected void doRun() throws Exception {\n+                            try (MapperService mapperService = indicesService.createIndexMapperService(indexMetadata)) {\n+                                mapperService.merge(indexMetadata, MapperService.MergeReason.MAPPING_RECOVERY);\n+                                future.onResponse(fromMapperService(mapperService));\n+                            }\n+                        }\n+                    });\n+                } else {\n+                    logger.trace(\"computing timestamp mapping for {} using existing index service\", index);\n+                    try {\n+                        future.onResponse(fromMapperService(indexService.mapperService()));\n+                    } catch (Exception e) {\n+                        assert false : e;\n+                        future.onResponse(null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean hasUsefulTimestampField(IndexMetadata indexMetadata) {\n+        if (indexMetadata == null) {\n+            return false;\n+        }\n+        final IndexLongFieldRange timestampMillisRange = indexMetadata.getTimestampMillisRange();\n+        return timestampMillisRange.isComplete() && timestampMillisRange != IndexLongFieldRange.UNKNOWN;\n+    }\n+\n+    private static DateFieldMapper.DateFieldType fromMapperService(MapperService mapperService) {\n+        final MappedFieldType mappedFieldType = mapperService.fieldType(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD);\n+        if (mappedFieldType instanceof DateFieldMapper.DateFieldType) {\n+            return (DateFieldMapper.DateFieldType) mappedFieldType;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @return the field type of the {@code @timestamp} field of the given index, or {@code null} if:\n+     * - the index is not found,\n+     * - the field is not found,\n+     * - the mapping is not known yet, or\n+     * - the field is not a timestamp field.\n+     */\n+    @Nullable\n+    public DateFieldMapper.DateFieldType getTimestampFieldType(Index index) {\n+        final PlainActionFuture<DateFieldMapper.DateFieldType> future = fieldTypesByIndex.get(index);\n+        if (future == null || future.isDone() == false) {", "originalCommit": "d44afc085f0d038f77189490c895b57a545713ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMzIzMw==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536013233", "bodyText": "I think it makes sense to return null and proceed regularly if the mapping isn't available yet. This should be rare enough to cause too much trouble.\nI guess the most problematic scenario is when a node joins and has to parse a lot of mappings, right?", "author": "fcofdez", "createdAt": "2020-12-04T10:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwNTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NzU2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536047565", "bodyText": "Right, although in that case there's no particular reason to expect shards to be unavailable.", "author": "DaveCTurner", "createdAt": "2020-12-04T11:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwNTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMDU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536010541", "bodyText": "Is the future necessary? won't assertBusy throw an exception after the timeout if the block didn't succeed?", "author": "fcofdez", "createdAt": "2020-12-04T10:50:57Z", "path": "x-pack/plugin/frozen-indices/src/internalClusterTest/java/org/elasticsearch/index/engine/FrozenIndexIT.java", "diffHunk": "@@ -97,4 +102,53 @@ public void testTimestampRangeRecalculatedOnStalePrimaryAllocation() throws IOEx\n         assertThat(timestampFieldRange.getMax(), equalTo(Instant.parse(\"2010-01-06T02:03:04.567Z\").getMillis()));\n     }\n \n+    public void testTimestampFieldTypeExposedByAllIndicesServices() throws Exception {\n+        internalCluster().startNodes(between(2, 4));\n+\n+        final String locale = randomFrom(\"\", \"en_GB\", \"fr_FR\");\n+\n+        assertAcked(prepareCreate(\"index\")\n+                .setSettings(Settings.builder()\n+                        .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+                        .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1))\n+                .setMapping(jsonBuilder().startObject().startObject(\"_doc\").startObject(\"properties\")\n+                        .startObject(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD)\n+                        .field(\"type\", \"date\")\n+                        .field(\"format\", \"strict_date_hour_minute_second_fraction\")\n+                        .field(\"locale\", locale)\n+                        .endObject()\n+                        .endObject().endObject().endObject()));\n+\n+        final Index index = client().admin().cluster().prepareState().clear().setIndices(\"index\").setMetadata(true)\n+                .get().getState().metadata().index(\"index\").getIndex();\n+\n+        ensureGreen(\"index\");\n+        if (randomBoolean()) {\n+            client().prepareIndex(\"index\").setSource(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD, \"2010-01-06T02:03:04.567\").get();\n+        }\n+\n+        for (final IndicesService indicesService : internalCluster().getInstances(IndicesService.class)) {\n+            assertNull(indicesService.getTimestampFieldType(index));\n+        }\n+\n+        assertAcked(client().execute(FreezeIndexAction.INSTANCE, new FreezeRequest(\"index\")).actionGet());\n+        ensureGreen(\"index\");\n+        for (final IndicesService indicesService : internalCluster().getInstances(IndicesService.class)) {\n+            final PlainActionFuture<DateFieldMapper.DateFieldType> timestampFieldTypeFuture = new PlainActionFuture<>();", "originalCommit": "d44afc085f0d038f77189490c895b57a545713ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NjUxMw==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536046513", "bodyText": "We have to pass timestampFieldType out of the assertBusy() block somehow. The following assertTrue(isDone) is technically unnecessary, we can't get to this point without having completed the future, but it's useful to document this fact.", "author": "DaveCTurner", "createdAt": "2020-12-04T11:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMDU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMjAwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536012001", "bodyText": "Maybe we can add a an assertion that checks that DateFieldMapper.DateFieldType#parse works with the original timestamp string?", "author": "fcofdez", "createdAt": "2020-12-04T10:53:11Z", "path": "x-pack/plugin/frozen-indices/src/internalClusterTest/java/org/elasticsearch/index/engine/FrozenIndexIT.java", "diffHunk": "@@ -97,4 +102,53 @@ public void testTimestampRangeRecalculatedOnStalePrimaryAllocation() throws IOEx\n         assertThat(timestampFieldRange.getMax(), equalTo(Instant.parse(\"2010-01-06T02:03:04.567Z\").getMillis()));\n     }\n \n+    public void testTimestampFieldTypeExposedByAllIndicesServices() throws Exception {\n+        internalCluster().startNodes(between(2, 4));\n+\n+        final String locale = randomFrom(\"\", \"en_GB\", \"fr_FR\");\n+\n+        assertAcked(prepareCreate(\"index\")\n+                .setSettings(Settings.builder()\n+                        .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+                        .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1))\n+                .setMapping(jsonBuilder().startObject().startObject(\"_doc\").startObject(\"properties\")\n+                        .startObject(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD)\n+                        .field(\"type\", \"date\")\n+                        .field(\"format\", \"strict_date_hour_minute_second_fraction\")\n+                        .field(\"locale\", locale)\n+                        .endObject()\n+                        .endObject().endObject().endObject()));\n+\n+        final Index index = client().admin().cluster().prepareState().clear().setIndices(\"index\").setMetadata(true)\n+                .get().getState().metadata().index(\"index\").getIndex();\n+\n+        ensureGreen(\"index\");\n+        if (randomBoolean()) {\n+            client().prepareIndex(\"index\").setSource(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD, \"2010-01-06T02:03:04.567\").get();\n+        }\n+\n+        for (final IndicesService indicesService : internalCluster().getInstances(IndicesService.class)) {\n+            assertNull(indicesService.getTimestampFieldType(index));\n+        }\n+\n+        assertAcked(client().execute(FreezeIndexAction.INSTANCE, new FreezeRequest(\"index\")).actionGet());\n+        ensureGreen(\"index\");\n+        for (final IndicesService indicesService : internalCluster().getInstances(IndicesService.class)) {\n+            final PlainActionFuture<DateFieldMapper.DateFieldType> timestampFieldTypeFuture = new PlainActionFuture<>();\n+            assertBusy(() -> {\n+                final DateFieldMapper.DateFieldType timestampFieldType = indicesService.getTimestampFieldType(index);\n+                assertNotNull(timestampFieldType);\n+                timestampFieldTypeFuture.onResponse(timestampFieldType);\n+            });\n+            assertTrue(timestampFieldTypeFuture.isDone());\n+            assertThat(timestampFieldTypeFuture.get().dateTimeFormatter().locale().toString(), equalTo(locale));", "originalCommit": "d44afc085f0d038f77189490c895b57a545713ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0Njk3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536046970", "bodyText": "Ok let me try and remember the month names in French to give this assertion some teeth \ud83c\uddeb\ud83c\uddf7", "author": "DaveCTurner", "createdAt": "2020-12-04T11:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMjAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2NzA1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65873#discussion_r536067052", "bodyText": "Done in 79ef7b0. Remembering the names wasn't the hard bit, it was working out that in French we write month names lower-case, with a trailing ., and sometimes use more than 3 letters.", "author": "DaveCTurner", "createdAt": "2020-12-04T12:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxMjAwMQ=="}], "type": "inlineReview"}, {"oid": "79ef7b032e6fe89ccac1b6c7360be6a5695432a5", "url": "https://github.com/elastic/elasticsearch/commit/79ef7b032e6fe89ccac1b6c7360be6a5695432a5", "message": "Ensure that localised dates can really be parsed by the mapper we got", "committedDate": "2020-12-04T12:32:05Z", "type": "commit"}, {"oid": "693a9a6e4bc46a15b07e3b0a9c86405729eea8c8", "url": "https://github.com/elastic/elasticsearch/commit/693a9a6e4bc46a15b07e3b0a9c86405729eea8c8", "message": "Merge branch 'master' into 2020-12-03-extract-timestamp-field-type", "committedDate": "2020-12-04T14:32:15Z", "type": "commit"}]}