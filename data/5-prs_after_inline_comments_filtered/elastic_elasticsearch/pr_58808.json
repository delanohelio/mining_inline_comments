{"pr_number": 58808, "pr_title": "Enforce higher priority for RepositoriesService ClusterStateApplier", "pr_createdAt": "2020-07-01T08:54:28Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58808", "timeline": [{"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "url": "https://github.com/elastic/elasticsearch/commit/ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "message": "Enforce higher priority for RepositoriesService ClusterStateApplier\n\nThis avoids shards allocation failures when the repository instance\ncomes in the same ClusterState update as the shard allocation.", "committedDate": "2020-07-01T08:50:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5ODEyOA==", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448298128", "bodyText": "Why autoManageMasterNodes = false?", "author": "ywelsch", "createdAt": "2020-07-01T11:27:06Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)", "originalCommit": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NTcxMg==", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448475712", "bodyText": "That was the only scenario where I was able to reproduce the failure consistently. I was missing the gateway.recover_after_data_nodes piece", "author": "fcofdez", "createdAt": "2020-07-01T16:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5ODEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTE4NA==", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448299184", "bodyText": "I think all the randomization above here is not needed and just unnecessarily making the test more complicated than need be. Just use string literals directly in the code.", "author": "ywelsch", "createdAt": "2020-07-01T11:29:03Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);", "originalCommit": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMDE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448300188", "bodyText": "add a note that this restriction can be lifted when #55142 is resolved.", "author": "ywelsch", "createdAt": "2020-07-01T11:31:10Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+\n+        // The scenario is easily reproducible with a 2 node (data and master) cluster\n+        internalCluster().setBootstrapMasterNodeIndex(1);\n+        internalCluster().startNodes(2);\n+        ensureStableCluster(2);\n+\n+        final Path repo = randomRepoPath();\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(fsRepoName).setType(\"fs\").setSettings(Settings.builder().put(\"location\", repo))\n+        );\n+\n+        assertAcked(prepareCreate(indexName, Settings.builder().put(INDEX_SOFT_DELETES_SETTING.getKey(), true)));", "originalCommit": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxMDU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448310581", "bodyText": "Isn't this racing against state recovery and the actual allocation taking place? We might be adding the listener too late. Perhaps we should delay state recovery (for example by setting gateway.recover_after_data_nodes to 3 on restart, and start up a third data node after the listener is registered (on the master)).", "author": "ywelsch", "createdAt": "2020-07-01T11:53:02Z", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+\n+        // The scenario is easily reproducible with a 2 node (data and master) cluster\n+        internalCluster().setBootstrapMasterNodeIndex(1);\n+        internalCluster().startNodes(2);\n+        ensureStableCluster(2);\n+\n+        final Path repo = randomRepoPath();\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(fsRepoName).setType(\"fs\").setSettings(Settings.builder().put(\"location\", repo))\n+        );\n+\n+        assertAcked(prepareCreate(indexName, Settings.builder().put(INDEX_SOFT_DELETES_SETTING.getKey(), true)));\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = between(10, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"foo\", randomBoolean() ? \"bar\" : \"baz\"));\n+        }\n+        indexRandom(true, true, indexRequestBuilders);\n+        refresh(indexName);\n+\n+        CreateSnapshotResponse createSnapshotResponse = client().admin()\n+            .cluster()\n+            .prepareCreateSnapshot(fsRepoName, snapshotName)\n+            .setWaitForCompletion(true)\n+            .get();\n+        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo();\n+        assertThat(snapshotInfo.successfulShards(), greaterThan(0));\n+        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()));\n+\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        Settings.Builder indexSettingsBuilder = Settings.builder()\n+            .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), false)\n+            .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+        final MountSearchableSnapshotRequest req = new MountSearchableSnapshotRequest(\n+            restoredIndexName,\n+            fsRepoName,\n+            snapshotInfo.snapshotId().getName(),\n+            indexName,\n+            indexSettingsBuilder.build(),\n+            Strings.EMPTY_ARRAY,\n+            true\n+        );\n+\n+        final RestoreSnapshotResponse restoreSnapshotResponse = client().execute(MountSearchableSnapshotAction.INSTANCE, req).get();\n+        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0));\n+\n+        ensureGreen(restoredIndexName);\n+\n+        // In order to reproduce this issue we need to force a full cluster restart so the new elected master\n+        // sends the entire ClusterState in one message, including assigned shards and repositories.\n+        internalCluster().fullRestart();\n+\n+        List<UnassignedInfo.Reason> unassignedReasons = new ArrayList<>();\n+        internalCluster().clusterService().addListener(event -> {", "originalCommit": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTUwMw==", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448459503", "bodyText": "I wasn't aware of that setting, I'll use that approach.", "author": "fcofdez", "createdAt": "2020-07-01T15:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxMDU4MQ=="}], "type": "inlineReview"}, {"oid": "690b00c6fc6e25d93ae49ff967da3fa9b3d6ceee", "url": "https://github.com/elastic/elasticsearch/commit/690b00c6fc6e25d93ae49ff967da3fa9b3d6ceee", "message": "Address review comments", "committedDate": "2020-07-01T16:18:45Z", "type": "commit"}, {"oid": "af5696e5d95d63acd823305854e7fa4cd2b3ce82", "url": "https://github.com/elastic/elasticsearch/commit/af5696e5d95d63acd823305854e7fa4cd2b3ce82", "message": "Merge remote-tracking branch 'origin/master' into repository-not-found-shard-failure", "committedDate": "2020-07-01T16:46:41Z", "type": "commit"}]}