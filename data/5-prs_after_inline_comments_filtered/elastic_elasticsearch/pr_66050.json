{"pr_number": 66050, "pr_title": "Scripting: Whitelist API spec gradle task", "pr_createdAt": "2020-12-08T17:31:11Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66050", "timeline": [{"oid": "cbea242027e00d79f9eea0ccc9030d983e44120a", "url": "https://github.com/elastic/elasticsearch/commit/cbea242027e00d79f9eea0ccc9030d983e44120a", "message": "Scripting whitelist api spec: Add generateContextApiSpec task", "committedDate": "2020-12-08T14:35:47Z", "type": "commit"}, {"oid": "7d61bbf29f59bdaed28fe14b29bb18c03c79a663", "url": "https://github.com/elastic/elasticsearch/commit/7d61bbf29f59bdaed28fe14b29bb18c03c79a663", "message": "Scripting whitelist api spec: Find common classes", "committedDate": "2020-12-08T14:51:35Z", "type": "commit"}, {"oid": "d9aec2feae9732187bd4958f24cfdc90d17fc687", "url": "https://github.com/elastic/elasticsearch/commit/d9aec2feae9732187bd4958f24cfdc90d17fc687", "message": "Scripting whitelist api spec: Generate common.json", "committedDate": "2020-12-08T14:55:36Z", "type": "commit"}, {"oid": "8d54686b4a9c09e19f81284da9e8941ae289a5b8", "url": "https://github.com/elastic/elasticsearch/commit/8d54686b4a9c09e19f81284da9e8941ae289a5b8", "message": "Scripting whitelist api spec: Handle arrays for parameters and return values", "committedDate": "2020-12-08T15:59:37Z", "type": "commit"}, {"oid": "519ef45a9ad9f536068525518a3c644124648f9e", "url": "https://github.com/elastic/elasticsearch/commit/519ef45a9ad9f536068525518a3c644124648f9e", "message": "Scripting whitelist api spec: Handle arrays for static methods", "committedDate": "2020-12-08T16:23:12Z", "type": "commit"}, {"oid": "c7fb7dd3dded682fb1290d62db0c46872159c01e", "url": "https://github.com/elastic/elasticsearch/commit/c7fb7dd3dded682fb1290d62db0c46872159c01e", "message": "Scripting whitelist api spec: Handle arrays for constructors", "committedDate": "2020-12-08T16:30:08Z", "type": "commit"}, {"oid": "ca8738ca70c4a9983484092400d6b2ae0d75a4a1", "url": "https://github.com/elastic/elasticsearch/commit/ca8738ca70c4a9983484092400d6b2ae0d75a4a1", "message": "Scripting whitelist api spec: Handle arrays for fields", "committedDate": "2020-12-08T16:37:13Z", "type": "commit"}, {"oid": "b1ac81077d1ac2194e4d2c1d3aa36da02e598987", "url": "https://github.com/elastic/elasticsearch/commit/b1ac81077d1ac2194e4d2c1d3aa36da02e598987", "message": "Scripting whitelist api spec: Change $ internal names to display names", "committedDate": "2020-12-08T16:59:01Z", "type": "commit"}, {"oid": "e89316ca1b04285323c29789093028ef680a732d", "url": "https://github.com/elastic/elasticsearch/commit/e89316ca1b04285323c29789093028ef680a732d", "message": "Scripting whitelist api spec: generate rest of the contexts", "committedDate": "2020-12-08T17:26:05Z", "type": "commit"}, {"oid": "240dde7586164dc3bb4f9d56b5d5ded7bec839cb", "url": "https://github.com/elastic/elasticsearch/commit/240dde7586164dc3bb4f9d56b5d5ded7bec839cb", "message": "Scripting whitelist api spec: remove unused imports in context doc generator", "committedDate": "2020-12-08T17:32:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjE2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66050#discussion_r538736166", "bodyText": "TODO remove TODO", "author": "stu-elastic", "createdAt": "2020-12-08T19:13:05Z", "path": "modules/lang-painless/src/doc/java/org/elasticsearch/painless/ContextGeneratorCommon.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.painless.action.PainlessContextClassBindingInfo;\n+import org.elasticsearch.painless.action.PainlessContextClassInfo;\n+import org.elasticsearch.painless.action.PainlessContextInfo;\n+import org.elasticsearch.painless.action.PainlessContextInstanceBindingInfo;\n+import org.elasticsearch.painless.action.PainlessContextMethodInfo;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+public class ContextGeneratorCommon {\n+    @SuppressForbidden(reason = \"retrieving data from an internal API not exposed as part of the REST client\")\n+    public static List<PainlessContextInfo> getContextInfos() throws IOException {\n+        URLConnection getContextNames = new URL(\n+            \"http://\" + System.getProperty(\"cluster.uri\") + \"/_scripts/painless/_context\").openConnection();\n+        XContentParser parser = JsonXContent.jsonXContent.createParser(null, null, getContextNames.getInputStream());\n+        parser.nextToken();\n+        parser.nextToken();\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> contextNames = (List<String>)(Object)parser.list();\n+        parser.close();\n+        ((HttpURLConnection)getContextNames).disconnect();\n+\n+        List<PainlessContextInfo> contextInfos = new ArrayList<>();\n+\n+        for (String contextName : contextNames) {\n+            URLConnection getContextInfo = new URL(\n+                \"http://\" + System.getProperty(\"cluster.uri\") + \"/_scripts/painless/_context?context=\" + contextName).openConnection();\n+            parser = JsonXContent.jsonXContent.createParser(null, null, getContextInfo.getInputStream());\n+            contextInfos.add(PainlessContextInfo.fromXContent(parser));\n+            ((HttpURLConnection)getContextInfo).disconnect();\n+        }\n+\n+        contextInfos.sort(Comparator.comparing(PainlessContextInfo::getName));\n+\n+        return contextInfos;\n+    }\n+\n+    public static String getType(Map<String, String> javaNamesToDisplayNames, String javaType) {\n+        int arrayDimensions = 0;\n+\n+        while (javaType.charAt(arrayDimensions) == '[') {\n+            ++arrayDimensions;\n+        }\n+\n+        if (arrayDimensions > 0) {\n+            if (javaType.charAt(javaType.length() - 1) == ';') {\n+                javaType = javaType.substring(arrayDimensions + 1, javaType.length() - 1);\n+            } else {\n+                javaType = javaType.substring(arrayDimensions);\n+            }\n+        }\n+\n+        if (\"Z\".equals(javaType) || \"boolean\".equals(javaType)) {\n+            javaType = \"boolean\";\n+        } else if (\"V\".equals(javaType) || \"void\".equals(javaType)) {\n+            javaType = \"void\";\n+        } else if (\"B\".equals(javaType) || \"byte\".equals(javaType)) {\n+            javaType = \"byte\";\n+        } else if (\"S\".equals(javaType) || \"short\".equals(javaType)) {\n+            javaType = \"short\";\n+        } else if (\"C\".equals(javaType) || \"char\".equals(javaType)) {\n+            javaType = \"char\";\n+        } else if (\"I\".equals(javaType) || \"int\".equals(javaType)) {\n+            javaType = \"int\";\n+        } else if (\"J\".equals(javaType) || \"long\".equals(javaType)) {\n+            javaType = \"long\";\n+        } else if (\"F\".equals(javaType) || \"float\".equals(javaType)) {\n+            javaType = \"float\";\n+        } else if (\"D\".equals(javaType) || \"double\".equals(javaType)) {\n+            javaType = \"double\";\n+        } else if (\"org.elasticsearch.painless.lookup.def\".equals(javaType)) {\n+            javaType = \"def\";\n+        } else {\n+            javaType = javaNamesToDisplayNames.get(javaType);\n+        }\n+\n+        while (arrayDimensions-- > 0) {\n+            javaType += \"[]\";\n+        }\n+\n+        return javaType;\n+    }\n+\n+    private static Map<String, String> getDisplayNames(Collection<PainlessContextInfo> contextInfos) {\n+        Map<String, String> javaNamesToDisplayNames = new HashMap<>();\n+\n+        for (PainlessContextInfo contextInfo : contextInfos) {\n+            for (PainlessContextClassInfo classInfo : contextInfo.getClasses()) {\n+                String className = classInfo.getName();\n+                if (javaNamesToDisplayNames.containsKey(className) == false) {\n+                    if (classInfo.isImported()) {\n+                        javaNamesToDisplayNames.put(className,\n+                            className.substring(className.lastIndexOf('.') + 1).replace('$', '.'));\n+                    } else {\n+                        javaNamesToDisplayNames.put(className, className.replace('$', '.'));\n+                    }\n+                }\n+            }\n+        }\n+        return javaNamesToDisplayNames;\n+    }\n+\n+    public static List<PainlessContextClassInfo> sortClassInfos(Collection<PainlessContextClassInfo> unsortedClassInfos) {\n+\n+        List<PainlessContextClassInfo> classInfos = new ArrayList<>(unsortedClassInfos);\n+        classInfos.removeIf(v ->\n+            \"void\".equals(v.getName())  || \"boolean\".equals(v.getName()) || \"byte\".equals(v.getName())   ||\n+                \"short\".equals(v.getName()) || \"char\".equals(v.getName())    || \"int\".equals(v.getName())    ||\n+                \"long\".equals(v.getName())  || \"float\".equals(v.getName())   || \"double\".equals(v.getName()) ||\n+                \"org.elasticsearch.painless.lookup.def\".equals(v.getName())  ||\n+                isInternalClass(v.getName())\n+        );\n+\n+        classInfos.sort((c1, c2) -> {\n+            String n1 = c1.getName();\n+            String n2 = c2.getName();\n+            boolean i1 = c1.isImported();\n+            boolean i2 = c2.isImported();\n+\n+            String p1 = n1.substring(0, n1.lastIndexOf('.'));\n+            String p2 = n2.substring(0, n2.lastIndexOf('.'));\n+\n+            int compare = p1.compareTo(p2);\n+\n+            if (compare == 0) {\n+                if (i1 && i2) {\n+                    compare = n1.substring(n1.lastIndexOf('.') + 1).compareTo(n2.substring(n2.lastIndexOf('.') + 1));\n+                } else if (i1 == false && i2 == false) {\n+                    compare = n1.compareTo(n2);\n+                } else {\n+                    compare = Boolean.compare(i1, i2) * -1;\n+                }\n+            }\n+\n+            return compare;\n+        });\n+\n+        // TODO(stu): unmodifiable list", "originalCommit": "240dde7586164dc3bb4f9d56b5d5ded7bec839cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "90a56403711a522104dd6c7da3cf06ef2f284c07", "url": "https://github.com/elastic/elasticsearch/commit/90a56403711a522104dd6c7da3cf06ef2f284c07", "message": "Scripting: unnecessary comments", "committedDate": "2020-12-08T19:17:29Z", "type": "commit"}]}