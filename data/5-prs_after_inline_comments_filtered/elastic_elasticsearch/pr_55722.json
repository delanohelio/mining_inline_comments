{"pr_number": 55722, "pr_title": "Remove \"Sub\" Nodes in Painless User Tree", "pr_createdAt": "2020-04-24T14:33:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55722", "timeline": [{"oid": "eac1d61e41717df51b42edf65cbd1570a2a46663", "url": "https://github.com/elastic/elasticsearch/commit/eac1d61e41717df51b42edf65cbd1570a2a46663", "message": "remove statement, use read instead", "committedDate": "2020-03-27T23:55:26Z", "type": "commit"}, {"oid": "082e94b4a590591196625bad85750d2fcbc4f551", "url": "https://github.com/elastic/elasticsearch/commit/082e94b4a590591196625bad85750d2fcbc4f551", "message": "add tests for not a statement", "committedDate": "2020-03-30T16:27:34Z", "type": "commit"}, {"oid": "d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "url": "https://github.com/elastic/elasticsearch/commit/d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-03-30T16:51:01Z", "type": "commit"}, {"oid": "4459ee9a8029edd7c995865bd3202830def8097c", "url": "https://github.com/elastic/elasticsearch/commit/4459ee9a8029edd7c995865bd3202830def8097c", "message": "move isDefOptimized to output instead of as mutable state on the nodes", "committedDate": "2020-03-30T19:02:43Z", "type": "commit"}, {"oid": "1eb0a513f54a2abc3a4d90877d43297a246e7dac", "url": "https://github.com/elastic/elasticsearch/commit/1eb0a513f54a2abc3a4d90877d43297a246e7dac", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-03-30T19:05:32Z", "type": "commit"}, {"oid": "372ec631791fceda73c22bb1dfbba176aeba7c1f", "url": "https://github.com/elastic/elasticsearch/commit/372ec631791fceda73c22bb1dfbba176aeba7c1f", "message": "Merge branch 'nodes0' into nodes1", "committedDate": "2020-03-30T19:05:58Z", "type": "commit"}, {"oid": "99c54f190497586547ab073b41a0c5d39d89b5fd", "url": "https://github.com/elastic/elasticsearch/commit/99c54f190497586547ab073b41a0c5d39d89b5fd", "message": "remove AStoreable and give individual nodes responsibility to check\nwrite", "committedDate": "2020-03-30T20:18:46Z", "type": "commit"}, {"oid": "2eceff4ba180840b185ae834b963c9b7ae1f58bc", "url": "https://github.com/elastic/elasticsearch/commit/2eceff4ba180840b185ae834b963c9b7ae1f58bc", "message": "clean up write messages and add tests", "committedDate": "2020-03-30T22:18:14Z", "type": "commit"}, {"oid": "78961f80bef311dfa557dd0288dec8a7a1564be6", "url": "https://github.com/elastic/elasticsearch/commit/78961f80bef311dfa557dd0288dec8a7a1564be6", "message": "elimate extraneous new array function reference ir node", "committedDate": "2020-03-30T22:57:27Z", "type": "commit"}, {"oid": "7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "url": "https://github.com/elastic/elasticsearch/commit/7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "message": "switch ir function ref nodes to different types", "committedDate": "2020-03-31T20:07:52Z", "type": "commit"}, {"oid": "791eca3b0d29f37c9d84fd196fb03618d33b8606", "url": "https://github.com/elastic/elasticsearch/commit/791eca3b0d29f37c9d84fd196fb03618d33b8606", "message": "remove ILambda in favor of ir tree calculating def method call recipe", "committedDate": "2020-03-31T20:45:25Z", "type": "commit"}, {"oid": "e77796275a7bf20572efb4dd1610e26ad0adefe1", "url": "https://github.com/elastic/elasticsearch/commit/e77796275a7bf20572efb4dd1610e26ad0adefe1", "message": "remove sub nodes from user tree", "committedDate": "2020-03-31T22:52:45Z", "type": "commit"}, {"oid": "94b6c80f963c042dae95604d3c6b469fff10d9ac", "url": "https://github.com/elastic/elasticsearch/commit/94b6c80f963c042dae95604d3c6b469fff10d9ac", "message": "Merge branch 'master' into nodes0", "committedDate": "2020-04-08T17:03:44Z", "type": "commit"}, {"oid": "e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "url": "https://github.com/elastic/elasticsearch/commit/e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "message": "Merge branch 'nodes0' into nodes1", "committedDate": "2020-04-08T17:03:54Z", "type": "commit"}, {"oid": "97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "url": "https://github.com/elastic/elasticsearch/commit/97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-08T17:24:14Z", "type": "commit"}, {"oid": "68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "url": "https://github.com/elastic/elasticsearch/commit/68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "message": "Merge branch 'nodes2' into nodes3", "committedDate": "2020-04-08T17:26:09Z", "type": "commit"}, {"oid": "251ff50fcac2ded70f1026560cf7cb67d1e86c28", "url": "https://github.com/elastic/elasticsearch/commit/251ff50fcac2ded70f1026560cf7cb67d1e86c28", "message": "Merge branch 'master' into nodes1", "committedDate": "2020-04-10T15:30:43Z", "type": "commit"}, {"oid": "198fa475e180a169ca1911734d49096dbaf4a1f3", "url": "https://github.com/elastic/elasticsearch/commit/198fa475e180a169ca1911734d49096dbaf4a1f3", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-10T15:36:40Z", "type": "commit"}, {"oid": "dd82b5f86711cb8d99c686d9fa21ddb035e84880", "url": "https://github.com/elastic/elasticsearch/commit/dd82b5f86711cb8d99c686d9fa21ddb035e84880", "message": "Merge branch 'nodes2' into nodes3", "committedDate": "2020-04-10T15:40:21Z", "type": "commit"}, {"oid": "a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "url": "https://github.com/elastic/elasticsearch/commit/a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "message": "Merge branch 'master' into nodes1", "committedDate": "2020-04-14T23:12:20Z", "type": "commit"}, {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328", "url": "https://github.com/elastic/elasticsearch/commit/4c93293c2ada3933550f1b64fa303a8785b7b328", "message": "Merge branch 'nodes1' into nodes2", "committedDate": "2020-04-14T23:12:46Z", "type": "commit"}, {"oid": "c8076bfa4366e371aaba802a038db3c56ce43074", "url": "https://github.com/elastic/elasticsearch/commit/c8076bfa4366e371aaba802a038db3c56ce43074", "message": "Merge branch 'master' into nodes2", "committedDate": "2020-04-21T14:51:10Z", "type": "commit"}, {"oid": "a4d34169a4724a4111cb30c9671e79798b64f3ef", "url": "https://github.com/elastic/elasticsearch/commit/a4d34169a4724a4111cb30c9671e79798b64f3ef", "message": "response to pr comments", "committedDate": "2020-04-21T16:38:42Z", "type": "commit"}, {"oid": "dafeaeb13af618684c04f0f5d38d509d4af92533", "url": "https://github.com/elastic/elasticsearch/commit/dafeaeb13af618684c04f0f5d38d509d4af92533", "message": "Merge branch 'master' into nodes2", "committedDate": "2020-04-21T17:31:42Z", "type": "commit"}, {"oid": "ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "url": "https://github.com/elastic/elasticsearch/commit/ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "message": "Merge branch 'nodes2' into nodes3", "committedDate": "2020-04-21T17:32:33Z", "type": "commit"}, {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "url": "https://github.com/elastic/elasticsearch/commit/a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "message": "Merge branch 'master' into nodes3", "committedDate": "2020-04-24T14:26:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4MzM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417583350", "bodyText": "(input.read || input.write) will always succeed here, see line 56.", "author": "stu-elastic", "createdAt": "2020-04-29T20:14:04Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            BraceSubDefNode braceSubDefNode = new BraceSubDefNode();\n+            braceSubDefNode.setChildNode(indexOutput.expressionNode);\n+            braceSubDefNode.setLocation(location);\n+            braceSubDefNode.setExpressionType(output.actual);\n+            expressionNode = braceSubDefNode;\n+        } else if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"put\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                throw createError(new IllegalArgumentException(\"Illegal map get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && setter.typeParameters.size() != 2) {\n+                throw createError(new IllegalArgumentException(\"Illegal map set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                    !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5NjExNA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417596114", "bodyText": "Fixed.", "author": "jdconrad", "createdAt": "2020-04-29T20:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4MzM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4NTAxMA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417585010", "bodyText": "Unnecessary first clause.", "author": "stu-elastic", "createdAt": "2020-04-29T20:17:04Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            BraceSubDefNode braceSubDefNode = new BraceSubDefNode();\n+            braceSubDefNode.setChildNode(indexOutput.expressionNode);\n+            braceSubDefNode.setLocation(location);\n+            braceSubDefNode.setExpressionType(output.actual);\n+            expressionNode = braceSubDefNode;\n+        } else if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"put\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                throw createError(new IllegalArgumentException(\"Illegal map get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && setter.typeParameters.size() != 2) {\n+                throw createError(new IllegalArgumentException(\"Illegal map set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                    !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                Input indexInput = new Input();\n+                indexInput.expected = setter != null ? setter.typeParameters.get(0) : getter.typeParameters.get(0);\n+                indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+                index.cast(indexInput, indexOutput);\n+\n+                output.actual = setter != null ? setter.typeParameters.get(1) : getter.returnType;\n+            } else {\n+                throw createError(new IllegalArgumentException(\"Illegal map shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            MapSubShortcutNode mapSubShortcutNode = new MapSubShortcutNode();\n+            mapSubShortcutNode.setChildNode(index.cast(indexOutput));\n+            mapSubShortcutNode.setLocation(location);\n+            mapSubShortcutNode.setExpressionType(output.actual);\n+            mapSubShortcutNode.setGetter(getter);\n+            mapSubShortcutNode.setSetter(setter);\n+            expressionNode = mapSubShortcutNode;\n+        } else if (List.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"set\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1 ||\n+                    getter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && (setter.typeParameters.size() != 2 || setter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0))\n+                    || !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5NjI5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417596292", "bodyText": "Fixed.", "author": "jdconrad", "createdAt": "2020-04-29T20:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4NTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4NjQyNg==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417586426", "bodyText": "This check seems fruitless.", "author": "stu-elastic", "createdAt": "2020-04-29T20:19:42Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            BraceSubDefNode braceSubDefNode = new BraceSubDefNode();\n+            braceSubDefNode.setChildNode(indexOutput.expressionNode);\n+            braceSubDefNode.setLocation(location);\n+            braceSubDefNode.setExpressionType(output.actual);\n+            expressionNode = braceSubDefNode;\n+        } else if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"put\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                throw createError(new IllegalArgumentException(\"Illegal map get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && setter.typeParameters.size() != 2) {\n+                throw createError(new IllegalArgumentException(\"Illegal map set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                    !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                Input indexInput = new Input();\n+                indexInput.expected = setter != null ? setter.typeParameters.get(0) : getter.typeParameters.get(0);\n+                indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+                index.cast(indexInput, indexOutput);\n+\n+                output.actual = setter != null ? setter.typeParameters.get(1) : getter.returnType;\n+            } else {\n+                throw createError(new IllegalArgumentException(\"Illegal map shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            MapSubShortcutNode mapSubShortcutNode = new MapSubShortcutNode();\n+            mapSubShortcutNode.setChildNode(index.cast(indexOutput));\n+            mapSubShortcutNode.setLocation(location);\n+            mapSubShortcutNode.setExpressionType(output.actual);\n+            mapSubShortcutNode.setGetter(getter);\n+            mapSubShortcutNode.setSetter(setter);\n+            expressionNode = mapSubShortcutNode;\n+        } else if (List.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"set\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1 ||\n+                    getter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && (setter.typeParameters.size() != 2 || setter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0))", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5NjE4MA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417596180", "bodyText": "Oops. Was responding to the previous comment. Added this issue (#55976)", "author": "jdconrad", "createdAt": "2020-04-29T20:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4NjQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4ODY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417588694", "bodyText": "input.expected == ZonedDateTime.class?", "author": "stu-elastic", "createdAt": "2020-04-29T20:23:56Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDot.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DotNode;\n+import org.elasticsearch.painless.ir.DotSubArrayLengthNode;\n+import org.elasticsearch.painless.ir.DotSubDefNode;\n+import org.elasticsearch.painless.ir.DotSubNode;\n+import org.elasticsearch.painless.ir.DotSubShortcutNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a field load/store and defers to a child subnode.\n+ */\n+public class EDot extends AExpression {\n+\n+    protected final boolean nullSafe;\n+    protected final String value;\n+\n+    public EDot(Location location, AExpression prefix, boolean nullSafe, String value) {\n+        super(location, prefix);\n+\n+        this.nullSafe = nullSafe;\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        Class<?> targetType = prefixOutput.actual;\n+        String targetCanonicalTypeName = PainlessLookupUtility.typeToCanonicalTypeName(targetType);\n+\n+        ExpressionNode expressionNode = null;\n+\n+        if (prefixOutput.actual.isArray()) {\n+            if (\"length\".equals(value)) {\n+                if (input.write) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"invalid assignment: cannot assign a value write to read-only field [length] for an array.\"));\n+                }\n+\n+                output.actual = int.class;\n+            } else {\n+                throw createError(new IllegalArgumentException(\n+                        \"Field [\" + value + \"] does not exist for type [\" + targetCanonicalTypeName + \"].\"));\n+            }\n+\n+            DotSubArrayLengthNode dotSubArrayLengthNode = new DotSubArrayLengthNode();\n+            dotSubArrayLengthNode.setLocation(location);\n+            dotSubArrayLengthNode.setExpressionType(output.actual);\n+            expressionNode = dotSubArrayLengthNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwNTU5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417605593", "bodyText": "Under certain conditions we can optimize out a cast and allow an invokedynamic call to do the cast for us. These conditions are during an assignment (that is not a compound assignment), where the left expression resolves to a def type brace or dot. For something like def x = new int[1]; x[0] = 1; the generated call from the invokedynamic instruction can take in the 1 as an int type instead of having to go from int to Object and then Object to int if we were to leave in the cast to a def type. However, this only works for assignments where the types can be implicitly cast to. Hence the exceptions here - if the user has done an explicit cast, if we do not know the target, and finally ZonedDateTime. ZonedDateTime is on this exception list because we allow unnatural implicit casts (ie invokedynamic doesn't do them natively) from JodaCompatibleDateTime to minimize disruptions to our users during our transition to Java time.", "author": "jdconrad", "createdAt": "2020-04-29T20:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4ODY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4ODk4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417588982", "bodyText": "input.expected == ZonedDateTime.class?", "author": "stu-elastic", "createdAt": "2020-04-29T20:24:29Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwNTY2NA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417605664", "bodyText": "Answered above.", "author": "jdconrad", "createdAt": "2020-04-29T20:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4ODk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4OTM5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417589393", "bodyText": "Same ZonedDateTime question.", "author": "stu-elastic", "createdAt": "2020-04-29T20:25:09Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECall.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubDefNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a method call and defers to a child subnode.\n+ */\n+public class ECall extends AExpression {\n+\n+    protected final String name;\n+    protected final List<AExpression> arguments;\n+    protected final boolean nullSafe;\n+\n+    public ECall(Location location, AExpression prefix, String name, List<AExpression> arguments, boolean nullSafe) {\n+        super(location, prefix);\n+\n+        this.name = Objects.requireNonNull(name);\n+        this.arguments = Collections.unmodifiableList(Objects.requireNonNull(arguments));\n+        this.nullSafe = nullSafe;\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.write) {\n+            throw createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to method call [\" + name + \"/\" + arguments.size() + \"]\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Input prefixInput = new Input();\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, prefixInput);\n+\n+        ExpressionNode expressionNode;\n+\n+        if (prefixOutput.actual == def.class) {\n+            List<Output> argumentOutputs = new ArrayList<>(arguments.size());\n+\n+            for (AExpression argument : arguments) {\n+                Input expressionInput = new Input();\n+                expressionInput.internal = true;\n+                Output expressionOutput = argument.analyze(classNode, scriptRoot, scope, expressionInput);\n+                argumentOutputs.add(expressionOutput);\n+\n+                if (expressionOutput.actual == void.class) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"Argument(s) cannot be of [void] type when calling method [\" + name + \"].\"));\n+                }\n+\n+                expressionInput.expected = expressionOutput.actual;\n+                argument.cast(expressionInput, expressionOutput);\n+            }\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwNTc1MA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417605750", "bodyText": "Answered above.", "author": "jdconrad", "createdAt": "2020-04-29T20:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4OTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MTk0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417591947", "bodyText": "(input.read || input.write)", "author": "stu-elastic", "createdAt": "2020-04-29T20:29:44Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDot.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DotNode;\n+import org.elasticsearch.painless.ir.DotSubArrayLengthNode;\n+import org.elasticsearch.painless.ir.DotSubDefNode;\n+import org.elasticsearch.painless.ir.DotSubNode;\n+import org.elasticsearch.painless.ir.DotSubShortcutNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a field load/store and defers to a child subnode.\n+ */\n+public class EDot extends AExpression {\n+\n+    protected final boolean nullSafe;\n+    protected final String value;\n+\n+    public EDot(Location location, AExpression prefix, boolean nullSafe, String value) {\n+        super(location, prefix);\n+\n+        this.nullSafe = nullSafe;\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        Class<?> targetType = prefixOutput.actual;\n+        String targetCanonicalTypeName = PainlessLookupUtility.typeToCanonicalTypeName(targetType);\n+\n+        ExpressionNode expressionNode = null;\n+\n+        if (prefixOutput.actual.isArray()) {\n+            if (\"length\".equals(value)) {\n+                if (input.write) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"invalid assignment: cannot assign a value write to read-only field [length] for an array.\"));\n+                }\n+\n+                output.actual = int.class;\n+            } else {\n+                throw createError(new IllegalArgumentException(\n+                        \"Field [\" + value + \"] does not exist for type [\" + targetCanonicalTypeName + \"].\"));\n+            }\n+\n+            DotSubArrayLengthNode dotSubArrayLengthNode = new DotSubArrayLengthNode();\n+            dotSubArrayLengthNode.setLocation(location);\n+            dotSubArrayLengthNode.setExpressionType(output.actual);\n+            expressionNode = dotSubArrayLengthNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            DotSubDefNode dotSubDefNode = new DotSubDefNode();\n+            dotSubDefNode.setLocation(location);\n+            dotSubDefNode.setExpressionType(output.actual);\n+            dotSubDefNode.setValue(value);\n+            expressionNode = dotSubDefNode;\n+        } else {\n+            PainlessField field = scriptRoot.getPainlessLookup().lookupPainlessField(prefixOutput.actual, prefix instanceof EStatic, value);\n+\n+            if (field == null) {\n+                PainlessMethod getter;\n+                PainlessMethod setter;\n+\n+                getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"get\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter == null) {\n+                    getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                            \"is\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+                }\n+\n+                setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"set\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter != null || setter != null) {\n+                    if (getter != null && (getter.returnType == void.class || !getter.typeParameters.isEmpty())) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal get shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (setter != null && (setter.returnType != void.class || setter.typeParameters.size() != 1)) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal set shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (getter != null && setter != null && setter.typeParameters.get(0) != getter.returnType) {\n+                        throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                    }\n+\n+                    if ((input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                        output.actual = setter != null ? setter.typeParameters.get(0) : getter.returnType;\n+                    } else {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    DotSubShortcutNode dotSubShortcutNode = new DotSubShortcutNode();\n+                    dotSubShortcutNode.setLocation(location);\n+                    dotSubShortcutNode.setExpressionType(output.actual);\n+                    dotSubShortcutNode.setGetter(getter);\n+                    dotSubShortcutNode.setSetter(setter);\n+                    expressionNode = dotSubShortcutNode;\n+                } else {\n+                    EConstant index = new EConstant(location, value);\n+                    index.analyze(classNode, scriptRoot, scope, new Input());\n+\n+                    if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+                        getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"get\", 1);\n+                        setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"put\", 2);\n+\n+                        if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map get shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (setter != null && setter.typeParameters.size() != 2) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map set shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                                !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                            throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                        }\n+\n+                        Output indexOutput;\n+\n+                        if ((input.read || input.write)", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5OTAzMg==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417599032", "bodyText": "Fixed.", "author": "jdconrad", "createdAt": "2020-04-29T20:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MTk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MjE4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417592185", "bodyText": "(input.read || input.write)", "author": "stu-elastic", "createdAt": "2020-04-29T20:30:11Z", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDot.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DotNode;\n+import org.elasticsearch.painless.ir.DotSubArrayLengthNode;\n+import org.elasticsearch.painless.ir.DotSubDefNode;\n+import org.elasticsearch.painless.ir.DotSubNode;\n+import org.elasticsearch.painless.ir.DotSubShortcutNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a field load/store and defers to a child subnode.\n+ */\n+public class EDot extends AExpression {\n+\n+    protected final boolean nullSafe;\n+    protected final String value;\n+\n+    public EDot(Location location, AExpression prefix, boolean nullSafe, String value) {\n+        super(location, prefix);\n+\n+        this.nullSafe = nullSafe;\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        Class<?> targetType = prefixOutput.actual;\n+        String targetCanonicalTypeName = PainlessLookupUtility.typeToCanonicalTypeName(targetType);\n+\n+        ExpressionNode expressionNode = null;\n+\n+        if (prefixOutput.actual.isArray()) {\n+            if (\"length\".equals(value)) {\n+                if (input.write) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"invalid assignment: cannot assign a value write to read-only field [length] for an array.\"));\n+                }\n+\n+                output.actual = int.class;\n+            } else {\n+                throw createError(new IllegalArgumentException(\n+                        \"Field [\" + value + \"] does not exist for type [\" + targetCanonicalTypeName + \"].\"));\n+            }\n+\n+            DotSubArrayLengthNode dotSubArrayLengthNode = new DotSubArrayLengthNode();\n+            dotSubArrayLengthNode.setLocation(location);\n+            dotSubArrayLengthNode.setExpressionType(output.actual);\n+            expressionNode = dotSubArrayLengthNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            DotSubDefNode dotSubDefNode = new DotSubDefNode();\n+            dotSubDefNode.setLocation(location);\n+            dotSubDefNode.setExpressionType(output.actual);\n+            dotSubDefNode.setValue(value);\n+            expressionNode = dotSubDefNode;\n+        } else {\n+            PainlessField field = scriptRoot.getPainlessLookup().lookupPainlessField(prefixOutput.actual, prefix instanceof EStatic, value);\n+\n+            if (field == null) {\n+                PainlessMethod getter;\n+                PainlessMethod setter;\n+\n+                getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"get\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter == null) {\n+                    getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                            \"is\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+                }\n+\n+                setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"set\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter != null || setter != null) {\n+                    if (getter != null && (getter.returnType == void.class || !getter.typeParameters.isEmpty())) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal get shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (setter != null && (setter.returnType != void.class || setter.typeParameters.size() != 1)) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal set shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (getter != null && setter != null && setter.typeParameters.get(0) != getter.returnType) {\n+                        throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                    }\n+\n+                    if ((input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                        output.actual = setter != null ? setter.typeParameters.get(0) : getter.returnType;\n+                    } else {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    DotSubShortcutNode dotSubShortcutNode = new DotSubShortcutNode();\n+                    dotSubShortcutNode.setLocation(location);\n+                    dotSubShortcutNode.setExpressionType(output.actual);\n+                    dotSubShortcutNode.setGetter(getter);\n+                    dotSubShortcutNode.setSetter(setter);\n+                    expressionNode = dotSubShortcutNode;\n+                } else {\n+                    EConstant index = new EConstant(location, value);\n+                    index.analyze(classNode, scriptRoot, scope, new Input());\n+\n+                    if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+                        getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"get\", 1);\n+                        setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"put\", 2);\n+\n+                        if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map get shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (setter != null && setter.typeParameters.size() != 2) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map set shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                                !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                            throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                        }\n+\n+                        Output indexOutput;\n+\n+                        if ((input.read || input.write)\n+                                && (input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                            Input indexInput = new Input();\n+                            indexInput.expected = setter != null ? setter.typeParameters.get(0) : getter.typeParameters.get(0);\n+                            indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+                            index.cast(indexInput, indexOutput);\n+\n+                            output.actual = setter != null ? setter.typeParameters.get(1) : getter.returnType;\n+                        } else {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        MapSubShortcutNode mapSubShortcutNode = new MapSubShortcutNode();\n+                        mapSubShortcutNode.setChildNode(index.cast(indexOutput));\n+                        mapSubShortcutNode.setLocation(location);\n+                        mapSubShortcutNode.setExpressionType(output.actual);\n+                        mapSubShortcutNode.setGetter(getter);\n+                        mapSubShortcutNode.setSetter(setter);\n+                        expressionNode = mapSubShortcutNode;\n+                    }\n+\n+                    if (List.class.isAssignableFrom(prefixOutput.actual)) {\n+                        getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"get\", 1);\n+                        setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"set\", 2);\n+\n+                        if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1 ||\n+                                getter.typeParameters.get(0) != int.class)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal list get shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (setter != null && (setter.typeParameters.size() != 2 || setter.typeParameters.get(0) != int.class)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal list set shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0))\n+                                || !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                            throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                        }\n+\n+                        Output indexOutput;\n+\n+                        if ((input.read || input.write)", "originalCommit": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5OTA5NA==", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417599094", "bodyText": "Fixed.", "author": "jdconrad", "createdAt": "2020-04-29T20:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MjE4NQ=="}], "type": "inlineReview"}, {"oid": "64796ba9432bd5240d7bd1a9190503622d0af0ba", "url": "https://github.com/elastic/elasticsearch/commit/64796ba9432bd5240d7bd1a9190503622d0af0ba", "message": "Merge branch 'master' into nodes3", "committedDate": "2020-04-29T20:36:52Z", "type": "commit"}, {"oid": "35a029e05a0b237f0de461efc33cb94992739614", "url": "https://github.com/elastic/elasticsearch/commit/35a029e05a0b237f0de461efc33cb94992739614", "message": "response to pr comments", "committedDate": "2020-04-29T20:57:49Z", "type": "commit"}]}