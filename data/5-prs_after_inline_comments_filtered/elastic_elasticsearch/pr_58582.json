{"pr_number": 58582, "pr_title": "Add data stream timestamp validation via metadata field mapper", "pr_createdAt": "2020-06-26T08:29:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58582", "timeline": [{"oid": "0688dd5af54756141c64eeca5186c50bdb0c0a79", "url": "https://github.com/elastic/elasticsearch/commit/0688dd5af54756141c64eeca5186c50bdb0c0a79", "message": "Add data stream timestamp validation via metadata field mapper\n\nThis commit adds a new metadata field mapper that validates,\nthat a document has exactly a single timestamp value in the data stream timestamp field.\n\nThe MetadataCreateIndexService inserts a data stream timestamp field mapper whenever\na new backing index of a data stream is created.\n\nRelates to #53100", "committedDate": "2020-06-26T08:24:19Z", "type": "commit"}, {"oid": "738f523af2fa2012046647342d5a6beda65d890b", "url": "https://github.com/elastic/elasticsearch/commit/738f523af2fa2012046647342d5a6beda65d890b", "message": "do not serialize at all when disabled", "committedDate": "2020-06-26T09:02:05Z", "type": "commit"}, {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "url": "https://github.com/elastic/elasticsearch/commit/d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "message": "fixed tests and renamed _data_stream_timestamp to _timestamp, some tests were failing\nbecause these tests assumed any field longer then 20 chars is too long.", "committedDate": "2020-06-26T10:04:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwMzkyMA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446103920", "bodyText": "shouldn't we always return when the fieldName is null ?", "author": "jimczi", "createdAt": "2020-06-26T10:31:32Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new DataStreamTimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new DataStreamTimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private DataStreamTimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public void postParse(ParseContext context) throws IOException {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        IndexableField[] fields = context.rootDoc().getFields(fieldName);\n+        if (fields.length == 0) {\n+            throw new IllegalArgumentException(\"data stream timestamp field [\" + fieldName + \"] is missing\");\n+        }\n+\n+        long numberOfValues =\n+            Arrays.stream(fields).filter(indexableField -> indexableField.fieldType().pointDimensionCount() > 0).count();\n+        if (numberOfValues > 1) {\n+            throw new IllegalArgumentException(\"data stream timestamp field [\" + fieldName + \"] encountered multiple values\");\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        if (includeDefaults == false && fieldName == null) {", "originalCommit": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5NzY1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446197659", "bodyText": "I'm ok with doing that, I just thought that if includeDefaults is true then that the fieldName should be returned anyway, irregardless whether it has a value. But I guess it is ok to ignore includeDefaults if fieldName is null?", "author": "martijnvg", "createdAt": "2020-06-26T13:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwMzkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446106461", "bodyText": "I wonder what this would look like though. It's very similar to the alias field so I wonder what @jtibshirani thinks of how this should work ?", "author": "jimczi", "createdAt": "2020-06-26T10:37:39Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.", "originalCommit": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIwMDE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446200191", "bodyText": "I think it would be similar to the code in FieldTypeLookup that checks FieldAliasMapper#path(). I think we can maybe piggyback on that.", "author": "martijnvg", "createdAt": "2020-06-26T13:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMTQxMA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446401410", "bodyText": "The field alias framework is narrow in scope and unfortunately isn't very extensible. @romseygeek is working on some refactors that will let field mappers delegate to other field types to expose search functionality. I think it will be cleaner and more forward-looking to collaborate on that.\nStepping back though, I don't know if this timestamp mapper should serve as a search-time alias for the delegate field. To me it'd be fine if it were just a hidden mapper that performed validation and recorded the data stream timestamp in the mappings. Generally we lean heavily on ECS to provide a consistent set of field names across individual schemas, and ECS has a convenient @timestamp field at the top level. Users can also define field aliases to allow for searching across different data streams. Does the 'timestamp' field need special treatment?\nOne advantage I can think of is that we could allow the delegate timestamp field to change for future indices in a data stream, and searches keep working on _timestamp. This doesn't seem like a common case though.", "author": "jtibshirani", "createdAt": "2020-06-26T20:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwNDg4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446904887", "bodyText": "Generally we lean heavily on ECS to provide a consistent set of field names across individual schemas, and ECS has a convenient @timestamp field at the top level. Users can also define field aliases to allow for searching across different data streams. Does the 'timestamp' field need special treatment?\n\nIn this case, just using @timestamp is imo preferable and sorting by meta field _timestamp would not be needed.\n\nOne advantage I can think of is that we could allow the delegate timestamp field to change for future indices in a data stream, and searches keep working on _timestamp.\n\nI think this becomes more useful, in cases existing indices get imported into a data stream, which is something that we would want to support down the line.\nHowever for now, I think there is no need for this, as the initial targeted users use ECS. I think we will be looking into this somewhere in the not so distant future.", "author": "martijnvg", "createdAt": "2020-06-29T11:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjczNw==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446106737", "bodyText": "Why do we need to reference the data stream naming ? It's a generic timestamp metadata field, right ?", "author": "jimczi", "createdAt": "2020-06-26T10:38:23Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {", "originalCommit": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5NjkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446396914", "bodyText": "@dakrone brought up the good point that we used to have a _timestamp metadata field (#18980), so there may be some confusion over naming. For me the right naming depends some open questions like if we'll allow searches on this field, and if we see a use for it outside of datastreams.", "author": "jtibshirani", "createdAt": "2020-06-26T20:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwMTIwNw==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446901207", "bodyText": "and if we see a use for it outside of datastreams.\n\nData steams targets append-only time based data sources. I think use cases that are not append-only, will keep on using indices + alias pattern. I think this usecase may also benefit from having a _timestamp metadata field.", "author": "martijnvg", "createdAt": "2020-06-29T11:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwODExMA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446108110", "bodyText": "It would be nice to add validation in the MapperService that the target field is of  type date and that it is indexed and has doc values. I  know that you validate this in the data stream code but it would be cleaner/safer to do it directly in the MapperService since the metadata field could be used outside of data streams ?", "author": "jimczi", "createdAt": "2020-06-26T10:41:40Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new DataStreamTimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new DataStreamTimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private DataStreamTimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public void postParse(ParseContext context) throws IOException {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+", "originalCommit": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5ODUxMA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446198510", "bodyText": "do it directly in the MapperService since the metadata field could be used outside of data streams ?\n\nIf this metadata field mapper has value outside data streams then yes it make sense to add the validation in MapperService.", "author": "martijnvg", "createdAt": "2020-06-26T13:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwODExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5MTIxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446391215", "bodyText": "I like the idea of moving the validation down into the mapping code even if the field mapper isn't used outside of data streams. It's really nice to have all mapping validation embedded in the mappers/ mapping logic instead of some living outside.", "author": "jtibshirani", "createdAt": "2020-06-26T20:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwODExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM4OTk5OA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446389998", "bodyText": "Maybe we could instead assert that the field type has at least one docvalues field? This would be more robust if we decide to stop indexing points (#48665).", "author": "jtibshirani", "createdAt": "2020-06-26T20:16:05Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new DataStreamTimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new DataStreamTimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private DataStreamTimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public void postParse(ParseContext context) throws IOException {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        IndexableField[] fields = context.rootDoc().getFields(fieldName);\n+        if (fields.length == 0) {\n+            throw new IllegalArgumentException(\"data stream timestamp field [\" + fieldName + \"] is missing\");\n+        }\n+\n+        long numberOfValues =", "originalCommit": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20732c8aa7478704fb5b58ee5ea69b4018c9c84a", "url": "https://github.com/elastic/elasticsearch/commit/20732c8aa7478704fb5b58ee5ea69b4018c9c84a", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field", "committedDate": "2020-06-29T10:26:03Z", "type": "commit"}, {"oid": "afcee7f51a44e6e4655954dbaad56f8430b10ec0", "url": "https://github.com/elastic/elasticsearch/commit/afcee7f51a44e6e4655954dbaad56f8430b10ec0", "message": "Added more mapping validation logic and\nunit tests", "committedDate": "2020-06-29T14:03:04Z", "type": "commit"}, {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b", "url": "https://github.com/elastic/elasticsearch/commit/fa689613c70206571c00a7d255f3e6420b8dff9b", "message": "rename", "committedDate": "2020-06-29T14:04:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI0NzUxMA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447247510", "bodyText": "I wonder if we could validate the actual mapping config itself, instead of the field type (which is the object used for searches/ aggregations). That way we could ensure the mapping doesn't contain other options that would be harmful: null_value and ignore_malformed.", "author": "jtibshirani", "createdAt": "2020-06-29T20:53:42Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    public void validate(FieldTypeLookup lookup) {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        MappedFieldType fieldType = lookup.get(fieldName);", "originalCommit": "fa689613c70206571c00a7d255f3e6420b8dff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1MTkwNg==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447251906", "bodyText": "I think we should throw an error here, no one should try to write to the _timestamp field.", "author": "jtibshirani", "createdAt": "2020-06-29T21:02:09Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    public void validate(FieldTypeLookup lookup) {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        MappedFieldType fieldType = lookup.get(fieldName);\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] points to a non existing field\");\n+        }\n+\n+        if (DateFieldMapper.CONTENT_TYPE.equals(fieldType.typeName()) == false &&\n+            DateFieldMapper.DATE_NANOS_CONTENT_TYPE.equals(fieldType.typeName()) == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] is of type [\" +\n+                fieldType.typeName() + \"], but [\" + DateFieldMapper.CONTENT_TYPE + \",\" + DateFieldMapper.DATE_NANOS_CONTENT_TYPE +\n+                \"] is expected\");\n+        }\n+\n+        if (fieldType.isSearchable() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] is not indexed\");\n+        }\n+        if (fieldType.hasDocValues() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] doesn't have doc values\");\n+        }\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {", "originalCommit": "fa689613c70206571c00a7d255f3e6420b8dff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1MzA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447253065", "bodyText": "We could use the name path instead of fieldName. This would match the naming for field aliases.", "author": "jtibshirani", "createdAt": "2020-06-29T21:04:29Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;", "originalCommit": "fa689613c70206571c00a7d255f3e6420b8dff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzAyOA==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447263028", "bodyText": "We could override mergeOptions and throw an error if the new field_name doesn't match. This includes the case of updating a null source path to a non-null one. I think currently we won't throw an error but just silently ignore the new mapping definition.", "author": "jtibshirani", "createdAt": "2020-06-29T21:24:59Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {", "originalCommit": "fa689613c70206571c00a7d255f3e6420b8dff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NTg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447265879", "bodyText": "This could just be TimestampFieldType ?", "author": "jtibshirani", "createdAt": "2020-06-29T21:30:55Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {", "originalCommit": "fa689613c70206571c00a7d255f3e6420b8dff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI3MTU1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447271555", "bodyText": "Is there a case where the data stream does not exist, but we are still creating a new index within it?", "author": "jtibshirani", "createdAt": "2020-06-29T21:43:39Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -494,10 +495,19 @@ private ClusterState applyCreateIndexRequestWithV2Template(final ClusterState cu\n         final Map<String, Object> mappings = resolveV2Mappings(request.mappings(), currentState, templateName, xContentRegistry);\n \n         if (request.dataStreamName() != null) {\n+            String timestampField;\n             DataStream dataStream = currentState.metadata().dataStreams().get(request.dataStreamName());\n             if (dataStream != null) {\n+                timestampField = dataStream.getTimeStampField().getName();\n                 dataStream.getTimeStampField().insertTimestampFieldMapping(mappings);\n+            } else {", "originalCommit": "fa689613c70206571c00a7d255f3e6420b8dff9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2NTUyNg==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447665526", "bodyText": "This in the case when data stream doesn't exist yet (has to be created with the first backing index), then the timestamp field should be resolved from composable index template. I added comments here to make this clearer.", "author": "martijnvg", "createdAt": "2020-06-30T13:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI3MTU1NQ=="}], "type": "inlineReview"}, {"oid": "e0a70d0623527f92d3e8b992bf58c46e46e3eef4", "url": "https://github.com/elastic/elasticsearch/commit/e0a70d0623527f92d3e8b992bf58c46e46e3eef4", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field", "committedDate": "2020-06-30T08:50:17Z", "type": "commit"}, {"oid": "63a18f3c96c77a26c34efcf23a7f290c45fe4427", "url": "https://github.com/elastic/elasticsearch/commit/63a18f3c96c77a26c34efcf23a7f290c45fe4427", "message": "iter after merge", "committedDate": "2020-06-30T09:22:00Z", "type": "commit"}, {"oid": "072d85e5702dc4cfe199eecfcd58f622b52c3a99", "url": "https://github.com/elastic/elasticsearch/commit/072d85e5702dc4cfe199eecfcd58f622b52c3a99", "message": "addressed small comments", "committedDate": "2020-06-30T09:31:47Z", "type": "commit"}, {"oid": "3cde4c11fc41925ddaef17c869753480b7610049", "url": "https://github.com/elastic/elasticsearch/commit/3cde4c11fc41925ddaef17c869753480b7610049", "message": "fixed test", "committedDate": "2020-06-30T09:34:02Z", "type": "commit"}, {"oid": "bbe76fa43dc05f7b040e0df4945b19e1abf1f0db", "url": "https://github.com/elastic/elasticsearch/commit/bbe76fa43dc05f7b040e0df4945b19e1abf1f0db", "message": "improve validation", "committedDate": "2020-06-30T12:32:32Z", "type": "commit"}, {"oid": "195bfa1bc2935ddbe6e5a5eeb80cddb096a41c82", "url": "https://github.com/elastic/elasticsearch/commit/195bfa1bc2935ddbe6e5a5eeb80cddb096a41c82", "message": "fixed more tests", "committedDate": "2020-06-30T12:35:12Z", "type": "commit"}, {"oid": "78c67199b6c4cf3e072d8f7f088d5751c99b4469", "url": "https://github.com/elastic/elasticsearch/commit/78c67199b6c4cf3e072d8f7f088d5751c99b4469", "message": "fail with an error if path is updated instead of silently ignoring it.", "committedDate": "2020-06-30T12:59:52Z", "type": "commit"}, {"oid": "d8da070716a17744574d68f2a0575a672f029b69", "url": "https://github.com/elastic/elasticsearch/commit/d8da070716a17744574d68f2a0575a672f029b69", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field", "committedDate": "2020-06-30T13:44:59Z", "type": "commit"}, {"oid": "28d568e5dfdf8dd93a7d02879747e6544edd5bd7", "url": "https://github.com/elastic/elasticsearch/commit/28d568e5dfdf8dd93a7d02879747e6544edd5bd7", "message": "fixed test", "committedDate": "2020-06-30T13:45:48Z", "type": "commit"}, {"oid": "0c03e370cd84928867b97c577dff53a977e1c464", "url": "https://github.com/elastic/elasticsearch/commit/0c03e370cd84928867b97c577dff53a977e1c464", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field", "committedDate": "2020-06-30T15:55:22Z", "type": "commit"}, {"oid": "7b24a57e94205ad02aecc39518b368e70d476023", "url": "https://github.com/elastic/elasticsearch/commit/7b24a57e94205ad02aecc39518b368e70d476023", "message": "fixed test", "committedDate": "2020-06-30T16:04:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MzQ2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447893467", "bodyText": "To me it'd be cleaner to avoid working with the raw JSON and just check specific attributes like 'null value' and 'ignore malformed'. We can add getters to DateFieldMapper if it makes it easier.", "author": "jtibshirani", "createdAt": "2020-06-30T18:27:13Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class TimestampFieldType extends MappedFieldType {\n+\n+        public TimestampFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new TimestampFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String path;\n+\n+        public Builder() {\n+            super(NAME, Defaults.TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setPath(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new TimestampFieldType(),\n+                path\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"path\")) {\n+                    builder.setPath((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.TIMESTAMP_FIELD_TYPE,\n+                new TimestampFieldType(), null);\n+        }\n+    }\n+\n+    private final String path;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String path) {\n+        super(fieldType, mappedFieldType);\n+        this.path = path;\n+    }\n+\n+    public void validate(DocumentFieldMappers lookup) {\n+        if (path == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        Mapper mapper = lookup.getMapper(path);\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] points to a non existing field\");\n+        }\n+\n+        if (DateFieldMapper.CONTENT_TYPE.equals(mapper.typeName()) == false &&\n+            DateFieldMapper.DATE_NANOS_CONTENT_TYPE.equals(mapper.typeName()) == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] is of type [\" +\n+                mapper.typeName() + \"], but [\" + DateFieldMapper.CONTENT_TYPE + \",\" + DateFieldMapper.DATE_NANOS_CONTENT_TYPE +\n+                \"] is expected\");\n+        }\n+\n+        DateFieldMapper dateFieldMapper = (DateFieldMapper) mapper;\n+        if (dateFieldMapper.fieldType().isSearchable() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] is not indexed\");\n+        }\n+        if (dateFieldMapper.fieldType().hasDocValues() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] doesn't have doc values\");\n+        }\n+\n+        // Validate whether disallowed mapping attributes have been specified on the field this meta field refers to:\n+        try (XContentBuilder builder = jsonBuilder()) {", "originalCommit": "7b24a57e94205ad02aecc39518b368e70d476023", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEyODk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r448128989", "bodyText": "This is a catch all validation, if there is any attribute specified but type, meta or format then fail.\nI prefer to keep this logic in the case we ever forget to check an (future new) attribute.\nThe idea is that for least for now in data streams we want to lock down what can be configured on the\ntimestamp field.\nHowever I can add specific checks for null value and ignore malformed for clearer error messages.\nLike the check for whether the field is searchable and has doc values.", "author": "martijnvg", "createdAt": "2020-07-01T05:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MzQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NDUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447894509", "bodyText": "I think these messages are intended to be end-user friendly? So something like this could be clearer: \"The configured timestamp field does not exist.\"", "author": "jtibshirani", "createdAt": "2020-06-30T18:28:59Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class TimestampFieldType extends MappedFieldType {\n+\n+        public TimestampFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new TimestampFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String path;\n+\n+        public Builder() {\n+            super(NAME, Defaults.TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setPath(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new TimestampFieldType(),\n+                path\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"path\")) {\n+                    builder.setPath((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.TIMESTAMP_FIELD_TYPE,\n+                new TimestampFieldType(), null);\n+        }\n+    }\n+\n+    private final String path;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String path) {\n+        super(fieldType, mappedFieldType);\n+        this.path = path;\n+    }\n+\n+    public void validate(DocumentFieldMappers lookup) {\n+        if (path == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        Mapper mapper = lookup.getMapper(path);\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] points to a non existing field\");", "originalCommit": "7b24a57e94205ad02aecc39518b368e70d476023", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NDgwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447894805", "bodyText": "Same thoughts for these other messages, users probably won't understand what \"timestamp meta field's field_name ...\" means.", "author": "jtibshirani", "createdAt": "2020-06-30T18:29:28Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class TimestampFieldType extends MappedFieldType {\n+\n+        public TimestampFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new TimestampFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String path;\n+\n+        public Builder() {\n+            super(NAME, Defaults.TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setPath(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new TimestampFieldType(),\n+                path\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"path\")) {\n+                    builder.setPath((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.TIMESTAMP_FIELD_TYPE,\n+                new TimestampFieldType(), null);\n+        }\n+    }\n+\n+    private final String path;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String path) {\n+        super(fieldType, mappedFieldType);\n+        this.path = path;\n+    }\n+\n+    public void validate(DocumentFieldMappers lookup) {\n+        if (path == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        Mapper mapper = lookup.getMapper(path);\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] points to a non existing field\");\n+        }\n+\n+        if (DateFieldMapper.CONTENT_TYPE.equals(mapper.typeName()) == false &&\n+            DateFieldMapper.DATE_NANOS_CONTENT_TYPE.equals(mapper.typeName()) == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] is of type [\" +", "originalCommit": "7b24a57e94205ad02aecc39518b368e70d476023", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNzg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447907885", "bodyText": "We could move this logic into MapperMergeValidator#validateFieldReferences to keep all the cross-field validation in one place.", "author": "jtibshirani", "createdAt": "2020-06-30T18:52:29Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -391,6 +391,12 @@ private synchronized DocumentMapper internalMerge(DocumentMapper mapper, MergeRe\n         }\n         checkIndexSortCompatibility(indexSettings.getIndexSortConfig(), hasNested);\n \n+        for (MetadataFieldMapper metadataFieldMapper : metadataMappers) {", "originalCommit": "7b24a57e94205ad02aecc39518b368e70d476023", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8b82f6a584ebe5bc9d750bdcb007594f7d203b5", "url": "https://github.com/elastic/elasticsearch/commit/b8b82f6a584ebe5bc9d750bdcb007594f7d203b5", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field", "committedDate": "2020-07-01T12:00:56Z", "type": "commit"}, {"oid": "41aec733ae974da82658a67f469f7063fa379655", "url": "https://github.com/elastic/elasticsearch/commit/41aec733ae974da82658a67f469f7063fa379655", "message": "fixed tests", "committedDate": "2020-07-01T12:16:25Z", "type": "commit"}, {"oid": "116f7b9f8a2371543a518325e8de4a72f5026a13", "url": "https://github.com/elastic/elasticsearch/commit/116f7b9f8a2371543a518325e8de4a72f5026a13", "message": "moved validation logic to MapperMergeValidator#validateFieldReferences(...)", "committedDate": "2020-07-01T12:28:52Z", "type": "commit"}, {"oid": "d0d9f3327f5f257333a4bd445d05220f2cafef3b", "url": "https://github.com/elastic/elasticsearch/commit/d0d9f3327f5f257333a4bd445d05220f2cafef3b", "message": "changed error messages and specifically check for null_value and ignore_malformed", "committedDate": "2020-07-01T13:02:57Z", "type": "commit"}]}