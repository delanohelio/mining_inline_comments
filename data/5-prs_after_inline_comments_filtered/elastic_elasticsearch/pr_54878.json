{"pr_number": 54878, "pr_title": "ILM: Add cluster update timeout on step retry", "pr_createdAt": "2020-04-07T12:02:00Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54878", "timeline": [{"oid": "982659b42f1e7fb398766a57bc8bafbc7a8ff180", "url": "https://github.com/elastic/elasticsearch/commit/982659b42f1e7fb398766a57bc8bafbc7a8ff180", "message": "ILM add cluster update timeout on step retry\n\nThis commits adds a timeout when moving ILM back on to a failed step. In\ncase the master is struggling with processing the cluster update requests\nthese ones will expire (as we'll send them again anyway on the next ILM\nloop run)", "committedDate": "2020-04-07T11:52:27Z", "type": "commit"}, {"oid": "90275b620780f81755c5da79b02dc19719a83ecd", "url": "https://github.com/elastic/elasticsearch/commit/90275b620780f81755c5da79b02dc19719a83ecd", "message": "ILM more descriptive source messages for cluster updates", "committedDate": "2020-04-07T11:53:00Z", "type": "commit"}, {"oid": "7568aebf6153710bd118bb00ccf810a01d72fc00", "url": "https://github.com/elastic/elasticsearch/commit/7568aebf6153710bd118bb00ccf810a01d72fc00", "message": "Use all StepKey information", "committedDate": "2020-04-07T12:55:17Z", "type": "commit"}, {"oid": "a64edeb900ba761778a9af74389e1da48107da03", "url": "https://github.com/elastic/elasticsearch/commit/a64edeb900ba761778a9af74389e1da48107da03", "message": "Merge branch 'master' into ilm-cluster-updates", "committedDate": "2020-04-07T12:56:14Z", "type": "commit"}, {"oid": "19502aa054e5617b3ec87cdbcb4fe60c61c355cf", "url": "https://github.com/elastic/elasticsearch/commit/19502aa054e5617b3ec87cdbcb4fe60c61c355cf", "message": "Merge branch 'master' into ilm-cluster-updates", "committedDate": "2020-04-07T13:09:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNTc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r404805788", "bodyText": "This is code formatting", "author": "andreidan", "createdAt": "2020-04-07T13:25:00Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "diffHunk": "@@ -204,33 +206,45 @@ void onErrorMaybeRetryFailedStep(String policy, IndexMetadata indexMetadata) {\n             int currentRetryAttempt = lifecycleState.getFailedStepRetryCount() == null ? 1 : 1 + lifecycleState.getFailedStepRetryCount();\n             logger.info(\"policy [{}] for index [{}] on an error step due to a transitive error, moving back to the failed \" +\n                 \"step [{}] for execution. retry attempt [{}]\", policy, index, lifecycleState.getFailedStep(), currentRetryAttempt);\n-            clusterService.submitStateUpdateTask(\"ilm-retry-failed-step\", new ClusterStateUpdateTask() {\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n-                        nowSupplier, stepRegistry, true);\n-                }\n+            clusterService.submitStateUpdateTask(\n+                String.format(Locale.ROOT, \"ilm-retry-failed-step {policy [%s], index [%s], failedStep [%s]}\", policy, index,\n+                    failedStep.getKey()),\n+                new ClusterStateUpdateTask() {\n \n-                @Override\n-                public void onFailure(String source, Exception e) {\n-                    logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n-                        failedStep.getKey().getName(), index), e);\n-                }\n+                    @Override\n+                    public TimeValue timeout() {\n+                        // we can afford to drop these requests if they timeout as on the next {@link\n+                        // IndexLifecycleRunner#runPeriodicStep} run the policy will still be in the ERROR step, as we haven't been able\n+                        // to move it back into the failed step, so we'll try again\n+                        return MasterNodeRequest.DEFAULT_MASTER_NODE_TIMEOUT;\n+                    }\n \n-                @Override\n-                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n-                    if (oldState.equals(newState) == false) {\n-                        IndexMetadata newIndexMeta = newState.metadata().index(index);\n-                        Step indexMetaCurrentStep = getCurrentStep(stepRegistry, policy, newIndexMeta);\n-                        StepKey stepKey = indexMetaCurrentStep.getKey();\n-                        if (stepKey != null && stepKey != TerminalPolicyStep.KEY && newIndexMeta != null) {\n-                            logger.trace(\"policy [{}] for index [{}] was moved back on the failed step for as part of an automatic \" +\n-                                \"retry. Attempting to execute the failed step [{}] if it's an async action\", policy, index, stepKey);\n-                            maybeRunAsyncAction(newState, newIndexMeta, policy, stepKey);\n+                    @Override\n+                    public ClusterState execute(ClusterState currentState) {\n+                        return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n+                            nowSupplier, stepRegistry, true);\n+                    }\n+\n+                    @Override\n+                    public void onFailure(String source, Exception e) {\n+                        logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n+                            failedStep.getKey().getName(), index), e);\n+                    }\n+\n+                    @Override\n+                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                        if (oldState.equals(newState) == false) {\n+                            IndexMetadata newIndexMeta = newState.metadata().index(index);\n+                            Step indexMetaCurrentStep = getCurrentStep(stepRegistry, policy, newIndexMeta);\n+                            StepKey stepKey = indexMetaCurrentStep.getKey();\n+                            if (stepKey != null && stepKey != TerminalPolicyStep.KEY && newIndexMeta != null) {\n+                                logger.trace(\"policy [{}] for index [{}] was moved back on the failed step for as part of an automatic \" +\n+                                    \"retry. Attempting to execute the failed step [{}] if it's an async action\", policy, index, stepKey);\n+                                maybeRunAsyncAction(newState, newIndexMeta, policy, stepKey);\n+                            }", "originalCommit": "19502aa054e5617b3ec87cdbcb4fe60c61c355cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c52d84b7dd2e6edf75db6254e7b4d74feaf04d1d", "url": "https://github.com/elastic/elasticsearch/commit/c52d84b7dd2e6edf75db6254e7b4d74feaf04d1d", "message": "Fix test", "committedDate": "2020-04-07T13:46:57Z", "type": "commit"}, {"oid": "c0bed3875c589e745af26a5e1120efe7a0b7ed04", "url": "https://github.com/elastic/elasticsearch/commit/c0bed3875c589e745af26a5e1120efe7a0b7ed04", "message": "ILM cluster state source for ClusterState* steps", "committedDate": "2020-04-07T13:46:57Z", "type": "commit"}, {"oid": "2961ac0244f5d6173f2b241496682e800437b0d3", "url": "https://github.com/elastic/elasticsearch/commit/2961ac0244f5d6173f2b241496682e800437b0d3", "message": "Merge branch 'master' into ilm-cluster-updates", "committedDate": "2020-04-07T14:07:58Z", "type": "commit"}, {"oid": "29aaa1c223d19c8c9370ac00ffef50c22e9267cc", "url": "https://github.com/elastic/elasticsearch/commit/29aaa1c223d19c8c9370ac00ffef50c22e9267cc", "message": "Merge branch 'master' into ilm-cluster-updates", "committedDate": "2020-04-07T16:29:50Z", "type": "commit"}, {"oid": "376485e1fc9636fc447becddea286ef6dd07ad5a", "url": "https://github.com/elastic/elasticsearch/commit/376485e1fc9636fc447becddea286ef6dd07ad5a", "message": "Use the configured ILM step master timeout setting", "committedDate": "2020-04-08T11:05:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzU4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r405443585", "bodyText": "I think we can use the setting we already created to manipulate the ILM related master timeouts. What do you think @dakrone ?", "author": "andreidan", "createdAt": "2020-04-08T11:08:56Z", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "diffHunk": "@@ -204,33 +205,45 @@ void onErrorMaybeRetryFailedStep(String policy, IndexMetadata indexMetadata) {\n             int currentRetryAttempt = lifecycleState.getFailedStepRetryCount() == null ? 1 : 1 + lifecycleState.getFailedStepRetryCount();\n             logger.info(\"policy [{}] for index [{}] on an error step due to a transitive error, moving back to the failed \" +\n                 \"step [{}] for execution. retry attempt [{}]\", policy, index, lifecycleState.getFailedStep(), currentRetryAttempt);\n-            clusterService.submitStateUpdateTask(\"ilm-retry-failed-step\", new ClusterStateUpdateTask() {\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n-                        nowSupplier, stepRegistry, true);\n-                }\n+            clusterService.submitStateUpdateTask(\n+                String.format(Locale.ROOT, \"ilm-retry-failed-step {policy [%s], index [%s], failedStep [%s]}\", policy, index,\n+                    failedStep.getKey()),\n+                new ClusterStateUpdateTask() {\n \n-                @Override\n-                public void onFailure(String source, Exception e) {\n-                    logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n-                        failedStep.getKey().getName(), index), e);\n-                }\n+                    @Override\n+                    public TimeValue timeout() {\n+                        // we can afford to drop these requests if they timeout as on the next {@link\n+                        // IndexLifecycleRunner#runPeriodicStep} run the policy will still be in the ERROR step, as we haven't been able\n+                        // to move it back into the failed step, so we'll try again\n+                        return LifecycleSettings.LIFECYCLE_STEP_MASTER_TIMEOUT_SETTING.get(clusterService.state().metadata().settings());", "originalCommit": "376485e1fc9636fc447becddea286ef6dd07ad5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU5MzAwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r405593001", "bodyText": "That sounds reasonable to me \ud83d\udc4d", "author": "dakrone", "createdAt": "2020-04-08T15:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMTcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r405611729", "bodyText": "@dakrone cool, thanks for confirming, this is ready for review then \ud83d\ude4f\ud83c\udffb", "author": "andreidan", "createdAt": "2020-04-08T15:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzU4NQ=="}], "type": "inlineReview"}]}