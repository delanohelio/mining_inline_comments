{"pr_number": 51815, "pr_title": "Add REST API for cache directory stats", "pr_createdAt": "2020-02-03T14:46:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51815", "timeline": [{"oid": "690a9b481fe9200a08d281b88489198b928d492e", "url": "https://github.com/elastic/elasticsearch/commit/690a9b481fe9200a08d281b88489198b928d492e", "message": "Add REST API for cache directory stats", "committedDate": "2020-02-03T14:36:22Z", "type": "commit"}, {"oid": "2dfb3fde2f8739f3f06ed7dfc6a7ebe512a086a0", "url": "https://github.com/elastic/elasticsearch/commit/2dfb3fde2f8739f3f06ed7dfc6a7ebe512a086a0", "message": "Fix typos", "committedDate": "2020-02-03T14:45:34Z", "type": "commit"}, {"oid": "88d5c2e5f19aa11cef774396ad3b543c127f69c1", "url": "https://github.com/elastic/elasticsearch/commit/88d5c2e5f19aa11cef774396ad3b543c127f69c1", "message": "TransportBroadcastByNodeAction", "committedDate": "2020-02-04T12:33:39Z", "type": "commit"}, {"oid": "fe84072c989e4698ce4a49075d899c3cf3d50463", "url": "https://github.com/elastic/elasticsearch/commit/fe84072c989e4698ce4a49075d899c3cf3d50463", "message": "Remove unnecessary dependency", "committedDate": "2020-02-04T15:13:28Z", "type": "commit"}, {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0", "url": "https://github.com/elastic/elasticsearch/commit/b934e0e377a4042976eff8db8802d7c9567f0cb0", "message": "Merge branch 'feature/searchable-snapshots' into add-instrumentation-step-2", "committedDate": "2020-02-04T17:35:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375109480", "bodyText": "Suggest renaming this to SearchableSnapshotShardStats to clarify that these stats are per-shard.", "author": "DaveCTurner", "createdAt": "2020-02-05T08:13:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {", "originalCommit": "b934e0e377a4042976eff8db8802d7c9567f0cb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDIxNg==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190216", "bodyText": "Sure, I pushed 1167ff7", "author": "tlrx", "createdAt": "2020-02-05T11:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTk1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375109955", "bodyText": "Should we use writeVLong? I think all these numbers will be nonnegative (we can assert that).", "author": "DaveCTurner", "createdAt": "2020-02-05T08:15:06Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {\n+\n+    private final List<CacheIndexInputStats> inputStats;\n+    private final ShardRouting shardRouting;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+\n+    public SearchableSnapshotStats(ShardRouting shardRouting, SnapshotId snapshotId, IndexId indexId, List<CacheIndexInputStats> stats) {\n+        this.shardRouting = Objects.requireNonNull(shardRouting);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.inputStats = unmodifiableList(Objects.requireNonNull(stats));\n+    }\n+\n+    public SearchableSnapshotStats(StreamInput in) throws IOException {\n+        this.shardRouting = new ShardRouting(in);\n+        this.snapshotId = new SnapshotId(in);\n+        this.indexId = new IndexId(in);\n+        this.inputStats = in.readList(CacheIndexInputStats::new);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        shardRouting.writeTo(out);\n+        snapshotId.writeTo(out);\n+        indexId.writeTo(out);\n+        out.writeList(inputStats);\n+    }\n+\n+    public ShardRouting getShardRouting() {\n+        return shardRouting;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public List<CacheIndexInputStats> getStats() {\n+        return inputStats;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        {\n+            builder.field(\"snapshot_uuid\", getSnapshotId().getUUID());\n+            builder.field(\"index_uuid\", getIndexId().getId());\n+            builder.startObject(\"shard\");\n+            {\n+                builder.field(\"state\", shardRouting.state());\n+                builder.field(\"primary\", shardRouting.primary());\n+                builder.field(\"node\", shardRouting.currentNodeId());\n+                if (shardRouting.relocatingNodeId() != null) {\n+                    builder.field(\"relocating_node\", shardRouting.relocatingNodeId());\n+                }\n+            }\n+            builder.endObject();\n+            builder.startArray(\"files\");\n+            {\n+                List<CacheIndexInputStats> stats = inputStats.stream()\n+                    .sorted(Comparator.comparing(CacheIndexInputStats::getFileName)).collect(toList());\n+                for (CacheIndexInputStats stat : stats) {\n+                    stat.toXContent(builder, params);\n+                }\n+            }\n+            builder.endArray();\n+        }\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        SearchableSnapshotStats that = (SearchableSnapshotStats) other;\n+        return Objects.equals(shardRouting, that.shardRouting)\n+            && Objects.equals(snapshotId, that.snapshotId)\n+            && Objects.equals(indexId, that.indexId)\n+            && Objects.equals(inputStats, that.inputStats);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(shardRouting, snapshotId, indexId, inputStats);\n+    }\n+\n+\n+    public static class CacheIndexInputStats implements Writeable, ToXContentObject {\n+\n+        private final String fileName;\n+        private final long fileLength;\n+\n+        private final long openCount;\n+        private final long innerCount;\n+        private final long closeCount;\n+\n+        private final Counter forwardSmallSeeks;\n+        private final Counter backwardSmallSeeks;\n+        private final Counter forwardLargeSeeks;\n+        private final Counter backwardLargeSeeks;\n+        private final Counter contiguousReads;\n+        private final Counter nonContiguousReads;\n+        private final Counter cachedBytesRead;\n+        private final Counter cachedBytesWritten;\n+        private final Counter directBytesRead;\n+\n+        public CacheIndexInputStats(String fileName, long fileLength, long openCount, long innerCount, long closeCount,\n+                                    Counter forwardSmallSeeks, Counter backwardSmallSeeks,\n+                                    Counter forwardLargeSeeks, Counter backwardLargeSeeks,\n+                                    Counter contiguousReads, Counter nonContiguousReads,\n+                                    Counter cachedBytesRead, Counter cachedBytesWritten,\n+                                    Counter directBytesRead) {\n+            this.fileName = fileName;\n+            this.fileLength = fileLength;\n+            this.openCount = openCount;\n+            this.innerCount = innerCount;\n+            this.closeCount = closeCount;\n+            this.forwardSmallSeeks = forwardSmallSeeks;\n+            this.backwardSmallSeeks = backwardSmallSeeks;\n+            this.forwardLargeSeeks = forwardLargeSeeks;\n+            this.backwardLargeSeeks = backwardLargeSeeks;\n+            this.contiguousReads = contiguousReads;\n+            this.nonContiguousReads = nonContiguousReads;\n+            this.cachedBytesRead = cachedBytesRead;\n+            this.cachedBytesWritten = cachedBytesWritten;\n+            this.directBytesRead = directBytesRead;\n+        }\n+\n+        CacheIndexInputStats(final StreamInput in) throws IOException {\n+            this.fileName = in.readString();\n+            this.fileLength = in.readVLong();\n+            this.openCount = in.readVLong();\n+            this.innerCount = in.readVLong();\n+            this.closeCount = in.readVLong();\n+            this.forwardSmallSeeks = new Counter(in);\n+            this.backwardSmallSeeks = new Counter(in);\n+            this.forwardLargeSeeks = new Counter(in);\n+            this.backwardLargeSeeks = new Counter(in);\n+            this.contiguousReads = new Counter(in);\n+            this.nonContiguousReads = new Counter(in);\n+            this.cachedBytesRead = new Counter(in);\n+            this.cachedBytesWritten = new Counter(in);\n+            this.directBytesRead = new Counter(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(fileName);\n+            out.writeVLong(fileLength);\n+            out.writeVLong(openCount);\n+            out.writeVLong(innerCount);\n+            out.writeVLong(closeCount);\n+\n+            forwardSmallSeeks.writeTo(out);\n+            backwardSmallSeeks.writeTo(out);\n+            forwardLargeSeeks.writeTo(out);\n+            backwardLargeSeeks.writeTo(out);\n+            contiguousReads.writeTo(out);\n+            nonContiguousReads.writeTo(out);\n+            cachedBytesRead.writeTo(out);\n+            cachedBytesWritten.writeTo(out);\n+            directBytesRead.writeTo(out);\n+        }\n+\n+        public String getFileName() {\n+            return fileName;\n+        }\n+\n+        public long getFileLength() {\n+            return fileLength;\n+        }\n+\n+        public long getOpenCount() {\n+            return openCount;\n+        }\n+\n+        public long getInnerCount() {\n+            return innerCount;\n+        }\n+\n+        public long getCloseCount() {\n+            return closeCount;\n+        }\n+\n+        public Counter getForwardSmallSeeks() {\n+            return forwardSmallSeeks;\n+        }\n+\n+        public Counter getBackwardSmallSeeks() {\n+            return backwardSmallSeeks;\n+        }\n+\n+        public Counter getForwardLargeSeeks() {\n+            return forwardLargeSeeks;\n+        }\n+\n+        public Counter getBackwardLargeSeeks() {\n+            return backwardLargeSeeks;\n+        }\n+\n+        public Counter getContiguousReads() {\n+            return contiguousReads;\n+        }\n+\n+        public Counter getNonContiguousReads() {\n+            return nonContiguousReads;\n+        }\n+\n+        public Counter getCachedBytesRead() {\n+            return cachedBytesRead;\n+        }\n+\n+        public Counter getCachedBytesWritten() {\n+            return cachedBytesWritten;\n+        }\n+\n+        public Counter getDirectBytesRead() {\n+            return directBytesRead;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            {\n+                builder.field(\"name\", getFileName());\n+                builder.field(\"length\", getFileLength());\n+                builder.field(\"open_count\", getOpenCount());\n+                builder.field(\"inner_count\", getInnerCount());\n+                builder.field(\"close_count\", getCloseCount());\n+                builder.field(\"contiguous_bytes_read\", getContiguousReads());\n+                builder.field(\"non_contiguous_bytes_read\", getNonContiguousReads());\n+                builder.field(\"cached_bytes_read\", getCachedBytesRead());\n+                builder.field(\"cached_bytes_written\", getCachedBytesWritten());\n+                builder.field(\"direct_bytes_read\", getDirectBytesRead());\n+                {\n+                    builder.startObject(\"forward_seeks\");\n+                    builder.field(\"small\", getForwardSmallSeeks());\n+                    builder.field(\"large\", getForwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"backward_seeks\");\n+                    builder.field(\"small\", getBackwardSmallSeeks());\n+                    builder.field(\"large\", getBackwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+            }\n+            return builder.endObject();\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (other == null || getClass() != other.getClass()) {\n+                return false;\n+            }\n+            CacheIndexInputStats stats = (CacheIndexInputStats) other;\n+            return fileLength == stats.fileLength\n+                && openCount == stats.openCount\n+                && innerCount == stats.innerCount\n+                && closeCount == stats.closeCount\n+                && Objects.equals(fileName, stats.fileName)\n+                && Objects.equals(forwardSmallSeeks, stats.forwardSmallSeeks)\n+                && Objects.equals(backwardSmallSeeks, stats.backwardSmallSeeks)\n+                && Objects.equals(forwardLargeSeeks, stats.forwardLargeSeeks)\n+                && Objects.equals(backwardLargeSeeks, stats.backwardLargeSeeks)\n+                && Objects.equals(contiguousReads, stats.contiguousReads)\n+                && Objects.equals(nonContiguousReads, stats.nonContiguousReads)\n+                && Objects.equals(cachedBytesRead, stats.cachedBytesRead)\n+                && Objects.equals(cachedBytesWritten, stats.cachedBytesWritten)\n+                && Objects.equals(directBytesRead, stats.directBytesRead);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(fileName, fileLength, openCount, innerCount, closeCount,\n+                forwardSmallSeeks, backwardSmallSeeks,\n+                forwardLargeSeeks, backwardLargeSeeks,\n+                contiguousReads, nonContiguousReads,\n+                cachedBytesRead, cachedBytesWritten,\n+                directBytesRead);\n+        }\n+    }\n+\n+    public static class Counter implements Writeable, ToXContentObject {\n+\n+        private final long count;\n+        private final long total;\n+        private final long min;\n+        private final long max;\n+\n+        public Counter(final long count, final long total, final long min, final long max) {\n+            this.count = count;\n+            this.total = total;\n+            this.min = min;\n+            this.max = max;\n+        }\n+\n+        Counter(final StreamInput in) throws IOException {\n+            this.count = in.readZLong();\n+            this.total = in.readZLong();\n+            this.min = in.readZLong();\n+            this.max = in.readZLong();\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            out.writeZLong(count);", "originalCommit": "b934e0e377a4042976eff8db8802d7c9567f0cb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDI0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190247", "bodyText": "They can be negative for backward seeks counters, which kind of makes sense. I also think we should handle negative longs here because Counter might have different purpose and count different things.\nAnyway I pushed b1d7973 to use negative longs in SearchableSnapshotShardStats serializing tests and also to add some randomization for the seeking threshold in IndexInputStatsTests.", "author": "tlrx", "createdAt": "2020-02-05T11:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1NjM2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375356363", "bodyText": "Ah of course. \ud83d\udc4d", "author": "DaveCTurner", "createdAt": "2020-02-05T16:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375114439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return stats;\n          \n          \n            \n                    return Collections.unmodifiableMap(stats);", "author": "DaveCTurner", "createdAt": "2020-02-05T08:26:15Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -64,6 +64,22 @@ private CacheKey createCacheKey(String fileName) {\n         return new CacheKey(snapshotId, indexId, shardId, fileName);\n     }\n \n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return stats;", "originalCommit": "b934e0e377a4042976eff8db8802d7c9567f0cb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDQxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190417", "bodyText": "Good catch too - thanks! I pushed dda6ab7", "author": "tlrx", "createdAt": "2020-02-05T11:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375124997", "bodyText": "Ideally, we would throw an exception if the user specified an index (or pattern) which didn't match any searchable snapshots, but this would naturally fall to the IndexNameExpressionResolver which doesn't seem to have a suitable extension point for this kind of logic.\nHowever, what do you think about handling at least the case of a user specifying a single index with a typo, matching nothing, with an INFE? I.e. if request.indices() is not empty or [\"*\"] or [\"_all\"] but searchableSnapshotIndices is empty, then that's a bad request.", "author": "DaveCTurner", "createdAt": "2020-02-05T08:51:20Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "originalCommit": "b934e0e377a4042976eff8db8802d7c9567f0cb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDQ4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190482", "bodyText": "That sounds like a good idea. I implemented it a bit differently though in c9468d1, by checking if one or more concrete indices were resolved (taking security into account) but none of them had a searchable store type (searchableSnapshotIndices is empty) which throws a resource not found exception. I've updated the REST API test for this.", "author": "tlrx", "createdAt": "2020-02-05T11:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MjA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375362040", "bodyText": "Hmm, this means that GET _searchable_snapshots/stats returns 200 OK in an empty cluster but 404 Not Found if there are any indices at all but none of them are searchable snapshots. I think that'll be surprising. Maybe it'd be best always to throw a RNFE if searchableSnapshotIndices is empty.", "author": "DaveCTurner", "createdAt": "2020-02-05T16:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5OTYxMA==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375699610", "bodyText": "I'm not fully sure how it should behave, also because Security also has its specific behavior so I went with your suggestion in d1049a3 which has the advantage to be consistent.", "author": "tlrx", "createdAt": "2020-02-06T08:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc0MTAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375741002", "bodyText": "Looks good. Test failures are not obviously related, maybe we need to merge something?", "author": "DaveCTurner", "createdAt": "2020-02-06T10:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc0MjI3MA==", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375742270", "bodyText": "Yes, need to merge master but I'm waiting for bwc to be reenabled before.", "author": "tlrx", "createdAt": "2020-02-06T10:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}], "type": "inlineReview"}, {"oid": "1167ff77ef1db7fb89c760de236fda2d2fcae0bf", "url": "https://github.com/elastic/elasticsearch/commit/1167ff77ef1db7fb89c760de236fda2d2fcae0bf", "message": "Renaming", "committedDate": "2020-02-05T09:32:08Z", "type": "commit"}, {"oid": "b1d79735f562188b5a0167b7c4400dff0f36c61e", "url": "https://github.com/elastic/elasticsearch/commit/b1d79735f562188b5a0167b7c4400dff0f36c61e", "message": "handle negative longs in tests + random seeking threshold", "committedDate": "2020-02-05T09:44:08Z", "type": "commit"}, {"oid": "a4f92bd70270a436a6395001dd4662fdc76efa07", "url": "https://github.com/elastic/elasticsearch/commit/a4f92bd70270a436a6395001dd4662fdc76efa07", "message": "unknown", "committedDate": "2020-02-05T09:45:46Z", "type": "commit"}, {"oid": "f2ea47f228c27bead4933eb04cc18ae82ca39601", "url": "https://github.com/elastic/elasticsearch/commit/f2ea47f228c27bead4933eb04cc18ae82ca39601", "message": "replicas to 0 and rename index to docs", "committedDate": "2020-02-05T10:06:28Z", "type": "commit"}, {"oid": "dda6ab7250aee4e614f516f3b718fedd3c6d8538", "url": "https://github.com/elastic/elasticsearch/commit/dda6ab7250aee4e614f516f3b718fedd3c6d8538", "message": "Collections.unmodifiableMap(stats);", "committedDate": "2020-02-05T10:09:24Z", "type": "commit"}, {"oid": "fde0a86e63f0ba22ff6aa1d5d29ddb5b5b1b49ec", "url": "https://github.com/elastic/elasticsearch/commit/fde0a86e63f0ba22ff6aa1d5d29ddb5b5b1b49ec", "message": "Document // NORELEASE", "committedDate": "2020-02-05T10:23:30Z", "type": "commit"}, {"oid": "c9468d104a8f341b94ba4bbba8373f68f30b508b", "url": "https://github.com/elastic/elasticsearch/commit/c9468d104a8f341b94ba4bbba8373f68f30b508b", "message": "RNFE", "committedDate": "2020-02-05T10:58:24Z", "type": "commit"}, {"oid": "d1049a35844f78f1faa595e01745efe472b5acbf", "url": "https://github.com/elastic/elasticsearch/commit/d1049a35844f78f1faa595e01745efe472b5acbf", "message": "RNFE bis", "committedDate": "2020-02-06T08:37:20Z", "type": "commit"}, {"oid": "c81bcdea24ddc8e98208f9685aff264e34ddfa6f", "url": "https://github.com/elastic/elasticsearch/commit/c81bcdea24ddc8e98208f9685aff264e34ddfa6f", "message": "Merge branch 'feature/searchable-snapshots' into add-instrumentation-step-2", "committedDate": "2020-02-06T11:52:34Z", "type": "commit"}]}