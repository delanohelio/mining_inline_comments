{"pr_number": 55117, "pr_title": "Validate REST specs against schema", "pr_createdAt": "2020-04-13T15:45:19Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55117", "timeline": [{"oid": "e7444630d4a4b79729f0e1ad8fca750e00e06f44", "url": "https://github.com/elastic/elasticsearch/commit/e7444630d4a4b79729f0e1ad8fca750e00e06f44", "message": "new validateRestSpec task and plugin\n\nA JSON schema was recently introduced for the REST API specification. #54252\nThis PR introduces a 3rd party validation tool to ensure that the\nREST specification conforms the schema.\n\nThe task is applied to the 3 projects that contain REST API specifications.\nThe plugin wires this task into the precommit commit task, and should be\nconsidered as part of the public API for the build tools for any plugin\ndeveloper to contribute their plugin's specification.\n\nAn ignore parameter has been introduced for the task to allow specific\nfile to be ignored from the validation. The ignored files in this PR\nwill soon get issues logged and a link so they can be fixed.\n\nCloses #54314", "committedDate": "2020-04-13T15:28:52Z", "type": "commit"}, {"oid": "7b8bdf055fff6b309875a544386a6b857778bf57", "url": "https://github.com/elastic/elasticsearch/commit/7b8bdf055fff6b309875a544386a6b857778bf57", "message": "fix javadoc", "committedDate": "2020-04-13T16:54:37Z", "type": "commit"}, {"oid": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "url": "https://github.com/elastic/elasticsearch/commit/b34ba76ffad406a205bd110a10ecfa80a4d02a46", "message": "Merge branch 'master' into validate_rest_spec", "committedDate": "2020-04-13T18:01:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTI4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407719283", "bodyText": "This should probably be called getInputFiles() or similar.", "author": "mark-vieira", "createdAt": "2020-04-13T21:02:22Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407719541", "bodyText": "How long does this thing take to run? Should we make it cacheable?", "author": "mark-vieira", "createdAt": "2020-04-13T21:02:52Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMDcyOA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411010728", "bodyText": "It's surprisingly quick. ~ .1s on my machine. I think we can leave this not cachable since currently only 3 projects have this task applied.", "author": "jakelandis", "createdAt": "2020-04-19T22:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMDk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407720944", "bodyText": "We should not directly access the schema from the task implementation. We should do this in the plugin and pass them in as an input to the task. Two reasons for this:\n\nThis logic simply shouldn't exist in the task. This \"wiring\" should be done by plugins. This makes the tasks more reusable and composable.\nThe schema isn't tracked as an input. Which means, if it changes we won't correctly flag this task as out of date.", "author": "mark-vieira", "createdAt": "2020-04-13T21:05:37Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {\n+        // load schema\n+        JsonSchema jsonSchema;\n+        FileTree jsonSchemas = Util.getJavaMainSourceResources(", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMTAwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411011009", "bodyText": "Done, and thanks for the feedback. I think the result is much cleaner.\nI changed the task so that it is generic Json validator and moved the ES specific location of stuff to the plugin.", "author": "jakelandis", "createdAt": "2020-04-19T23:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMDk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407721394", "bodyText": "All this stuff should be in the plugin. These are conventions specific to our project. We should be able to easily reuse this task to validate something else. Right now that would be impossible do to these conventions being hard-coded into the task implementation.", "author": "mark-vieira", "createdAt": "2020-04-13T21:06:34Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMTA0NA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411011044", "bodyText": "Agreed, and done.", "author": "jakelandis", "createdAt": "2020-04-19T23:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMjI0NA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407722244", "bodyText": "Again, this should be in the plugin. We should be just add a setInputFiles(FileCollection files) that we pass exactly what we want to validate. Then the plugin can do all this source set stuff. Also the plugin should confirm these source sets exist (or apply the plugin that creates them) so things don't explode.", "author": "mark-vieira", "createdAt": "2020-04-13T21:08:18Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMTA5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411011093", "bodyText": "done.", "author": "jakelandis", "createdAt": "2020-04-19T23:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMjI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407723335", "bodyText": "I wonder if it's worth doing any kind of caching here, or if the schema stuff does this internally? We want to avoid parsing the schema over and over if possible.", "author": "mark-vieira", "createdAt": "2020-04-13T21:10:27Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {\n+        // load schema\n+        JsonSchema jsonSchema;\n+        FileTree jsonSchemas = Util.getJavaMainSourceResources(\n+            getProject().findProject(SCHEMA_PROJECT),\n+            Util.filterByPatterns(getPatternSetFactory().create(), Collections.singletonList(JSON_SCHEMA_PATTERN), null)\n+        );\n+        if (jsonSchemas == null || jsonSchemas.getFiles().size() != 1) {\n+            throw new IllegalStateException(\n+                String.format(\n+                    \"Could not find the schema file from glob pattern [%s] and project [%s] for JSON spec validation\",\n+                    JSON_SCHEMA_PATTERN,\n+                    SCHEMA_PROJECT\n+                )\n+            );\n+        }\n+        File jsonSchemaOnDisk = jsonSchemas.iterator().next();\n+        getLogger().debug(\"JSON schema for REST spec: [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+        jsonSchema = factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMTE0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411011146", "bodyText": "I added a simple in-memory cache. not sure how much it helps, but can't hurt.", "author": "jakelandis", "createdAt": "2020-04-19T23:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNDU2OA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407724568", "bodyText": "Bonus points if we make this task incremental so we only revalidate changed files \ud83d\ude09. This is a prime candidate for that kind of thing because each file can be independently validated.\nhttps://docs.gradle.org/current/userguide/custom_tasks.html#incremental_tasks", "author": "mark-vieira", "createdAt": "2020-04-13T21:13:00Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMTI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411011274", "bodyText": "Done.  this is a neat feature I was not aware of.", "author": "jakelandis", "createdAt": "2020-04-19T23:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNDU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407727726", "bodyText": "Let's avoid smashing the output of this task in an exception message. Instead let's follow the example of other core Gradle tasks which is to simply log the errors in the task using logger and then throw an exception message that says something like \"There were errors, refer to task output.\". We can (and should) include a summary in the exception (ex: \"Validation failed: 3 files contained 8 violations\"), but details should be in task output.\nFor example, here's a checkstyle error: https://gradle-enterprise.elastic.co/s/ixyvqw455k6m6/failure?openFailures=WzBd&openStackTraces=WzFd#top=0", "author": "mark-vieira", "createdAt": "2020-04-13T21:19:06Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";\n+    private static final String JSON_SCHEMA_PATTERN = DOUBLE_STARS + \"/schema.json\";\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+\n+    @SkipWhenEmpty\n+    @InputFiles\n+    public FileTree getInputDir() {\n+        // if null results in in NO-SOURCE\n+        return Util.getJavaTestAndMainSourceResources(\n+            getProject(),\n+            Util.filterByPatterns(\n+                getPatternSetFactory().create(),\n+                Collections.singletonList(JSON_SPEC_PATTERN_INCLUDE),\n+                Collections.singletonList(JSON_SPEC_PATTERN_EXCLUDE)\n+            )\n+        );\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @Inject\n+    protected Factory<PatternSet> getPatternSetFactory() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @TaskAction\n+    public void validate() throws IOException {\n+        // load schema\n+        JsonSchema jsonSchema;\n+        FileTree jsonSchemas = Util.getJavaMainSourceResources(\n+            getProject().findProject(SCHEMA_PROJECT),\n+            Util.filterByPatterns(getPatternSetFactory().create(), Collections.singletonList(JSON_SCHEMA_PATTERN), null)\n+        );\n+        if (jsonSchemas == null || jsonSchemas.getFiles().size() != 1) {\n+            throw new IllegalStateException(\n+                String.format(\n+                    \"Could not find the schema file from glob pattern [%s] and project [%s] for JSON spec validation\",\n+                    JSON_SCHEMA_PATTERN,\n+                    SCHEMA_PROJECT\n+                )\n+            );\n+        }\n+        File jsonSchemaOnDisk = jsonSchemas.iterator().next();\n+        getLogger().debug(\"JSON schema for REST spec: [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+        jsonSchema = factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+        // validate input files\n+        FileTree specs = getInputDir();\n+        Map<File, Set<ValidationMessage>> errors = new HashMap<>();\n+        for (File file : specs.getFiles()) {\n+            if (ignore.contains(file.getName())) {\n+                getLogger().info(\"Ignoring file [{}] due to configuration\", file.getName());\n+                continue;\n+            }\n+            // validate all files and hold on to errors for a complete report if there are failures\n+            getLogger().debug(\"Validating REST spec [{}]\", file.getName());\n+            Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+            for (ValidationMessage validationMessage : validationMessages) {\n+                errors.computeIfAbsent(file, k -> new HashSet<>()).add(validationMessage);\n+            }\n+        }\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating REST specification.\");\n+            sb.append(System.lineSeparator());\n+            sb.append(String.format(\"Schema: %s\", jsonSchemaOnDisk));\n+            sb.append(System.lineSeparator());\n+            errors.forEach((file, error) -> {\n+                sb.append(System.lineSeparator());\n+                sb.append(String.format(\"File: %s\", file.getName()));\n+                sb.append(System.lineSeparator());\n+                sb.append(\"----------------------\");\n+                sb.append(System.lineSeparator());\n+                error.forEach(message -> {\n+                    sb.append(message);\n+                    sb.append(System.lineSeparator());\n+                });\n+            });\n+            throw new JsonSchemaException(sb.toString());", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMjIxMw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411012213", "bodyText": "Done. The a validation error looks like:\n> Task :rest-api-spec:validateRestSpec FAILED\n[validate JSON][ERROR][cat.thread_pool.json][$.cat.thread_pool.params.size.options[0]: does not match the regex pattern ^[a-zA-Z_]+$]\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':rest-api-spec:validateRestSpec'.\n> Error validating JSON. See the report at: file:/Users/jakelandis/workspace/8x/elasticsearch/rest-api-spec/build/reports/validateJson.txt\n  JSON validation failed: 1 files contained 1 violations\n\n\nThe report looks like:\nSchema: /Users/jakelandis/workspace/8x/elasticsearch/rest-api-spec/src/main/resources/schema.json\n----------Validation Errors-----------\n/Users/jakelandis/workspace/8x/elasticsearch/rest-api-spec/src/main/resources/rest-api-spec/api/cat.thread_pool.json: $.cat.thread_pool.params.size.options[0]: does not match the regex pattern ^[a-zA-Z_]+$", "author": "jakelandis", "createdAt": "2020-04-19T23:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3NzczMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411577731", "bodyText": "I'm not sure we need the report file and the log output, what do you think? To me the log output is the priority, as that's the only convenient way to debug errors in CI. And if we have all the info we need in the console, do we need to create the report file?\nSorry if my example sent you down that path. I was mainly getting at the fact that individual errors are reported in the task output and the exception message simply refers to that output.", "author": "mark-vieira", "createdAt": "2020-04-20T17:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5MTg3MA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411591870", "bodyText": "I think there is marginal benefit to having a report. It allows me to use the fqn for the files without polluting the log output with long names. Also, this validation as-is should feel familiar since it like checkstyle (not sure if that is good or bad)\nI have a minor preference to keep the report.", "author": "jakelandis", "createdAt": "2020-04-20T18:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5NDc1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411594755", "bodyText": "I have a minor preference to keep the report.\n\nSGTM \ud83d\udc4d", "author": "mark-vieira", "createdAt": "2020-04-20T18:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5NjI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411596255", "bodyText": "If we are going to keep the report, let's just go ahead and ditch the success marker then. No point in having two different outputs. In the case of scenario where we found no errors, we can just say as much in the report file. So let's get rid of that and the need to extend PrecommitTask.", "author": "mark-vieira", "createdAt": "2020-04-20T18:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1MDQ0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411650441", "bodyText": "done. 6090fba", "author": "jakelandis", "createdAt": "2020-04-20T19:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODg1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407728851", "bodyText": "I think the more idiomatic thing is to use Optional.empty() here.", "author": "mark-vieira", "createdAt": "2020-04-13T21:21:30Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -75,4 +84,91 @@ public static URI getBuildSrcCodeSource() {\n             throw new GradleException(\"Error determining build tools JAR location\", e);\n         }\n     }\n+\n+    public static Function<FileTree, FileTree> filterByPatterns(\n+        PatternSet patternSet,\n+        @Nullable List<String> includePatterns,\n+        @Nullable List<String> excludePatterns\n+    ) {\n+        return inFiles -> {\n+            if (inFiles != null && inFiles.isEmpty() == false) {\n+                if (includePatterns != null) {\n+                    patternSet.include(includePatterns);\n+                }\n+                if (excludePatterns != null) {\n+                    patternSet.exclude(excludePatterns);\n+                }\n+                return inFiles.getAsFileTree().matching(patternSet);\n+            } else {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(mainFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for test resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(testFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the combined {@link FileTree} for test and main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestAndMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        if (testFileTree.isPresent() && mainFileTree.isPresent()) {\n+            return filter.apply(testFileTree.get().plus(mainFileTree.get()));\n+        } else {\n+            return filter.apply(testFileTree.orElse(mainFileTree.orElse(null)));\n+        }\n+    }\n+\n+    /**\n+     * @param project The project to look for test Java resources.\n+     * @return An Optional that contains the Java test SourceSet if it exists.\n+     */\n+    public static Optional<SourceSet> getJavaTestSourceSet(Project project) {\n+        return project.getConvention().findPlugin(JavaPluginConvention.class) == null\n+            ? Optional.ofNullable(null)", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODk1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407728953", "bodyText": "Use Optional.empty().", "author": "mark-vieira", "createdAt": "2020-04-13T21:21:41Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -75,4 +84,91 @@ public static URI getBuildSrcCodeSource() {\n             throw new GradleException(\"Error determining build tools JAR location\", e);\n         }\n     }\n+\n+    public static Function<FileTree, FileTree> filterByPatterns(\n+        PatternSet patternSet,\n+        @Nullable List<String> includePatterns,\n+        @Nullable List<String> excludePatterns\n+    ) {\n+        return inFiles -> {\n+            if (inFiles != null && inFiles.isEmpty() == false) {\n+                if (includePatterns != null) {\n+                    patternSet.include(includePatterns);\n+                }\n+                if (excludePatterns != null) {\n+                    patternSet.exclude(excludePatterns);\n+                }\n+                return inFiles.getAsFileTree().matching(patternSet);\n+            } else {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(mainFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the {@link FileTree} for test resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        return filter.apply(testFileTree.orElse(null));\n+    }\n+\n+    /**\n+     * @param project The project to look for resources.\n+     * @param filter  Optional filter function to filter the returned resources\n+     * @return Returns the combined {@link FileTree} for test and main resources from Java projects. Returns null if no files exist.\n+     */\n+    @Nullable\n+    public static FileTree getJavaTestAndMainSourceResources(Project project, @Nullable Function<FileTree, FileTree> filter) {\n+        if (filter == null) {\n+            filter = Function.identity();\n+        }\n+        final Optional<FileTree> testFileTree = getJavaTestSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        final Optional<FileTree> mainFileTree = getJavaMainSourceSet(project).map(SourceSet::getResources).map(FileTree::getAsFileTree);\n+        if (testFileTree.isPresent() && mainFileTree.isPresent()) {\n+            return filter.apply(testFileTree.get().plus(mainFileTree.get()));\n+        } else {\n+            return filter.apply(testFileTree.orElse(mainFileTree.orElse(null)));\n+        }\n+    }\n+\n+    /**\n+     * @param project The project to look for test Java resources.\n+     * @return An Optional that contains the Java test SourceSet if it exists.\n+     */\n+    public static Optional<SourceSet> getJavaTestSourceSet(Project project) {\n+        return project.getConvention().findPlugin(JavaPluginConvention.class) == null\n+            ? Optional.ofNullable(null)\n+            : Optional.ofNullable(GradleUtils.getJavaSourceSets(project).findByName(SourceSet.TEST_SOURCE_SET_NAME));\n+    }\n+\n+    /**\n+     * @param project The project to look for main Java resources.\n+     * @return An Optional that contains the Java main SourceSet if it exists.\n+     */\n+    public static Optional<SourceSet> getJavaMainSourceSet(Project project) {\n+        return project.getConvention().findPlugin(JavaPluginConvention.class) == null\n+            ? Optional.ofNullable(null)", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjQ5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407732493", "bodyText": "This is a bit of an awkward way of defining a filter. Instead of creating a function that takes a FileTree and returns another FileTree why not model the filter as an Action<? super PatternFilterable>? Then your methods that take this could just look like:\ngetJavaMainSourceResources(project, spec -> spec.include(**/foo/**))\n\nThis also avoids the need to create a PatternSet via PatternSetFactory which is technically an internal API.", "author": "mark-vieira", "createdAt": "2020-04-13T21:29:06Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -75,4 +84,91 @@ public static URI getBuildSrcCodeSource() {\n             throw new GradleException(\"Error determining build tools JAR location\", e);\n         }\n     }\n+\n+    public static Function<FileTree, FileTree> filterByPatterns(", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407735976", "bodyText": "Also would alleviate the need for a bunch of null-checking logic on the filter.", "author": "mark-vieira", "createdAt": "2020-04-13T21:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMTY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411011660", "bodyText": "Cool, thanks for the pointer. Updated to use Action<? super PatternFilterable> and think it is much cleaner now.", "author": "jakelandis", "createdAt": "2020-04-19T23:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r407735096", "bodyText": "Does this file ever get validated?", "author": "mark-vieira", "createdAt": "2020-04-13T21:34:33Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecTask.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.util.PatternSet;\n+import org.gradle.internal.Factory;\n+\n+import javax.inject.Inject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the REST specification against a schema. There should only be a single location for the schema, but any project can contribute\n+ * to the REST specification.\n+ */\n+public class ValidateRestSpecTask extends PrecommitTask {\n+\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STARS = \"**\"; // checkstyle thinks this is an empty javadoc statement, so string concat instead\n+    private static final String JSON_SPEC_PATTERN_INCLUDE = DOUBLE_STARS + \"/rest-api-spec/api/\" + DOUBLE_STARS + \"/*.json\";\n+    private static final String JSON_SPEC_PATTERN_EXCLUDE = DOUBLE_STARS + \"/_common.json\";", "originalCommit": "b34ba76ffad406a205bd110a10ecfa80a4d02a46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxMTU1MA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411011550", "bodyText": "Nope.  this is a hard coded exception to the JSON schema validation.", "author": "jakelandis", "createdAt": "2020-04-19T23:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTA5Ng=="}], "type": "inlineReview"}, {"oid": "4b2fadc390e08611c44f7a1c53ba16e20f73a975", "url": "https://github.com/elastic/elasticsearch/commit/4b2fadc390e08611c44f7a1c53ba16e20f73a975", "message": "review updates (still missing report)", "committedDate": "2020-04-19T22:50:22Z", "type": "commit"}, {"oid": "9d89f406be2c56c8bab8f556753457a1bdf36edd", "url": "https://github.com/elastic/elasticsearch/commit/9d89f406be2c56c8bab8f556753457a1bdf36edd", "message": "checkstyle/spotless and new report", "committedDate": "2020-04-19T22:50:23Z", "type": "commit"}, {"oid": "6c7e1a376b559353ad855354586362077d1dc9a8", "url": "https://github.com/elastic/elasticsearch/commit/6c7e1a376b559353ad855354586362077d1dc9a8", "message": "Merge remote-tracking branch 'upstream/master' into validate_rest_spec", "committedDate": "2020-04-19T22:54:14Z", "type": "commit"}, {"oid": "86b8a77baf338551ffbcb33c144b3f72835903b6", "url": "https://github.com/elastic/elasticsearch/commit/86b8a77baf338551ffbcb33c144b3f72835903b6", "message": "minor wording changes", "committedDate": "2020-04-19T22:56:42Z", "type": "commit"}, {"oid": "0918c9a25c136c0b4af6bf1bf8df277ef63e4d50", "url": "https://github.com/elastic/elasticsearch/commit/0918c9a25c136c0b4af6bf1bf8df277ef63e4d50", "message": "checkstyle", "committedDate": "2020-04-19T23:13:20Z", "type": "commit"}, {"oid": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "url": "https://github.com/elastic/elasticsearch/commit/6a25b26c569a3448a42634a6f281f9f45a6ae95a", "message": "add another ignore", "committedDate": "2020-04-19T23:19:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3NTA0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411475046", "bodyText": "oops... this isn't effective across multiple tasks.  Will remove this, or move out to the plugin.", "author": "jakelandis", "createdAt": "2020-04-20T15:32:05Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MjgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411582835", "bodyText": "Let's just ditch it. These tasks are already pretty quick and the risk of daemon memory leaks here are probably not worth the performance benefit. We can come back later and micro-optimize if we get some time.", "author": "mark-vieira", "createdAt": "2020-04-20T18:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3NTA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY0NzA3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411647075", "bodyText": "done e06e434", "author": "jakelandis", "createdAt": "2020-04-20T19:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3NTA0Ng=="}], "type": "inlineReview"}, {"oid": "e06e43456333730868a2a24a14c427d23796d054", "url": "https://github.com/elastic/elasticsearch/commit/e06e43456333730868a2a24a14c427d23796d054", "message": "remove unecessary 'cache'", "committedDate": "2020-04-20T19:48:16Z", "type": "commit"}, {"oid": "6090fbafe059f95885918d9d6705abe663623c31", "url": "https://github.com/elastic/elasticsearch/commit/6090fbafe059f95885918d9d6705abe663623c31", "message": "use default task instead of precommit task", "committedDate": "2020-04-20T19:54:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNzY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411617670", "bodyText": "Let's remove static here. I realize there's some overhead in allocating these but the potential for weird memory leaks in the daemon is probalby not worth it. The Gradle daemon is long-lived and also caches classloaders. Static references can cause weird issues with leaking classloaders which can cause daemons to eventually OOM.", "author": "mark-vieira", "createdAt": "2020-04-20T19:00:44Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMDY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411620686", "bodyText": "There's no concurrency that I can see here. We are simply validating each input file serially on the task execution thread. Also, we should probably use a map implementation that maintains insertion order like LinkedHashMap so that in cases with multiple errors the ordering makes sense (all errors for the same file in the same place in line order).", "author": "mark-vieira", "createdAt": "2020-04-20T19:05:54Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMTQ4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411621483", "bodyText": "Keep in mind here that fileChange could be a removed file. In which case we'd fail here as we'd try to validate a file that has been deleted. We should filter those out.", "author": "mark-vieira", "createdAt": "2020-04-20T19:07:14Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMzAyNA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411623024", "bodyText": "I think we might be able to simplify things by just making this a FileCollection instead of a FileTree. There's no reason to keep a tree structure here as ignores are done of a file name basis and file paths are completely irrelevant for the purposes of validation.\nThis considerably simplifies things like adding input files from completely disparate directories. You can do this with file trees but it ends up creating a UnionFileTree which can have some funky behavior.", "author": "mark-vieira", "createdAt": "2020-04-20T19:09:50Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyNDMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411624307", "bodyText": "There's no need to use String.format here as the Logger.error() method supports formatting strings using {} as a placeholder.", "author": "mark-vieira", "createdAt": "2020-04-20T19:12:04Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);\n+            Files.writeString(\n+                getErrorReport().toPath(),\n+                System.lineSeparator() + \"----------Validation Errors-----------\" + System.lineSeparator(),\n+                StandardOpenOption.APPEND\n+            );\n+            Files.write(\n+                getErrorReport().toPath(),\n+                errors.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n+                StandardOpenOption.APPEND\n+            );\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating JSON. See the report at: \");\n+            sb.append(getErrorReport().toURI().toASCIIString());\n+            sb.append(System.lineSeparator());\n+            sb.append(\n+                String.format(\"JSON validation failed: %d files contained %d violations\", errors.keySet().size(), errors.values().size())\n+            );\n+            throw new JsonSchemaException(sb.toString());\n+        }\n+    }\n+\n+    private void maybeLogAndCollectError(Set<ValidationMessage> messages, ConcurrentHashMap<File, Set<String>> errors, File file) {\n+        for (ValidationMessage message : messages) {\n+            String error = String.format(\"[validate JSON][ERROR][%s][%s]\", file.getName(), message.toString());", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyNTM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411625348", "bodyText": "Same as above, let's use a set implementation that maintains ordering so we don't potentially print an error for line 50 before one on line 30 in the report.", "author": "mark-vieira", "createdAt": "2020-04-20T19:13:45Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);\n+            Files.writeString(\n+                getErrorReport().toPath(),\n+                System.lineSeparator() + \"----------Validation Errors-----------\" + System.lineSeparator(),\n+                StandardOpenOption.APPEND\n+            );\n+            Files.write(\n+                getErrorReport().toPath(),\n+                errors.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n+                StandardOpenOption.APPEND\n+            );\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating JSON. See the report at: \");\n+            sb.append(getErrorReport().toURI().toASCIIString());\n+            sb.append(System.lineSeparator());\n+            sb.append(\n+                String.format(\"JSON validation failed: %d files contained %d violations\", errors.keySet().size(), errors.values().size())\n+            );\n+            throw new JsonSchemaException(sb.toString());\n+        }\n+    }\n+\n+    private void maybeLogAndCollectError(Set<ValidationMessage> messages, ConcurrentHashMap<File, Set<String>> errors, File file) {\n+        for (ValidationMessage message : messages) {\n+            String error = String.format(\"[validate JSON][ERROR][%s][%s]\", file.getName(), message.toString());\n+            getLogger().error(error);\n+            try {\n+                errors.computeIfAbsent(file, k -> new HashSet<>())", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyNjk4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411626985", "bodyText": "I feel like we should probably just create a single PrintWriter and do all this stuff in one go. Each call to Files.write* is going to have to open and then close a stream on that file. Let's just do this once.", "author": "mark-vieira", "createdAt": "2020-04-20T19:16:34Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyODQxNA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411628414", "bodyText": "Is it strictly necessary to resolve the canonical file path here? I mean, if folks are working in some kind linked workspace folder wouldn't it be friendlier to report that path instead of the resolved one?", "author": "mark-vieira", "createdAt": "2020-04-20T19:18:54Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends PrecommitTask {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+    // no need to rebuild the JsonSchema multiple times per build\n+    private static ConcurrentHashMap<File, JsonSchema> cache = new ConcurrentHashMap<>(1);\n+\n+    @Incremental\n+    @InputFiles\n+    public FileTree getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getSuccessMarker() {\n+        return new File(getProject().getBuildDir(), \"markers/\" + this.getName());\n+    }\n+\n+    @OutputFile\n+    public File getErrorReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        JsonSchema jsonSchema = cache.computeIfAbsent(getJsonSchema(), k -> {\n+            SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+            try {\n+                return factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        ConcurrentHashMap<File, Set<String>> errors = new ConcurrentHashMap<>();\n+        // incrementally evaluate input files\n+        inputChanges.getFileChanges(getInputFiles()).forEach(fileChange -> {\n+            File file = fileChange.getFile();\n+            if (ignore.contains(file.getName())) {\n+                getLogger().debug(\"Ignoring file [{}] due to configuration\", file.getName());\n+            } else if (file.isDirectory() == false) {\n+                // validate all files and hold on to errors for a complete report if there are failures\n+                getLogger().debug(\"Validating JSON [{}]\", file.getName());\n+                try {\n+                    Set<ValidationMessage> validationMessages = jsonSchema.validate(mapper.readTree(file));\n+                    maybeLogAndCollectError(validationMessages, errors, file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+\n+        if (errors.isEmpty()) {\n+            Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE);\n+        } else {\n+            // build output and throw exception\n+            Files.writeString(getErrorReport().toPath(), String.format(\"Schema: %s\", jsonSchemaOnDisk), StandardOpenOption.CREATE);\n+            Files.writeString(\n+                getErrorReport().toPath(),\n+                System.lineSeparator() + \"----------Validation Errors-----------\" + System.lineSeparator(),\n+                StandardOpenOption.APPEND\n+            );\n+            Files.write(\n+                getErrorReport().toPath(),\n+                errors.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n+                StandardOpenOption.APPEND\n+            );\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Error validating JSON. See the report at: \");\n+            sb.append(getErrorReport().toURI().toASCIIString());\n+            sb.append(System.lineSeparator());\n+            sb.append(\n+                String.format(\"JSON validation failed: %d files contained %d violations\", errors.keySet().size(), errors.values().size())\n+            );\n+            throw new JsonSchemaException(sb.toString());\n+        }\n+    }\n+\n+    private void maybeLogAndCollectError(Set<ValidationMessage> messages, ConcurrentHashMap<File, Set<String>> errors, File file) {\n+        for (ValidationMessage message : messages) {\n+            String error = String.format(\"[validate JSON][ERROR][%s][%s]\", file.getName(), message.toString());\n+            getLogger().error(error);\n+            try {\n+                errors.computeIfAbsent(file, k -> new HashSet<>())\n+                    .add(String.format(\"%s: %s\", file.getCanonicalFile(), message.toString()));", "originalCommit": "6a25b26c569a3448a42634a6f281f9f45a6ae95a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwNTYxMA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411705610", "bodyText": "i don't think it matters too much. are you advocating for absolute path, or relative path ?", "author": "jakelandis", "createdAt": "2020-04-20T21:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyODQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwODA3OA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411708078", "bodyText": "Absolute path, but we don't have to resolve the canonical path. It's costly, and requires catching an IOException vs just using the given absolute path.", "author": "mark-vieira", "createdAt": "2020-04-20T21:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyODQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzEzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411683137", "bodyText": "Firstly, project configuration is never done in parallel, so there's no need for the thread safety stuff here. Second, I think this is overly complex. Instead of all this nastiness to try and find the file, let's just go ahead and have the project configure its location. It's one file, and it's rarely if every going to move. Doing a bunch of work at configuraiton time to scan for this file seems unnecessary.", "author": "mark-vieira", "createdAt": "2020-04-20T20:50:56Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateRestSpecPlugin.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import org.elasticsearch.gradle.util.Util;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+\n+public class ValidateRestSpecPlugin implements Plugin<Project> {\n+    private static final String SCHEMA_PROJECT = \":rest-api-spec\";\n+    private static final String DOUBLE_STAR = \"**\"; // checkstyle thinks these are javadocs :(\n+    // no need to find this file multiple times\n+    private static volatile File jsonSchema;\n+\n+    @Override\n+    public void apply(Project project) {\n+        if (jsonSchema == null) {", "originalCommit": "6090fbafe059f95885918d9d6705abe663623c31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzUxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411727519", "bodyText": "I moved the work into the task configuration ... is that what you meant ? e9dd891\n(I think this is still configuration time work... but since it is a registered task, won't do any work unless needed ?)", "author": "jakelandis", "createdAt": "2020-04-20T22:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyOTkwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411729900", "bodyText": "Not exactly, although this is better since we now defer the work unless the task is actually executed. I mean we should remove this \"search\" altogether and just do something along the lines of validateJson.jsonSchema = file('rest-api-spec/src/main/resources/schema.json') in the project build script or even hard-code in the plugin for now (since it's already tightly coupled to our project).\nMy reasoning being, there is exactly one file, we always know where it'll be and it rarely moves. Why all the work to dynamically locate it?", "author": "mark-vieira", "createdAt": "2020-04-20T22:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczNjIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411736230", "bodyText": "OK .. i understand now. I hard coded it in the plugin. 1768c6d", "author": "jakelandis", "createdAt": "2020-04-20T22:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzEzNw=="}], "type": "inlineReview"}, {"oid": "e9dd8917d69a7e041f580ceff86f17d3c040e9b6", "url": "https://github.com/elastic/elasticsearch/commit/e9dd8917d69a7e041f580ceff86f17d3c040e9b6", "message": "review updates", "committedDate": "2020-04-20T22:10:36Z", "type": "commit"}, {"oid": "323e4d047e239757254c0cfb2403a1e4f3760ce4", "url": "https://github.com/elastic/elasticsearch/commit/323e4d047e239757254c0cfb2403a1e4f3760ce4", "message": "remove unnecessary FileWriter", "committedDate": "2020-04-20T22:25:03Z", "type": "commit"}, {"oid": "1768c6d21bd38ec6d3064b5d33ed69937c97fde2", "url": "https://github.com/elastic/elasticsearch/commit/1768c6d21bd38ec6d3064b5d33ed69937c97fde2", "message": "hard code schema location", "committedDate": "2020-04-20T22:31:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411738566", "bodyText": "nit: I think just writing this as f.getChangeType() != ChangeType.REMOVED is simpler yes? Does our stance on using == false in the codebase mean avoid != as well in cases where using .equals() is unnecessary?", "author": "mark-vieira", "createdAt": "2020-04-20T22:38:33Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.ChangeType;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends DefaultTask {\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+\n+    @Incremental\n+    @InputFiles\n+    public FileCollection getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {\n+        this.inputFiles = inputFiles;\n+    }\n+\n+    @InputFile\n+    public File getJsonSchema() {\n+        return jsonSchema;\n+    }\n+\n+    public void setJsonSchema(File jsonSchema) {\n+        this.jsonSchema = jsonSchema;\n+    }\n+\n+    @Input\n+    @Optional\n+    public Set<String> getIgnore() {\n+        return ignore;\n+    }\n+\n+    public void ignore(String... ignore) {\n+        this.ignore.addAll(Arrays.asList(ignore));\n+    }\n+\n+    @OutputFile\n+    public File getReport() {\n+        return new File(getProject().getBuildDir(), \"reports/validateJson.txt\");\n+    }\n+\n+    @TaskAction\n+    public void validate(InputChanges inputChanges) throws IOException {\n+        File jsonSchemaOnDisk = getJsonSchema();\n+        getLogger().debug(\"JSON schema : [{}]\", jsonSchemaOnDisk.getAbsolutePath());\n+        SchemaValidatorsConfig config = new SchemaValidatorsConfig();\n+        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);\n+        JsonSchema jsonSchema = factory.getSchema(mapper.readTree(jsonSchemaOnDisk), config);\n+        Map<File, Set<String>> errors = new LinkedHashMap<>();\n+        // incrementally evaluate input files\n+        StreamSupport.stream(inputChanges.getFileChanges(getInputFiles()).spliterator(), false)\n+            .filter(f -> ChangeType.REMOVED.equals(f.getChangeType()) == false)", "originalCommit": "1768c6d21bd38ec6d3064b5d33ed69937c97fde2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NDczOA==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411744738", "bodyText": "not sure ... i think i am just used to == false now :)  ... changed it to !=", "author": "jakelandis", "createdAt": "2020-04-20T22:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczOTM4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55117#discussion_r411739383", "bodyText": "Setter should be FileCollection as well. Also the field should be updated.", "author": "mark-vieira", "createdAt": "2020-04-20T22:40:19Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ValidateJsonAgainstSchemaTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.precommit;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.networknt.schema.JsonSchema;\n+import com.networknt.schema.JsonSchemaException;\n+import com.networknt.schema.JsonSchemaFactory;\n+import com.networknt.schema.SchemaValidatorsConfig;\n+import com.networknt.schema.SpecVersion;\n+import com.networknt.schema.ValidationMessage;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.UncheckedIOException;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputFile;\n+import org.gradle.api.tasks.InputFiles;\n+import org.gradle.api.tasks.Optional;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.work.ChangeType;\n+import org.gradle.work.Incremental;\n+import org.gradle.work.InputChanges;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Incremental task to validate a set of JSON files against against a schema.\n+ */\n+public class ValidateJsonAgainstSchemaTask extends DefaultTask {\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    private Set<String> ignore = new HashSet<>();\n+    private File jsonSchema;\n+    private FileTree inputFiles;\n+\n+    @Incremental\n+    @InputFiles\n+    public FileCollection getInputFiles() {\n+        return inputFiles;\n+    }\n+\n+    public void setInputFiles(FileTree inputFiles) {", "originalCommit": "1768c6d21bd38ec6d3064b5d33ed69937c97fde2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b11efbd2b5decf6c8dd5e7548e9664b8ca9e981e", "url": "https://github.com/elastic/elasticsearch/commit/b11efbd2b5decf6c8dd5e7548e9664b8ca9e981e", "message": "review changes", "committedDate": "2020-04-20T22:51:35Z", "type": "commit"}, {"oid": "143119134cb101dceed443494d1cc953339715aa", "url": "https://github.com/elastic/elasticsearch/commit/143119134cb101dceed443494d1cc953339715aa", "message": "Merge branch 'master' into validate_rest_spec", "committedDate": "2020-04-21T20:12:18Z", "type": "commit"}]}