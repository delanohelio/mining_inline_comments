{"pr_number": 65604, "pr_title": "Add infrastructure for managing system indices", "pr_createdAt": "2020-11-30T13:42:11Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65604", "timeline": [{"oid": "d7b728c38bc1ff46c6fa5f18779c84a8b3d87817", "url": "https://github.com/elastic/elasticsearch/commit/d7b728c38bc1ff46c6fa5f18779c84a8b3d87817", "message": "Add infrastructure for managing system indices\n\nPart of #61656.\n\nAdd the necessary support for automatically creating and updating system\nindices. This works by making it possible to create a system index\ndescriptor with all the information needed to manage the mappings,\nsettings and aliases.\n\nFollow-up work will opt existing indices into this framework.", "committedDate": "2020-11-30T12:27:38Z", "type": "commit"}, {"oid": "f6382f4d38e40277374e549f48177a22ca4bd18a", "url": "https://github.com/elastic/elasticsearch/commit/f6382f4d38e40277374e549f48177a22ca4bd18a", "message": "Checkstyle", "committedDate": "2020-11-30T14:03:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMzMxMA==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r532833310", "bodyText": "Can we simplify this method a bit? We don't really share logic between non-system index creation and system index creation as far as I can see so I think we can test for the non system case and simply return the update request there?", "author": "jaymode", "createdAt": "2020-11-30T19:08:54Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/create/AutoCreateAction.java", "diffHunk": "@@ -141,12 +152,56 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             return currentState;\n                         }\n \n-                        CreateIndexClusterStateUpdateRequest updateRequest =\n-                            new CreateIndexClusterStateUpdateRequest(request.cause(), indexName, request.index())\n-                                .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout());\n+                        CreateIndexClusterStateUpdateRequest updateRequest = buildUpdateRequest(indexName);\n+\n                         return createIndexService.applyCreateIndexRequest(currentState, updateRequest, false);\n                     }\n                 }\n+\n+                private CreateIndexClusterStateUpdateRequest buildUpdateRequest(String indexName) {\n+                    boolean isSystemIndex = false;\n+                    String mappings = null;\n+                    Settings settings = null;\n+                    String aliasName = null;\n+                    String concreteIndexName = indexName;\n+\n+                    final SystemIndexDescriptor descriptor = systemIndices.findMatchingDescriptor(indexName);\n+\n+                    if (descriptor != null && descriptor.isAutomaticallyManaged()) {", "originalCommit": "f6382f4d38e40277374e549f48177a22ca4bd18a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r532834831", "bodyText": "Similar to the comment in AutoCreateAction, can we break up the system and non-system case since we don't really need to share anything between the two cases?", "author": "jaymode", "createdAt": "2020-11-30T19:11:27Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java", "diffHunk": "@@ -63,13 +73,48 @@ protected void masterOperation(Task task, final CreateIndexRequest request, fina\n         }\n \n         final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index());\n+\n+        String mappings = request.mappings();\n+        Settings settings = request.settings();\n+        Set<Alias> aliases = request.aliases();\n+\n+        String concreteIndexName = indexName;\n+        boolean isSystemIndex = false;\n+\n+        SystemIndexDescriptor descriptor = systemIndices.findMatchingDescriptor(indexName);\n+\n+        if (descriptor != null && descriptor.isAutomaticallyManaged()) {\n+            isSystemIndex = true;\n+            // System indices define their own settings and mappings, which cannot be overridden.\n+            mappings = descriptor.getMappings();\n+            settings = descriptor.getSettings();\n+            concreteIndexName = descriptor.getPrimaryIndex();\n+\n+            if (descriptor.getAliasName() == null) {\n+                aliases = Set.of();\n+            } else {\n+                aliases = Set.of(new Alias(descriptor.getAliasName()));\n+            }\n+        }\n+\n         final CreateIndexClusterStateUpdateRequest updateRequest =\n-            new CreateIndexClusterStateUpdateRequest(cause, indexName, request.index())\n+            new CreateIndexClusterStateUpdateRequest(cause, concreteIndexName, request.index())\n                 .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout())\n-                .settings(request.settings()).mappings(request.mappings())\n-                .aliases(request.aliases())\n+                .aliases(aliases)\n                 .waitForActiveShards(request.waitForActiveShards());\n \n+        if (isSystemIndex) {", "originalCommit": "f6382f4d38e40277374e549f48177a22ca4bd18a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1OTEzNw==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r532859137", "bodyText": "I think we need to make an effort to wait for any pending updates to finish prior to launching more by tracking them between cluster state updates. We've had issues in the past where we overloaded master nodes with too many requests due to a pattern like this.", "author": "jaymode", "createdAt": "2020-11-30T19:49:54Z", "path": "server/src/main/java/org/elasticsearch/indices/SystemIndexManager.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.health.ClusterIndexHealth;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.gateway.GatewayService;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_FORMAT_SETTING;\n+\n+/**\n+ * This class ensures that all system indices have up-to-date mappings, provided\n+ * those indices can be automatically managed. Only some system indices are managed\n+ * internally to Elasticsearch - others are created and managed externally, e.g.\n+ * Kibana indices.\n+ */\n+public class SystemIndexManager implements ClusterStateListener {\n+    private static final Logger logger = LogManager.getLogger(SystemIndexManager.class);\n+\n+    private final SystemIndices systemIndices;\n+    private final Client client;\n+\n+    public SystemIndexManager(SystemIndices systemIndices, Client client) {\n+        this.systemIndices = systemIndices;\n+        this.client = client;\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        final ClusterState state = event.state();\n+        if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {\n+            // wait until the gateway has recovered from disk, otherwise we may think we don't have some\n+            // indices but they may not have been restored from the cluster state on disk\n+            logger.debug(\"system indices manager waiting until state has been recovered\");\n+            return;\n+        }\n+\n+        // If this node is not a master node, exit.\n+        if (state.nodes().isLocalNodeElectedMaster() == false) {\n+            return;\n+        }\n+\n+        getEligibleDescriptors(state.getMetadata()).stream()", "originalCommit": "f6382f4d38e40277374e549f48177a22ca4bd18a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ac8888bd1bc0fc212aecee301a1c885bfe833174", "url": "https://github.com/elastic/elasticsearch/commit/ac8888bd1bc0fc212aecee301a1c885bfe833174", "message": "Address review feedback\n\n- Separate logic for building create index requests into sytem-index and\n  non-system-index versions\n- Use an AtomicBoolean to prevent updates to system index mappings\n  overloading the master", "committedDate": "2020-12-01T13:33:24Z", "type": "commit"}, {"oid": "3fb68a4135294d0224186651f8ee073a0a85d301", "url": "https://github.com/elastic/elasticsearch/commit/3fb68a4135294d0224186651f8ee073a0a85d301", "message": "Merge remote-tracking branch 'upstream/master' into 61656-auto-create-system-indices-infra", "committedDate": "2020-12-01T13:35:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5NjE0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534296146", "bodyText": "I think we should make this a debug log like the regular message", "author": "jaymode", "createdAt": "2020-12-02T16:16:49Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/create/AutoCreateAction.java", "diffHunk": "@@ -141,12 +152,51 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             return currentState;\n                         }\n \n-                        CreateIndexClusterStateUpdateRequest updateRequest =\n-                            new CreateIndexClusterStateUpdateRequest(request.cause(), indexName, request.index())\n-                                .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout());\n+                        final SystemIndexDescriptor descriptor = systemIndices.findMatchingDescriptor(indexName);\n+                        CreateIndexClusterStateUpdateRequest updateRequest = descriptor != null && descriptor.isAutomaticallyManaged()\n+                            ? buildSystemIndexUpdateRequest(descriptor)\n+                            : buildUpdateRequest(indexName);\n+\n                         return createIndexService.applyCreateIndexRequest(currentState, updateRequest, false);\n                     }\n                 }\n+\n+                private CreateIndexClusterStateUpdateRequest buildUpdateRequest(String indexName) {\n+                    CreateIndexClusterStateUpdateRequest updateRequest =\n+                        new CreateIndexClusterStateUpdateRequest(request.cause(), indexName, request.index())\n+                            .ackTimeout(request.timeout())\n+                            .masterNodeTimeout(request.masterNodeTimeout());\n+                    logger.debug(\"Auto-creating index {}\", indexName);\n+                    return updateRequest;\n+                }\n+\n+                private CreateIndexClusterStateUpdateRequest buildSystemIndexUpdateRequest(SystemIndexDescriptor descriptor) {\n+                    String mappings = descriptor.getMappings();\n+                    Settings settings = descriptor.getSettings();\n+                    String aliasName = descriptor.getAliasName();\n+                    String concreteIndexName = descriptor.getPrimaryIndex();\n+\n+                    CreateIndexClusterStateUpdateRequest updateRequest =\n+                        new CreateIndexClusterStateUpdateRequest(request.cause(), concreteIndexName, request.index())\n+                            .ackTimeout(request.timeout())\n+                            .masterNodeTimeout(request.masterNodeTimeout());\n+\n+                    updateRequest.waitForActiveShards(ActiveShardCount.ALL);\n+\n+                    if (mappings != null) {\n+                        updateRequest.mappings(mappings);\n+                    }\n+                    if (settings != null) {\n+                        updateRequest.settings(settings);\n+                    }\n+                    if (aliasName != null) {\n+                        updateRequest.aliases(Set.of(new Alias(aliasName)));\n+                    }\n+\n+                    logger.info(\"Auto-creating system index {}\", concreteIndexName);", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5OTgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534299834", "bodyText": "On backport, we will need to make this a deprecation warning", "author": "jaymode", "createdAt": "2020-12-02T16:21:32Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/settings/put/TransportUpdateSettingsAction.java", "diffHunk": "@@ -75,9 +87,24 @@ protected ClusterBlockException checkBlock(UpdateSettingsRequest request, Cluste\n     protected void masterOperation(Task task, final UpdateSettingsRequest request, final ClusterState state,\n                                    final ActionListener<AcknowledgedResponse> listener) {\n         final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);\n+        final Settings requestSettings = request.settings();\n+\n+\n+        final Map<String, List<String>> systemIndexViolations = checkForSystemIndexViolations(concreteIndices, requestSettings);\n+        if (systemIndexViolations.isEmpty() == false) {\n+            final String message = \"Cannot override settings on system indices: \"\n+                + systemIndexViolations.entrySet()\n+                    .stream()\n+                    .map(entry -> \"[\" + entry.getKey() + \"] -> \" + entry.getValue())\n+                    .collect(Collectors.joining(\", \"));\n+            logger.warn(message);", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4ODMwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534488306", "bodyText": "Can I clarify - in the backport, should this raise a deprecation warning but not fail the request?", "author": "pugnascotia", "createdAt": "2020-12-02T21:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5OTgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMjMzOA==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534502338", "bodyText": "Correct on backport this should result in a deprecation warning and still allow the request to go through.", "author": "jaymode", "createdAt": "2020-12-02T21:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5OTgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMDA2MA==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534300060", "bodyText": "On backport, we will need to make this a deprecation warning", "author": "jaymode", "createdAt": "2020-12-02T16:21:48Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java", "diffHunk": "@@ -87,12 +92,25 @@ protected void masterOperation(Task task, final PutMappingRequest request, final\n                                    final ActionListener<AcknowledgedResponse> listener) {\n         try {\n             final Index[] concreteIndices = resolveIndices(state, request, indexNameExpressionResolver);\n+            final String mappingSource = request.source();\n \n             final Optional<Exception> maybeValidationException = requestValidators.validateRequest(request, state, concreteIndices);\n             if (maybeValidationException.isPresent()) {\n                 listener.onFailure(maybeValidationException.get());\n                 return;\n             }\n+\n+            final List<String> violations = checkForSystemIndexViolations(concreteIndices, mappingSource);\n+            if (violations.isEmpty() == false) {\n+                final String message = \"Cannot update mappings in \"\n+                    + violations\n+                    + \": system indices can only use mappings from their descriptors, \"\n+                    + \"but the mappings in the request did not match those in the descriptors(s)\";\n+                logger.warn(message);", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMDc0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534300742", "bodyText": "Can you add a javadocs for this method to indicate what it does and what is thrown?", "author": "jaymode", "createdAt": "2020-12-02T16:22:41Z", "path": "server/src/main/java/org/elasticsearch/common/Strings.java", "diffHunk": "@@ -874,6 +874,13 @@ public static String cleanTruncate(String s, int length) {\n         return s.substring(0, length);\n     }\n \n+    public static String requireNonEmpty(String str, String message) {", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzI3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534303276", "bodyText": "How about adding a private constructor so that all creations are from SystemIndexDescriptor.builder()?", "author": "jaymode", "createdAt": "2020-12-02T16:25:49Z", "path": "server/src/main/java/org/elasticsearch/indices/SystemIndexDescriptor.java", "diffHunk": "@@ -81,10 +191,160 @@ public String getDescription() {\n \n     @Override\n     public String toString() {\n-        return \"SystemIndexDescriptor[pattern=[\" + indexPattern + \"], description=[\" + description + \"]]\";\n+        return \"SystemIndexDescriptor[pattern=[\" + indexPattern + \"], description=[\" + description + \"], aliasName=[\" + aliasName + \"]]\";\n+    }\n+\n+    public String getMappings() {\n+        return mappings;\n+    }\n+\n+    public Settings getSettings() {\n+        return settings;\n+    }\n+\n+    public String getAliasName() {\n+        return aliasName;\n+    }\n+\n+    public int getIndexFormat() {\n+        return this.indexFormat;\n+    }\n+\n+    public String getVersionMetaKey() {\n+        return this.versionMetaKey;\n+    }\n+\n+    public boolean isAutomaticallyManaged() {\n+        return this.mappings != null || this.settings != null;\n+    }\n+\n+    public String getOrigin() {\n+        return this.origin;\n     }\n \n-    // TODO: Index settings and mapping\n     // TODO: getThreadpool()\n     // TODO: Upgrade handling (reindex script?)\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private String indexPattern;\n+        private String primaryIndex;\n+        private String description;\n+        private XContentBuilder mappingsBuilder = null;\n+        private Settings settings = null;\n+        private String aliasName = null;\n+        private int indexFormat = 0;\n+        private String versionMetaKey = null;\n+        private String origin = null;\n+", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwNDgwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534304802", "bodyText": "Can all validation be moved into the constructor?", "author": "jaymode", "createdAt": "2020-12-02T16:27:43Z", "path": "server/src/main/java/org/elasticsearch/indices/SystemIndexDescriptor.java", "diffHunk": "@@ -81,10 +191,160 @@ public String getDescription() {\n \n     @Override\n     public String toString() {\n-        return \"SystemIndexDescriptor[pattern=[\" + indexPattern + \"], description=[\" + description + \"]]\";\n+        return \"SystemIndexDescriptor[pattern=[\" + indexPattern + \"], description=[\" + description + \"], aliasName=[\" + aliasName + \"]]\";\n+    }\n+\n+    public String getMappings() {\n+        return mappings;\n+    }\n+\n+    public Settings getSettings() {\n+        return settings;\n+    }\n+\n+    public String getAliasName() {\n+        return aliasName;\n+    }\n+\n+    public int getIndexFormat() {\n+        return this.indexFormat;\n+    }\n+\n+    public String getVersionMetaKey() {\n+        return this.versionMetaKey;\n+    }\n+\n+    public boolean isAutomaticallyManaged() {\n+        return this.mappings != null || this.settings != null;\n+    }\n+\n+    public String getOrigin() {\n+        return this.origin;\n     }\n \n-    // TODO: Index settings and mapping\n     // TODO: getThreadpool()\n     // TODO: Upgrade handling (reindex script?)\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private String indexPattern;\n+        private String primaryIndex;\n+        private String description;\n+        private XContentBuilder mappingsBuilder = null;\n+        private Settings settings = null;\n+        private String aliasName = null;\n+        private int indexFormat = 0;\n+        private String versionMetaKey = null;\n+        private String origin = null;\n+\n+        public Builder setIndexPattern(String indexPattern) {\n+            this.indexPattern = indexPattern;\n+            return this;\n+        }\n+\n+        public Builder setPrimaryIndex(String primaryIndex) {\n+            this.primaryIndex = primaryIndex;\n+            return this;\n+        }\n+\n+        public Builder setDescription(String description) {\n+            this.description = description;\n+            return this;\n+        }\n+\n+        public Builder setMappings(XContentBuilder mappingsBuilder) {\n+            this.mappingsBuilder = mappingsBuilder;\n+            return this;\n+        }\n+\n+        public Builder setSettings(Settings settings) {\n+            this.settings = settings;\n+            return this;\n+        }\n+\n+        public Builder setAliasName(String aliasName) {\n+            this.aliasName = aliasName;\n+            return this;\n+        }\n+\n+        public Builder setIndexFormat(int indexFormat) {\n+            if (indexFormat < 0) {\n+                throw new IllegalArgumentException(\"indexFormat must be >= 0\");\n+            }\n+            this.indexFormat = indexFormat;\n+            return this;\n+        }\n+\n+        public Builder setVersionMetaKey(String versionMetaKey) {\n+            this.versionMetaKey = versionMetaKey;\n+            return this;\n+        }\n+\n+        public Builder setOrigin(String origin) {\n+            this.origin = origin;\n+            return this;\n+        }\n+\n+        public SystemIndexDescriptor build() {\n+            String mappings = mappingsBuilder == null ? null : Strings.toString(mappingsBuilder);\n+\n+            Strings.requireNonEmpty(indexPattern, \"indexPattern must be supplied\");", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMxMDQ4OA==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534310488", "bodyText": "Let's avoid extra work here by guarding this with a if (upgradeInProgress.get() == false) check", "author": "jaymode", "createdAt": "2020-12-02T16:34:49Z", "path": "server/src/main/java/org/elasticsearch/indices/SystemIndexManager.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.health.ClusterIndexHealth;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.gateway.GatewayService;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_FORMAT_SETTING;\n+\n+/**\n+ * This class ensures that all system indices have up-to-date mappings, provided\n+ * those indices can be automatically managed. Only some system indices are managed\n+ * internally to Elasticsearch - others are created and managed externally, e.g.\n+ * Kibana indices.\n+ */\n+public class SystemIndexManager implements ClusterStateListener {\n+    private static final Logger logger = LogManager.getLogger(SystemIndexManager.class);\n+\n+    private final SystemIndices systemIndices;\n+    private final Client client;\n+    private final AtomicBoolean isUpgradeInProgress;\n+\n+    public SystemIndexManager(SystemIndices systemIndices, Client client) {\n+        this.systemIndices = systemIndices;\n+        this.client = client;\n+        this.isUpgradeInProgress = new AtomicBoolean(false);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        final ClusterState state = event.state();\n+        if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {\n+            // wait until the gateway has recovered from disk, otherwise we may think we don't have some\n+            // indices but they may not have been restored from the cluster state on disk\n+            logger.debug(\"system indices manager waiting until state has been recovered\");\n+            return;\n+        }\n+\n+        // If this node is not a master node, exit.\n+        if (state.nodes().isLocalNodeElectedMaster() == false) {\n+            return;\n+        }\n+", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMxMjYzOA==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534312638", "bodyText": "this sets to false early. There can still be in flight items and isUpgradeInProgress would be incorrect. You may want to use something like a GroupedActionListener", "author": "jaymode", "createdAt": "2020-12-02T16:37:42Z", "path": "server/src/main/java/org/elasticsearch/indices/SystemIndexManager.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.health.ClusterIndexHealth;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.gateway.GatewayService;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_FORMAT_SETTING;\n+\n+/**\n+ * This class ensures that all system indices have up-to-date mappings, provided\n+ * those indices can be automatically managed. Only some system indices are managed\n+ * internally to Elasticsearch - others are created and managed externally, e.g.\n+ * Kibana indices.\n+ */\n+public class SystemIndexManager implements ClusterStateListener {\n+    private static final Logger logger = LogManager.getLogger(SystemIndexManager.class);\n+\n+    private final SystemIndices systemIndices;\n+    private final Client client;\n+    private final AtomicBoolean isUpgradeInProgress;\n+\n+    public SystemIndexManager(SystemIndices systemIndices, Client client) {\n+        this.systemIndices = systemIndices;\n+        this.client = client;\n+        this.isUpgradeInProgress = new AtomicBoolean(false);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        final ClusterState state = event.state();\n+        if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {\n+            // wait until the gateway has recovered from disk, otherwise we may think we don't have some\n+            // indices but they may not have been restored from the cluster state on disk\n+            logger.debug(\"system indices manager waiting until state has been recovered\");\n+            return;\n+        }\n+\n+        // If this node is not a master node, exit.\n+        if (state.nodes().isLocalNodeElectedMaster() == false) {\n+            return;\n+        }\n+\n+        getEligibleDescriptors(state.getMetadata()).stream()\n+            .filter(descriptor -> getUpgradeStatus(state, descriptor) == UpgradeStatus.NEEDS_MAPPINGS_UPDATE)\n+            .forEach(this::upgradeIndexMetadata);\n+    }\n+\n+    /**\n+     * Checks all known system index descriptors, looking for those that correspond to\n+     * indices that can be automatically managed and that have already been created.\n+     * @param metadata the cluster state metadata to consult\n+     * @return a list of descriptors that could potentially be updated\n+     */\n+    List<SystemIndexDescriptor> getEligibleDescriptors(Metadata metadata) {\n+        return this.systemIndices.getSystemIndexDescriptors()\n+            .stream()\n+            .filter(SystemIndexDescriptor::isAutomaticallyManaged)\n+            .filter(d -> metadata.hasConcreteIndex(d.getPrimaryIndex()))\n+            .collect(Collectors.toList());\n+    }\n+\n+    enum UpgradeStatus {\n+        CLOSED,\n+        UNHEALTHY,\n+        NEEDS_UPGRADE,\n+        UP_TO_DATE,\n+        NEEDS_MAPPINGS_UPDATE\n+    }\n+\n+    /**\n+     * Determines an index's current state, with respect to whether its mappings can\n+     * be updated.\n+     *\n+     * @param clusterState the cluster state to use when calculating the upgrade state\n+     * @param descriptor information about the system index to check\n+     * @return a value that indicates the index's state.\n+     */\n+    UpgradeStatus getUpgradeStatus(ClusterState clusterState, SystemIndexDescriptor descriptor) {\n+        final State indexState = calculateIndexState(clusterState, descriptor);\n+\n+        final String indexDescription = \"Index [\" + descriptor.getPrimaryIndex() + \"] (alias [\" + descriptor.getAliasName() + \"])\";\n+\n+        // The messages below will be logged on every cluster state update, which is why even in the index closed / red\n+        // cases, the log levels are DEBUG.\n+\n+        if (indexState.indexState == IndexMetadata.State.CLOSE) {\n+            logger.debug(\n+                \"Index {} is closed. This is likely to prevent some features from functioning correctly\", indexDescription);\n+            return UpgradeStatus.CLOSED;\n+        }\n+\n+        if (indexState.indexHealth == ClusterHealthStatus.RED) {\n+            logger.debug(\"Index {} health status is RED, any pending mapping upgrades will wait until this changes\", indexDescription);\n+            return UpgradeStatus.UNHEALTHY;\n+        }\n+\n+        if (indexState.isIndexUpToDate == false) {\n+            logger.debug(\n+                \"Index {} is not on the current version. Features relying \"\n+                    + \"on the index will not be available until the index is upgraded\",\n+                indexDescription\n+            );\n+            return UpgradeStatus.NEEDS_UPGRADE;\n+        } else if (indexState.mappingUpToDate) {\n+            logger.trace(\"Index {} is up-to-date, no action required\", indexDescription);\n+            return UpgradeStatus.UP_TO_DATE;\n+        } else {\n+            logger.info(\"Index {} mappings are not up-to-date and will be updated\", indexDescription);\n+            return UpgradeStatus.NEEDS_MAPPINGS_UPDATE;\n+        }\n+    }\n+\n+    /**\n+     * Updates the mappings for a system index\n+     * @param descriptor information about the system index\n+     */\n+    private void upgradeIndexMetadata(SystemIndexDescriptor descriptor) {\n+        if (isUpgradeInProgress.compareAndSet(false, true) == false) {\n+            return;\n+        }\n+\n+        final String indexName = descriptor.getPrimaryIndex();\n+\n+        PutMappingRequest request = new PutMappingRequest(indexName).source(descriptor.getMappings(), XContentType.JSON);\n+\n+        final OriginSettingClient originSettingClient = new OriginSettingClient(this.client, descriptor.getOrigin());\n+\n+        originSettingClient.admin().indices().putMapping(request, new ActionListener<>() {\n+            @Override\n+            public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n+                isUpgradeInProgress.set(false);", "originalCommit": "3fb68a4135294d0224186651f8ee073a0a85d301", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NjU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534496581", "bodyText": "I'm not sure I follow. The upgradeIndexMetadata method is called once for each index that needs upgraded, and the first thing the method does is attempt to set isUpgradeInProgress to true. So only one index will be upgraded, and the rest need to wait until isUpgradeInProgress becomes false again. I wrote it that way so as to be cautious about adding load to the master.\nWere you thinking that we'd dispatch all the mapping updates in one go, and use a GroupedActionListener to release the isUpgradeInProgress once they'd all finished?", "author": "pugnascotia", "createdAt": "2020-12-02T21:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMxMjYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTE2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r534505166", "bodyText": "I'm not sure I follow.\n\nThat's because I did not follow the code properly. I think it would be best to fire off all of the upgrades at once rather than sequentially since IIRC the code is computing everything that needs upgraded each time.\n\nWere you thinking that we'd dispatch all the mapping updates in one go, and use a GroupedActionListener to release the isUpgradeInProgress once they'd all finished?\n\nYes that is what I was thinking. I wanted to avoid resending each one every time there was a cluster state update if other cluster state updates happened prior to the mapping updates that we had previously sent.", "author": "jaymode", "createdAt": "2020-12-02T21:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMxMjYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI1NTg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r535255880", "bodyText": "I've reworked the locking and upgrading to use a GroupedActionListener.", "author": "pugnascotia", "createdAt": "2020-12-03T14:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMxMjYzOA=="}], "type": "inlineReview"}, {"oid": "fc1e95845249f4d323050dc1ca5c89ebceadae6e", "url": "https://github.com/elastic/elasticsearch/commit/fc1e95845249f4d323050dc1ca5c89ebceadae6e", "message": "Merge remote-tracking branch 'upstream/master' into 61656-auto-create-system-indices-infra", "committedDate": "2020-12-02T21:16:57Z", "type": "commit"}, {"oid": "8adb25b91d071a98d172951d4086ae879d170ddb", "url": "https://github.com/elastic/elasticsearch/commit/8adb25b91d071a98d172951d4086ae879d170ddb", "message": "Review feedback", "committedDate": "2020-12-02T21:43:18Z", "type": "commit"}, {"oid": "37bfbeed5100f0712a8d6488d5c96dd7463d2701", "url": "https://github.com/elastic/elasticsearch/commit/37bfbeed5100f0712a8d6488d5c96dd7463d2701", "message": "Apply all mappings updates at once\n\nRun all upgrades at once, and use a GroupedActionListener to release the\nlock once all have completed.", "committedDate": "2020-12-03T14:06:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNDU3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r535324573", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        } else {\n          \n          \n            \n                            isUpgradeInProgress.set(false);\n          \n          \n            \n                        }", "author": "jaymode", "createdAt": "2020-12-03T15:20:59Z", "path": "server/src/main/java/org/elasticsearch/indices/SystemIndexManager.java", "diffHunk": "@@ -83,9 +84,22 @@ public void clusterChanged(ClusterChangedEvent event) {\n             return;\n         }\n \n-        getEligibleDescriptors(state.getMetadata()).stream()\n-            .filter(descriptor -> getUpgradeStatus(state, descriptor) == UpgradeStatus.NEEDS_MAPPINGS_UPDATE)\n-            .forEach(this::upgradeIndexMetadata);\n+        if (isUpgradeInProgress.compareAndSet(false, true)) {\n+            final List<SystemIndexDescriptor> descriptors = getEligibleDescriptors(state.getMetadata()).stream()\n+                .filter(descriptor -> getUpgradeStatus(state, descriptor) == UpgradeStatus.NEEDS_MAPPINGS_UPDATE)\n+                .collect(Collectors.toList());\n+\n+            if (descriptors.isEmpty() == false) {\n+                // Use a GroupedActionListener so that we only release the lock once all upgrade attempts have succeeded or failed.\n+                // The failures are logged in upgradeIndexMetadata(), so we don't actually care about them here.\n+                ActionListener<AcknowledgedResponse> listener = new GroupedActionListener<>(\n+                    ActionListener.wrap(() -> isUpgradeInProgress.set(false)),\n+                    descriptors.size()\n+                );\n+\n+                descriptors.forEach(descriptor -> upgradeIndexMetadata(descriptor, listener));\n+            }", "originalCommit": "37bfbeed5100f0712a8d6488d5c96dd7463d2701", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MTk4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65604#discussion_r535341981", "bodyText": "Good catch! \ud83d\ude05", "author": "pugnascotia", "createdAt": "2020-12-03T15:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNDU3Mw=="}], "type": "inlineReview"}, {"oid": "751a895dc4d969d95fe58b7e3391ff0e24d07f17", "url": "https://github.com/elastic/elasticsearch/commit/751a895dc4d969d95fe58b7e3391ff0e24d07f17", "message": "Merge remote-tracking branch 'upstream/master' into 61656-auto-create-system-indices-infra", "committedDate": "2020-12-03T15:35:48Z", "type": "commit"}, {"oid": "77d31632efbfd22d7b2319d8bb725d2a2b7be2c6", "url": "https://github.com/elastic/elasticsearch/commit/77d31632efbfd22d7b2319d8bb725d2a2b7be2c6", "message": "Remember to release the lock", "committedDate": "2020-12-03T15:37:06Z", "type": "commit"}]}