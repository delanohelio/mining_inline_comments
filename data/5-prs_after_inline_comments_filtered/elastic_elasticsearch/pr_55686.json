{"pr_number": 55686, "pr_title": "Add simulate template composition API _index_template/_simulate_index/{name} ", "pr_createdAt": "2020-04-23T17:09:35Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55686", "timeline": [{"oid": "2be7e19cae6da0e922782917509f8b1a4091347b", "url": "https://github.com/elastic/elasticsearch/commit/2be7e19cae6da0e922782917509f8b1a4091347b", "message": "Add _index_template/_simulate_index/{name} api\n\nThis adds a new api to simulate matching the given index name against the\n index templates in the system.", "committedDate": "2020-04-23T17:08:36Z", "type": "commit"}, {"oid": "17a912ec388360b6fc2592fa98c1c74fb3307504", "url": "https://github.com/elastic/elasticsearch/commit/17a912ec388360b6fc2592fa98c1c74fb3307504", "message": "Remove unused logger", "committedDate": "2020-04-24T10:03:50Z", "type": "commit"}, {"oid": "3025a516aa949c7ed3d033e5c6a448cc48ee7ef5", "url": "https://github.com/elastic/elasticsearch/commit/3025a516aa949c7ed3d033e5c6a448cc48ee7ef5", "message": "Merge branch 'master' into itv2-simulate-api", "committedDate": "2020-04-24T10:04:18Z", "type": "commit"}, {"oid": "490ca72dc0ad1c2d67f6c842a8c75ac93a767f40", "url": "https://github.com/elastic/elasticsearch/commit/490ca72dc0ad1c2d67f6c842a8c75ac93a767f40", "message": "Tests", "committedDate": "2020-04-24T11:20:34Z", "type": "commit"}, {"oid": "20eeea45f8d2d965cedbef03f19f0985ce935da2", "url": "https://github.com/elastic/elasticsearch/commit/20eeea45f8d2d965cedbef03f19f0985ce935da2", "message": "Yaml parsing and new line", "committedDate": "2020-04-24T11:34:25Z", "type": "commit"}, {"oid": "871980a966bbbfb72d81e2658b9f507837c36fca", "url": "https://github.com/elastic/elasticsearch/commit/871980a966bbbfb72d81e2658b9f507837c36fca", "message": "Fix tests", "committedDate": "2020-04-24T13:18:54Z", "type": "commit"}, {"oid": "f34071d40356be7f21eeccaae6f1d654a0c8dbdb", "url": "https://github.com/elastic/elasticsearch/commit/f34071d40356be7f21eeccaae6f1d654a0c8dbdb", "message": "Fix version restriction", "committedDate": "2020-04-24T13:42:41Z", "type": "commit"}, {"oid": "8ba793acb79d915f3cf849115981d4f4fd6cbb9c", "url": "https://github.com/elastic/elasticsearch/commit/8ba793acb79d915f3cf849115981d4f4fd6cbb9c", "message": "Fix response serialisation", "committedDate": "2020-04-24T14:27:49Z", "type": "commit"}, {"oid": "4b85534b3dbe6f18eddf4c02b2523ee89229edd5", "url": "https://github.com/elastic/elasticsearch/commit/4b85534b3dbe6f18eddf4c02b2523ee89229edd5", "message": "Rename PostSimulateIndexTemplateAction to SimulateIndexTemplateAction", "committedDate": "2020-04-24T15:18:25Z", "type": "commit"}, {"oid": "b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6", "url": "https://github.com/elastic/elasticsearch/commit/b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6", "message": "Rename RestPostSimulateIndexTemplateAction to RestSimulateIndexTemplateAction", "committedDate": "2020-04-24T15:20:46Z", "type": "commit"}, {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b", "url": "https://github.com/elastic/elasticsearch/commit/cbcc9770decf5ed6932fd4471786eb2fa710947b", "message": "Remove \"post_\" prefix", "committedDate": "2020-04-24T16:28:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MjQ0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414672449", "bodyText": "This could probably be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"indices:admin/index_template/simulate_index/post\";\n          \n          \n            \n                public static final String NAME = \"indices:admin/index_template/simulate_index\";", "author": "dakrone", "createdAt": "2020-04-24T15:39:05Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionType;\n+\n+public class SimulateIndexTemplateAction extends ActionType<SimulateIndexTemplateResponse> {\n+\n+    public static final SimulateIndexTemplateAction INSTANCE = new SimulateIndexTemplateAction();\n+    public static final String NAME = \"indices:admin/index_template/simulate_index/post\";", "originalCommit": "b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MzM0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414673346", "bodyText": "We've been collapsing the request and response objects into the action itself (for example in PutIndexTemplateV2Action), so if you want to, you can do that, otherwise a separate class is fine with me too.", "author": "dakrone", "createdAt": "2020-04-24T15:40:25Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateRequest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateV2Action;\n+import org.elasticsearch.action.support.master.MasterNodeReadRequest;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class SimulateIndexTemplateRequest extends MasterNodeReadRequest<SimulateIndexTemplateRequest> {", "originalCommit": "b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODU1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415688557", "bodyText": "I somehow found it hard to navigate to those classes, that's why I chose to have them standalone. I'd rather leave them like this if you don't have a strong opinion otherwise", "author": "andreidan", "createdAt": "2020-04-27T10:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MzM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5OTQ2NA==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415999464", "bodyText": "That's totally fine with me", "author": "dakrone", "createdAt": "2020-04-27T17:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MzM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414901353", "bodyText": "I'm a little on the fence about this, on one hand it's good we tell users what overlap, on the other hand, maybe we don't want to keep this around for a long time with the phrase \"v1\" in it.\nWhat about including other V2 templates that could overlap here? And just calling it overlapping_templates? Or even expanding it to more information (that doesn't have to include the \"vN\" in the key name:\n\"overlapping\": [\n  { \n    \"name\": \"template_1\",\n    \"patterns\": [...],\n    \"priority\": 4,\n    \"type\": \"v1\"\n  }\n]\n\nWhat do you think? I'm wary of introducing the phrase \"v1\" for something we'll have to support for a very long time (past when \"v1\" templates are removed)", "author": "dakrone", "createdAt": "2020-04-24T22:38:41Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Contains the information on what V2 templates would match a given index.\n+ */\n+public class SimulateIndexTemplateResponse extends ActionResponse implements ToXContentObject {\n+\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField OVERLAPPING_V1_TEMPLATES = new ParseField(\"overlapping_v1_templates\");", "originalCommit": "cbcc9770decf5ed6932fd4471786eb2fa710947b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjY1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415706657", "bodyText": "I agree retiring the V1 concept will posses some problems. I do however question the utility of overlapping v2 templates though? (as, V2 templates don't overlap with V2 templates in the sense of some influencing the resulting mappings/settings of others, we have a clear winner)\nI think we might be offloading a bit of work to the user to make some sense of that field and filter out the V2 templates.\nWould it make sense to only call it \"overlapping\" and keep the current returned format and also keep only returning the V1 overlapping templates? Documenting this field accordingly.\nWhen V1 templates are retired this field will always be empty so the clients will also not break.", "author": "andreidan", "createdAt": "2020-04-27T10:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5OTI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415999253", "bodyText": "Would it make sense to only call it \"overlapping\" and keep the current returned format and also keep only returning the V1 overlapping templates? Documenting this field accordingly.\n\nHmm.. what about calling it \"overlapping\" and including both V1 and V2 templates in the list? Eventually no more V1 templates will be in the list, but it could still be useful to see V2 templates that would have matched the index.", "author": "dakrone", "createdAt": "2020-04-27T17:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU4MTc3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416581772", "bodyText": "Implemented this Lee, I think this is ready for review", "author": "andreidan", "createdAt": "2020-04-28T12:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjA4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414902089", "bodyText": "I think we might want to put this logic in a static method in MetadataCreateIndexService (since I believe it does something similar) so that the simulation can reuse the real method.", "author": "dakrone", "createdAt": "2020-04-24T22:41:05Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+        Map<String, AliasMetadata> aliases = new HashMap<>();\n+        for (Map<String, AliasMetadata> alias : resolvedAliases) {\n+            for (Map.Entry<String, AliasMetadata> aliasEntry : alias.entrySet()) {\n+                if (aliases.containsKey(aliasEntry.getKey()) == false) {\n+                    aliases.put(aliasEntry.getKey(), aliasEntry.getValue());\n+                }\n+            }\n+        }", "originalCommit": "cbcc9770decf5ed6932fd4471786eb2fa710947b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMzUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414903516", "bodyText": "Super minor, but the indentation for these lines is off now", "author": "dakrone", "createdAt": "2020-04-24T22:45:20Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -502,7 +502,7 @@ private ClusterState applyCreateIndexRequestWithV2Template(final ClusterState cu\n             Collections.singletonList(templateName), metadataTransformer);\n     }\n \n-    static Map<String, Object> resolveV2Mappings(final String requestMappings,\n+    public static Map<String, Object> resolveV2Mappings(final String requestMappings,\n                                                  final ClusterState currentState,\n                                                  final String templateName,\n                                                  final NamedXContentRegistry xContentRegistry) throws Exception {", "originalCommit": "cbcc9770decf5ed6932fd4471786eb2fa710947b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMzU1OA==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414903558", "bodyText": "Same nit about indentation", "author": "dakrone", "createdAt": "2020-04-24T22:45:28Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -332,8 +332,7 @@ static void validateV2TemplateRequest(Metadata metadata, String name, IndexTempl\n         }\n     }\n \n-    // Package visible for testing\n-    ClusterState addIndexTemplateV2(final ClusterState currentState, final boolean create,\n+    public ClusterState addIndexTemplateV2(final ClusterState currentState, final boolean create,\n                                     final String name, final IndexTemplateV2 template) throws Exception {", "originalCommit": "cbcc9770decf5ed6932fd4471786eb2fa710947b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3ca7e204c195a86e2bce35ef6f234eb5af1308d9", "url": "https://github.com/elastic/elasticsearch/commit/3ca7e204c195a86e2bce35ef6f234eb5af1308d9", "message": "Drop /post from action name\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-04-27T10:13:38Z", "type": "commit"}, {"oid": "a436e39cfd973840e6b705ee07dc40203a8fb1c2", "url": "https://github.com/elastic/elasticsearch/commit/a436e39cfd973840e6b705ee07dc40203a8fb1c2", "message": "Update rest api spec\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-04-27T10:16:56Z", "type": "commit"}, {"oid": "604936a60e8476be976327fb5ab1543e938bddc3", "url": "https://github.com/elastic/elasticsearch/commit/604936a60e8476be976327fb5ab1543e938bddc3", "message": "Drop \"post\" from package name", "committedDate": "2020-04-27T14:06:57Z", "type": "commit"}, {"oid": "edc86109550bba6903b89250161665d934943921", "url": "https://github.com/elastic/elasticsearch/commit/edc86109550bba6903b89250161665d934943921", "message": "Fix indentation", "committedDate": "2020-04-27T15:03:33Z", "type": "commit"}, {"oid": "34d7a75c92c8ba7d25cf62b5d3e65f13d0146621", "url": "https://github.com/elastic/elasticsearch/commit/34d7a75c92c8ba7d25cf62b5d3e65f13d0146621", "message": "Use the resolveAndValidateAliases method to resolve aliases", "committedDate": "2020-04-27T15:05:23Z", "type": "commit"}, {"oid": "c68ece91dea4f95ad86dfe7d362fdf4247ff5788", "url": "https://github.com/elastic/elasticsearch/commit/c68ece91dea4f95ad86dfe7d362fdf4247ff5788", "message": "Merge branch 'master' into itv2-simulate-api", "committedDate": "2020-04-27T15:06:07Z", "type": "commit"}, {"oid": "6a319da3fc7bc0c290d07335125d694ef95ce679", "url": "https://github.com/elastic/elasticsearch/commit/6a319da3fc7bc0c290d07335125d694ef95ce679", "message": "Rename overlapping_v1_templates to overlapping", "committedDate": "2020-04-27T15:09:20Z", "type": "commit"}, {"oid": "41342820266a7092b6a4ae88239ddcb0922456f1", "url": "https://github.com/elastic/elasticsearch/commit/41342820266a7092b6a4ae88239ddcb0922456f1", "message": "Update methods docs and fix use case where candidate exists", "committedDate": "2020-04-28T11:45:50Z", "type": "commit"}, {"oid": "facb14adaa80db06dc0932688bf245c8906b661e", "url": "https://github.com/elastic/elasticsearch/commit/facb14adaa80db06dc0932688bf245c8906b661e", "message": "Return overlapping V1 and V2 templates and their patterns", "committedDate": "2020-04-28T11:50:37Z", "type": "commit"}, {"oid": "651b578087625e222bd7c9d1a8825a8f2130a906", "url": "https://github.com/elastic/elasticsearch/commit/651b578087625e222bd7c9d1a8825a8f2130a906", "message": "Remove v1 mentions", "committedDate": "2020-04-28T12:00:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NDA4NA==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416684084", "bodyText": "I think we need to change this to not use dynamically named keys, rather than:\n\"overlapping\": {\n   \"foo\": [\"bar\"],\n   \"baz\": [\"eggplant\"]\n}\nIt should probably be something like:\n\"overlapping\": [\n  {\n    \"name\": \"foo\",\n    \"index_patterns\": [\"bar\"]\n  },\n  {\n    \"name\": \"baz\",\n    \"index_patterns\": [\"eggplant\"]\n  }\n]", "author": "dakrone", "createdAt": "2020-04-28T14:58:38Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Contains the information on what V2 templates would match a given index.\n+ */\n+public class SimulateIndexTemplateResponse extends ActionResponse implements ToXContentObject {\n+\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField OVERLAPPING = new ParseField(\"overlapping\");\n+\n+    @Nullable\n+    // the resolved settings, mappings and aliases for the matched templates, if any\n+    private Template resolvedTemplate;\n+\n+    @Nullable\n+    // a map of template names and their index patterns that would overlap when matching the given index name\n+    private Map<String, List<String>> overlappingTemplates;\n+\n+    public SimulateIndexTemplateResponse(@Nullable Template resolvedTemplate, @Nullable Map<String, List<String>> overlappingTemplates) {\n+        this.resolvedTemplate = resolvedTemplate;\n+        this.overlappingTemplates = overlappingTemplates;\n+    }\n+\n+    public SimulateIndexTemplateResponse(StreamInput in) throws IOException {\n+        super(in);\n+        resolvedTemplate = in.readOptionalWriteable(Template::new);\n+        if (in.readBoolean()) {\n+            int overlappingTemplatesCount = in.readInt();\n+            overlappingTemplates = new HashMap<>(overlappingTemplatesCount, 1L);\n+            for (int i = 0; i < overlappingTemplatesCount; i++) {\n+                String templateName = in.readString();\n+                overlappingTemplates.put(templateName, in.readStringList());\n+            }\n+        } else {\n+            this.overlappingTemplates = null;\n+        }\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeOptionalWriteable(resolvedTemplate);\n+        if (overlappingTemplates != null) {\n+            out.writeBoolean(true);\n+            out.writeInt(overlappingTemplates.size());\n+            for (Map.Entry<String, List<String>> entry : overlappingTemplates.entrySet()) {\n+                out.writeString(entry.getKey());\n+                out.writeStringCollection(entry.getValue());\n+            }\n+        } else {\n+            out.writeBoolean(false);\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (this.resolvedTemplate != null) {\n+            builder.field(TEMPLATE.getPreferredName(), this.resolvedTemplate);\n+        }\n+        if (this.overlappingTemplates != null) {\n+            builder.field(OVERLAPPING.getPreferredName(), overlappingTemplates);", "originalCommit": "651b578087625e222bd7c9d1a8825a8f2130a906", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NjY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416686649", "bodyText": "I think this should put the results in a new map, otherwise we rely on findConflictingV1Templates returning a mutable Map", "author": "dakrone", "createdAt": "2020-04-28T15:01:49Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),\n+                resolvedAliases, simulateOnClusterState.metadata(), aliasValidator, xContentRegistry,\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                tempIndexService.newQueryShardContext(0, null, () -> 0L, null));\n+\n+            IndexTemplateV2 templateV2 = simulateOnClusterState.metadata().templatesV2().get(matchingTemplate);\n+            assert templateV2 != null : \"the matched template must exist\";\n+\n+            Map<String, List<String>> overlapping = findConflictingV1Templates(simulateOnClusterState, matchingTemplate,", "originalCommit": "651b578087625e222bd7c9d1a8825a8f2130a906", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0MDU5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416740595", "bodyText": "ah good shout, I had allocations on my mind", "author": "andreidan", "createdAt": "2020-04-28T16:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NjY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NzkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416687914", "bodyText": "In subsequent work (doesn't have to be this PR) maybe we can extract this into a helper method, creating an IndexService for the simulation here makes me a little uneasy for a long-term solution.", "author": "dakrone", "createdAt": "2020-04-28T15:03:35Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),", "originalCommit": "651b578087625e222bd7c9d1a8825a8f2130a906", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0MjYyNw==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416742627", "bodyText": "completely agree, this is clunky and rather error-prone (easy to forget to close etc)", "author": "andreidan", "createdAt": "2020-04-28T16:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NzkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4ODU0OA==", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416688548", "bodyText": "I think the string here can be changed to indicate this is being removed because of a simulation rather than validating template aliases", "author": "dakrone", "createdAt": "2020-04-28T15:04:23Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),\n+                resolvedAliases, simulateOnClusterState.metadata(), aliasValidator, xContentRegistry,\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                tempIndexService.newQueryShardContext(0, null, () -> 0L, null));\n+\n+            IndexTemplateV2 templateV2 = simulateOnClusterState.metadata().templatesV2().get(matchingTemplate);\n+            assert templateV2 != null : \"the matched template must exist\";\n+\n+            Map<String, List<String>> overlapping = findConflictingV1Templates(simulateOnClusterState, matchingTemplate,\n+                templateV2.indexPatterns());\n+            overlapping.putAll(findConflictingV2Templates(simulateOnClusterState, matchingTemplate, templateV2.indexPatterns()));\n+\n+            Template template = new Template(settings, mappingsJson == null ? null : new CompressedXContent(mappingsJson),\n+                aliases.stream().collect(Collectors.toMap(AliasMetadata::getAlias, Function.identity())));\n+            listener.onResponse(new SimulateIndexTemplateResponse(template, overlapping));\n+        } finally {\n+            if (index != null) {\n+                indicesService.removeIndex(index, NO_LONGER_ASSIGNED, \"created to validate template aliases\");", "originalCommit": "651b578087625e222bd7c9d1a8825a8f2130a906", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "03d9b0fc8f5e29a695dc95f3f68301029d37eb9f", "url": "https://github.com/elastic/elasticsearch/commit/03d9b0fc8f5e29a695dc95f3f68301029d37eb9f", "message": "Drop dynamic keys from response", "committedDate": "2020-04-28T16:09:29Z", "type": "commit"}, {"oid": "8863d1f0e347ee1896c4e6d0635a80c04462987b", "url": "https://github.com/elastic/elasticsearch/commit/8863d1f0e347ee1896c4e6d0635a80c04462987b", "message": "Use additional map", "committedDate": "2020-04-28T16:12:19Z", "type": "commit"}, {"oid": "db5782bca51e856de14f83aeaaa23c183a80f135", "url": "https://github.com/elastic/elasticsearch/commit/db5782bca51e856de14f83aeaaa23c183a80f135", "message": "Update remove indexService reason", "committedDate": "2020-04-28T16:16:05Z", "type": "commit"}, {"oid": "7a6582c0edab2ffd5c918ed5bc72d9cad7a71d25", "url": "https://github.com/elastic/elasticsearch/commit/7a6582c0edab2ffd5c918ed5bc72d9cad7a71d25", "message": "Merge branch 'master' into itv2-simulate-api", "committedDate": "2020-04-28T16:42:34Z", "type": "commit"}, {"oid": "ab918fde8a8deeacf66dd85a5e269cecf1300aaf", "url": "https://github.com/elastic/elasticsearch/commit/ab918fde8a8deeacf66dd85a5e269cecf1300aaf", "message": "Use composed_of in the simulated template", "committedDate": "2020-04-28T17:15:39Z", "type": "commit"}, {"oid": "e36864758147a5e90ffc6baef7b43a60318384c4", "url": "https://github.com/elastic/elasticsearch/commit/e36864758147a5e90ffc6baef7b43a60318384c4", "message": "Assert overlapping is array", "committedDate": "2020-04-28T17:16:23Z", "type": "commit"}, {"oid": "d3cac66fd657b82a849577aa94da224c7a6830fc", "url": "https://github.com/elastic/elasticsearch/commit/d3cac66fd657b82a849577aa94da224c7a6830fc", "message": "Merge branch 'master' into itv2-simulate-api", "committedDate": "2020-04-28T17:17:08Z", "type": "commit"}]}