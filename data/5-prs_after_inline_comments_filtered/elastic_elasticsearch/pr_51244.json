{"pr_number": 51244, "pr_title": "Preserve ApiKey credentials for async verification", "pr_createdAt": "2020-01-21T05:32:43Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51244", "timeline": [{"oid": "45963e20033dcb71620e6b991ca15ac899f7894f", "url": "https://github.com/elastic/elasticsearch/commit/45963e20033dcb71620e6b991ca15ac899f7894f", "message": "Preserve ApiKey credentials for async verification\n\nThe ApiKeyService would aggressively \"close\" ApiKeyCredentials objects\nduring processing. However, under rare circumstances, the verfication\nof the secret key would be performed asychronously and may need access\nto the SecureString after it had been closed by the caller.\n\nThe trigger for this would be if the cache already held a Future for\nthat ApiKey, but the future was not yet complete. In this case the\nverification of the secret key would take place asynchronously on the\ngeneric thread pool.\n\nThis commit moves the \"close\" of the credentials to the body of the\nlistener so that it only occurs after key verification is complete.", "committedDate": "2020-01-21T05:24:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxOTIxMA==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368819210", "bodyText": "Without the fix to not close the credentials, this line would fail with:\n\nSecureString has already been closed", "author": "tvernum", "createdAt": "2020-01-21T05:41:14Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);", "originalCommit": "45963e20033dcb71620e6b991ca15ac899f7894f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyNDQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368924480", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Call the top level method because it has been know to be buggy in async situations\n          \n          \n            \n                    // Call the top level method because it has been known to be buggy in async situations", "author": "jkakavas", "createdAt": "2020-01-21T10:36:41Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations", "originalCommit": "45963e20033dcb71620e6b991ca15ac899f7894f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0858ef206455d32aa58d6a2d76e53f190a808433", "url": "https://github.com/elastic/elasticsearch/commit/0858ef206455d32aa58d6a2d76e53f190a808433", "message": "Merge branch 'master' into fix/api-key-sync-close", "committedDate": "2020-01-23T05:21:59Z", "type": "commit"}, {"oid": "b585ab8a1abfeebd85647f73fd506cb0e820fbb9", "url": "https://github.com/elastic/elasticsearch/commit/b585ab8a1abfeebd85647f73fd506cb0e820fbb9", "message": "Fix comment", "committedDate": "2020-01-23T05:22:47Z", "type": "commit"}, {"oid": "4100f2c58627b584fbe291fbbe12be814d85ebea", "url": "https://github.com/elastic/elasticsearch/commit/4100f2c58627b584fbe291fbbe12be814d85ebea", "message": "Merge branch 'master' into fix/api-key-sync-close", "committedDate": "2020-01-23T10:24:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1MjMxNA==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368852314", "bodyText": "A minor comment: Is it worthwhile to wrap the ActionListeners earlier on so that we don't have to call credentials.close() in multiple places. That is once we know credentials is not null, we can have:\nvar credentialsClosingListener = ActionListener.wrap(...);\nThen just use the new listener in subsequent code. At this point, it may be worthwhile to extract this part of code into a new method.", "author": "ywangd", "createdAt": "2020-01-21T07:55:15Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -301,10 +301,15 @@ void authenticateWithApiKeyIfPresent(ThreadContext ctx, ActionListener<Authentic\n                         .request();\n                 executeAsyncWithOrigin(ctx, SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {\n                     if (response.isExists()) {\n-                        try (ApiKeyCredentials ignore = credentials) {\n-                            final Map<String, Object> source = response.getSource();\n-                            validateApiKeyCredentials(docId, source, credentials, clock, listener);\n-                        }\n+                        final Map<String, Object> source = response.getSource();\n+                        validateApiKeyCredentials(docId, source, credentials, clock, ActionListener.wrap(", "originalCommit": "45963e20033dcb71620e6b991ca15ac899f7894f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2MTU3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370461579", "bodyText": "Good idea, I'll see how it looks.", "author": "tvernum", "createdAt": "2020-01-24T03:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1MjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NjM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368856394", "bodyText": "Mainly curious: it really takes 2 seconds for the notify to work?", "author": "ywangd", "createdAt": "2020-01-21T08:07:46Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);\n+\n+        assertThat(hashCounter.get(), equalTo(1));\n+        if (future2.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future2.actionGet());\n+        }\n+\n+        synchronized (hashWait) {\n+            hashWait.notify();\n+        }\n+\n+        assertThat(future1.actionGet(TimeValue.timeValueSeconds(2)).isAuthenticated(), is(true));", "originalCommit": "45963e20033dcb71620e6b991ca15ac899f7894f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2MjAxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370462017", "bodyText": "No, but in these tests there's a delicate balance between not having the tests run too long and not getting noise.\nThis should be done in milliseconds. But if the VM that running CI get slowed down for some reason, or we get really long GC pause, and this takes 1.5 seconds, that shouldn't cause the test to fail.\nWe want a time that is long enough that the timeout means \"this is never going to happen, the test failed\" but not so long that you're sitting there wondering if the test is ever going to be done.", "author": "tvernum", "createdAt": "2020-01-24T03:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NjM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2NjAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370466002", "bodyText": "Thanks that makes sense.", "author": "ywangd", "createdAt": "2020-01-24T04:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NjM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NzAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368857013", "bodyText": "Trivial: Could probably replace this with a CompletableFuture object? If so, could save a couple of lines.", "author": "ywangd", "createdAt": "2020-01-21T08:09:40Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();", "originalCommit": "45963e20033dcb71620e6b991ca15ac899f7894f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3MTExMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370471111", "bodyText": "I used a semaphore instead, but thanks for the prompt. When I wrote the test I planned to come back and replace the wait/notify with something else after it was all working, but I forgot.", "author": "tvernum", "createdAt": "2020-01-24T04:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NzAxMw=="}], "type": "inlineReview"}, {"oid": "dbf164a5c9bd52ed0f85db0cc9e77aafc4129a6c", "url": "https://github.com/elastic/elasticsearch/commit/dbf164a5c9bd52ed0f85db0cc9e77aafc4129a6c", "message": "Address feedback\n\n- Wrap the listener in 1 place\n- Use a semaphore instead of Object.wait", "committedDate": "2020-01-24T03:54:14Z", "type": "commit"}, {"oid": "cfe8e763f7d7d7a99c296c6aca875a9b15074831", "url": "https://github.com/elastic/elasticsearch/commit/cfe8e763f7d7d7a99c296c6aca875a9b15074831", "message": "Merge branch 'master' into fix/api-key-sync-close", "committedDate": "2020-01-24T03:55:09Z", "type": "commit"}, {"oid": "b59c67ac4d042e70f0b642df5d631b363b4b5b37", "url": "https://github.com/elastic/elasticsearch/commit/b59c67ac4d042e70f0b642df5d631b363b4b5b37", "message": "Fix import", "committedDate": "2020-01-24T04:07:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3MzgyMA==", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370473820", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public  HttpProxy(String host, Integer port, Scheme scheme) {\n          \n          \n            \n                public HttpProxy(String host, Integer port, Scheme scheme) {", "author": "tvernum", "createdAt": "2020-01-24T04:56:31Z", "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpProxy.java", "diffHunk": "@@ -32,7 +32,7 @@ public HttpProxy(String host, Integer port) {\n         this.port = port;\n     }\n \n-    public HttpProxy(String host, Integer port, Scheme scheme) {\n+    public  HttpProxy(String host, Integer port, Scheme scheme) {", "originalCommit": "b59c67ac4d042e70f0b642df5d631b363b4b5b37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a303bd4b9c9fc40abc591cef7dc3533fadbc7d63", "url": "https://github.com/elastic/elasticsearch/commit/a303bd4b9c9fc40abc591cef7dc3533fadbc7d63", "message": "Update x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpProxy.java", "committedDate": "2020-01-24T04:56:49Z", "type": "commit"}]}