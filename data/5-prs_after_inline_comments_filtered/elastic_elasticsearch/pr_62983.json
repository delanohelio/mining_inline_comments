{"pr_number": 62983, "pr_title": "Make Rounding.nextRoundingValue consistent", "pr_createdAt": "2020-09-28T20:43:39Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62983", "timeline": [{"oid": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "url": "https://github.com/elastic/elasticsearch/commit/def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "message": "Make Rounding.nextRoundingValue consistent\n\n\"interval\" style roundings were implementing `nextRoundingValue` in a\nfairly inconsistent way - it'd produce a value, but sometimes that\nvalue would be the same as the previous rounding value. This makes it\nconsistently the next value that `rounding` would make.", "committedDate": "2020-09-28T20:44:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMTA1MA==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496221050", "bodyText": "I'm not sure I need to keep these. They failed on some of my other attempts at implementing this method.", "author": "nik9000", "createdAt": "2020-09-28T20:44:11Z", "path": "server/src/test/java/org/elasticsearch/common/RoundingTests.java", "diffHunk": "@@ -469,6 +469,20 @@ public void testRandomTimeIntervalRounding() {\n         }\n     }\n \n+    public void testFoo() {\n+        Rounding rounding = new Rounding.TimeIntervalRounding(960000, ZoneId.of(\"Europe/Minsk\"));\n+        long rounded = rounding.prepareForUnknown().round(877824908400L);\n+        long next = rounding.prepareForUnknown().nextRoundingValue(rounded);\n+        assertThat(next, greaterThan(rounded));\n+    }\n+\n+    public void testBar() {\n+        Rounding rounding = new Rounding.TimeIntervalRounding(480000, ZoneId.of(\"Portugal\"));\n+        long rounded = rounding.prepareJavaTime().round(972780720000L);\n+        long next = rounding.prepareJavaTime().nextRoundingValue(rounded);\n+        assertThat(next, greaterThan(rounded));\n+    }", "originalCommit": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNTI4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496225286", "bodyText": "I'd keep them in, personally.  Could just put a note that those specific values caused problems for some implementations, so we're keeping them around for regression testing, or something like that.", "author": "not-napoleon", "createdAt": "2020-09-28T20:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMTA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1ODgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497558807", "bodyText": "I know we don't use them much, but this would be an excellent candidate for junit parameterized testing.", "author": "not-napoleon", "createdAt": "2020-09-30T14:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMTA1MA=="}], "type": "inlineReview"}, {"oid": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "url": "https://github.com/elastic/elasticsearch/commit/def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "message": "Make Rounding.nextRoundingValue consistent\n\n\"interval\" style roundings were implementing `nextRoundingValue` in a\nfairly inconsistent way - it'd produce a value, but sometimes that\nvalue would be the same as the previous rounding value. This makes it\nconsistently the next value that `rounding` would make.", "committedDate": "2020-09-28T20:44:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyODM1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496228351", "bodyText": "So I'm just glancing at this, and haven't read the whole class, but, it looks like the old implementation was using interval as a number of seconds, and this is using it as a number of milliseconds?  Is that correct?  Or am I misunderstanding something here?", "author": "not-napoleon", "createdAt": "2020-09-28T20:58:26Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1119,12 +1118,16 @@ public long round(long utcMillis) {\n             }\n \n             @Override\n-            public long nextRoundingValue(long time) {\n-                int offsetSeconds = timeZone.getRules().getOffset(Instant.ofEpochMilli(time)).getTotalSeconds();\n-                long millis = time + interval + offsetSeconds * 1000;\n-                return ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC)\n-                    .withZoneSameLocal(timeZone)\n-                    .toInstant().toEpochMilli();\n+            public long nextRoundingValue(long utcMillis) {\n+                long from = utcMillis + interval; // TODO this implementation makes me very upset", "originalCommit": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc0MTM5MA==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496741390", "bodyText": "The old implementation had the zone's offset in seconds but the interval was in millis.", "author": "nik9000", "createdAt": "2020-09-29T14:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyODM1MQ=="}], "type": "inlineReview"}, {"oid": "70f107388be6d4caabf47cbf8be7d5fee0e4113c", "url": "https://github.com/elastic/elasticsearch/commit/70f107388be6d4caabf47cbf8be7d5fee0e4113c", "message": "binary search/newton's method thing", "committedDate": "2020-09-29T15:08:43Z", "type": "commit"}, {"oid": "17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "url": "https://github.com/elastic/elasticsearch/commit/17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "message": "Logger", "committedDate": "2020-09-29T15:43:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1MjA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497552047", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                assert highEnough && false == tooHigh;\n          \n          \n            \n                                assert highEnough && (false == tooHigh);\n          \n      \n    \n    \n  \n\nI know it's redundant, but I think it's more readable to add parenthesis than have to remember the precedence order.", "author": "not-napoleon", "createdAt": "2020-09-30T14:24:41Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1119,12 +1122,60 @@ public long round(long utcMillis) {\n             }\n \n             @Override\n-            public long nextRoundingValue(long time) {\n-                int offsetSeconds = timeZone.getRules().getOffset(Instant.ofEpochMilli(time)).getTotalSeconds();\n-                long millis = time + interval + offsetSeconds * 1000;\n-                return ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC)\n-                    .withZoneSameLocal(timeZone)\n-                    .toInstant().toEpochMilli();\n+            public long nextRoundingValue(long utcMillis) {\n+                /*\n+                 * Ok. I'm not proud of this, but it gets the job done. So here is the deal:\n+                 * its super important that nextRoundingValue be *exactly* the next rounding\n+                 * value. And I can't come up with a nice way to use the java time API to figure\n+                 * it out. Thus, we treat \"round\" like a black box here and run a kind of whacky\n+                 * binary search, newton's method hybrid. We don't have a \"slope\" so we can't do\n+                 * a \"real\" newton's method, so we just sort of cut the diff in half. As janky\n+                 * as it looks, it tends to get the job done in under four iterations. Frankly,\n+                 * `round(round(utcMillis) + interval)` is usually a good guess so we mostly get\n+                 * it in a single iteration. But daylight savings time and other janky stuff can\n+                 * make it less likely.\n+                 */\n+                long prevRound = round(utcMillis);\n+                long increment = interval;\n+                long from = prevRound;\n+                int iterations = 0;\n+                while (++iterations < 100) {\n+                    from += increment;\n+                    long rounded = round(from);\n+                    boolean highEnough = rounded > prevRound;\n+                    if (false == highEnough) {\n+                        if (increment < 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    long roundedRoundedDown = round(rounded - 1);\n+                    boolean tooHigh = roundedRoundedDown > prevRound;\n+                    if (tooHigh) {\n+                        if (increment > 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    assert highEnough && false == tooHigh;", "originalCommit": "17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NTg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497555896", "bodyText": "I think you're using assert false here so this throws in testing but not in production.  If that's the case, please just put a note for why we want the behavior to be different in prod, and maybe what will actually be returned in that case.  And if not, please throw an actual exception.", "author": "not-napoleon", "createdAt": "2020-09-30T14:29:02Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1119,12 +1122,60 @@ public long round(long utcMillis) {\n             }\n \n             @Override\n-            public long nextRoundingValue(long time) {\n-                int offsetSeconds = timeZone.getRules().getOffset(Instant.ofEpochMilli(time)).getTotalSeconds();\n-                long millis = time + interval + offsetSeconds * 1000;\n-                return ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC)\n-                    .withZoneSameLocal(timeZone)\n-                    .toInstant().toEpochMilli();\n+            public long nextRoundingValue(long utcMillis) {\n+                /*\n+                 * Ok. I'm not proud of this, but it gets the job done. So here is the deal:\n+                 * its super important that nextRoundingValue be *exactly* the next rounding\n+                 * value. And I can't come up with a nice way to use the java time API to figure\n+                 * it out. Thus, we treat \"round\" like a black box here and run a kind of whacky\n+                 * binary search, newton's method hybrid. We don't have a \"slope\" so we can't do\n+                 * a \"real\" newton's method, so we just sort of cut the diff in half. As janky\n+                 * as it looks, it tends to get the job done in under four iterations. Frankly,\n+                 * `round(round(utcMillis) + interval)` is usually a good guess so we mostly get\n+                 * it in a single iteration. But daylight savings time and other janky stuff can\n+                 * make it less likely.\n+                 */\n+                long prevRound = round(utcMillis);\n+                long increment = interval;\n+                long from = prevRound;\n+                int iterations = 0;\n+                while (++iterations < 100) {\n+                    from += increment;\n+                    long rounded = round(from);\n+                    boolean highEnough = rounded > prevRound;\n+                    if (false == highEnough) {\n+                        if (increment < 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    long roundedRoundedDown = round(rounded - 1);\n+                    boolean tooHigh = roundedRoundedDown > prevRound;\n+                    if (tooHigh) {\n+                        if (increment > 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    assert highEnough && false == tooHigh;\n+                    assert roundedRoundedDown == prevRound;\n+                    if (iterations > 3 && logger.isDebugEnabled()) {\n+                        logger.debug(\"Iterated {} time for {} using {}\", iterations, utcMillis, TimeIntervalRounding.this.toString());\n+                    }\n+                    return rounded;\n+                }\n+                assert false : String.format(", "originalCommit": "17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MDUwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497560506", "bodyText": "Sure!", "author": "nik9000", "createdAt": "2020-09-30T14:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NTg5Ng=="}], "type": "inlineReview"}, {"oid": "3a7fc015858e89d3963ce240cec7d3f80c4bdc71", "url": "https://github.com/elastic/elasticsearch/commit/3a7fc015858e89d3963ce240cec7d3f80c4bdc71", "message": "Apply suggestions from code review\n\nCo-authored-by: Mark Tozzi <mark.tozzi@gmail.com>", "committedDate": "2020-09-30T14:35:08Z", "type": "commit"}, {"oid": "3dc048338c151a960e3f6ac50c55e9aed0311707", "url": "https://github.com/elastic/elasticsearch/commit/3dc048338c151a960e3f6ac50c55e9aed0311707", "message": "Explain", "committedDate": "2020-09-30T17:11:47Z", "type": "commit"}]}