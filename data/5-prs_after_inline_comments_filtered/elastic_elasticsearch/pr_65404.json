{"pr_number": 65404, "pr_title": "Extract security wildcard pattern matching", "pr_createdAt": "2020-11-24T03:19:29Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65404", "timeline": [{"oid": "2881817aedee8ae9b84119ef31249265c83945c0", "url": "https://github.com/elastic/elasticsearch/commit/2881817aedee8ae9b84119ef31249265c83945c0", "message": "Extract security wildcard pattern matching\n\nThis commit moves the implementation of wildcard pattern matching into\na standalone utility class (\"StringMatcher\").\n\nIn general, we rely on lucene Automaton objects to implement pattern\nmatching (wildcards and regexp) within Elasticsearch security - for\nexample in Index name patterns within a role.\n\nThe IndicesPermission class also has a special optimisation for exact\nstring matches (that is raw index names that contain no wildcards) as\nusing String.equals / Set.contains is more efficient for this common\ncase.\n\nAll of the above functionality has now been extracted into the\nStringMatcher class, and it is now used in several places where it may\nbe more efficient that the previous use of raw Automaton objects.\n\nA future change will expand this StringMatcher class with additional\noptimisations for common use cases that are poorly handled within our\nexisting automaton compilation process.\n\nRelates: #36062", "committedDate": "2020-11-24T02:47:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNTg1MA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529505850", "bodyText": "Should these methods have argument of type StringMatcher instead of Predicate? A raw predicate does not make much sense to have description?\nNits:\n\nIt seems the two and methods can be merged into one if it follows the pattern of the or method.\nIf any of the description is itself a combined one, e.g. a|b|c, when concatenating it again with another description, would it be helpful to put parenthesis around it, e.g. (a|b|c)&d?", "author": "ywangd", "createdAt": "2020-11-24T12:24:41Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }", "originalCommit": "2881817aedee8ae9b84119ef31249265c83945c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MjEyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529842129", "bodyText": "@ywangd I believe this is Predicate and and or default methods signature we have to use. We can build the description from the Predicate.", "author": "BigPandaToo", "createdAt": "2020-11-24T19:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNTg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwNjgwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529906809", "bodyText": "These methods are not annotated with @Override. So I thought the intention was to have different methods instead of the default ones.\nWith that being said, Java does not have multiple dispatch. A method of public StringMatcher and(StringMatcher) does not guarantee to work as intended all the time. So its usefulness is arguable. Other options could be a new interface extending Predicate or assert the argument's type. But they are not perfect either.", "author": "ywangd", "createdAt": "2020-11-24T21:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNTg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDcwOTE4NA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r534709184", "bodyText": "The first two should be marked @Override (I think IntelliJ does weird things, with overriding default implementations...).\nThe 3rd (and(String,Predicate)) isn't an override, but is intentionally a Predicate so that you can apply a description to a generic predicate. It gets used in IndicesPermission for that exact purpose.", "author": "tvernum", "createdAt": "2020-12-03T06:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNzg3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529507870", "bodyText": "More of a question: What about empty string, all and _all? should they be handled before reaching to this class?", "author": "ywangd", "createdAt": "2020-11-24T12:28:15Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {", "originalCommit": "2881817aedee8ae9b84119ef31249265c83945c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDcwOTc4MA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r534709780", "bodyText": "I don't think there's any case where those are relevant here. We don't support all in the places where this is used.", "author": "tvernum", "createdAt": "2020-12-03T06:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNzg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwOTI2OA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529509268", "bodyText": "Nit: Could use a more generic parameter name instead of indices, same goes for the buildAutomataPredicate method.", "author": "ywangd", "createdAt": "2020-11-24T12:30:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);\n+            }\n+            return strings.stream().map(s -> {\n+                if (s.length() > 16) {\n+                    return Strings.cleanTruncate(s, 12) + \"...\";\n+                } else {\n+                    return s;\n+                }\n+            }).collect(Collectors.joining(\"|\"));\n+        }\n+\n+        private static Predicate<String> buildExactMatchPredicate(Set<String> indices) {", "originalCommit": "2881817aedee8ae9b84119ef31249265c83945c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwOTQxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529509411", "bodyText": "Any reason this is not a Set?", "author": "ywangd", "createdAt": "2020-11-24T12:30:53Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();", "originalCommit": "2881817aedee8ae9b84119ef31249265c83945c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzODIwMw==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543038203", "bodyText": "I've made it a LinkedHashSet. Order has a small potential performance impact, and I don't want to break something, but there's definitely no value in duplicates.", "author": "tvernum", "createdAt": "2020-12-15T04:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwOTQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxNTY2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529815663", "bodyText": "Nit: Any concerns here about description compatibility with AutomataPredicate (comma delimited and trancating 80 strings)?", "author": "BigPandaToo", "createdAt": "2020-11-24T19:10:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);\n+            }\n+            return strings.stream().map(s -> {\n+                if (s.length() > 16) {\n+                    return Strings.cleanTruncate(s, 12) + \"...\";", "originalCommit": "2881817aedee8ae9b84119ef31249265c83945c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1MzU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543053577", "bodyText": "I've improved the description generation, so that it only truncates as necessary to keep the whole string under 250 characters.\nI think that is to be preferred over simply attempting compatibility with the AutomataPredicate", "author": "tvernum", "createdAt": "2020-12-15T05:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxNTY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgyNjM0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529826345", "bodyText": "How about adding \"?\" for completeness?", "author": "BigPandaToo", "createdAt": "2020-11-24T19:29:26Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/support/StringMatcherTests.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+public class StringMatcherTests extends ESTestCase {\n+\n+    public void testEmptySet() throws Exception {\n+        final StringMatcher matcher = StringMatcher.of();\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(i, 20));\n+        }\n+    }\n+\n+    public void testSingleWildcard() throws Exception {\n+        final String prefix = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(prefix + \"*\");\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, prefix + randomAlphaOfLengthBetween(i, 20));\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(1, prefix.length() - 1));\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.startsWith(prefix), () -> randomAlphaOfLengthBetween(1, 8)));\n+        }\n+    }\n+\n+    public void testSingleExactMatch() throws Exception {\n+        final String str = randomAlphaOfLengthBetween(3, 12);\n+        final StringMatcher matcher = StringMatcher.of(str);\n+        assertMatch(matcher, str);\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.equals(str), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertNoMatch(matcher, randomAlphaOfLength(1) + str);\n+            assertNoMatch(matcher, str + randomAlphaOfLength(1));\n+        }\n+    }\n+\n+    public void testSingleRegex() throws Exception {\n+        final String notStr = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(\"/~(\" + notStr + \")/\");\n+        assertNoMatch(matcher, notStr);\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, randomValueOtherThanMany(s -> s.equals(notStr), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertMatch(matcher, randomAlphaOfLength(1) + notStr);\n+            assertMatch(matcher, notStr + randomAlphaOfLength(1));\n+        }\n+\n+    }\n+\n+    public void testMultiplePatterns() throws Exception {\n+        final String prefix1 = randomAlphaOfLengthBetween(3, 5);\n+        final String prefix2 = randomAlphaOfLengthBetween(5, 8);\n+        final String prefix3 = randomAlphaOfLengthBetween(10, 12);\n+        final String suffix1 = randomAlphaOfLengthBetween(5, 10);\n+        final String suffix2 = randomAlphaOfLengthBetween(8, 12);\n+        final String exact1 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(5, 9));\n+        final String exact2 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(10, 12));\n+        final String exact3 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(15, 20));\n+\n+        final StringMatcher matcher = StringMatcher.of(List.of(", "originalCommit": "2881817aedee8ae9b84119ef31249265c83945c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgyODQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529828439", "bodyText": "extra bracket?", "author": "BigPandaToo", "createdAt": "2020-11-24T19:33:02Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);", "originalCommit": "2881817aedee8ae9b84119ef31249265c83945c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1MzAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543053012", "bodyText": "Fixed.", "author": "tvernum", "createdAt": "2020-12-15T05:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgyODQzOQ=="}], "type": "inlineReview"}, {"oid": "219e30e3b168dc503c31fc17dca4d30e949089e0", "url": "https://github.com/elastic/elasticsearch/commit/219e30e3b168dc503c31fc17dca4d30e949089e0", "message": "Merge branch 'master' into feature/patterns-util-class", "committedDate": "2020-12-15T04:24:28Z", "type": "commit"}, {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "url": "https://github.com/elastic/elasticsearch/commit/5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "message": "Address feedback", "committedDate": "2020-12-15T05:16:01Z", "type": "commit"}, {"oid": "677f819709d790ad1004efcff79beea14aae2ea6", "url": "https://github.com/elastic/elasticsearch/commit/677f819709d790ad1004efcff79beea14aae2ea6", "message": "Merge branch 'master' into feature/patterns-util-class", "committedDate": "2020-12-16T05:39:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NDUxNw==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543974517", "bodyText": "Nit: Unlike the other or and and methods, this one does not have a statement of Objects.requireNonNull(other);. The relevant methods of Java Predicate calls requireNonNull anyway. So it is not really necessary to have the check here. I am happy either way, but some consistency across the methods would be good.", "author": "ywangd", "createdAt": "2020-12-16T05:25:25Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);", "originalCommit": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3MzY5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r545573696", "bodyText": "It delegates to the method below it, which does have the requireNotNull method. I don't think it's really needed here.", "author": "tvernum", "createdAt": "2020-12-18T04:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NDUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NzU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543977591", "bodyText": "Nit: this parameter is redundant since the argument is always the field variable of allText.", "author": "ywangd", "createdAt": "2020-12-16T05:29:18Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final Set<String> nonExactMatch = new LinkedHashSet<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {", "originalCommit": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NDA0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r545574041", "bodyText": "I've elected to make it static instead. I think the method reads better if it simply describes the argument rather than being tied to a particular field, but if that's true then it should be a static utility method.", "author": "tvernum", "createdAt": "2020-12-18T05:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NzU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3OTc0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543979748", "bodyText": "Nit: It is technically possible that this single item has a length greater than 250.", "author": "ywangd", "createdAt": "2020-12-16T05:32:21Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final Set<String> nonExactMatch = new LinkedHashSet<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);", "originalCommit": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NDM0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r545574342", "bodyText": "Yes, it is. The 250 character limit is intentionally soft. It's there to prevent us generating 10kb of toString in logs/error messages, but I don't think we actually care about 250 vs 255 or even 300 characters.", "author": "tvernum", "createdAt": "2020-12-18T05:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3OTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk4NDk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543984977", "bodyText": "Nit: If the intention is to keep the length of the final string under 250, this only takes care of the situation when there are fewer items, but has issues when there are many items. For example, if there are 250 items and each of them takes more than 1 char, the end result will be longer than 250 chars.", "author": "ywangd", "createdAt": "2020-12-16T05:39:04Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final Set<String> nonExactMatch = new LinkedHashSet<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);\n+            }\n+            final int totalLength = strings.stream().map(String::length).reduce(0, Math::addExact);\n+            if (totalLength < 250) {\n+                return Strings.collectionToDelimitedString(strings, \"|\");\n+            }\n+            final int maxItemLength = Math.max(16, 250 / strings.size());\n+            return strings.stream().map(s -> {\n+                if (s.length() > maxItemLength) {\n+                    return Strings.cleanTruncate(s, maxItemLength - 3) + \"...\";\n+                } else {\n+                    return s;\n+                }\n+            }).collect(Collectors.joining(\"|\"));", "originalCommit": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk5MzY4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543993687", "bodyText": "Nit: seems to be unfortunate that the description constructed in the or and and methods could be longer than 250 chars after all the effort went into Builder#describe.", "author": "ywangd", "createdAt": "2020-12-16T05:51:02Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));", "originalCommit": "677f819709d790ad1004efcff79beea14aae2ea6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNDE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r544004157", "bodyText": "Nit: why not\nassertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact1, exact2, exact3, prefix1, prefix2, suffix1, suffix2) + randomFrom(nonAlpha));\nAlso, why random from nonAlpha, shouldn't these tests work equally with any printable chars?\nUnless they were supposed to test something that wasn't obvious to me.", "author": "ywangd", "createdAt": "2020-12-16T06:04:33Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/support/StringMatcherTests.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class StringMatcherTests extends ESTestCase {\n+\n+    public void testEmptySet() throws Exception {\n+        final StringMatcher matcher = StringMatcher.of();\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(i, 20));\n+        }\n+    }\n+\n+    public void testSingleWildcard() throws Exception {\n+        final String prefix = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(prefix + \"*\");\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, prefix + randomAlphaOfLengthBetween(i, 20));\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(1, prefix.length() - 1));\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.startsWith(prefix), () -> randomAlphaOfLengthBetween(1, 8)));\n+        }\n+    }\n+\n+    public void testSingleExactMatch() throws Exception {\n+        final String str = randomAlphaOfLengthBetween(3, 12);\n+        final StringMatcher matcher = StringMatcher.of(str);\n+        assertMatch(matcher, str);\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.equals(str), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertNoMatch(matcher, randomAlphaOfLength(1) + str);\n+            assertNoMatch(matcher, str + randomAlphaOfLength(1));\n+        }\n+    }\n+\n+    public void testSingleRegex() throws Exception {\n+        final String notStr = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(\"/~(\" + notStr + \")/\");\n+        assertNoMatch(matcher, notStr);\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, randomValueOtherThanMany(s -> s.equals(notStr), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertMatch(matcher, randomAlphaOfLength(1) + notStr);\n+            assertMatch(matcher, notStr + randomAlphaOfLength(1));\n+        }\n+\n+    }\n+\n+    public void testMultiplePatterns() throws Exception {\n+        final String prefix1 = randomAlphaOfLengthBetween(3, 5);\n+        final String prefix2 = randomAlphaOfLengthBetween(5, 8);\n+        final String prefix3 = randomAlphaOfLengthBetween(10, 12);\n+        final String suffix1 = randomAlphaOfLengthBetween(5, 10);\n+        final String suffix2 = randomAlphaOfLengthBetween(8, 12);\n+        final String exact1 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(5, 9));\n+        final String exact2 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(10, 12));\n+        final String exact3 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(15, 20));\n+\n+        final StringMatcher matcher = StringMatcher.of(List.of(\n+            prefix1 + \"*\", prefix2 + \"?\", \"/\" + prefix3 + \"@/\", \"*\" + suffix1, \"/@\" + suffix2 + \"/\", exact1, exact2, exact3\n+        ));\n+\n+        assertMatch(matcher, exact1);\n+        assertMatch(matcher, exact2);\n+        assertMatch(matcher, exact3);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix1);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix2);\n+        assertMatch(matcher, prefix1 + randomAlphaOfLengthBetween(1, 5));\n+        assertMatch(matcher, prefix2 + randomAlphaOfLength(1));\n+        assertMatch(matcher, prefix3 + randomAlphaOfLengthBetween(1, 5));\n+\n+        assertNoMatch(matcher, prefix2 + randomAlphaOfLength(2));\n+\n+        final char[] nonAlpha = \"@/#$0123456789()[]{}<>;:%&\".toCharArray();\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact1, prefix1, suffix1) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact2, prefix2, suffix2) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact3, prefix3) + randomFrom(nonAlpha));", "originalCommit": "677f819709d790ad1004efcff79beea14aae2ea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NTE3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r545585179", "bodyText": "Also, why random from nonAlpha, shouldn't these tests work equally with any printable chars?\n\nMaking sure that there's zero chance of overlap between the strings is hard.\nFor example if prefix1 is \"abc\" and suffix1 is \"bcdef\" then \"a\" + suffix1 + \"z\" will actually match because it matches prefix1.\nFor the purposes of this test (for multiple patterns) I felt it was easier to guarantee non-overlap by working on different alphabets.", "author": "tvernum", "createdAt": "2020-12-18T05:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NjYwNA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r545586604", "bodyText": "Wow good point!", "author": "ywangd", "createdAt": "2020-12-18T05:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNzM2NA==", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r544007364", "bodyText": "Nit: why not use the equal method of randomUnicodeOfLengthBetween that is available as part of EsTestCase?\nAlso, if we test unicode for description here, should it also be tested for matching?", "author": "ywangd", "createdAt": "2020-12-16T06:08:44Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/support/StringMatcherTests.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class StringMatcherTests extends ESTestCase {\n+\n+    public void testEmptySet() throws Exception {\n+        final StringMatcher matcher = StringMatcher.of();\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(i, 20));\n+        }\n+    }\n+\n+    public void testSingleWildcard() throws Exception {\n+        final String prefix = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(prefix + \"*\");\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, prefix + randomAlphaOfLengthBetween(i, 20));\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(1, prefix.length() - 1));\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.startsWith(prefix), () -> randomAlphaOfLengthBetween(1, 8)));\n+        }\n+    }\n+\n+    public void testSingleExactMatch() throws Exception {\n+        final String str = randomAlphaOfLengthBetween(3, 12);\n+        final StringMatcher matcher = StringMatcher.of(str);\n+        assertMatch(matcher, str);\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.equals(str), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertNoMatch(matcher, randomAlphaOfLength(1) + str);\n+            assertNoMatch(matcher, str + randomAlphaOfLength(1));\n+        }\n+    }\n+\n+    public void testSingleRegex() throws Exception {\n+        final String notStr = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(\"/~(\" + notStr + \")/\");\n+        assertNoMatch(matcher, notStr);\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, randomValueOtherThanMany(s -> s.equals(notStr), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertMatch(matcher, randomAlphaOfLength(1) + notStr);\n+            assertMatch(matcher, notStr + randomAlphaOfLength(1));\n+        }\n+\n+    }\n+\n+    public void testMultiplePatterns() throws Exception {\n+        final String prefix1 = randomAlphaOfLengthBetween(3, 5);\n+        final String prefix2 = randomAlphaOfLengthBetween(5, 8);\n+        final String prefix3 = randomAlphaOfLengthBetween(10, 12);\n+        final String suffix1 = randomAlphaOfLengthBetween(5, 10);\n+        final String suffix2 = randomAlphaOfLengthBetween(8, 12);\n+        final String exact1 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(5, 9));\n+        final String exact2 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(10, 12));\n+        final String exact3 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(15, 20));\n+\n+        final StringMatcher matcher = StringMatcher.of(List.of(\n+            prefix1 + \"*\", prefix2 + \"?\", \"/\" + prefix3 + \"@/\", \"*\" + suffix1, \"/@\" + suffix2 + \"/\", exact1, exact2, exact3\n+        ));\n+\n+        assertMatch(matcher, exact1);\n+        assertMatch(matcher, exact2);\n+        assertMatch(matcher, exact3);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix1);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix2);\n+        assertMatch(matcher, prefix1 + randomAlphaOfLengthBetween(1, 5));\n+        assertMatch(matcher, prefix2 + randomAlphaOfLength(1));\n+        assertMatch(matcher, prefix3 + randomAlphaOfLengthBetween(1, 5));\n+\n+        assertNoMatch(matcher, prefix2 + randomAlphaOfLength(2));\n+\n+        final char[] nonAlpha = \"@/#$0123456789()[]{}<>;:%&\".toCharArray();\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact1, prefix1, suffix1) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact2, prefix2, suffix2) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact3, prefix3) + randomFrom(nonAlpha));\n+    }\n+\n+    public void testToString() throws Exception {\n+        // Replace any '/' characters because they're meaningful at the start, and just removing them all is simpler\n+        final String text1 = RandomizedTest.randomUnicodeOfLengthBetween(5, 80).replace('/', '.');\n+        final String text2 = RandomizedTest.randomUnicodeOfLength(20).replace('/', '.');\n+        final String text3 = RandomizedTest.randomUnicodeOfLength(50).replace('/', '.');", "originalCommit": "677f819709d790ad1004efcff79beea14aae2ea6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "09038d442b23be7dfba2546ad33e5e1758796ea4", "url": "https://github.com/elastic/elasticsearch/commit/09038d442b23be7dfba2546ad33e5e1758796ea4", "message": "Merge branch 'master' into feature/patterns-util-class", "committedDate": "2020-12-18T04:25:51Z", "type": "commit"}, {"oid": "ea6288ed505a5604c0d42eebba644cd2c56544d2", "url": "https://github.com/elastic/elasticsearch/commit/ea6288ed505a5604c0d42eebba644cd2c56544d2", "message": "More feedback", "committedDate": "2020-12-18T06:49:45Z", "type": "commit"}]}