{"pr_number": 61880, "pr_title": "Fix ILM history index settings", "pr_createdAt": "2020-09-02T19:58:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61880", "timeline": [{"oid": "15dee81bc771d8b07d76894961e6c861136b70f8", "url": "https://github.com/elastic/elasticsearch/commit/15dee81bc771d8b07d76894961e6c861136b70f8", "message": "fix ilm history settings", "committedDate": "2020-09-02T19:53:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2NDc0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61880#discussion_r482864743", "bodyText": "why would beforeBulk timeout? would removing the policy from the test index and/or stopping ILM solve the issue of outstanding ilm-history entries? (we're manually rolling over the ilm-history alias so ILM is only needed to trigger the creation of the first history index)", "author": "andreidan", "createdAt": "2020-09-03T10:08:55Z", "path": "x-pack/plugin/ilm/src/internalClusterTest/java/org/elasticsearch/xpack/ilm/ILMHistoryTests.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.admin.indices.get.GetIndexResponse;\n+import org.elasticsearch.action.admin.indices.rollover.RolloverResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction;\n+import org.elasticsearch.xpack.ilm.history.ILMHistoryStore;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.xpack.core.ilm.LifecyclePolicyTestsUtils.randomTimeseriesLifecyclePolicy;\n+import static org.hamcrest.Matchers.arrayContaining;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 1)\n+public class ILMHistoryTests extends ESIntegTestCase {\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        Settings.Builder settings = Settings.builder().put(super.nodeSettings(nodeOrdinal));\n+        settings.put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.SECURITY_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.WATCHER_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.GRAPH_ENABLED.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_POLL_INTERVAL, \"1s\");\n+        settings.put(LifecycleSettings.SLM_HISTORY_INDEX_ENABLED_SETTING.getKey(), false);\n+        return settings.build();\n+    }\n+\n+    @Override\n+    protected boolean ignoreExternalCluster() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(LocalStateCompositeXPackPlugin.class, IndexLifecycle.class);\n+    }\n+\n+    private void putTestPolicy() throws InterruptedException, java.util.concurrent.ExecutionException {\n+        LifecyclePolicy lifecyclePolicy = randomTimeseriesLifecyclePolicy(\"test\");\n+        PutLifecycleAction.Request putLifecycleRequest = new PutLifecycleAction.Request(lifecyclePolicy);\n+        PutLifecycleAction.Response putLifecycleResponse = client().execute(PutLifecycleAction.INSTANCE, putLifecycleRequest).get();\n+        assertAcked(putLifecycleResponse);\n+    }\n+\n+    public void testIlmHistoryIndexCanRollover() throws Exception {\n+        putTestPolicy();\n+        Settings settings = Settings.builder().put(indexSettings()).put(SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(SETTING_NUMBER_OF_REPLICAS, 0).put(LifecycleSettings.LIFECYCLE_NAME, \"test\").build();\n+        CreateIndexResponse res = client().admin().indices().prepareCreate(\"test\").setSettings(settings).get();\n+        assertTrue(res.isAcknowledged());\n+\n+        assertBusy(() -> {\n+            String firstIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000001\";\n+            try {\n+                GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().setIndices(firstIndex).get();\n+                assertThat(getIndexResponse.getIndices(), arrayContaining(firstIndex));\n+            } catch (Exception e) {\n+                fail(e.getMessage());\n+            }\n+        });\n+\n+        RolloverResponse rolloverResponse = client().admin().indices().prepareRolloverIndex(ILMHistoryStore.ILM_HISTORY_ALIAS).get();\n+        String secondIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000002\";\n+        assertTrue(rolloverResponse.isAcknowledged());\n+        assertThat(rolloverResponse.getNewIndex(), is(secondIndex));\n+\n+        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().setIndices(secondIndex).get();\n+        assertThat(getIndexResponse.getIndices(), arrayContaining(secondIndex));\n+\n+        //wait for all history items to index to avoid waiting for timeout in ILMHistoryStore beforeBulk\n+        Thread.sleep(6000);", "originalCommit": "15dee81bc771d8b07d76894961e6c861136b70f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxMjQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61880#discussion_r482912498", "bodyText": "I've changed it, I stop ILM to reduce amount of history items to index and I wait for the ones that are created. It should be better than explicit wait. WDYT?", "author": "probakowski", "createdAt": "2020-09-03T11:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2NDc0Mw=="}], "type": "inlineReview"}, {"oid": "7914c593f441785efb0ab8778a7b8bc824d8a671", "url": "https://github.com/elastic/elasticsearch/commit/7914c593f441785efb0ab8778a7b8bc824d8a671", "message": "change waiting condition", "committedDate": "2020-09-03T11:34:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4ODI2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61880#discussion_r482988261", "bodyText": "should we avoid the randomisation of the ILM policy and use an empty hot phase only ILM policy? that way we can assert exactly how many items must be inserted before moving on with the test tear down. I think there might be another race condition possible otherwise as the stop ILM call is not a hard stop but has to be detected and depending on what step we're in we might execute more steps (see https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleService.java#L133 )", "author": "andreidan", "createdAt": "2020-09-03T13:44:09Z", "path": "x-pack/plugin/ilm/src/internalClusterTest/java/org/elasticsearch/xpack/ilm/ILMHistoryTests.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.admin.indices.get.GetIndexResponse;\n+import org.elasticsearch.action.admin.indices.rollover.RolloverResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.StopILMRequest;\n+import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction;\n+import org.elasticsearch.xpack.core.ilm.action.StopILMAction;\n+import org.elasticsearch.xpack.ilm.history.ILMHistoryStore;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.index.query.QueryBuilders.matchQuery;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.xpack.core.ilm.LifecyclePolicyTestsUtils.randomTimeseriesLifecyclePolicy;\n+import static org.hamcrest.Matchers.arrayContaining;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 1)\n+public class ILMHistoryTests extends ESIntegTestCase {\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        Settings.Builder settings = Settings.builder().put(super.nodeSettings(nodeOrdinal));\n+        settings.put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.SECURITY_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.WATCHER_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.GRAPH_ENABLED.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_POLL_INTERVAL, \"1s\");\n+        settings.put(LifecycleSettings.SLM_HISTORY_INDEX_ENABLED_SETTING.getKey(), false);\n+        return settings.build();\n+    }\n+\n+    @Override\n+    protected boolean ignoreExternalCluster() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(LocalStateCompositeXPackPlugin.class, IndexLifecycle.class);\n+    }\n+\n+    private void putTestPolicy() throws InterruptedException, java.util.concurrent.ExecutionException {\n+        LifecyclePolicy lifecyclePolicy = randomTimeseriesLifecyclePolicy(\"test\");\n+        PutLifecycleAction.Request putLifecycleRequest = new PutLifecycleAction.Request(lifecyclePolicy);\n+        PutLifecycleAction.Response putLifecycleResponse = client().execute(PutLifecycleAction.INSTANCE, putLifecycleRequest).get();\n+        assertAcked(putLifecycleResponse);\n+    }\n+\n+    public void testIlmHistoryIndexCanRollover() throws Exception {\n+        putTestPolicy();\n+        Settings settings = Settings.builder().put(indexSettings()).put(SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(SETTING_NUMBER_OF_REPLICAS, 0).put(LifecycleSettings.LIFECYCLE_NAME, \"test\").build();\n+        CreateIndexResponse res = client().admin().indices().prepareCreate(\"test\").setSettings(settings).get();\n+        assertTrue(res.isAcknowledged());\n+\n+        String firstIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000001\";\n+        String secondIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000002\";\n+\n+        assertBusy(() -> {\n+            try {\n+                GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().setIndices(firstIndex).get();\n+                assertThat(getIndexResponse.getIndices(), arrayContaining(firstIndex));\n+            } catch (Exception e) {\n+                fail(e.getMessage());\n+            }\n+        });\n+\n+        assertTrue(client().execute(StopILMAction.INSTANCE, new StopILMRequest()).actionGet().isAcknowledged());\n+\n+        //wait for all history items to index to avoid waiting for timeout in ILMHistoryStore beforeBulk\n+        assertBusy(() -> {\n+            SearchResponse search = client().prepareSearch(firstIndex).setQuery(matchQuery(\"index\", firstIndex)).setSize(0).get();\n+            assertThat(search.getHits().getTotalHits().value, greaterThan(0L));", "originalCommit": "7914c593f441785efb0ab8778a7b8bc824d8a671", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MTMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/61880#discussion_r483071323", "bodyText": "You may be right there is still flakiness there. I've simplified policy, wait for exact number of messages to be indexed and wait for ILM to be stopped", "author": "probakowski", "createdAt": "2020-09-03T15:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4ODI2MQ=="}], "type": "inlineReview"}, {"oid": "582d05f1a77350ab9d69999fbd978027750ff198", "url": "https://github.com/elastic/elasticsearch/commit/582d05f1a77350ab9d69999fbd978027750ff198", "message": "derandomize policy + stopped ILM", "committedDate": "2020-09-03T15:27:37Z", "type": "commit"}, {"oid": "7a5d3c79c8eab925abea9fda446ffb553d6d0420", "url": "https://github.com/elastic/elasticsearch/commit/7a5d3c79c8eab925abea9fda446ffb553d6d0420", "message": "Merge branch 'master' into ilm-history-settings", "committedDate": "2020-09-03T15:38:30Z", "type": "commit"}]}