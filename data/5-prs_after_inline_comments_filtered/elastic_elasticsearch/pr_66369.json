{"pr_number": 66369, "pr_title": "Searchable snapshot rolling restart", "pr_createdAt": "2020-12-15T16:09:24Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66369", "timeline": [{"oid": "a4de2265bf4457a61b7dc4360d30fdc441c37bca", "url": "https://github.com/elastic/elasticsearch/commit/a4de2265bf4457a61b7dc4360d30fdc441c37bca", "message": "Searchable snapshot rolling restart\n\nAdd a new setting\n`xpack.searchable.snapshot.allocation.enable.primaries`\nthat indicates the behavior of searchable snapshots when the generic\n`cluster.routing.allocation.enable` setting is set to `primaries`.\nValid values are NONE and PRIMARIES (defer to generic decider). Defaults\nto NONE since this ensures existing rolling restart procedures do not\nreallocate searchable snapshot shards to other nodes.", "committedDate": "2020-12-15T16:08:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4MTM2OA==", "url": "https://github.com/elastic/elasticsearch/pull/66369#discussion_r543481368", "bodyText": "I think we don't need to assertBusy() here, if this fails even once then that's a fail.", "author": "DaveCTurner", "createdAt": "2020-12-15T16:12:38Z", "path": "x-pack/plugin/searchable-snapshots/src/internalClusterTest/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotEnableAllocationDeciderIntegTests.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.elasticsearch.client.Requests;\n+import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.snapshots.mockstore.MockRepository;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+import org.hamcrest.Matchers;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST)\n+public class SearchableSnapshotEnableAllocationDeciderIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins());\n+        plugins.add(MockRepository.Plugin.class);\n+        return plugins;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            // Use an unbound cache so we can recover the searchable snapshot completely all the times\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testAllocationDisabled() throws Exception {\n+        final String restoredIndexName = setupMountedIndex();\n+        int numPrimaries = getNumShards(restoredIndexName).numPrimaries;\n+        setEnableAllocation(EnableAllocationDecider.Allocation.PRIMARIES);\n+        if (randomBoolean()) {\n+            setSearchableSnapshotPrimariesAllocation(EnableAllocationDecider.Allocation.NONE);\n+        }\n+        Set<String> indexNodes = internalCluster().nodesInclude(restoredIndexName);\n+        for (String indexNode : indexNodes) {\n+            internalCluster().restartNode(indexNode);\n+        }\n+\n+        assertBusy(() -> {", "originalCommit": "a4de2265bf4457a61b7dc4360d30fdc441c37bca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4NTE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/66369#discussion_r543485149", "bodyText": "Hmm this means we have these options:\nxpack.searchable.snapshot.allocation.enable.primaries: none\nxpack.searchable.snapshot.allocation.enable.primaries: primaries\n\nThe repetition of primaries seems odd to me. I see that this is a bit nicer than a straight boolean, given the relationship to the other allocation decider, but how about these options instead?\nxpack.searchable.snapshot.allocation.enable: none\nxpack.searchable.snapshot.allocation.enable: all", "author": "DaveCTurner", "createdAt": "2020-12-15T16:17:20Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotEnableAllocationDecider.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+\n+public class SearchableSnapshotEnableAllocationDecider extends AllocationDecider {\n+\n+    static final String NAME = \"searchable_snapshots_enable\";\n+\n+    /**\n+     * This setting indicates the behavior of searchable snapshots when cluster.routing.allocation.enable=primaries\n+     *\n+     */\n+    public static final Setting<EnableAllocationDecider.Allocation> SEARCHABLE_SNAPSHOTS_ALLOCATION_ENABLE_PRIMARIES_SETTING =\n+        new Setting<>(\"xpack.searchable.snapshot.allocation.enable.primaries\", EnableAllocationDecider.Allocation.NONE.toString(),", "originalCommit": "a4de2265bf4457a61b7dc4360d30fdc441c37bca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMzg2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/66369#discussion_r543503866", "bodyText": "I misunderstood the precise meaning of this setting, sorry, it defaults to none!\nWe discussed this in another channel and decided a boolean called xpack.searchable.snapshot.allocate_on_rolling_restart which defaults to false.", "author": "DaveCTurner", "createdAt": "2020-12-15T16:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4NTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4NzkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/66369#discussion_r543487902", "bodyText": "I think this message is wrong, the decider return YES here because xpack.searchable.snapshot.allocation.enable.primaries: primaries permits it.", "author": "DaveCTurner", "createdAt": "2020-12-15T16:20:48Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotEnableAllocationDecider.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+\n+public class SearchableSnapshotEnableAllocationDecider extends AllocationDecider {\n+\n+    static final String NAME = \"searchable_snapshots_enable\";\n+\n+    /**\n+     * This setting indicates the behavior of searchable snapshots when cluster.routing.allocation.enable=primaries\n+     *\n+     */\n+    public static final Setting<EnableAllocationDecider.Allocation> SEARCHABLE_SNAPSHOTS_ALLOCATION_ENABLE_PRIMARIES_SETTING =\n+        new Setting<>(\"xpack.searchable.snapshot.allocation.enable.primaries\", EnableAllocationDecider.Allocation.NONE.toString(),\n+            SearchableSnapshotEnableAllocationDecider::parseSetting,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static EnableAllocationDecider.Allocation parseSetting(String value) {\n+        EnableAllocationDecider.Allocation allocation = EnableAllocationDecider.Allocation.parse(value);\n+        if (allocation == EnableAllocationDecider.Allocation.ALL || allocation == EnableAllocationDecider.Allocation.NEW_PRIMARIES) {\n+            throw new IllegalArgumentException(\"[\" + SEARCHABLE_SNAPSHOTS_ALLOCATION_ENABLE_PRIMARIES_SETTING.getKey() + \"=\" + allocation\n+                 + \"] is not valid\");\n+        }\n+        return allocation;\n+    }\n+\n+    private volatile EnableAllocationDecider.Allocation enableAllocation;\n+    private volatile EnableAllocationDecider.Allocation primariesAllocation;\n+\n+    public SearchableSnapshotEnableAllocationDecider(Settings settings, ClusterSettings clusterSettings) {\n+        this.enableAllocation = EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.get(settings);\n+        this.primariesAllocation = SEARCHABLE_SNAPSHOTS_ALLOCATION_ENABLE_PRIMARIES_SETTING.get(settings);\n+        assertSettingValue();\n+        clusterSettings.addSettingsUpdateConsumer(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING,\n+            this::setEnableAllocation);\n+        clusterSettings.addSettingsUpdateConsumer(SEARCHABLE_SNAPSHOTS_ALLOCATION_ENABLE_PRIMARIES_SETTING,\n+            this::setPrimariesAllocation);\n+    }\n+\n+    public void assertSettingValue() {\n+        assert this.primariesAllocation != EnableAllocationDecider.Allocation.ALL && this.primariesAllocation != EnableAllocationDecider.Allocation.NEW_PRIMARIES;\n+    }\n+\n+    private void setPrimariesAllocation(EnableAllocationDecider.Allocation allocation) {\n+        this.primariesAllocation = allocation;\n+        assertSettingValue();\n+    }\n+\n+    private void setEnableAllocation(EnableAllocationDecider.Allocation allocation) {\n+        this.enableAllocation = allocation;\n+    }\n+\n+    @Override\n+    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n+        return canAllocate(shardRouting, allocation);\n+    }\n+\n+    @Override\n+    public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n+        final IndexMetadata indexMetadata = allocation.metadata().getIndexSafe(shardRouting.index());\n+        if (SearchableSnapshotsConstants.isSearchableSnapshotStore(indexMetadata.getSettings())) {\n+            EnableAllocationDecider.Allocation enableAllocation = this.enableAllocation;\n+            EnableAllocationDecider.Allocation primariesAllocation = this.primariesAllocation;\n+            if (enableAllocation == EnableAllocationDecider.Allocation.PRIMARIES) {\n+                if (primariesAllocation == EnableAllocationDecider.Allocation.NONE) {\n+                    return allocation.decision(Decision.NO, NAME,\n+                        \"no allocations of searchable snapshots allowed due to [%s=%s] and [%s=%s]\",\n+                        EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(),\n+                        enableAllocation,\n+                        SEARCHABLE_SNAPSHOTS_ALLOCATION_ENABLE_PRIMARIES_SETTING.getKey(),\n+                        primariesAllocation\n+                    );\n+                } else {\n+                    return allocation.decision(Decision.YES, NAME, \"decider relies on generic enable decider\");", "originalCommit": "a4de2265bf4457a61b7dc4360d30fdc441c37bca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2d7aecc3ca98e751663fcb7056a1b5d9a6434d13", "url": "https://github.com/elastic/elasticsearch/commit/2d7aecc3ca98e751663fcb7056a1b5d9a6434d13", "message": "Changed name and type of setting and messages.", "committedDate": "2020-12-15T16:59:21Z", "type": "commit"}]}