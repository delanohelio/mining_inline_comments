{"pr_number": 65489, "pr_title": "Introduce dynamic runtime setting", "pr_createdAt": "2020-11-25T10:51:21Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65489", "timeline": [{"oid": "4616173c4106edf5c416abfc6d6aa766b46e91b0", "url": "https://github.com/elastic/elasticsearch/commit/4616173c4106edf5c416abfc6d6aa766b46e91b0", "message": "WIP: introduce new dynamic runtime setting\n\nThe dynamic:runtime setting is similar to dynamic:true in that it dynamically defines fields based on values parsed from incoming documents. Though instead of defining leaf fields under properties, it defines them as runtime fields under the runtime section. This is useful in scenarios where search speed can be traded for storage costs, given that runtime fields are loaded at runtime rather than indexed.", "committedDate": "2020-11-25T10:21:18Z", "type": "commit"}, {"oid": "5f037e4fee151ace6f63605d7b55de6120c0e7b7", "url": "https://github.com/elastic/elasticsearch/commit/5f037e4fee151ace6f63605d7b55de6120c0e7b7", "message": "Merge branch 'master' into enhancement/dynamic_runtime_mode", "committedDate": "2020-11-25T10:22:59Z", "type": "commit"}, {"oid": "34ed3994b22f11fe94cadc72434f84014cea0e81", "url": "https://github.com/elastic/elasticsearch/commit/34ed3994b22f11fe94cadc72434f84014cea0e81", "message": "iter", "committedDate": "2020-11-25T10:39:39Z", "type": "commit"}, {"oid": "8b2bcaabf8101e523b4b0ef5d10d2967aff20f09", "url": "https://github.com/elastic/elasticsearch/commit/8b2bcaabf8101e523b4b0ef5d10d2967aff20f09", "message": "iter", "committedDate": "2020-11-25T10:50:29Z", "type": "commit"}, {"oid": "0841dc140129a1be836c133a965db0593bfd5d0b", "url": "https://github.com/elastic/elasticsearch/commit/0841dc140129a1be836c133a965db0593bfd5d0b", "message": "iter", "committedDate": "2020-11-25T11:05:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MTg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532791868", "bodyText": "I'm curious why you don't make it an interface.", "author": "nik9000", "createdAt": "2020-11-30T17:59:30Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.time.DateFormatter;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Encapsulates the logic for dynamically creating fields based on values parsed from incoming documents.\n+ */\n+abstract class DynamicFieldsBuilder {", "originalCommit": "0841dc140129a1be836c133a965db0593bfd5d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2NjYyOA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532866628", "bodyText": "good question, I initially used an interface, but everything in the file is public by default then and all the methods can only be public which I dislike very much.", "author": "javanna", "createdAt": "2020-11-30T19:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MTg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzU1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532793551", "bodyText": "Could we use DynamicFieldsBuilder instead? And let the runtime plugin delegate for binary fields? Should we throw an exception for binary fields instead? Or not create them at all? It fields weird that runtime:dynamic could make non-dynamic fields.", "author": "nik9000", "createdAt": "2020-11-30T18:02:02Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DynamicRuntimeFieldsBuilder.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.time.DateFormatter;\n+import org.elasticsearch.plugins.MapperPlugin;\n+\n+/**\n+ * Defines how runtime fields are created dynamically. Used when objects are mapped with dynamic:runtime.\n+ * @see MapperPlugin#getDynamicRuntimeFieldsBuilder()\n+ */\n+public interface DynamicRuntimeFieldsBuilder {", "originalCommit": "0841dc140129a1be836c133a965db0593bfd5d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2ODY0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532868645", "bodyText": "This one can only even return RuntimeFieldType, hence runtime in its name seems a good fit? the binary field situation is indeed a bit weird. The point of having this different interface for plugins is that the return type can only be RuntimeFieldType. The other internal abstraction returns DynamicField which is really some internal shenanigans to wrap either a mapper or a runtime field type, something that I would not want to expose to plugins.", "author": "javanna", "createdAt": "2020-11-30T20:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3NDc2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532874762", "bodyText": "Yeah, that makes sense. I you are calling it dynamic: runtime. It'd be weird to return something else!", "author": "nik9000", "createdAt": "2020-11-30T20:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTIxNA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532795214", "bodyText": "Could we have this return the DynamicFieldsBuilder` or something like it? It kind of feels weird to have the way we handle dynamic fields controlled both by this enum and a pluggable behavior layer.", "author": "nik9000", "createdAt": "2020-11-30T18:04:49Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -540,10 +543,9 @@ private static void parseArray(ParseContext context, ObjectMapper parentMapper,\n             Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, parentMapper);\n             parentMapper = parentMapperTuple.v2();\n             ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context);\n-            if (dynamic == ObjectMapper.Dynamic.STRICT) {\n-                throw new StrictDynamicMappingException(parentMapper.fullPath(), arrayFieldName);\n-            } else if (dynamic == ObjectMapper.Dynamic.TRUE) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, arrayFieldName, XContentFieldType.OBJECT);\n+            if (dynamic.canCreateDynamicFields()) {", "originalCommit": "0841dc140129a1be836c133a965db0593bfd5d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3MTM3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532871371", "bodyText": "the idea is that this new method on the enum removes the need for the if (dynamic == RUNTIME || dynamic == TRUE) all over the place. I could see how we would forget for instance RUNTIME in some places while this way it is streamlined. At the same time, we don't want to make other dynamic modes pluggable, and actually it is only sort of pluggable for the  runtime mode, in that the mapping between the runtime fields and their dynamic type needs to be provided by the plugin. Does that make sense? I am not sure what you were proposing though.", "author": "javanna", "createdAt": "2020-11-30T20:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3NTM1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532875357", "bodyText": "I'm sort of wondering if the enum can build the DynamicFieldsBuilder and the strict one can throw and the false one can noop.", "author": "nik9000", "createdAt": "2020-11-30T20:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NDM5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532884393", "bodyText": "I see, I briefly also considered this, and then I went for not making the enum bigger. I will have a look if this simplifies things.", "author": "javanna", "createdAt": "2020-11-30T20:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532795842", "bodyText": "dynamicOrDefault has this:\n            if (parentMapper == null) {\n                // If parentMapper is ever null, it means the parent of the current mapper was dynamically created.\n                // But in order to be created dynamically, the dynamic setting of that parent was necessarily true\n                return ObjectMapper.Dynamic.TRUE;\n            }\n\nwhich worries me a bit. Should that depend on the configured dynamic value?", "author": "nik9000", "createdAt": "2020-11-30T18:05:57Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -540,10 +543,9 @@ private static void parseArray(ParseContext context, ObjectMapper parentMapper,\n             Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, parentMapper);\n             parentMapper = parentMapperTuple.v2();\n             ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context);", "originalCommit": "0841dc140129a1be836c133a965db0593bfd5d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NzUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532797501", "bodyText": "It might not be a problem, but it is worth an extra comment explaining why not.", "author": "nik9000", "createdAt": "2020-11-30T18:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3MjA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532872040", "bodyText": "well spotted, I actually need to double check if this may cause troubles, I am not 100% sure yet.", "author": "javanna", "createdAt": "2020-11-30T20:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MDk2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537660965", "bodyText": "this was indeed a bug, should be fixed now but I had to add a way to retrieve dynamically created objects, as we can no longer assume TRUE now, it could also be RUNTIME.", "author": "javanna", "createdAt": "2020-12-07T16:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NjU2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532796567", "bodyText": "Neat!", "author": "nik9000", "createdAt": "2020-11-30T18:07:08Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -679,63 +669,29 @@ private static void parseNullValue(ParseContext context, ObjectMapper parentMapp\n                         // failure to parse this, continue\n                         continue;\n                     }\n-                    Mapper.Builder builder\n-                        = context.root().findTemplateBuilder(context, currentFieldName, dateTimeFormatter);\n-                    if (builder == null) {\n-                        boolean ignoreMalformed = IGNORE_MALFORMED_SETTING.get(context.indexSettings().getSettings());\n-                        builder = new DateFieldMapper.Builder(currentFieldName, DateFieldMapper.Resolution.MILLISECONDS,\n-                            dateTimeFormatter, ignoreMalformed, Version.indexCreated(context.indexSettings().getSettings()));\n-                    }\n-                    return builder;\n-\n+                    return dynamicFieldsBuilder.newDynamicDateField(context, currentFieldName, dateTimeFormatter);\n                 }\n             }\n-\n-            Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.STRING);\n-            if (builder == null) {\n-                builder = new TextFieldMapper.Builder(currentFieldName,\n-                    () -> context.indexAnalyzers().getDefaultIndexAnalyzer())\n-                        .addMultiField(new KeywordFieldMapper.Builder(\"keyword\").ignoreAbove(256));\n-            }\n-            return builder;\n+            return dynamicFieldsBuilder.newDynamicStringField(context, currentFieldName);\n         } else if (token == XContentParser.Token.VALUE_NUMBER) {\n             XContentParser.NumberType numberType = context.parser().numberType();\n             if (numberType == XContentParser.NumberType.INT\n                     || numberType == XContentParser.NumberType.LONG\n                     || numberType == XContentParser.NumberType.BIG_INTEGER) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.LONG);\n-                if (builder == null) {\n-                    builder = newLongBuilder(currentFieldName, context.indexSettings().getSettings());\n-                }\n-                return builder;\n+                return dynamicFieldsBuilder.newDynamicLongField(context, currentFieldName);\n             } else if (numberType == XContentParser.NumberType.FLOAT\n                     || numberType == XContentParser.NumberType.DOUBLE\n                     || numberType == XContentParser.NumberType.BIG_DECIMAL) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.DOUBLE);\n-                if (builder == null) {\n-                    // no templates are defined, we use float by default instead of double\n-                    // since this is much more space-efficient and should be enough most of\n-                    // the time\n-                    builder = newFloatBuilder(currentFieldName, context.indexSettings().getSettings());\n-                }\n-                return builder;\n+                return dynamicFieldsBuilder.newDynamicDoubleField(context, currentFieldName);\n             }\n         } else if (token == XContentParser.Token.VALUE_BOOLEAN) {\n-            Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.BOOLEAN);\n-            if (builder == null) {\n-                builder = new BooleanFieldMapper.Builder(currentFieldName);\n-            }\n-            return builder;\n+            return dynamicFieldsBuilder.newDynamicBooleanField(context, currentFieldName);\n         } else if (token == XContentParser.Token.VALUE_EMBEDDED_OBJECT) {\n-            Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.BINARY);\n-            if (builder == null) {\n-                builder = new BinaryFieldMapper.Builder(currentFieldName);\n-            }\n-            return builder;\n+            return dynamicFieldsBuilder.newDynamicBinaryField(context, currentFieldName);", "originalCommit": "0841dc140129a1be836c133a965db0593bfd5d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NzMzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532797331", "bodyText": "Maybe the builders should call these methods on the context?", "author": "nik9000", "createdAt": "2020-11-30T18:08:23Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -752,11 +708,15 @@ private static void parseDynamicValue(final ParseContext context, ObjectMapper p\n         if (dynamic == ObjectMapper.Dynamic.FALSE) {\n             return;\n         }\n-        final Mapper.Builder builder = createBuilderFromDynamicValue(context, token, currentFieldName);\n-        Mapper mapper = builder.build(context.path());\n-        context.addDynamicMapper(mapper);\n-\n-        parseObjectOrField(context, mapper);\n+        DynamicFieldsBuilder dynamicFieldsBuilder = DynamicFieldsBuilder.forDynamic(dynamic);\n+        DynamicField dynamicField = createDynamicFieldFromValue(context, token, currentFieldName, dynamicFieldsBuilder);\n+        if (dynamicField.isRuntimeField()) {", "originalCommit": "0841dc140129a1be836c133a965db0593bfd5d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3MjU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532872571", "bodyText": "can you expand? I don't follow", "author": "javanna", "createdAt": "2020-11-30T20:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3NjIxMw==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532876213", "bodyText": "Like, instead of returning the runtime field or whatever it can just call addDynamicRuntimeField if it is making a runtime field or addDynamicMapper if it is making a dynamic mapper.", "author": "nik9000", "createdAt": "2020-11-30T20:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NTI0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r532885247", "bodyText": "ah I see, this makes sense, I will try this out.", "author": "javanna", "createdAt": "2020-11-30T20:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NzMzMQ=="}], "type": "inlineReview"}, {"oid": "07de311615d63ce193b22d4ddac32b15e12992f6", "url": "https://github.com/elastic/elasticsearch/commit/07de311615d63ce193b22d4ddac32b15e12992f6", "message": "Merge branch 'master' into enhancement/dynamic_runtime_mode", "committedDate": "2020-12-04T11:30:19Z", "type": "commit"}, {"oid": "d5587f7c0e412e14a6b04b75646c3e8566bebe9b", "url": "https://github.com/elastic/elasticsearch/commit/d5587f7c0e412e14a6b04b75646c3e8566bebe9b", "message": "checkstyle", "committedDate": "2020-12-04T12:01:08Z", "type": "commit"}, {"oid": "222321d4c7cfe37b55217a79b898173a039b709d", "url": "https://github.com/elastic/elasticsearch/commit/222321d4c7cfe37b55217a79b898173a039b709d", "message": "iter", "committedDate": "2020-12-04T12:34:59Z", "type": "commit"}, {"oid": "e08844e005976e15708bf10b13d12e26a46bbc0a", "url": "https://github.com/elastic/elasticsearch/commit/e08844e005976e15708bf10b13d12e26a46bbc0a", "message": "iter", "committedDate": "2020-12-04T17:05:35Z", "type": "commit"}, {"oid": "26a559a0a06a6cef6b9b87ab3164da0989aa5bc5", "url": "https://github.com/elastic/elasticsearch/commit/26a559a0a06a6cef6b9b87ab3164da0989aa5bc5", "message": "Merge branch 'master' into enhancement/dynamic_runtime_mode", "committedDate": "2020-12-04T17:22:58Z", "type": "commit"}, {"oid": "f528d2651ee96fb6f37e2524e0004da13414f97c", "url": "https://github.com/elastic/elasticsearch/commit/f528d2651ee96fb6f37e2524e0004da13414f97c", "message": "fix date creation", "committedDate": "2020-12-04T17:51:07Z", "type": "commit"}, {"oid": "776fb4e634711d5669b9aca01c435978e85be5d4", "url": "https://github.com/elastic/elasticsearch/commit/776fb4e634711d5669b9aca01c435978e85be5d4", "message": "iter", "committedDate": "2020-12-04T17:51:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI3ODAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r536278015", "bodyText": "this is all moved to DynamicFieldsBuilder now. it simplifies things as we no longer need to return either a runtime field or a mapper builder. We can directly do what's necessary, meaning adding the field where appropriate to the context, and potentially going further with parsing for concrete fields.", "author": "javanna", "createdAt": "2020-12-04T17:59:27Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -626,122 +623,6 @@ private static void parseNullValue(ParseContext context, ObjectMapper parentMapp\n         }\n     }\n \n-    private static Mapper.Builder newLongBuilder(String name, Settings settings) {\n-        return new NumberFieldMapper.Builder(name, NumberFieldMapper.NumberType.LONG, settings);\n-    }\n-\n-    private static Mapper.Builder newFloatBuilder(String name, Settings settings) {\n-        return new NumberFieldMapper.Builder(name, NumberFieldMapper.NumberType.FLOAT, settings);\n-    }\n-\n-    private static Mapper.Builder createBuilderFromDynamicValue(final ParseContext context,\n-                                                                     XContentParser.Token token,\n-                                                                     String currentFieldName) throws IOException {\n-        if (token == XContentParser.Token.VALUE_STRING) {\n-            String text = context.parser().text();\n-\n-            boolean parseableAsLong = false;\n-            try {\n-                Long.parseLong(text);\n-                parseableAsLong = true;\n-            } catch (NumberFormatException e) {\n-                // not a long number\n-            }\n-\n-            boolean parseableAsDouble = false;\n-            try {\n-                Double.parseDouble(text);\n-                parseableAsDouble = true;\n-            } catch (NumberFormatException e) {\n-                // not a double number\n-            }\n-\n-            if (parseableAsLong && context.root().numericDetection()) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.LONG);\n-                if (builder == null) {\n-                    builder = newLongBuilder(currentFieldName, context.indexSettings().getSettings());\n-                }\n-                return builder;\n-            } else if (parseableAsDouble && context.root().numericDetection()) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.DOUBLE);\n-                if (builder == null) {\n-                    builder = newFloatBuilder(currentFieldName, context.indexSettings().getSettings());\n-                }\n-                return builder;\n-            } else if (parseableAsLong == false && parseableAsDouble == false && context.root().dateDetection()) {\n-                // We refuse to match pure numbers, which are too likely to be\n-                // false positives with date formats that include eg.\n-                // `epoch_millis` or `YYYY`\n-                for (DateFormatter dateTimeFormatter : context.root().dynamicDateTimeFormatters()) {\n-                    try {\n-                        dateTimeFormatter.parse(text);\n-                    } catch (ElasticsearchParseException | DateTimeParseException | IllegalArgumentException e) {\n-                        // failure to parse this, continue\n-                        continue;\n-                    }\n-                    Mapper.Builder builder\n-                        = context.root().findTemplateBuilder(context, currentFieldName, dateTimeFormatter);\n-                    if (builder == null) {\n-                        boolean ignoreMalformed = IGNORE_MALFORMED_SETTING.get(context.indexSettings().getSettings());\n-                        builder = new DateFieldMapper.Builder(currentFieldName, DateFieldMapper.Resolution.MILLISECONDS,\n-                            dateTimeFormatter, ignoreMalformed, context.indexSettings().getIndexVersionCreated());\n-                    }\n-                    return builder;\n-\n-                }\n-            }\n-\n-            Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.STRING);\n-            if (builder == null) {\n-                builder = new TextFieldMapper.Builder(currentFieldName, context.indexAnalyzers())\n-                        .addMultiField(new KeywordFieldMapper.Builder(\"keyword\").ignoreAbove(256));\n-            }\n-            return builder;\n-        } else if (token == XContentParser.Token.VALUE_NUMBER) {\n-            XContentParser.NumberType numberType = context.parser().numberType();\n-            if (numberType == XContentParser.NumberType.INT\n-                    || numberType == XContentParser.NumberType.LONG\n-                    || numberType == XContentParser.NumberType.BIG_INTEGER) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.LONG);\n-                if (builder == null) {\n-                    builder = newLongBuilder(currentFieldName, context.indexSettings().getSettings());\n-                }\n-                return builder;\n-            } else if (numberType == XContentParser.NumberType.FLOAT\n-                    || numberType == XContentParser.NumberType.DOUBLE\n-                    || numberType == XContentParser.NumberType.BIG_DECIMAL) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.DOUBLE);\n-                if (builder == null) {\n-                    // no templates are defined, we use float by default instead of double\n-                    // since this is much more space-efficient and should be enough most of\n-                    // the time\n-                    builder = newFloatBuilder(currentFieldName, context.indexSettings().getSettings());\n-                }\n-                return builder;\n-            }\n-        } else if (token == XContentParser.Token.VALUE_BOOLEAN) {\n-            Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.BOOLEAN);\n-            if (builder == null) {\n-                builder = new BooleanFieldMapper.Builder(currentFieldName);\n-            }\n-            return builder;\n-        } else if (token == XContentParser.Token.VALUE_EMBEDDED_OBJECT) {\n-            Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.BINARY);\n-            if (builder == null) {\n-                builder = new BinaryFieldMapper.Builder(currentFieldName);\n-            }\n-            return builder;\n-        } else {\n-            Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.STRING);\n-            if (builder != null) {\n-                return builder;\n-            }\n-        }\n-        // TODO how do we identify dynamically that its a binary value?\n-        throw new IllegalStateException(\"Can't handle serializing a dynamic type with content token [\" + token + \"] and field name [\"\n-            + currentFieldName + \"]\");\n-    }\n-", "originalCommit": "776fb4e634711d5669b9aca01c435978e85be5d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a9e625c4c0e38d4901cd7e556b974ec6325b549", "url": "https://github.com/elastic/elasticsearch/commit/3a9e625c4c0e38d4901cd7e556b974ec6325b549", "message": "docs and rename", "committedDate": "2020-12-04T18:09:07Z", "type": "commit"}, {"oid": "8952c53859bc163158c5d319e480127938acb74e", "url": "https://github.com/elastic/elasticsearch/commit/8952c53859bc163158c5d319e480127938acb74e", "message": "iter", "committedDate": "2020-12-04T20:41:07Z", "type": "commit"}, {"oid": "edc6a29d20679e287dc6863bf2b0761ae6a1bbf2", "url": "https://github.com/elastic/elasticsearch/commit/edc6a29d20679e287dc6863bf2b0761ae6a1bbf2", "message": "Merge branch 'master' into enhancement/dynamic_runtime_mode", "committedDate": "2020-12-07T09:28:54Z", "type": "commit"}, {"oid": "c2e9797297bc517784ddb9604ad8d4e33fc0d2e3", "url": "https://github.com/elastic/elasticsearch/commit/c2e9797297bc517784ddb9604ad8d4e33fc0d2e3", "message": "iter and some tests", "committedDate": "2020-12-07T16:46:22Z", "type": "commit"}, {"oid": "114b5f412aca7db5be18dcb890323b2b3d67fb26", "url": "https://github.com/elastic/elasticsearch/commit/114b5f412aca7db5be18dcb890323b2b3d67fb26", "message": "spotless", "committedDate": "2020-12-07T16:51:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NDk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537664944", "bodyText": "this is pretty horrible. I am not sure how to make it better yet. We are introducing one reason to update the root without having to add a mapper to it.", "author": "javanna", "createdAt": "2020-12-07T16:55:28Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -206,18 +204,35 @@ private static MapperParsingException wrapInMapperParsingException(SourceToParse\n     }\n \n     /** Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings. */\n-    static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {\n-        if (dynamicMappers.isEmpty()) {\n+    static Mapping createDynamicUpdate(Mapping mapping,\n+                                       DocumentMapper docMapper,\n+                                       List<Mapper> dynamicMappers,\n+                                       List<RuntimeFieldType> dynamicRuntimeFields) {\n+        if (dynamicMappers.isEmpty() && dynamicRuntimeFields.isEmpty()) {\n             return null;\n         }\n+        RootObjectMapper root;\n+        if (dynamicMappers.isEmpty() == false) {\n+            root = createDynamicUpdate(mapping.root, docMapper, dynamicMappers);\n+        } else {\n+            root = (RootObjectMapper)mapping.root.mappingUpdate(null);", "originalCommit": "114b5f412aca7db5be18dcb890323b2b3d67fb26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgzOTQ4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537839486", "bodyText": "Passing null to make a copy is a bit sad, yeah. Maybe we could have a copy method?", "author": "nik9000", "createdAt": "2020-12-07T21:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NDk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0MTkwNw==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r538241907", "bodyText": "I followed this approach and things do look a bit better, thanks!", "author": "javanna", "createdAt": "2020-12-08T10:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NDk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NzQ1OA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537667458", "bodyText": "this is not particularly elegant, but it does the job. Ideas on how to make it nicer?", "author": "javanna", "createdAt": "2020-12-07T16:58:34Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java", "diffHunk": "@@ -407,6 +432,9 @@ public void seqID(SeqNoFieldMapper.SequenceIDFields seqID) {\n \n         @Override\n         public void addDynamicMapper(Mapper mapper) {\n+            if (mapper instanceof ObjectMapper) {\n+                dynamicObjectMappers.put(mapper.name(), (ObjectMapper)mapper);\n+            }", "originalCommit": "114b5f412aca7db5be18dcb890323b2b3d67fb26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MTk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537841944", "bodyText": "Not really.... We do a fair bit of `instanceof to dig up ObjectMapper and its friends like MetaDataFieldMapper. It ain't great but its what we do a fair bit.....", "author": "nik9000", "createdAt": "2020-12-07T21:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NzQ1OA=="}], "type": "inlineReview"}, {"oid": "9e6f13e7a4cf1c7ed3c335174bbfdbf119c89543", "url": "https://github.com/elastic/elasticsearch/commit/9e6f13e7a4cf1c7ed3c335174bbfdbf119c89543", "message": "iter", "committedDate": "2020-12-07T20:51:28Z", "type": "commit"}, {"oid": "613b88289da91d4d804e4ba16daa4b0fccc7f58d", "url": "https://github.com/elastic/elasticsearch/commit/613b88289da91d4d804e4ba16daa4b0fccc7f58d", "message": "iter", "committedDate": "2020-12-07T21:07:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgzOTg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537839886", "bodyText": "Leftover?", "author": "nik9000", "createdAt": "2020-12-07T21:18:37Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -542,25 +552,24 @@ private static void parseArray(ParseContext context, ObjectMapper parentMapper,\n             ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context);\n             if (dynamic == ObjectMapper.Dynamic.STRICT) {\n                 throw new StrictDynamicMappingException(parentMapper.fullPath(), arrayFieldName);\n-            } else if (dynamic == ObjectMapper.Dynamic.TRUE) {\n-                Mapper.Builder builder = context.root().findTemplateBuilder(context, arrayFieldName, XContentFieldType.OBJECT);\n-                if (builder == null) {\n+            } else if (dynamic == ObjectMapper.Dynamic.FALSE)  {\n+                // TODO: shouldn't this skip, not parse?", "originalCommit": "613b88289da91d4d804e4ba16daa4b0fccc7f58d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1MzQ1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537853456", "bodyText": "no this is only moved, it is one of those TODOs that have been there forever. I was planning on leaving it", "author": "javanna", "createdAt": "2020-12-07T21:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgzOTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537842378", "bodyText": "Probably should add javadoc for this.", "author": "nik9000", "createdAt": "2020-12-07T21:22:49Z", "path": "server/src/main/java/org/elasticsearch/plugins/MapperPlugin.java", "diffHunk": "@@ -48,6 +49,10 @@\n         return Collections.emptyMap();\n     }\n \n+    default DynamicRuntimeFieldsBuilder getDynamicRuntimeFieldsBuilder() {", "originalCommit": "613b88289da91d4d804e4ba16daa4b0fccc7f58d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MzM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r537843360", "bodyText": "Probably worth javadoc on these if we have more than one.", "author": "nik9000", "createdAt": "2020-12-07T21:24:25Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/DateScriptFieldType.java", "diffHunk": "@@ -100,6 +99,17 @@ private DateScriptFieldType(String name, DateFieldScript.Factory scriptFactory,\n         this.dateMathParser = dateTimeFormatter.toDateMathParser();\n     }\n \n+    DateScriptFieldType(String name) {", "originalCommit": "613b88289da91d4d804e4ba16daa4b0fccc7f58d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5fc23fb384aa5cff9165b601105fc2c3253d3d9", "url": "https://github.com/elastic/elasticsearch/commit/f5fc23fb384aa5cff9165b601105fc2c3253d3d9", "message": "missing javadoc", "committedDate": "2020-12-07T21:50:08Z", "type": "commit"}, {"oid": "2b05ca32bf118c70f112291fac2e9e5e821892e8", "url": "https://github.com/elastic/elasticsearch/commit/2b05ca32bf118c70f112291fac2e9e5e821892e8", "message": "iter", "committedDate": "2020-12-07T22:41:26Z", "type": "commit"}, {"oid": "e64ad64aef52706f8b6c70d7871d5801eb33f611", "url": "https://github.com/elastic/elasticsearch/commit/e64ad64aef52706f8b6c70d7871d5801eb33f611", "message": "Merge branch 'master' into enhancement/dynamic_runtime_mode", "committedDate": "2020-12-07T22:41:43Z", "type": "commit"}, {"oid": "b1918f84d332973f5ace6e5420e00789d127509c", "url": "https://github.com/elastic/elasticsearch/commit/b1918f84d332973f5ace6e5420e00789d127509c", "message": "iter", "committedDate": "2020-12-08T07:58:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3ODU0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r538178548", "bodyText": "I think we should rework this to use ObjectMapper.Builder so that we can make the actual mappings immutable, but let's do that in a followup.", "author": "romseygeek", "createdAt": "2020-12-08T09:33:18Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -206,18 +204,35 @@ private static MapperParsingException wrapInMapperParsingException(SourceToParse\n     }\n \n     /** Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings. */\n-    static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {\n-        if (dynamicMappers.isEmpty()) {\n+    static Mapping createDynamicUpdate(Mapping mapping,\n+                                       DocumentMapper docMapper,\n+                                       List<Mapper> dynamicMappers,\n+                                       List<RuntimeFieldType> dynamicRuntimeFields) {\n+        if (dynamicMappers.isEmpty() && dynamicRuntimeFields.isEmpty()) {\n             return null;\n         }\n+        RootObjectMapper root;\n+        if (dynamicMappers.isEmpty() == false) {\n+            root = createDynamicUpdate(mapping.root, docMapper, dynamicMappers);\n+        } else {\n+            root = mapping.root.copyAndReset();\n+        }\n+        root.addRuntimeFields(dynamicRuntimeFields);\n+        return mapping.mappingUpdate(root);\n+    }", "originalCommit": "b1918f84d332973f5ace6e5420e00789d127509c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyMzA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r538223085", "bodyText": "agreed, this improvement is already listed here: #64663", "author": "javanna", "createdAt": "2020-12-08T10:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3ODU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwMzA2MA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r538203060", "bodyText": "Are we happy that this intermediate object with no concrete leaf fields gets added?  It feels a bit weird to me, but I can see how it ends up being necessary because of all the book-keeping we do while we create dynamic mappings during parsing.", "author": "romseygeek", "createdAt": "2020-12-08T10:06:05Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java", "diffHunk": "@@ -378,6 +384,36 @@ public void testPropagateDynamicWithDynamicMapper() throws Exception {\n         assertNotNull(doc.rootDoc().getField(\"foo.bar.baz\"));\n     }\n \n+    public void testPropagateDynamicRuntimeWithDynamicMapper() throws Exception {\n+        DocumentMapper mapper = createDocumentMapper(topMapping(b -> {\n+            b.field(\"dynamic\", false);\n+            b.startObject(\"properties\");\n+            {\n+                b.startObject(\"foo\");\n+                {\n+                    b.field(\"type\", \"object\");\n+                    b.field(\"dynamic\", \"runtime\");\n+                    b.startObject(\"properties\").endObject();\n+                }\n+                b.endObject();\n+            }\n+            b.endObject();\n+        }));\n+        ParsedDocument doc = mapper.parse(source(b -> {\n+            b.startObject(\"foo\");\n+            {\n+                b.field(\"baz\", \"test\");\n+                b.startObject(\"bar\").field(\"baz\", \"something\").endObject();\n+            }\n+            b.endObject();\n+        }));\n+        assertNull(doc.rootDoc().getField(\"foo.bar.baz\"));\n+        assertEquals(\"{\\\"_doc\\\":{\\\"dynamic\\\":\\\"false\\\",\" +\n+            \"\\\"runtime\\\":{\\\"foo.bar.baz\\\":{\\\"type\\\":\\\"string\\\"},\\\"foo.baz\\\":{\\\"type\\\":\\\"string\\\"}},\" +\n+            \"\\\"properties\\\":{\\\"foo\\\":{\\\"dynamic\\\":\\\"runtime\\\",\\\"properties\\\":{\\\"bar\\\":{\\\"type\\\":\\\"object\\\"}}}}}}\",", "originalCommit": "b1918f84d332973f5ace6e5420e00789d127509c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyODAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r538228013", "bodyText": "good question: I have wondered the same, and wondered also: what do we do when a document is sent which contains no leaf fields, only objects? Effectively no lucene fields (besides metadata fields) are created, yet we map the objects. I followed the same pattern here, which kind of fits in the runtime section design, as it is applied on top of mappings, hence it is natural that it does not hold objects, and that only the leaf fields get mapped in there. As a consequence, unseen objects get dynamically mapped under properties in dynamic runtime mode. I can see how this may feel weird at first glance, though I wonder what the alternatives are, and what the downsides could be of this approach.", "author": "javanna", "createdAt": "2020-12-08T10:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwMzA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzM4Nzc4NA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r653387784", "bodyText": "replying to myself 6 months later: this would be the main downside of dynamically mapping objects under dynamic:runtime: #70268 . I am thinking now that it makes more sense to skip mapping objects in dynamic runtime mode.", "author": "javanna", "createdAt": "2021-06-17T09:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwMzA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwOTgxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r538209811", "bodyText": "Shouldn't this take the date formatter into account?", "author": "romseygeek", "createdAt": "2020-12-08T10:15:36Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/DynamicRuntimeFieldsBuilder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.elasticsearch.common.time.DateFormatter;\n+import org.elasticsearch.index.mapper.RuntimeFieldType;\n+\n+public final class DynamicRuntimeFieldsBuilder implements org.elasticsearch.index.mapper.DynamicRuntimeFieldsBuilder {\n+\n+    public static final DynamicRuntimeFieldsBuilder INSTANCE = new DynamicRuntimeFieldsBuilder();\n+\n+    private DynamicRuntimeFieldsBuilder() {}\n+\n+    @Override\n+    public RuntimeFieldType newDynamicStringField(String name) {\n+        return new KeywordScriptFieldType(name);\n+    }\n+\n+    @Override\n+    public RuntimeFieldType newDynamicLongField(String name) {\n+        return new LongScriptFieldType(name);\n+    }\n+\n+    @Override\n+    public RuntimeFieldType newDynamicDoubleField(String name) {\n+        return new DoubleScriptFieldType(name);\n+    }\n+\n+    @Override\n+    public RuntimeFieldType newDynamicBooleanField(String name) {\n+        return new BooleanScriptFieldType(name);\n+    }\n+\n+    @Override\n+    public RuntimeFieldType newDynamicDateField(String name, DateFormatter dateFormatter) {\n+        return new DateScriptFieldType(name);", "originalCommit": "b1918f84d332973f5ace6e5420e00789d127509c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyNDI2OA==", "url": "https://github.com/elastic/elasticsearch/pull/65489#discussion_r538224268", "bodyText": "good point, maybe. That brings up that we may need more testing with the real implementations.", "author": "javanna", "createdAt": "2020-12-08T10:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwOTgxMQ=="}], "type": "inlineReview"}, {"oid": "1920acdcd2ae4880e88ebecf7f5696cfdc3c4565", "url": "https://github.com/elastic/elasticsearch/commit/1920acdcd2ae4880e88ebecf7f5696cfdc3c4565", "message": "iter", "committedDate": "2020-12-08T10:46:24Z", "type": "commit"}, {"oid": "7a557db66fd3e7b6fedddba83f0d67f010e2304a", "url": "https://github.com/elastic/elasticsearch/commit/7a557db66fd3e7b6fedddba83f0d67f010e2304a", "message": "Merge branch 'master' into enhancement/dynamic_runtime_mode", "committedDate": "2020-12-08T10:55:50Z", "type": "commit"}, {"oid": "d10f0d52a9bdb5a14f2627d6da85d91d50e8454b", "url": "https://github.com/elastic/elasticsearch/commit/d10f0d52a9bdb5a14f2627d6da85d91d50e8454b", "message": "spotless", "committedDate": "2020-12-08T10:56:50Z", "type": "commit"}, {"oid": "bcd0f50361a03d5f81607f2e69fb04bc64f3ef05", "url": "https://github.com/elastic/elasticsearch/commit/bcd0f50361a03d5f81607f2e69fb04bc64f3ef05", "message": "fix date format and add tests", "committedDate": "2020-12-08T11:50:12Z", "type": "commit"}, {"oid": "7c600c301a76e5a18457e5e10e90e1414123cf1e", "url": "https://github.com/elastic/elasticsearch/commit/7c600c301a76e5a18457e5e10e90e1414123cf1e", "message": "spotless", "committedDate": "2020-12-08T11:56:13Z", "type": "commit"}, {"oid": "540f335f4efbede2951707d46f80f00df9da212a", "url": "https://github.com/elastic/elasticsearch/commit/540f335f4efbede2951707d46f80f00df9da212a", "message": "one more test", "committedDate": "2020-12-08T13:06:24Z", "type": "commit"}]}