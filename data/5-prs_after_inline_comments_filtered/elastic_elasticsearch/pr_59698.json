{"pr_number": 59698, "pr_title": "Remove dangling index auto import functionality", "pr_createdAt": "2020-07-16T13:32:23Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59698", "timeline": [{"oid": "9b345ae3953877fc70fad661c423ddf703c23b66", "url": "https://github.com/elastic/elasticsearch/commit/9b345ae3953877fc70fad661c423ddf703c23b66", "message": "Remove dangling index auto import functionality\n\nCloses 48366.", "committedDate": "2020-07-16T13:27:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NDY4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455854683", "bodyText": "Looks like the tests already mock out the ClusterService, so I think we could pass in the metadata via that mock, have them call getDanglingIndices() and thereby inline this. Or have DanglingIndicesState track a Supplier<ClusterState> rather than the full ClusterService and pass that in for the tests. Not sure which I prefer really, up to you.", "author": "DaveCTurner", "createdAt": "2020-07-16T15:01:15Z", "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "diffHunk": "@@ -47,234 +40,74 @@\n \n /**\n  * The dangling indices state is responsible for finding new dangling indices (indices that have\n- * their state written on disk, but don't exists in the metadata of the cluster), and importing\n- * them into the cluster.\n+ * their state written on disk, but don't exists in the metadata of the cluster).\n  */\n-public class DanglingIndicesState implements ClusterStateListener {\n+public class DanglingIndicesState {\n \n     private static final Logger logger = LogManager.getLogger(DanglingIndicesState.class);\n \n-    /**\n-     * Controls whether dangling indices should be automatically detected and imported into the cluster\n-     * state upon discovery. This setting is deprecated - use the <code>_dangling</code> API instead.\n-     * If disabled, dangling indices will not be automatically detected.\n-     *\n-     * @see org.elasticsearch.action.admin.indices.dangling\n-     */\n-    public static final Setting<Boolean> AUTO_IMPORT_DANGLING_INDICES_SETTING = Setting.boolSetting(\n-        \"gateway.auto_import_dangling_indices\",\n-        false,\n-        Setting.Property.NodeScope,\n-        Setting.Property.Deprecated\n-    );\n-\n-    private final NodeEnvironment nodeEnv;\n     private final MetaStateService metaStateService;\n-    private final LocalAllocateDangledIndices danglingIndicesAllocator;\n-    private final boolean isAutoImportDanglingIndicesEnabled;\n     private final ClusterService clusterService;\n \n-    private final Map<Index, IndexMetadata> danglingIndices = ConcurrentCollections.newConcurrentMap();\n-\n     @Inject\n-    public DanglingIndicesState(NodeEnvironment nodeEnv, MetaStateService metaStateService,\n-                                LocalAllocateDangledIndices danglingIndicesAllocator, ClusterService clusterService) {\n-        this.nodeEnv = nodeEnv;\n+    public DanglingIndicesState(MetaStateService metaStateService, ClusterService clusterService) {\n         this.metaStateService = metaStateService;\n-        this.danglingIndicesAllocator = danglingIndicesAllocator;\n         this.clusterService = clusterService;\n-\n-        this.isAutoImportDanglingIndicesEnabled = AUTO_IMPORT_DANGLING_INDICES_SETTING.get(clusterService.getSettings());\n-\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            clusterService.addListener(this);\n-        } else {\n-            logger.warn(\n-                AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey()\n-                    + \" is disabled, dangling indices will not be automatically detected or imported and must be managed manually\"\n-            );\n-        }\n-    }\n-\n-    boolean isAutoImportDanglingIndicesEnabled() {\n-        return this.isAutoImportDanglingIndicesEnabled;\n-    }\n-\n-    /**\n-     * Process dangling indices based on the provided meta data, handling cleanup, finding\n-     * new dangling indices, and allocating outstanding ones.\n-     */\n-    public void processDanglingIndices(final Metadata metadata) {\n-        assert this.isAutoImportDanglingIndicesEnabled;\n-\n-        if (nodeEnv.hasNodeFile() == false) {\n-            return;\n-        }\n-        cleanupAllocatedDangledIndices(metadata);\n-        findNewAndAddDanglingIndices(metadata);\n-        allocateDanglingIndices(metadata);\n     }\n \n     /**\n-     * Either return the current set of dangling indices, if auto-import is enabled, otherwise\n-     * scan for dangling indices right away.\n+     * Finds new dangling indices by iterating over the indices and trying to find indices\n+     * that have state on disk, but are not part of the provided metadata.\n      * @return a map of currently-known dangling indices\n      */\n     public Map<Index, IndexMetadata> getDanglingIndices() {\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            // This might be a good use case for CopyOnWriteHashMap\n-            return Map.copyOf(this.danglingIndices);\n-        } else {\n-            return findNewDanglingIndices(emptyMap(), this.clusterService.state().metadata());\n-        }\n-    }\n-\n-    /**\n-     * Cleans dangling indices if they are already allocated on the provided meta data.\n-     */\n-    void cleanupAllocatedDangledIndices(Metadata metadata) {\n-        for (Index index : danglingIndices.keySet()) {\n-            final IndexMetadata indexMetadata = metadata.index(index);\n-            if (indexMetadata != null && indexMetadata.getIndex().getName().equals(index.getName())) {\n-                if (indexMetadata.getIndex().getUUID().equals(index.getUUID()) == false) {\n-                    logger.warn(\"[{}] can not be imported as a dangling index, as there is already another index \" +\n-                        \"with the same name but a different uuid. local index will be ignored (but not deleted)\", index);\n-                } else {\n-                    logger.debug(\"[{}] no longer dangling (created), removing from dangling list\", index);\n-                }\n-                danglingIndices.remove(index);\n-            }\n-        }\n+        final Metadata metadata = this.clusterService.state().metadata();\n+        return findDanglingIndices(metadata);\n     }\n \n-    /**\n-     * Finds (@{link #findNewAndAddDanglingIndices}) and adds the new dangling indices\n-     * to the currently tracked dangling indices.\n-     */\n-    void findNewAndAddDanglingIndices(final Metadata metadata) {\n-        final IndexGraveyard graveyard = metadata.indexGraveyard();\n+    // Extracted from getDanglingIndices() as a package-private method to allow easier testing testing", "originalCommit": "9b345ae3953877fc70fad661c423ddf703c23b66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NTA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455855042", "bodyText": "Don't think we need to mock this any more.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);", "author": "DaveCTurner", "createdAt": "2020-07-16T15:01:44Z", "path": "server/src/test/java/org/elasticsearch/gateway/DanglingIndicesStateTests.java", "diffHunk": "@@ -248,77 +148,20 @@ public void testDanglingIndicesStripAliases() throws Exception {\n             assertThat(dangledIndex.getAliases().size(), equalTo(1));\n \n             final Metadata metadata = Metadata.builder().build();\n-            Map<Index, IndexMetadata> newDanglingIndices = danglingState.findNewDanglingIndices(emptyMap(), metadata);\n+            Map<Index, IndexMetadata> newDanglingIndices = danglingState.findDanglingIndices(metadata);\n             assertThat(newDanglingIndices.size(), equalTo(1));\n             Map.Entry<Index, IndexMetadata> entry = newDanglingIndices.entrySet().iterator().next();\n             assertThat(entry.getKey().getName(), equalTo(\"test1\"));\n             assertThat(entry.getValue().getAliases().size(), equalTo(0));\n         }\n     }\n \n-    /**\n-     * Check that when auto-imports are disabled, then no change listener is registered with the cluster state.\n-     */\n-    public void testClusterStateListenerNotRegisterWhenSettingDisabled() throws Exception {\n-        try (NodeEnvironment env = newNodeEnvironment()) {\n-            MetaStateService metaStateService = new MetaStateService(env, xContentRegistry());\n-            LocalAllocateDangledIndices localAllocateDangledIndices = mock(LocalAllocateDangledIndices.class);\n-\n-            final Settings allocateSettings = Settings.builder().put(AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey(), false).build();\n-\n-            final ClusterService clusterServiceMock = mock(ClusterService.class);\n-            when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);\n-\n-            new DanglingIndicesState(\n-                env,\n-                metaStateService,\n-                localAllocateDangledIndices,\n-                clusterServiceMock\n-            );\n-\n-            verify(clusterServiceMock, never()).addListener(any());\n-        }\n-    }\n-\n-    /**\n-     * Check that when auto-imports are enabled, then dangling indices are automatically imported.\n-     */\n-    public void testDanglingIndicesAreAllocatedWhenEnabled() throws Exception {\n-        try (NodeEnvironment env = newNodeEnvironment()) {\n-            MetaStateService metaStateService = new MetaStateService(env, xContentRegistry());\n-            LocalAllocateDangledIndices localAllocateDangledIndices = mock(LocalAllocateDangledIndices.class);\n-            final Settings allocateSettings = Settings.builder().put(AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey(), true).build();\n-\n-            final ClusterService clusterServiceMock = mock(ClusterService.class);\n-            when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);\n-\n-            DanglingIndicesState danglingIndicesState = new DanglingIndicesState(\n-                env,\n-                metaStateService,\n-                localAllocateDangledIndices, clusterServiceMock\n-            );\n-\n-            assertTrue(\"Expected dangling imports to be enabled\", danglingIndicesState.isAutoImportDanglingIndicesEnabled());\n-\n-            final Settings.Builder settings = Settings.builder().put(indexSettings).put(IndexMetadata.SETTING_INDEX_UUID, \"test1UUID\");\n-            IndexMetadata dangledIndex = IndexMetadata.builder(\"test1\").settings(settings).build();\n-            metaStateService.writeIndex(\"test_write\", dangledIndex);\n-\n-            final Metadata metadata = Metadata.builder().build();\n-            danglingIndicesState.findNewAndAddDanglingIndices(metadata);\n-\n-            danglingIndicesState.allocateDanglingIndices(metadata);\n-\n-            verify(localAllocateDangledIndices).allocateDangled(any(), any());\n-        }\n-    }\n-\n-    private DanglingIndicesState createDanglingIndicesState(NodeEnvironment env, MetaStateService metaStateService) {\n-        final Settings allocateSettings = Settings.builder().put(AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey(), true).build();\n+    private DanglingIndicesState createDanglingIndicesState(MetaStateService metaStateService) {\n+        final Settings allocateSettings = Settings.builder().build();\n \n         final ClusterService clusterServiceMock = mock(ClusterService.class);\n         when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);", "originalCommit": "9b345ae3953877fc70fad661c423ddf703c23b66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NjI1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455856259", "bodyText": "I prefer the original:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Failed to list dangling indices\", e);\n          \n          \n            \n                        logger.warn(\"failed to list dangling indices\", e);", "author": "DaveCTurner", "createdAt": "2020-07-16T15:03:29Z", "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "diffHunk": "@@ -47,234 +40,74 @@\n \n /**\n  * The dangling indices state is responsible for finding new dangling indices (indices that have\n- * their state written on disk, but don't exists in the metadata of the cluster), and importing\n- * them into the cluster.\n+ * their state written on disk, but don't exists in the metadata of the cluster).\n  */\n-public class DanglingIndicesState implements ClusterStateListener {\n+public class DanglingIndicesState {\n \n     private static final Logger logger = LogManager.getLogger(DanglingIndicesState.class);\n \n-    /**\n-     * Controls whether dangling indices should be automatically detected and imported into the cluster\n-     * state upon discovery. This setting is deprecated - use the <code>_dangling</code> API instead.\n-     * If disabled, dangling indices will not be automatically detected.\n-     *\n-     * @see org.elasticsearch.action.admin.indices.dangling\n-     */\n-    public static final Setting<Boolean> AUTO_IMPORT_DANGLING_INDICES_SETTING = Setting.boolSetting(\n-        \"gateway.auto_import_dangling_indices\",\n-        false,\n-        Setting.Property.NodeScope,\n-        Setting.Property.Deprecated\n-    );\n-\n-    private final NodeEnvironment nodeEnv;\n     private final MetaStateService metaStateService;\n-    private final LocalAllocateDangledIndices danglingIndicesAllocator;\n-    private final boolean isAutoImportDanglingIndicesEnabled;\n     private final ClusterService clusterService;\n \n-    private final Map<Index, IndexMetadata> danglingIndices = ConcurrentCollections.newConcurrentMap();\n-\n     @Inject\n-    public DanglingIndicesState(NodeEnvironment nodeEnv, MetaStateService metaStateService,\n-                                LocalAllocateDangledIndices danglingIndicesAllocator, ClusterService clusterService) {\n-        this.nodeEnv = nodeEnv;\n+    public DanglingIndicesState(MetaStateService metaStateService, ClusterService clusterService) {\n         this.metaStateService = metaStateService;\n-        this.danglingIndicesAllocator = danglingIndicesAllocator;\n         this.clusterService = clusterService;\n-\n-        this.isAutoImportDanglingIndicesEnabled = AUTO_IMPORT_DANGLING_INDICES_SETTING.get(clusterService.getSettings());\n-\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            clusterService.addListener(this);\n-        } else {\n-            logger.warn(\n-                AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey()\n-                    + \" is disabled, dangling indices will not be automatically detected or imported and must be managed manually\"\n-            );\n-        }\n-    }\n-\n-    boolean isAutoImportDanglingIndicesEnabled() {\n-        return this.isAutoImportDanglingIndicesEnabled;\n-    }\n-\n-    /**\n-     * Process dangling indices based on the provided meta data, handling cleanup, finding\n-     * new dangling indices, and allocating outstanding ones.\n-     */\n-    public void processDanglingIndices(final Metadata metadata) {\n-        assert this.isAutoImportDanglingIndicesEnabled;\n-\n-        if (nodeEnv.hasNodeFile() == false) {\n-            return;\n-        }\n-        cleanupAllocatedDangledIndices(metadata);\n-        findNewAndAddDanglingIndices(metadata);\n-        allocateDanglingIndices(metadata);\n     }\n \n     /**\n-     * Either return the current set of dangling indices, if auto-import is enabled, otherwise\n-     * scan for dangling indices right away.\n+     * Finds new dangling indices by iterating over the indices and trying to find indices\n+     * that have state on disk, but are not part of the provided metadata.\n      * @return a map of currently-known dangling indices\n      */\n     public Map<Index, IndexMetadata> getDanglingIndices() {\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            // This might be a good use case for CopyOnWriteHashMap\n-            return Map.copyOf(this.danglingIndices);\n-        } else {\n-            return findNewDanglingIndices(emptyMap(), this.clusterService.state().metadata());\n-        }\n-    }\n-\n-    /**\n-     * Cleans dangling indices if they are already allocated on the provided meta data.\n-     */\n-    void cleanupAllocatedDangledIndices(Metadata metadata) {\n-        for (Index index : danglingIndices.keySet()) {\n-            final IndexMetadata indexMetadata = metadata.index(index);\n-            if (indexMetadata != null && indexMetadata.getIndex().getName().equals(index.getName())) {\n-                if (indexMetadata.getIndex().getUUID().equals(index.getUUID()) == false) {\n-                    logger.warn(\"[{}] can not be imported as a dangling index, as there is already another index \" +\n-                        \"with the same name but a different uuid. local index will be ignored (but not deleted)\", index);\n-                } else {\n-                    logger.debug(\"[{}] no longer dangling (created), removing from dangling list\", index);\n-                }\n-                danglingIndices.remove(index);\n-            }\n-        }\n+        final Metadata metadata = this.clusterService.state().metadata();\n+        return findDanglingIndices(metadata);\n     }\n \n-    /**\n-     * Finds (@{link #findNewAndAddDanglingIndices}) and adds the new dangling indices\n-     * to the currently tracked dangling indices.\n-     */\n-    void findNewAndAddDanglingIndices(final Metadata metadata) {\n-        final IndexGraveyard graveyard = metadata.indexGraveyard();\n+    // Extracted from getDanglingIndices() as a package-private method to allow easier testing testing\n+    Map<Index, IndexMetadata> findDanglingIndices(Metadata metadata) {\n+        final Set<String> excludeIndexPathIds = new HashSet<>(metadata.indices().size());\n \n-        // If a tombstone is created for a dangling index, we need to make sure that the\n-        // index is no longer considered dangling.\n-        danglingIndices.keySet().removeIf(graveyard::containsIndex);\n-\n-        danglingIndices.putAll(findNewDanglingIndices(danglingIndices, metadata));\n-    }\n-\n-    /**\n-     * Finds new dangling indices by iterating over the indices and trying to find indices\n-     * that have state on disk, but are not part of the provided metadata, or not detected\n-     * as dangled already.\n-     */\n-    public Map<Index, IndexMetadata> findNewDanglingIndices(Map<Index, IndexMetadata> existingDanglingIndices, final Metadata metadata) {\n-        final Set<String> excludeIndexPathIds = new HashSet<>(metadata.indices().size() + danglingIndices.size());\n         for (ObjectCursor<IndexMetadata> cursor : metadata.indices().values()) {\n             excludeIndexPathIds.add(cursor.value.getIndex().getUUID());\n         }\n-        for (Index index : existingDanglingIndices.keySet()) {\n-            excludeIndexPathIds.add(index.getUUID());\n-        }\n+\n         try {\n             final List<IndexMetadata> indexMetadataList = metaStateService.loadIndicesStates(excludeIndexPathIds::contains);\n-            Map<Index, IndexMetadata> newIndices = new HashMap<>(indexMetadataList.size());\n+            final Map<Index, IndexMetadata> danglingIndices = new HashMap<>();\n             final IndexGraveyard graveyard = metadata.indexGraveyard();\n \n             for (IndexMetadata indexMetadata : indexMetadataList) {\n                 Index index = indexMetadata.getIndex();\n                 if (graveyard.containsIndex(index) == false) {\n-                    newIndices.put(index, stripAliases(indexMetadata));\n+                    danglingIndices.put(index, stripAliases(indexMetadata));\n                 }\n             }\n \n-            return newIndices;\n+            return danglingIndices;\n         } catch (IOException e) {\n-            logger.warn(\"failed to list dangling indices\", e);\n+            logger.warn(\"Failed to list dangling indices\", e);", "originalCommit": "9b345ae3953877fc70fad661c423ddf703c23b66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTc2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455861769", "bodyText": "Hurrah!", "author": "DaveCTurner", "createdAt": "2020-07-16T15:10:50Z", "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "diffHunk": "@@ -47,234 +40,74 @@\n \n /**\n  * The dangling indices state is responsible for finding new dangling indices (indices that have\n- * their state written on disk, but don't exists in the metadata of the cluster), and importing\n- * them into the cluster.\n+ * their state written on disk, but don't exists in the metadata of the cluster).\n  */\n-public class DanglingIndicesState implements ClusterStateListener {\n+public class DanglingIndicesState {", "originalCommit": "9b345ae3953877fc70fad661c423ddf703c23b66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d6e573915f24087aa04d0901b7986d63dbdbbb24", "url": "https://github.com/elastic/elasticsearch/commit/d6e573915f24087aa04d0901b7986d63dbdbbb24", "message": "Review feedback", "committedDate": "2020-07-16T19:17:25Z", "type": "commit"}, {"oid": "0bebbe85d56f4a76b32d55d941ae4963d5d2c42e", "url": "https://github.com/elastic/elasticsearch/commit/0bebbe85d56f4a76b32d55d941ae4963d5d2c42e", "message": "Checkstyle", "committedDate": "2020-07-17T09:41:48Z", "type": "commit"}, {"oid": "c5ea28cf2027bd89090d49ba3b7fc65392f652a6", "url": "https://github.com/elastic/elasticsearch/commit/c5ea28cf2027bd89090d49ba3b7fc65392f652a6", "message": "Merge remote-tracking branch 'upstream/master' into remove-dangling-index-auto-import-v2", "committedDate": "2020-07-17T11:02:35Z", "type": "commit"}]}