{"pr_number": 51423, "pr_title": "Expose the logic to cancel task when the rest channel is closed", "pr_createdAt": "2020-01-24T14:56:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51423", "timeline": [{"oid": "a279a9e90bddcf043892ae4fc2362628da3db07b", "url": "https://github.com/elastic/elasticsearch/commit/a279a9e90bddcf043892ae4fc2362628da3db07b", "message": "Expose the logic to cancel task when the rest channel is closed\n\nThis commit moves the logic that cancels search requests when the rest channel is closed\nto a generic client that can be used by other APIs. This will be useful for any rest action\nthat wants to cancel the execution of a task if the underlying rest channel is closed by the\nclient before completion.\n\nRelates #49931\nRelates #50990\nRelates #50990", "committedDate": "2020-01-24T14:51:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMzAxNA==", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370703014", "bodyText": "nit: this might be abusive streams a bit, let's do a for loop?", "author": "jpountz", "createdAt": "2020-01-24T15:48:10Z", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -111,35 +144,27 @@ void maybeRegisterChannel(HttpChannel httpChannel) {\n         synchronized void registerTask(TaskHolder taskHolder, TaskId taskId) {\n             taskHolder.taskId = taskId;\n             if (taskHolder.completed == false) {\n-                this.taskIds.add(taskId);\n+                this.tasks.add(taskId);\n             }\n         }\n \n         synchronized void unregisterTask(TaskHolder taskHolder) {\n             if (taskHolder.taskId != null) {\n-                this.taskIds.remove(taskHolder.taskId);\n+                this.tasks.remove(taskHolder.taskId);\n             }\n             taskHolder.completed = true;\n         }\n \n         @Override\n-        public synchronized void onResponse(Void aVoid) {\n-            //When the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n-            CloseListener closeListener = httpChannels.remove(channel.get());\n-            assert closeListener != null : \"channel not found in the map of tracked channels\";\n-            for (TaskId taskId : taskIds) {\n-                ThreadContext threadContext = client.threadPool().getThreadContext();\n-                try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n-                    // we stash any context here since this is an internal execution and should not leak any existing context information\n-                    threadContext.markAsSystemContext();\n-                    ContextPreservingActionListener<CancelTasksResponse> contextPreservingListener = new ContextPreservingActionListener<>(\n-                        threadContext.newRestorableContext(false),  ActionListener.wrap(r -> {}, e -> {}));\n-                    CancelTasksRequest cancelTasksRequest = new CancelTasksRequest();\n-                    cancelTasksRequest.setTaskId(taskId);\n-                    //We don't wait for cancel tasks to come back. Task cancellation is just best effort.\n-                    client.admin().cluster().cancelTasks(cancelTasksRequest, contextPreservingListener);\n-                }\n+        public void onResponse(Void aVoid) {\n+            final List<TaskId> toCancel;\n+            synchronized (this) {\n+                // when the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n+                CloseListener closeListener = httpChannels.remove(channel.get());\n+                assert closeListener != null : \"channel not found in the map of tracked channels\";\n+                toCancel = new ArrayList<>(tasks);\n             }\n+            toCancel.stream().forEach(taskId -> cancelTask(taskId));", "originalCommit": "a279a9e90bddcf043892ae4fc2362628da3db07b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMzczNA==", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370703734", "bodyText": "we don't need to protect httpChannels so we could move the synchronized keyword two lines below?", "author": "jpountz", "createdAt": "2020-01-24T15:49:33Z", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -111,35 +144,27 @@ void maybeRegisterChannel(HttpChannel httpChannel) {\n         synchronized void registerTask(TaskHolder taskHolder, TaskId taskId) {\n             taskHolder.taskId = taskId;\n             if (taskHolder.completed == false) {\n-                this.taskIds.add(taskId);\n+                this.tasks.add(taskId);\n             }\n         }\n \n         synchronized void unregisterTask(TaskHolder taskHolder) {\n             if (taskHolder.taskId != null) {\n-                this.taskIds.remove(taskHolder.taskId);\n+                this.tasks.remove(taskHolder.taskId);\n             }\n             taskHolder.completed = true;\n         }\n \n         @Override\n-        public synchronized void onResponse(Void aVoid) {\n-            //When the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n-            CloseListener closeListener = httpChannels.remove(channel.get());\n-            assert closeListener != null : \"channel not found in the map of tracked channels\";\n-            for (TaskId taskId : taskIds) {\n-                ThreadContext threadContext = client.threadPool().getThreadContext();\n-                try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n-                    // we stash any context here since this is an internal execution and should not leak any existing context information\n-                    threadContext.markAsSystemContext();\n-                    ContextPreservingActionListener<CancelTasksResponse> contextPreservingListener = new ContextPreservingActionListener<>(\n-                        threadContext.newRestorableContext(false),  ActionListener.wrap(r -> {}, e -> {}));\n-                    CancelTasksRequest cancelTasksRequest = new CancelTasksRequest();\n-                    cancelTasksRequest.setTaskId(taskId);\n-                    //We don't wait for cancel tasks to come back. Task cancellation is just best effort.\n-                    client.admin().cluster().cancelTasks(cancelTasksRequest, contextPreservingListener);\n-                }\n+        public void onResponse(Void aVoid) {\n+            final List<TaskId> toCancel;\n+            synchronized (this) {", "originalCommit": "a279a9e90bddcf043892ae4fc2362628da3db07b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwNTkxOA==", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370705918", "bodyText": "I think it needs to be synchronized?", "author": "jpountz", "createdAt": "2020-01-24T15:53:36Z", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -77,25 +107,28 @@ public void onFailure(Exception e) {\n                     }\n                 }\n             });\n-        closeListener.registerTask(taskHolder, new TaskId(client.getLocalNodeId(), task.getId()));\n+        final TaskId taskId = new TaskId(client.getLocalNodeId(), task.getId());\n+        closeListener.registerTask(taskHolder, taskId);\n         closeListener.maybeRegisterChannel(httpChannel);\n     }\n \n-    public int getNumChannels() {\n-        return httpChannels.size();\n+    private void cancelTask(TaskId taskId) {\n+        CancelTasksRequest req = new CancelTasksRequest()\n+            .setTaskId(taskId)\n+            .setReason(\"channel closed\");\n+        // force the origin to execute the cancellation as a system user\n+        new OriginSettingClient(client, TASKS_ORIGIN).admin().cluster().cancelTasks(req, ActionListener.wrap(() -> {}));\n     }\n \n-    final class CloseListener implements ActionListener<Void> {\n-        private final Client client;\n+    private class CloseListener implements ActionListener<Void> {\n         private final AtomicReference<HttpChannel> channel = new AtomicReference<>();\n-        private final Set<TaskId> taskIds = new HashSet<>();\n+        private final Set<TaskId> tasks = new HashSet<>();\n \n-        CloseListener(Client client) {\n-            this.client = client;\n+        CloseListener() {\n         }\n \n         int getNumTasks() {", "originalCommit": "a279a9e90bddcf043892ae4fc2362628da3db07b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0OTkwNw==", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370749907", "bodyText": "should we assert that channel.get() is not null?", "author": "jpountz", "createdAt": "2020-01-24T17:23:30Z", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -111,35 +144,27 @@ void maybeRegisterChannel(HttpChannel httpChannel) {\n         synchronized void registerTask(TaskHolder taskHolder, TaskId taskId) {\n             taskHolder.taskId = taskId;\n             if (taskHolder.completed == false) {\n-                this.taskIds.add(taskId);\n+                this.tasks.add(taskId);\n             }\n         }\n \n         synchronized void unregisterTask(TaskHolder taskHolder) {\n             if (taskHolder.taskId != null) {\n-                this.taskIds.remove(taskHolder.taskId);\n+                this.tasks.remove(taskHolder.taskId);\n             }\n             taskHolder.completed = true;\n         }\n \n         @Override\n-        public synchronized void onResponse(Void aVoid) {\n-            //When the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n-            CloseListener closeListener = httpChannels.remove(channel.get());\n-            assert closeListener != null : \"channel not found in the map of tracked channels\";\n-            for (TaskId taskId : taskIds) {\n-                ThreadContext threadContext = client.threadPool().getThreadContext();\n-                try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n-                    // we stash any context here since this is an internal execution and should not leak any existing context information\n-                    threadContext.markAsSystemContext();\n-                    ContextPreservingActionListener<CancelTasksResponse> contextPreservingListener = new ContextPreservingActionListener<>(\n-                        threadContext.newRestorableContext(false),  ActionListener.wrap(r -> {}, e -> {}));\n-                    CancelTasksRequest cancelTasksRequest = new CancelTasksRequest();\n-                    cancelTasksRequest.setTaskId(taskId);\n-                    //We don't wait for cancel tasks to come back. Task cancellation is just best effort.\n-                    client.admin().cluster().cancelTasks(cancelTasksRequest, contextPreservingListener);\n-                }\n+        public void onResponse(Void aVoid) {\n+            final List<TaskId> toCancel;\n+            synchronized (this) {\n+                // when the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n+                CloseListener closeListener = httpChannels.remove(channel.get());", "originalCommit": "a279a9e90bddcf043892ae4fc2362628da3db07b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d92322ca9b224d6d4a832ae93d1f05c16ead91be", "url": "https://github.com/elastic/elasticsearch/commit/d92322ca9b224d6d4a832ae93d1f05c16ead91be", "message": "address review", "committedDate": "2020-01-27T08:52:59Z", "type": "commit"}]}