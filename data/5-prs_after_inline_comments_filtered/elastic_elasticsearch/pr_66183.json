{"pr_number": 66183, "pr_title": "EQL: Enforce validation of key compatibility", "pr_createdAt": "2020-12-10T17:41:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66183", "timeline": [{"oid": "bd20481a7d40623b8368db70b6060c713be53e59", "url": "https://github.com/elastic/elasticsearch/commit/bd20481a7d40623b8368db70b6060c713be53e59", "message": "EQL: Enforce validation of key compatibility\n\nCurrently the engine allows keys with different types to be specified\nfor joining.\nThis is problematic since it suggest there is an implicit normalization\nbeing applied which is not the case and further, might not be what the\nuser expects.\nInstead of letting this silent behavior in, the verifier now validates\nthat at least the types are compatible.\nDo note that this requires a follow-up for text vs strings.", "committedDate": "2020-12-10T17:39:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/66183#discussion_r541778234", "bodyText": "I would have chosen a slightly different error message, something that would made clearer that the incompatible types are to blame: key [X] type [Y] has an incompatible type with key [A] type [B].", "author": "astefan", "createdAt": "2020-12-12T20:51:06Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Verifier.java", "diffHunk": "@@ -236,4 +244,35 @@ public Verifier(Metrics metrics) {\n \n         return failures;\n     }\n-}\n\\ No newline at end of file\n+\n+    private void checkJoinKeyTypes(LogicalPlan plan, Set<Failure> localFailures) {\n+        if (plan instanceof Join) {\n+            Join join = (Join) plan;\n+            List<KeyedFilter> queries = join.queries();\n+            KeyedFilter until = join.until();\n+            // pick first query and iterate its keys\n+            KeyedFilter first = queries.get(0);\n+            List<? extends NamedExpression> keys = first.keys();\n+            for (int keyIndex = 0; keyIndex < keys.size(); keyIndex++) {\n+                NamedExpression currentKey = keys.get(keyIndex);\n+                for (int i = 1; i < queries.size(); i++) {\n+                    KeyedFilter filter = queries.get(i);\n+                    doCheckKeyTypes(join, localFailures, currentKey, filter.keys().get(keyIndex));\n+                    if (until.keys().isEmpty() == false) {\n+                        doCheckKeyTypes(join, localFailures, currentKey, until.keys().get(keyIndex));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void doCheckKeyTypes(Join join, Set<Failure> localFailures, NamedExpression expectedKey, NamedExpression currentKey) {\n+        if (DataTypes.areCompatible(expectedKey.dataType(), currentKey.dataType()) == false) {\n+            localFailures.add(fail(currentKey, \"{} key [{}] type [{}] is incompatible with key [{}] type [{}]\",", "originalCommit": "bd20481a7d40623b8368db70b6060c713be53e59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1MDAxNw==", "url": "https://github.com/elastic/elasticsearch/pull/66183#discussion_r542150017", "bodyText": "What's unclear about the current message?\nSequence key[X] type[Y] is incompatible with key [A] type [B] vs\nkey[X] type[Y] has an incompatible type with key [A] type [B].\nThe messages are the same length however I find the former more informative.", "author": "costin", "createdAt": "2020-12-14T06:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODIzNA=="}], "type": "inlineReview"}, {"oid": "3875032582a51995f64bc9b38902632611f26620", "url": "https://github.com/elastic/elasticsearch/commit/3875032582a51995f64bc9b38902632611f26620", "message": "Merge branch 'master' into eql/verify-key-types", "committedDate": "2020-12-14T06:55:25Z", "type": "commit"}]}