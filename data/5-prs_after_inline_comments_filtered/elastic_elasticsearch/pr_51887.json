{"pr_number": 51887, "pr_title": "Refactor Percentiles/Ranks aggregation builders and factories", "pr_createdAt": "2020-02-04T20:35:23Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51887", "timeline": [{"oid": "844e7089dcff85c47e578b0ca0794cece4a9c54c", "url": "https://github.com/elastic/elasticsearch/commit/844e7089dcff85c47e578b0ca0794cece4a9c54c", "message": "Refactor Percentiles/Ranks aggregation builders and factories\n\n- Consolidates HDR/TDigest factories into a single factory\n- Consolidates most HDR/TDigest builder into an abstract builder\n- Deprecates method(), compression(), numSigFig() in favor of a new\nunified PercentileMethod.Config object\n- Disallows setting algo options that don't apply to current algo\n\nThe unified config method carries both the method and algo-specific\nsetting. This provides a mechanism to reject settings that apply\nto the wrong algorithm.  For BWC the old methods are retained\nbut marked as deprecated, and can be removed in future versions.", "committedDate": "2020-02-04T20:22:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzNTUxMw==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375335513", "bodyText": "I think this should be HDR, not TDigest?", "author": "not-napoleon", "createdAt": "2020-02-05T15:43:46Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public abstract class AbstractPercentilesAggregationBuilder<T extends ValuesSourceAggregationBuilder<ValuesSource, T>>\n+    extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource, T> {\n+\n+    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n+    protected boolean keyed = true;\n+    protected double[] values;\n+    private PercentilesMethod.Config percentilesConfig;\n+    private ParseField valuesField;\n+\n+    AbstractPercentilesAggregationBuilder(String name, double[] values, PercentilesMethod.Config percentilesConfig,\n+                                          ParseField valuesField) {\n+        super(name, CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"[\" + valuesField.getPreferredName() + \"] must not be null: [\" + name + \"]\");\n+        }\n+        if (values.length == 0) {\n+            throw new IllegalArgumentException(\"[\" + valuesField.getPreferredName() + \"] must not be an empty array: [\" + name + \"]\");\n+        }\n+        double[] sortedValues = Arrays.copyOf(values, values.length);\n+        Arrays.sort(sortedValues);\n+        this.values = sortedValues;\n+        this.percentilesConfig = percentilesConfig;\n+        this.valuesField = valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(String name, ParseField valuesField) {\n+        super(name,  CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        this.valuesField = valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(AbstractPercentilesAggregationBuilder<T> clone,\n+                                          AggregatorFactories.Builder factoriesBuilder, Map<String, Object> metaData) {\n+        super(clone, factoriesBuilder, metaData);\n+        this.percentilesConfig = clone.percentilesConfig;\n+        this.keyed = clone.keyed;\n+        this.values = clone.values;\n+        this.valuesField = clone.valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(StreamInput in) throws IOException {\n+        super(in, CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        values = in.readDoubleArray();\n+        keyed = in.readBoolean();\n+        if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            percentilesConfig\n+                = (PercentilesMethod.Config) in.readOptionalWriteable((Reader<Writeable>) PercentilesMethod.Config::fromStream);\n+        } else {\n+            int numberOfSignificantValueDigits = in.readVInt();\n+            double compression = in.readDouble();\n+            PercentilesMethod method = PercentilesMethod.readFromStream(in);\n+            percentilesConfig = PercentilesMethod.Config.fromLegacy(method, compression, numberOfSignificantValueDigits);\n+        }\n+    }\n+\n+    @Override\n+    protected void innerWriteTo(StreamOutput out) throws IOException {\n+        out.writeDoubleArray(values);\n+        out.writeBoolean(keyed);\n+        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            out.writeOptionalWriteable(percentilesConfig);\n+        } else {\n+            // Legacy method serialized both SigFigs and compression, even though we only need one.  So we need\n+            // to serialize the default for the unused method\n+            int numberOfSignificantValueDigits = percentilesConfig.getMethod().equals(PercentilesMethod.HDR)\n+                ? ((PercentilesMethod.Config.Hdr)percentilesConfig).getNumberOfSignificantValueDigits()\n+                : PercentilesMethod.Config.Hdr.DEFAULT_NUMBER_SIG_FIGS;\n+\n+            double compression = percentilesConfig.getMethod().equals(PercentilesMethod.TDIGEST)\n+                ? ((PercentilesMethod.Config.TDigest)percentilesConfig).getCompression()\n+                : PercentilesMethod.Config.TDigest.DEFAULT_COMPRESSION;\n+\n+            out.writeVInt(numberOfSignificantValueDigits);\n+            out.writeDouble(compression);\n+            percentilesConfig.getMethod().writeTo(out);\n+        }\n+    }\n+\n+    /**\n+     * Set whether the XContent response should be keyed\n+     */\n+    public T keyed(boolean keyed) {\n+        this.keyed = keyed;\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Get whether the XContent response should be keyed\n+     */\n+    public boolean keyed() {\n+        return keyed;\n+    }\n+\n+    /**\n+     * Expert: set the number of significant digits in the values. Only relevant\n+     * when using {@link PercentilesMethod#HDR}.\n+     *\n+     * Deprecated: set numberOfSignificantValueDigits by configuring a {@link PercentilesMethod.Config.TDigest} instead", "originalCommit": "844e7089dcff85c47e578b0ca0794cece4a9c54c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzODg1NA==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375338854", "bodyText": "This is needed because builders don't have a \"build\"...method\n\n\ud83d\ude22 \ud83d\ude22 \ud83d\ude22", "author": "not-napoleon", "createdAt": "2020-02-05T15:48:45Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public abstract class AbstractPercentilesAggregationBuilder<T extends ValuesSourceAggregationBuilder<ValuesSource, T>>\n+    extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource, T> {\n+\n+    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n+    protected boolean keyed = true;\n+    protected double[] values;\n+    private PercentilesMethod.Config percentilesConfig;\n+    private ParseField valuesField;\n+\n+    AbstractPercentilesAggregationBuilder(String name, double[] values, PercentilesMethod.Config percentilesConfig,\n+                                          ParseField valuesField) {\n+        super(name, CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"[\" + valuesField.getPreferredName() + \"] must not be null: [\" + name + \"]\");\n+        }\n+        if (values.length == 0) {\n+            throw new IllegalArgumentException(\"[\" + valuesField.getPreferredName() + \"] must not be an empty array: [\" + name + \"]\");\n+        }\n+        double[] sortedValues = Arrays.copyOf(values, values.length);\n+        Arrays.sort(sortedValues);\n+        this.values = sortedValues;\n+        this.percentilesConfig = percentilesConfig;\n+        this.valuesField = valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(String name, ParseField valuesField) {\n+        super(name,  CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        this.valuesField = valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(AbstractPercentilesAggregationBuilder<T> clone,\n+                                          AggregatorFactories.Builder factoriesBuilder, Map<String, Object> metaData) {\n+        super(clone, factoriesBuilder, metaData);\n+        this.percentilesConfig = clone.percentilesConfig;\n+        this.keyed = clone.keyed;\n+        this.values = clone.values;\n+        this.valuesField = clone.valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(StreamInput in) throws IOException {\n+        super(in, CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        values = in.readDoubleArray();\n+        keyed = in.readBoolean();\n+        if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            percentilesConfig\n+                = (PercentilesMethod.Config) in.readOptionalWriteable((Reader<Writeable>) PercentilesMethod.Config::fromStream);\n+        } else {\n+            int numberOfSignificantValueDigits = in.readVInt();\n+            double compression = in.readDouble();\n+            PercentilesMethod method = PercentilesMethod.readFromStream(in);\n+            percentilesConfig = PercentilesMethod.Config.fromLegacy(method, compression, numberOfSignificantValueDigits);\n+        }\n+    }\n+\n+    @Override\n+    protected void innerWriteTo(StreamOutput out) throws IOException {\n+        out.writeDoubleArray(values);\n+        out.writeBoolean(keyed);\n+        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            out.writeOptionalWriteable(percentilesConfig);\n+        } else {\n+            // Legacy method serialized both SigFigs and compression, even though we only need one.  So we need\n+            // to serialize the default for the unused method\n+            int numberOfSignificantValueDigits = percentilesConfig.getMethod().equals(PercentilesMethod.HDR)\n+                ? ((PercentilesMethod.Config.Hdr)percentilesConfig).getNumberOfSignificantValueDigits()\n+                : PercentilesMethod.Config.Hdr.DEFAULT_NUMBER_SIG_FIGS;\n+\n+            double compression = percentilesConfig.getMethod().equals(PercentilesMethod.TDIGEST)\n+                ? ((PercentilesMethod.Config.TDigest)percentilesConfig).getCompression()\n+                : PercentilesMethod.Config.TDigest.DEFAULT_COMPRESSION;\n+\n+            out.writeVInt(numberOfSignificantValueDigits);\n+            out.writeDouble(compression);\n+            percentilesConfig.getMethod().writeTo(out);\n+        }\n+    }\n+\n+    /**\n+     * Set whether the XContent response should be keyed\n+     */\n+    public T keyed(boolean keyed) {\n+        this.keyed = keyed;\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Get whether the XContent response should be keyed\n+     */\n+    public boolean keyed() {\n+        return keyed;\n+    }\n+\n+    /**\n+     * Expert: set the number of significant digits in the values. Only relevant\n+     * when using {@link PercentilesMethod#HDR}.\n+     *\n+     * Deprecated: set numberOfSignificantValueDigits by configuring a {@link PercentilesMethod.Config.TDigest} instead\n+     * and set via {@link PercentilesAggregationBuilder#setPercentilesConfig(PercentilesMethod.Config)}\n+     */\n+    @Deprecated\n+    public T numberOfSignificantValueDigits(int numberOfSignificantValueDigits) {\n+        if (numberOfSignificantValueDigits < 0 || numberOfSignificantValueDigits > 5) {\n+            throw new IllegalArgumentException(\"[numberOfSignificantValueDigits] must be between 0 and 5: [\" + name + \"]\");\n+        }\n+\n+        if (percentilesConfig == null || percentilesConfig.getMethod().equals(PercentilesMethod.HDR)) {\n+            percentilesConfig = new PercentilesMethod.Config.Hdr(numberOfSignificantValueDigits);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot set [numberOfSignificantValueDigits] because the method \" +\n+                \"has already been configured for TDigest\");\n+        }\n+\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Expert: get the number of significant digits in the values. Only relevant\n+     * when using {@link PercentilesMethod#HDR}.\n+     *\n+     * Deprecated: get numberOfSignificantValueDigits by inspecting the {@link PercentilesMethod.Config} returned from\n+     * {@link PercentilesAggregationBuilder#getPercentilesConfig()} instead\n+     */\n+    @Deprecated\n+    public int numberOfSignificantValueDigits() {\n+        if (percentilesConfig != null && percentilesConfig.getMethod().equals(PercentilesMethod.HDR)) {\n+            return ((PercentilesMethod.Config.Hdr)percentilesConfig).getNumberOfSignificantValueDigits();\n+        }\n+        throw new IllegalStateException(\"Percentiles [method] has not been configured yet, or is a TDigest\");\n+    }\n+\n+    /**\n+     * Expert: set the compression. Higher values improve accuracy but also\n+     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n+     *\n+     * Deprecated: set compression by configuring a {@link PercentilesMethod.Config.TDigest} instead\n+     * and set via {@link PercentilesAggregationBuilder#setPercentilesConfig(PercentilesMethod.Config)}\n+     */\n+    @Deprecated\n+    public T compression(double compression) {\n+        if (compression < 0.0) {\n+            throw new IllegalArgumentException(\n+                \"[compression] must be greater than or equal to 0. Found [\" + compression + \"] in [\" + name + \"]\");\n+        }\n+\n+        if (percentilesConfig == null || percentilesConfig.getMethod().equals(PercentilesMethod.TDIGEST)) {\n+            percentilesConfig = new PercentilesMethod.Config.TDigest(compression);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot set [compression] because the method has already been configured for HDRHistogram\");\n+        }\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Expert: get the compression. Higher values improve accuracy but also\n+     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n+     *\n+     * Deprecated: get compression by inspecting the {@link PercentilesMethod.Config} returned from\n+     * {@link PercentilesAggregationBuilder#getPercentilesConfig()} instead\n+     */\n+    @Deprecated\n+    public double compression() {\n+        if (percentilesConfig != null && percentilesConfig.getMethod().equals(PercentilesMethod.TDIGEST)) {\n+            return ((PercentilesMethod.Config.TDigest)percentilesConfig).getCompression();\n+        }\n+        throw new IllegalStateException(\"Percentiles [method] has not been configured yet, or is a HdrHistogram\");\n+    }\n+\n+\n+    /**\n+     * Deprecated: set method by configuring a {@link PercentilesMethod.Config} instead\n+     * and set via {@link PercentilesAggregationBuilder#setPercentilesConfig(PercentilesMethod.Config)}\n+     */\n+    @Deprecated\n+    public T method(PercentilesMethod method) {\n+        if (method == null) {\n+            throw new IllegalArgumentException(\"[method] must not be null: [\" + name + \"]\");\n+        }\n+        if (percentilesConfig == null) {\n+            if (method.equals(PercentilesMethod.TDIGEST) ) {\n+                this.percentilesConfig = new PercentilesMethod.Config.TDigest();\n+            } else {\n+                this.percentilesConfig = new PercentilesMethod.Config.Hdr();\n+            }\n+        } else if (percentilesConfig.getMethod().equals(method) == false) {\n+            // we already have an algo configured, but it's different from the requested method\n+            // reset to default for the requested method\n+            if (method.equals(PercentilesMethod.TDIGEST) ) {\n+                this.percentilesConfig = new PercentilesMethod.Config.TDigest();\n+            } else {\n+                this.percentilesConfig = new PercentilesMethod.Config.Hdr();\n+            }\n+        } // if method and config were same, this is a no-op so we don't overwrite settings\n+\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Deprecated: get method by inspecting the {@link PercentilesMethod.Config} returned from\n+     * {@link PercentilesAggregationBuilder#getPercentilesConfig()} instead\n+     */\n+    @Nullable\n+    @Deprecated\n+    public PercentilesMethod method() {\n+        return percentilesConfig == null ? null : percentilesConfig.getMethod();\n+    }\n+\n+    /**\n+     * Returns how the percentiles algorithm has been configured, or null if it has not been configured yet\n+     */\n+    @Nullable\n+    public PercentilesMethod.Config getPercentilesConfig() {\n+        return percentilesConfig;\n+    }\n+\n+    /**\n+     * Sets how the percentiles algorithm should be configured\n+     */\n+    public T setPercentilesConfig(PercentilesMethod.Config percentilesConfig) {\n+        this.percentilesConfig = percentilesConfig;\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Return the current algo configuration, or a default (Tdigest) otherwise\n+     *\n+     * This is needed because builders don't have a \"build\" or \"finalize\" method, but", "originalCommit": "844e7089dcff85c47e578b0ca0794cece4a9c54c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5NTY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375495680", "bodyText": "\ud83d\ude2d", "author": "polyfractal", "createdAt": "2020-02-05T20:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzODg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0NDM4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375344387", "bodyText": "A little javadoc here would be helpful.  Maybe just something short, saying that aggs looking to work with TDigest or HDRHistogram should implement this builder to get the standard config behavior for those?", "author": "not-napoleon", "createdAt": "2020-02-05T15:56:52Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public abstract class AbstractPercentilesAggregationBuilder<T extends ValuesSourceAggregationBuilder<ValuesSource, T>>", "originalCommit": "844e7089dcff85c47e578b0ca0794cece4a9c54c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0NTU2OA==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375345568", "bodyText": "Nit: Indentation - shouldn't this line up with String, not name?", "author": "not-napoleon", "createdAt": "2020-02-05T15:58:34Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/PercentileRanksAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.AggregatorFactory;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+class PercentileRanksAggregatorFactory extends ValuesSourceAggregatorFactory<ValuesSource> {\n+\n+    private final double[] percents;\n+    private final PercentilesMethod.Config percentilesConfig;\n+    private final boolean keyed;\n+\n+    PercentileRanksAggregatorFactory(String name,\n+                                            ValuesSourceConfig<ValuesSource> config,", "originalCommit": "844e7089dcff85c47e578b0ca0794cece4a9c54c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5Njk3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375496975", "bodyText": "Think the IDE has been drinking on the job :psyduck:", "author": "polyfractal", "createdAt": "2020-02-05T20:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0NTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NzMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375397329", "bodyText": "I really don't like this if(method.equals(TDIGEST) {...} else if (method.equals(HDR) {...} else { throw } pattern.  We use it in a lot of places, and if we ever add another percentile method, we'll have to find and touch each of them.  Plus, the throw is always unreachable now, since we'd have already thrown trying to create a bogus enum instance.\nIn this case, it's pretty trivial to put a method on the enum that takes a StreamInput and returns a Config, and I think we should do that.  We should at least think about applying this logic to the other places we have this type of construct.", "author": "not-napoleon", "createdAt": "2020-02-05T17:23:34Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/PercentilesMethod.java", "diffHunk": "@@ -65,4 +86,165 @@ public void writeTo(StreamOutput out) throws IOException {\n     public String toString() {\n         return parseField.getPreferredName();\n     }\n+\n+    /**\n+     * A small config object that carries algo-specific settings.  This allows the factory to have\n+     * a single unified constructor for both algos, but internally switch execution\n+     * depending on which algo is selected\n+     */\n+    public abstract static class Config implements ToXContent, Writeable {\n+        private final PercentilesMethod method;\n+\n+        Config(PercentilesMethod method) {\n+            this.method = method;\n+        }\n+\n+        public static Config fromStream(StreamInput in) throws IOException {\n+            PercentilesMethod method = PercentilesMethod.readFromStream(in);\n+            if (method.equals(PercentilesMethod.TDIGEST)) {", "originalCommit": "844e7089dcff85c47e578b0ca0794cece4a9c54c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNDAwNA==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375504004", "bodyText": "Pushed a change that takes care of the factory/builder instances of these as discussed on slack.  I'm not sure this particular one is easily solved though.  Note that this is a static method on the abstract Config object, one level \"inside\" the PercentilesMethod enum\nThe higher-level PercentilesMethod has a readFromStream() which is in use today to serialize the enum (as well as both compression and numSigFig in the builder).  The builder already has to incorporate version checks for wire BWC, so I was hesitant to lump the Config serialization into the existing PercentilesMethod because it would also need version checks.\n(Also, conceptually we're in a slightly odd place where the \"new way\" is to serialize the Config object which holds a PercentileMethod enum, so asking the enum to deserialize a Config seems incorrect.  But that's more of an artifact of the current hierarchy which should be cleaner once things are removed post-deprecation)\nOtherwise, I'm happy to move this up a level... but I think we'll still need these if/else at this point in the code.  Since this isn't a NamedWriteable style situation, we have to inspect the serialized method to determine what kind of object needs to be built next.  I don't see any way around that?", "author": "polyfractal", "createdAt": "2020-02-05T20:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NzMyOQ=="}], "type": "inlineReview"}, {"oid": "315f546834e41920e2db8fbc667f6d400a3233af", "url": "https://github.com/elastic/elasticsearch/commit/315f546834e41920e2db8fbc667f6d400a3233af", "message": "Address some review comments", "committedDate": "2020-02-05T20:50:37Z", "type": "commit"}, {"oid": "830b796997644cd901081c76384052b3f325d0fb", "url": "https://github.com/elastic/elasticsearch/commit/830b796997644cd901081c76384052b3f325d0fb", "message": "Proposed config change", "committedDate": "2020-02-06T16:42:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3NTEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375975122", "bodyText": "I feel like there should be some parsing code around here somewhere.", "author": "nik9000", "createdAt": "2020-02-06T17:25:56Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * This provides a base class for aggregations that are building percentiles or percentiles-like functionality (e.g. percentile ranks).\n+ * It provides a set of common fields/functionality for setting the available algorithms (TDigest and HDRHistogram),\n+ * as well as algorithm-specific settings via a {@link PercentilesMethod.Config} object\n+ */\n+public abstract class AbstractPercentilesAggregationBuilder<T extends ValuesSourceAggregationBuilder<ValuesSource, T>>\n+    extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource, T> {\n+\n+    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n+    protected boolean keyed = true;\n+    protected double[] values;\n+    private PercentilesMethod.Config percentilesConfig;\n+    private ParseField valuesField;\n+\n+    AbstractPercentilesAggregationBuilder(String name, double[] values, PercentilesMethod.Config percentilesConfig,\n+                                          ParseField valuesField) {\n+        super(name, CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"[\" + valuesField.getPreferredName() + \"] must not be null: [\" + name + \"]\");\n+        }\n+        if (values.length == 0) {\n+            throw new IllegalArgumentException(\"[\" + valuesField.getPreferredName() + \"] must not be an empty array: [\" + name + \"]\");\n+        }\n+        double[] sortedValues = Arrays.copyOf(values, values.length);\n+        Arrays.sort(sortedValues);\n+        this.values = sortedValues;\n+        this.percentilesConfig = percentilesConfig;\n+        this.valuesField = valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(String name, ParseField valuesField) {\n+        super(name,  CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        this.valuesField = valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(AbstractPercentilesAggregationBuilder<T> clone,\n+                                          AggregatorFactories.Builder factoriesBuilder, Map<String, Object> metaData) {\n+        super(clone, factoriesBuilder, metaData);\n+        this.percentilesConfig = clone.percentilesConfig;\n+        this.keyed = clone.keyed;\n+        this.values = clone.values;\n+        this.valuesField = clone.valuesField;\n+    }\n+\n+    AbstractPercentilesAggregationBuilder(StreamInput in) throws IOException {\n+        super(in, CoreValuesSourceType.NUMERIC, ValueType.NUMERIC);\n+        values = in.readDoubleArray();\n+        keyed = in.readBoolean();\n+        if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            percentilesConfig\n+                = (PercentilesMethod.Config) in.readOptionalWriteable((Reader<Writeable>) PercentilesMethod.Config::fromStream);\n+        } else {\n+            int numberOfSignificantValueDigits = in.readVInt();\n+            double compression = in.readDouble();\n+            PercentilesMethod method = PercentilesMethod.readFromStream(in);\n+            percentilesConfig = PercentilesMethod.Config.fromLegacy(method, compression, numberOfSignificantValueDigits);\n+        }\n+    }\n+\n+    @Override\n+    protected void innerWriteTo(StreamOutput out) throws IOException {\n+        out.writeDoubleArray(values);\n+        out.writeBoolean(keyed);\n+        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            out.writeOptionalWriteable(percentilesConfig);\n+        } else {\n+            // Legacy method serialized both SigFigs and compression, even though we only need one.  So we need\n+            // to serialize the default for the unused method\n+            int numberOfSignificantValueDigits = percentilesConfig.getMethod().equals(PercentilesMethod.HDR)\n+                ? ((PercentilesMethod.Config.Hdr)percentilesConfig).getNumberOfSignificantValueDigits()\n+                : PercentilesMethod.Config.Hdr.DEFAULT_NUMBER_SIG_FIGS;\n+\n+            double compression = percentilesConfig.getMethod().equals(PercentilesMethod.TDIGEST)\n+                ? ((PercentilesMethod.Config.TDigest)percentilesConfig).getCompression()\n+                : PercentilesMethod.Config.TDigest.DEFAULT_COMPRESSION;\n+\n+            out.writeVInt(numberOfSignificantValueDigits);\n+            out.writeDouble(compression);\n+            percentilesConfig.getMethod().writeTo(out);\n+        }\n+    }\n+\n+    /**\n+     * Set whether the XContent response should be keyed\n+     */\n+    public T keyed(boolean keyed) {\n+        this.keyed = keyed;\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Get whether the XContent response should be keyed\n+     */\n+    public boolean keyed() {\n+        return keyed;\n+    }\n+\n+    /**\n+     * Expert: set the number of significant digits in the values. Only relevant\n+     * when using {@link PercentilesMethod#HDR}.\n+     *\n+     * Deprecated: set numberOfSignificantValueDigits by configuring a {@link PercentilesMethod.Config.Hdr} instead\n+     * and set via {@link PercentilesAggregationBuilder#setPercentilesConfig(PercentilesMethod.Config)}\n+     */\n+    @Deprecated\n+    public T numberOfSignificantValueDigits(int numberOfSignificantValueDigits) {\n+        if (numberOfSignificantValueDigits < 0 || numberOfSignificantValueDigits > 5) {\n+            throw new IllegalArgumentException(\"[numberOfSignificantValueDigits] must be between 0 and 5: [\" + name + \"]\");\n+        }\n+\n+        if (percentilesConfig == null || percentilesConfig.getMethod().equals(PercentilesMethod.HDR)) {\n+            percentilesConfig = new PercentilesMethod.Config.Hdr(numberOfSignificantValueDigits);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot set [numberOfSignificantValueDigits] because the method \" +\n+                \"has already been configured for TDigest\");\n+        }\n+\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Expert: get the number of significant digits in the values. Only relevant\n+     * when using {@link PercentilesMethod#HDR}.\n+     *\n+     * Deprecated: get numberOfSignificantValueDigits by inspecting the {@link PercentilesMethod.Config} returned from\n+     * {@link PercentilesAggregationBuilder#getPercentilesConfig()} instead\n+     */\n+    @Deprecated\n+    public int numberOfSignificantValueDigits() {\n+        if (percentilesConfig != null && percentilesConfig.getMethod().equals(PercentilesMethod.HDR)) {\n+            return ((PercentilesMethod.Config.Hdr)percentilesConfig).getNumberOfSignificantValueDigits();\n+        }\n+        throw new IllegalStateException(\"Percentiles [method] has not been configured yet, or is a TDigest\");\n+    }\n+\n+    /**\n+     * Expert: set the compression. Higher values improve accuracy but also\n+     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n+     *\n+     * Deprecated: set compression by configuring a {@link PercentilesMethod.Config.TDigest} instead\n+     * and set via {@link PercentilesAggregationBuilder#setPercentilesConfig(PercentilesMethod.Config)}\n+     */\n+    @Deprecated\n+    public T compression(double compression) {\n+        if (compression < 0.0) {\n+            throw new IllegalArgumentException(\n+                \"[compression] must be greater than or equal to 0. Found [\" + compression + \"] in [\" + name + \"]\");\n+        }\n+\n+        if (percentilesConfig == null || percentilesConfig.getMethod().equals(PercentilesMethod.TDIGEST)) {\n+            percentilesConfig = new PercentilesMethod.Config.TDigest(compression);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot set [compression] because the method has already been configured for HDRHistogram\");\n+        }\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Expert: get the compression. Higher values improve accuracy but also\n+     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n+     *\n+     * Deprecated: get compression by inspecting the {@link PercentilesMethod.Config} returned from\n+     * {@link PercentilesAggregationBuilder#getPercentilesConfig()} instead\n+     */\n+    @Deprecated\n+    public double compression() {\n+        if (percentilesConfig != null && percentilesConfig.getMethod().equals(PercentilesMethod.TDIGEST)) {\n+            return ((PercentilesMethod.Config.TDigest)percentilesConfig).getCompression();\n+        }\n+        throw new IllegalStateException(\"Percentiles [method] has not been configured yet, or is a HdrHistogram\");\n+    }\n+\n+\n+    /**\n+     * Deprecated: set method by configuring a {@link PercentilesMethod.Config} instead\n+     * and set via {@link PercentilesAggregationBuilder#setPercentilesConfig(PercentilesMethod.Config)}\n+     */\n+    @Deprecated\n+    public T method(PercentilesMethod method) {\n+        if (method == null) {\n+            throw new IllegalArgumentException(\"[method] must not be null: [\" + name + \"]\");\n+        }\n+        if (percentilesConfig == null) {\n+            if (method.equals(PercentilesMethod.TDIGEST) ) {\n+                this.percentilesConfig = new PercentilesMethod.Config.TDigest();\n+            } else {\n+                this.percentilesConfig = new PercentilesMethod.Config.Hdr();\n+            }\n+        } else if (percentilesConfig.getMethod().equals(method) == false) {\n+            // we already have an algo configured, but it's different from the requested method\n+            // reset to default for the requested method\n+            if (method.equals(PercentilesMethod.TDIGEST) ) {\n+                this.percentilesConfig = new PercentilesMethod.Config.TDigest();\n+            } else {\n+                this.percentilesConfig = new PercentilesMethod.Config.Hdr();\n+            }\n+        } // if method and config were same, this is a no-op so we don't overwrite settings\n+\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Deprecated: get method by inspecting the {@link PercentilesMethod.Config} returned from\n+     * {@link PercentilesAggregationBuilder#getPercentilesConfig()} instead\n+     */\n+    @Nullable\n+    @Deprecated\n+    public PercentilesMethod method() {\n+        return percentilesConfig == null ? null : percentilesConfig.getMethod();\n+    }\n+\n+    /**\n+     * Returns how the percentiles algorithm has been configured, or null if it has not been configured yet\n+     */\n+    @Nullable\n+    public PercentilesMethod.Config getPercentilesConfig() {\n+        return percentilesConfig;\n+    }\n+\n+    /**\n+     * Sets how the percentiles algorithm should be configured\n+     */\n+    public T setPercentilesConfig(PercentilesMethod.Config percentilesConfig) {\n+        this.percentilesConfig = percentilesConfig;\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Return the current algo configuration, or a default (Tdigest) otherwise\n+     *\n+     * This is needed because builders don't have a \"build\" or \"finalize\" method, but\n+     * the old API did bake in defaults.  Certain operations like xcontent, equals, hashcode\n+     * will use the values in the builder at any time and need to be aware of defaults.\n+     *\n+     * But to maintain BWC behavior as much as possible, we allow the user to set\n+     * algo settings independent of method.  To keep life simple we use a null to track\n+     * if any method has been selected yet.\n+     *\n+     * However, this means we need a way to fetch the default if the user hasn't\n+     * selected any method and uses a builder-side feature like xcontent\n+     */\n+    PercentilesMethod.Config configOrDefault() {\n+        if (percentilesConfig == null) {\n+            return new PercentilesMethod.Config.TDigest();\n+        }\n+        return percentilesConfig;\n+    }\n+\n+    @Override\n+    protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {\n+        builder.array(valuesField.getPreferredName(), values);\n+        builder.field(KEYED_FIELD.getPreferredName(), keyed);\n+        builder = configOrDefault().toXContent(builder, params);\n+        return builder;\n+    }\n+", "originalCommit": "830b796997644cd901081c76384052b3f325d0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3NzQxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375977417", "bodyText": "If you have a method to et the config method you could use the flavor of ObjectParser that takes a categoryClass and parse these two an named xcontent. I don't believe that flavor is supported by ContructingObjectParser hough. This'll do the trick, but it is less nice.", "author": "nik9000", "createdAt": "2020-02-06T17:30:34Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/PercentileRanksAggregationBuilder.java", "diffHunk": "@@ -21,290 +21,97 @@\n \n import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n-import org.elasticsearch.common.xcontent.ObjectParser;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories.Builder;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n-import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n-import org.elasticsearch.search.aggregations.support.ValueType;\n import org.elasticsearch.search.aggregations.support.ValuesSource;\n-import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder.LeafOnly;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceParserHelper;\n \n import java.io.IOException;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n \n-import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n-\n-public class PercentileRanksAggregationBuilder extends LeafOnly<ValuesSource, PercentileRanksAggregationBuilder> {\n+public class PercentileRanksAggregationBuilder extends AbstractPercentilesAggregationBuilder<PercentileRanksAggregationBuilder> {\n     public static final String NAME = PercentileRanks.TYPE_NAME;\n \n-    public static final ParseField VALUES_FIELD = new ParseField(\"values\");\n-\n-    private static class TDigestOptions {\n-        Double compression;\n-    }\n-\n-    private static final ObjectParser<TDigestOptions, String> TDIGEST_OPTIONS_PARSER =\n-            new ObjectParser<>(PercentilesMethod.TDIGEST.getParseField().getPreferredName(), TDigestOptions::new);\n+    private static final ParseField VALUES_FIELD = new ParseField(\"values\");\n+    private static final ConstructingObjectParser<PercentileRanksAggregationBuilder, String> PARSER;\n     static {\n-        TDIGEST_OPTIONS_PARSER.declareDouble((opts, compression) -> opts.compression = compression, new ParseField(\"compression\"));\n-    }\n+        PARSER = new ConstructingObjectParser<>(PercentileRanksAggregationBuilder.NAME, false, (objects, name) -> {\n+\n+            double[] values = ((List<Double>) objects[0]).stream().mapToDouble(Double::doubleValue).toArray();\n+            PercentilesMethod.Config percentilesConfig;\n+\n+            if (objects[1] != null && objects[2] != null) {", "originalCommit": "830b796997644cd901081c76384052b3f325d0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk4MDA2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r375980066", "bodyText": "I think we should have something in the superclass that helps with the parsing. I'm not sure what though.", "author": "nik9000", "createdAt": "2020-02-06T17:35:15Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/PercentilesAggregationBuilder.java", "diffHunk": "@@ -21,154 +21,86 @@\n \n import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.xcontent.ObjectParser;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n import org.elasticsearch.common.xcontent.XContentParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories.Builder;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n-import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n-import org.elasticsearch.search.aggregations.support.ValueType;\n import org.elasticsearch.search.aggregations.support.ValuesSource;\n-import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder.LeafOnly;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceParserHelper;\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n \n-public class PercentilesAggregationBuilder extends LeafOnly<ValuesSource, PercentilesAggregationBuilder> {\n+public class PercentilesAggregationBuilder extends AbstractPercentilesAggregationBuilder<PercentilesAggregationBuilder> {\n     public static final String NAME = Percentiles.TYPE_NAME;\n \n     private static final double[] DEFAULT_PERCENTS = new double[] { 1, 5, 25, 50, 75, 95, 99 };\n-    public static final ParseField PERCENTS_FIELD = new ParseField(\"percents\");\n-    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n-    public static final ParseField COMPRESSION_FIELD = new ParseField(\"compression\");\n-    public static final ParseField NUMBER_SIGNIFICANT_DIGITS_FIELD = new ParseField(\"number_of_significant_value_digits\");\n+    private static final ParseField PERCENTS_FIELD = new ParseField(\"percents\");\n \n-    private static class TDigestOptions {\n-        Double compression;\n-    }\n-\n-    private static final ObjectParser<TDigestOptions, Void> TDIGEST_OPTIONS_PARSER =\n-            new ObjectParser<>(PercentilesMethod.TDIGEST.getParseField().getPreferredName(), TDigestOptions::new);\n+    private static final ConstructingObjectParser<PercentilesAggregationBuilder, String> PARSER;\n     static {\n-        TDIGEST_OPTIONS_PARSER.declareDouble((opts, compression) -> opts.compression = compression, COMPRESSION_FIELD);\n-    }\n+        PARSER = new ConstructingObjectParser<>(PercentilesAggregationBuilder.NAME, false, (objects, name) -> {\n \n-    private static class HDROptions {\n-        Integer numberOfSigDigits;\n-    }\n+            double[] values = ((List<Double>) objects[0]).stream().mapToDouble(Double::doubleValue).toArray();\n+            PercentilesMethod.Config percentilesConfig;\n \n-    private static final ObjectParser<HDROptions, Void> HDR_OPTIONS_PARSER =\n-            new ObjectParser<>(PercentilesMethod.HDR.getParseField().getPreferredName(), HDROptions::new);\n-    static {\n-        HDR_OPTIONS_PARSER.declareInt(\n-                (opts, numberOfSigDigits) -> opts.numberOfSigDigits = numberOfSigDigits,\n-                NUMBER_SIGNIFICANT_DIGITS_FIELD);\n-    }\n+            if (objects[1] != null && objects[2] != null) {\n+                throw new IllegalStateException(\"Only one percentiles method should be declared.\");\n+            } else if (objects[1] == null && objects[2] == null) {\n+                // Default is tdigest\n+                percentilesConfig = new PercentilesMethod.Config.TDigest();\n+            } else if (objects[1] != null) {\n+                percentilesConfig = (PercentilesMethod.Config) objects[1];\n+            } else {\n+                percentilesConfig = (PercentilesMethod.Config) objects[2];\n+            }\n \n-    private static final ObjectParser<InternalBuilder, Void> PARSER;\n-    static {\n-        PARSER = new ObjectParser<>(PercentilesAggregationBuilder.NAME);\n-        ValuesSourceParserHelper.declareAnyFields(PARSER, true, true);\n+            return new PercentilesAggregationBuilder(name, values, percentilesConfig);\n+        });\n \n-        PARSER.declareDoubleArray(\n-                (b, v) -> b.percentiles(v.stream().mapToDouble(Double::doubleValue).toArray()),\n-                PERCENTS_FIELD);\n+        ValuesSourceParserHelper.declareAnyFields(PARSER, true, true);\n \n+        PARSER.declareDoubleArray(ConstructingObjectParser.constructorArg(), PERCENTS_FIELD);\n         PARSER.declareBoolean(PercentilesAggregationBuilder::keyed, KEYED_FIELD);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), PercentilesMethod.TDIGEST_PARSER,", "originalCommit": "830b796997644cd901081c76384052b3f325d0fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c343eabf083e5a2429e7c7a0b1e5da1d5b941d7", "url": "https://github.com/elastic/elasticsearch/commit/7c343eabf083e5a2429e7c7a0b1e5da1d5b941d7", "message": "Review cleanup, fixes to deal with optional defaults in tests", "committedDate": "2020-02-06T22:27:03Z", "type": "commit"}, {"oid": "e8a7b3da64934c0be49b97b7b9aed7d7f8587238", "url": "https://github.com/elastic/elasticsearch/commit/e8a7b3da64934c0be49b97b7b9aed7d7f8587238", "message": "Clarify how the parser works, rename percentileConfig methods for consistency", "committedDate": "2020-02-07T19:52:13Z", "type": "commit"}, {"oid": "2e76f662aa164815b1c1712885e4e20411e38049", "url": "https://github.com/elastic/elasticsearch/commit/2e76f662aa164815b1c1712885e4e20411e38049", "message": "Move Config to own high-level class", "committedDate": "2020-02-07T21:02:31Z", "type": "commit"}, {"oid": "6e804bca2ee35297f5937bf2edd9ac9f8d8bbb8c", "url": "https://github.com/elastic/elasticsearch/commit/6e804bca2ee35297f5937bf2edd9ac9f8d8bbb8c", "message": "checkstyle", "committedDate": "2020-02-10T16:26:48Z", "type": "commit"}, {"oid": "7a9245302ad0040e01ef563b676022238c0a4ba5", "url": "https://github.com/elastic/elasticsearch/commit/7a9245302ad0040e01ef563b676022238c0a4ba5", "message": "Merge remote-tracking branch 'origin/master' into percentiles_builder_refactor", "committedDate": "2020-02-10T16:27:05Z", "type": "commit"}, {"oid": "4dc1118b972d1cd7c11ccdeabb41b248a2af1fa7", "url": "https://github.com/elastic/elasticsearch/commit/4dc1118b972d1cd7c11ccdeabb41b248a2af1fa7", "message": "Merge conflict", "committedDate": "2020-02-10T17:00:47Z", "type": "commit"}, {"oid": "098e098779229d079dfa8b7a0c7cf5f26296d832", "url": "https://github.com/elastic/elasticsearch/commit/098e098779229d079dfa8b7a0c7cf5f26296d832", "message": "Loosen exception catching on yaml tests\n\nThe exception message changed slightly, and rather than make\ntwo tests with version gates we can just look for a 4xx exception.", "committedDate": "2020-02-10T19:19:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MzEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r377283136", "bodyText": "nit: Can we just add something to the javadoc for what we expect the contents of objects to be?  Especially, it looks like we're passing in two configs, at most one of which should be not null, but it's not clear if order matters for them.", "author": "not-napoleon", "createdAt": "2020-02-10T19:56:09Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.TriFunction;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceParserHelper;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * This provides a base class for aggregations that are building percentiles or percentiles-like functionality (e.g. percentile ranks).\n+ * It provides a set of common fields/functionality for setting the available algorithms (TDigest and HDRHistogram),\n+ * as well as algorithm-specific settings via a {@link PercentilesConfig} object\n+ */\n+public abstract class AbstractPercentilesAggregationBuilder<T extends AbstractPercentilesAggregationBuilder<T>>\n+    extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource, T> {\n+\n+    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n+    protected boolean keyed = true;\n+    protected double[] values;\n+    private PercentilesConfig percentilesConfig;\n+    private ParseField valuesField;\n+\n+    public static <T extends AbstractPercentilesAggregationBuilder<T>> ConstructingObjectParser<T, String> getParser(String aggName,\n+                                                         TriFunction<String, double[], PercentilesConfig, T> fn,\n+                                                         ParseField valuesField) {\n+\n+        /**\n+         * This is a non-ideal ConstructingObjectParser, because it is a compromise between Percentiles and Ranks.\n+         * Ranks requires an array of values because there is no sane default, and we want to keep that in the ctor.\n+         * Percentiles has defaults, which means the API allows the user to either use the default or configure\n+         * their own.\n+         *\n+         * The mutability of Percentiles keeps us from having a strict ConstructingObjectParser, while the ctor\n+         * of Ranks keeps us from using a regular ObjectParser.\n+         *\n+         * This is a compromise, in that it is a ConstructingOP which accepts all optional arguments, and then we sort\n+         * out the behavior from there\n+         */\n+        ConstructingObjectParser<T, String> parser = new ConstructingObjectParser<>(aggName, false, (objects, name) -> {", "originalCommit": "098e098779229d079dfa8b7a0c7cf5f26296d832", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MDIzMw==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r377290233", "bodyText": "I like how this looks as a top level.  Makes more sense this way.", "author": "not-napoleon", "createdAt": "2020-02-10T20:11:18Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/PercentilesConfig.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.DocValueFormat;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A small config object that carries algo-specific settings.  This allows the factory to have\n+ * a single unified constructor for both algos, but internally switch execution\n+ * depending on which algo is selected\n+ */\n+public abstract class PercentilesConfig implements ToXContent, Writeable {", "originalCommit": "098e098779229d079dfa8b7a0c7cf5f26296d832", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ffa6a2c4e16490b459f0aecd0820f2625fe17970", "url": "https://github.com/elastic/elasticsearch/commit/ffa6a2c4e16490b459f0aecd0820f2625fe17970", "message": "Clarify and rename args object in ConstructingObjectParser", "committedDate": "2020-02-10T21:33:59Z", "type": "commit"}, {"oid": "dcd55ce2dbb72fd3dd05e3c5f08c823f314b61b4", "url": "https://github.com/elastic/elasticsearch/commit/dcd55ce2dbb72fd3dd05e3c5f08c823f314b61b4", "message": "Merge remote-tracking branch 'origin/master' into percentiles_builder_refactor", "committedDate": "2020-02-11T16:55:02Z", "type": "commit"}, {"oid": "3672467101dc66cd9b9c9918d6dffaf50b9efa11", "url": "https://github.com/elastic/elasticsearch/commit/3672467101dc66cd9b9c9918d6dffaf50b9efa11", "message": "Adjust to account for new validations", "committedDate": "2020-02-11T17:16:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwOTEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r377809120", "bodyText": "Could you pass a method that builds the default instead of having it be handled in the ctor?", "author": "nik9000", "createdAt": "2020-02-11T18:13:11Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.TriFunction;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceParserHelper;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * This provides a base class for aggregations that are building percentiles or percentiles-like functionality (e.g. percentile ranks).\n+ * It provides a set of common fields/functionality for setting the available algorithms (TDigest and HDRHistogram),\n+ * as well as algorithm-specific settings via a {@link PercentilesConfig} object\n+ */\n+public abstract class AbstractPercentilesAggregationBuilder<T extends AbstractPercentilesAggregationBuilder<T>>\n+    extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource, T> {\n+\n+    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n+    protected boolean keyed = true;\n+    protected double[] values;\n+    private PercentilesConfig percentilesConfig;\n+    private ParseField valuesField;\n+\n+    public static <T extends AbstractPercentilesAggregationBuilder<T>> ConstructingObjectParser<T, String> getParser(String aggName,\n+                                                         TriFunction<String, double[], PercentilesConfig, T> fn,\n+                                                         ParseField valuesField) {\n+\n+        /**\n+         * This is a non-ideal ConstructingObjectParser, because it is a compromise between Percentiles and Ranks.\n+         * Ranks requires an array of values because there is no sane default, and we want to keep that in the ctor.\n+         * Percentiles has defaults, which means the API allows the user to either use the default or configure\n+         * their own.\n+         *\n+         * The mutability of Percentiles keeps us from having a strict ConstructingObjectParser, while the ctor\n+         * of Ranks keeps us from using a regular ObjectParser.\n+         *\n+         * This is a compromise, in that it is a ConstructingOP which accepts all optional arguments, and then we sort\n+         * out the behavior from there\n+         *\n+         * `args` are provided from the ConstructingObjectParser in-order they are defined in the parser.  So:\n+         *  - args[0]: values\n+         *  - args[1]: tdigest config options\n+         *  - args[2]: hdr config options\n+         *\n+         *  If `args` is null or empty, it means all were omitted.  This is usually an anti-pattern for\n+         *  ConstructingObjectParser, but we're allowing it because of the above-mentioned reasons\n+         */\n+        ConstructingObjectParser<T, String> parser = new ConstructingObjectParser<>(aggName, false, (args, name) -> {", "originalCommit": "3672467101dc66cd9b9c9918d6dffaf50b9efa11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMDYyNg==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r377810626", "bodyText": "I think it'd be a little more clear if you did:\nPercentilesConfig explicitTDigestConfig = (PercentilesConfig) args[1];\nPercentilesConfig explicitHdrConfig = (PercentilesConfig) args[2];\nif (explicitTDigestConfig == null && explicitHdrConfig == null) {\n...\n\nIT feels like it'd be cleaner to throw an exception if both are set. Is that something you aren't doing for bwc? Maybe leave a comment in that case.", "author": "nik9000", "createdAt": "2020-02-11T18:16:16Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.TriFunction;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceParserHelper;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * This provides a base class for aggregations that are building percentiles or percentiles-like functionality (e.g. percentile ranks).\n+ * It provides a set of common fields/functionality for setting the available algorithms (TDigest and HDRHistogram),\n+ * as well as algorithm-specific settings via a {@link PercentilesConfig} object\n+ */\n+public abstract class AbstractPercentilesAggregationBuilder<T extends AbstractPercentilesAggregationBuilder<T>>\n+    extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource, T> {\n+\n+    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n+    protected boolean keyed = true;\n+    protected double[] values;\n+    private PercentilesConfig percentilesConfig;\n+    private ParseField valuesField;\n+\n+    public static <T extends AbstractPercentilesAggregationBuilder<T>> ConstructingObjectParser<T, String> getParser(String aggName,\n+                                                         TriFunction<String, double[], PercentilesConfig, T> fn,\n+                                                         ParseField valuesField) {\n+\n+        /**\n+         * This is a non-ideal ConstructingObjectParser, because it is a compromise between Percentiles and Ranks.\n+         * Ranks requires an array of values because there is no sane default, and we want to keep that in the ctor.\n+         * Percentiles has defaults, which means the API allows the user to either use the default or configure\n+         * their own.\n+         *\n+         * The mutability of Percentiles keeps us from having a strict ConstructingObjectParser, while the ctor\n+         * of Ranks keeps us from using a regular ObjectParser.\n+         *\n+         * This is a compromise, in that it is a ConstructingOP which accepts all optional arguments, and then we sort\n+         * out the behavior from there\n+         *\n+         * `args` are provided from the ConstructingObjectParser in-order they are defined in the parser.  So:\n+         *  - args[0]: values\n+         *  - args[1]: tdigest config options\n+         *  - args[2]: hdr config options\n+         *\n+         *  If `args` is null or empty, it means all were omitted.  This is usually an anti-pattern for\n+         *  ConstructingObjectParser, but we're allowing it because of the above-mentioned reasons\n+         */\n+        ConstructingObjectParser<T, String> parser = new ConstructingObjectParser<>(aggName, false, (args, name) -> {\n+\n+            if (args == null || args.length == 0) {\n+                // Note: if this is a Percentiles agg, the null `values` will be converted into a default,\n+                // whereas a Ranks agg will throw an exception due to missing a required param\n+                return fn.apply(name, null, new PercentilesConfig.TDigest());\n+            }\n+\n+            double[] values = args[0] != null ? ((List<Double>) args[0]).stream().mapToDouble(Double::doubleValue).toArray() : null;\n+            PercentilesConfig percentilesConfig;\n+\n+            if (args[1] != null && args[2] != null) {", "originalCommit": "3672467101dc66cd9b9c9918d6dffaf50b9efa11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyMzEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r377823136", "bodyText": "++ I can add some local variables to make it more explicit.\n\nIT feels like it'd be cleaner to throw an exception if both are set. Is that something you aren't doing for bwc? Maybe leave a comment in that case.\n\nThat's exactly what this block is doing :)  Probably will be clearer after the explicit local variables\nif (args[1] != null && args[2] != null) {\n  throw new IllegalArgumentException(\"Only one percentiles method should be declared.\");\n}", "author": "polyfractal", "createdAt": "2020-02-11T18:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMDYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMTU0NA==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r377811544", "bodyText": "Could you rename fn to ctor? I think it is fair to think of it as a constructor reference.", "author": "nik9000", "createdAt": "2020-02-11T18:17:56Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AbstractPercentilesAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.TriFunction;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValueType;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceParserHelper;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * This provides a base class for aggregations that are building percentiles or percentiles-like functionality (e.g. percentile ranks).\n+ * It provides a set of common fields/functionality for setting the available algorithms (TDigest and HDRHistogram),\n+ * as well as algorithm-specific settings via a {@link PercentilesConfig} object\n+ */\n+public abstract class AbstractPercentilesAggregationBuilder<T extends AbstractPercentilesAggregationBuilder<T>>\n+    extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource, T> {\n+\n+    public static final ParseField KEYED_FIELD = new ParseField(\"keyed\");\n+    protected boolean keyed = true;\n+    protected double[] values;\n+    private PercentilesConfig percentilesConfig;\n+    private ParseField valuesField;\n+\n+    public static <T extends AbstractPercentilesAggregationBuilder<T>> ConstructingObjectParser<T, String> getParser(String aggName,\n+                                                         TriFunction<String, double[], PercentilesConfig, T> fn,", "originalCommit": "3672467101dc66cd9b9c9918d6dffaf50b9efa11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMTk1NA==", "url": "https://github.com/elastic/elasticsearch/pull/51887#discussion_r377811954", "bodyText": "createParser?", "author": "nik9000", "createdAt": "2020-02-11T18:18:41Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/PercentileRanksAggregationBuilder.java", "diffHunk": "@@ -21,290 +21,72 @@\n \n import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n-import org.elasticsearch.common.xcontent.ObjectParser;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories.Builder;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n-import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n-import org.elasticsearch.search.aggregations.support.ValueType;\n import org.elasticsearch.search.aggregations.support.ValuesSource;\n-import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder.LeafOnly;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n-import org.elasticsearch.search.aggregations.support.ValuesSourceParserHelper;\n \n import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n \n-import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n-\n-public class PercentileRanksAggregationBuilder extends LeafOnly<ValuesSource, PercentileRanksAggregationBuilder> {\n+public class PercentileRanksAggregationBuilder extends AbstractPercentilesAggregationBuilder<PercentileRanksAggregationBuilder> {\n     public static final String NAME = PercentileRanks.TYPE_NAME;\n \n-    public static final ParseField VALUES_FIELD = new ParseField(\"values\");\n-\n-    private static class TDigestOptions {\n-        Double compression;\n-    }\n-\n-    private static final ObjectParser<TDigestOptions, String> TDIGEST_OPTIONS_PARSER =\n-            new ObjectParser<>(PercentilesMethod.TDIGEST.getParseField().getPreferredName(), TDigestOptions::new);\n-    static {\n-        TDIGEST_OPTIONS_PARSER.declareDouble((opts, compression) -> opts.compression = compression, new ParseField(\"compression\"));\n-    }\n-\n-    private static class HDROptions {\n-        Integer numberOfSigDigits;\n-    }\n-\n-    private static final ObjectParser<HDROptions, String> HDR_OPTIONS_PARSER =\n-            new ObjectParser<>(PercentilesMethod.HDR.getParseField().getPreferredName(), HDROptions::new);\n-    static {\n-        HDR_OPTIONS_PARSER.declareInt((opts, numberOfSigDigits) -> opts.numberOfSigDigits = numberOfSigDigits,\n-                new ParseField(\"number_of_significant_value_digits\"));\n-    }\n-\n-    // The builder requires two parameters for the constructor: aggregation name and values array.  The\n-    // agg name is supplied externally via the Parser's context (as a String), while the values array\n-    // is parsed from the request and supplied to the ConstructingObjectParser as a ctor argument\n+    private static final ParseField VALUES_FIELD = new ParseField(\"values\");\n     private static final ConstructingObjectParser<PercentileRanksAggregationBuilder, String> PARSER;\n     static {\n-        PARSER = new ConstructingObjectParser<>(PercentileRanksAggregationBuilder.NAME, false,\n-            (a, context) -> new PercentileRanksAggregationBuilder(context, (List) a[0]));\n-        ValuesSourceParserHelper.declareAnyFields(PARSER, true, true);\n-        PARSER.declareDoubleArray(constructorArg(), VALUES_FIELD);\n-        PARSER.declareBoolean(PercentileRanksAggregationBuilder::keyed, PercentilesAggregationBuilder.KEYED_FIELD);\n-\n-        PARSER.declareField((b, v) -> {\n-            b.method(PercentilesMethod.TDIGEST);\n-            if (v.compression != null) {\n-                b.compression(v.compression);\n-            }\n-        }, TDIGEST_OPTIONS_PARSER::parse, PercentilesMethod.TDIGEST.getParseField(), ObjectParser.ValueType.OBJECT);\n-\n-        PARSER.declareField((b, v) -> {\n-            b.method(PercentilesMethod.HDR);\n-            if (v.numberOfSigDigits != null) {\n-                b.numberOfSignificantValueDigits(v.numberOfSigDigits);\n-            }\n-        }, HDR_OPTIONS_PARSER::parse, PercentilesMethod.HDR.getParseField(), ObjectParser.ValueType.OBJECT);\n+        PARSER = AbstractPercentilesAggregationBuilder.getParser(", "originalCommit": "3672467101dc66cd9b9c9918d6dffaf50b9efa11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31aaa9226fbfd79baad465ec25bf6cb0c58bbb19", "url": "https://github.com/elastic/elasticsearch/commit/31aaa9226fbfd79baad465ec25bf6cb0c58bbb19", "message": "Address review comments", "committedDate": "2020-02-11T19:14:49Z", "type": "commit"}]}