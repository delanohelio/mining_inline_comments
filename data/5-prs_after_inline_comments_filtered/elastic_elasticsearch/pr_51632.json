{"pr_number": 51632, "pr_title": "Simplify rebalancer's weight function", "pr_createdAt": "2020-01-29T17:07:15Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51632", "timeline": [{"oid": "87f8665c340525f8012f87136b13f36bb6835f99", "url": "https://github.com/elastic/elasticsearch/commit/87f8665c340525f8012f87136b13f36bb6835f99", "message": "Fix JavaDoc", "committedDate": "2020-01-29T16:32:17Z", "type": "commit"}, {"oid": "9dfb1c5baea042544ba49296fa16b6aa5288c39e", "url": "https://github.com/elastic/elasticsearch/commit/9dfb1c5baea042544ba49296fa16b6aa5288c39e", "message": "Simplify numAdditionalShards calculation and assert it matches original", "committedDate": "2020-01-29T16:32:18Z", "type": "commit"}, {"oid": "455f2f5a0fe9f9957006ea33da851130f3b2d91d", "url": "https://github.com/elastic/elasticsearch/commit/455f2f5a0fe9f9957006ea33da851130f3b2d91d", "message": "Inline and simplify", "committedDate": "2020-01-29T16:32:18Z", "type": "commit"}, {"oid": "ed674ba443a2423b73e2d0009d4553cf18a8b26e", "url": "https://github.com/elastic/elasticsearch/commit/ed674ba443a2423b73e2d0009d4553cf18a8b26e", "message": "Inline", "committedDate": "2020-01-29T16:32:18Z", "type": "commit"}, {"oid": "89454306f94810671247dd5c02b5aecee9a36bcc", "url": "https://github.com/elastic/elasticsearch/commit/89454306f94810671247dd5c02b5aecee9a36bcc", "message": "More inline", "committedDate": "2020-01-29T16:32:19Z", "type": "commit"}, {"oid": "abe7c86151236682af08d711cef86abf0413e712", "url": "https://github.com/elastic/elasticsearch/commit/abe7c86151236682af08d711cef86abf0413e712", "message": "Inline and rearrange", "committedDate": "2020-01-29T16:32:19Z", "type": "commit"}, {"oid": "5bc7f5d52000a5f940b70d4756b061cb9b5c6c5b", "url": "https://github.com/elastic/elasticsearch/commit/5bc7f5d52000a5f940b70d4756b061cb9b5c6c5b", "message": "Inline deltas and simplify", "committedDate": "2020-01-29T16:32:20Z", "type": "commit"}, {"oid": "e01a832577f876a1fa02b30cd1751b83d550b04f", "url": "https://github.com/elastic/elasticsearch/commit/e01a832577f876a1fa02b30cd1751b83d550b04f", "message": "No need to add 1 to weight when finding the min or sorting", "committedDate": "2020-01-29T16:32:20Z", "type": "commit"}, {"oid": "99ae9a3d4a223629586bd4369573a5aef27513dd", "url": "https://github.com/elastic/elasticsearch/commit/99ae9a3d4a223629586bd4369573a5aef27513dd", "message": "Simplify", "committedDate": "2020-01-29T16:32:21Z", "type": "commit"}, {"oid": "53260da95a0f956347a33d352d48cb40060d1de4", "url": "https://github.com/elastic/elasticsearch/commit/53260da95a0f956347a33d352d48cb40060d1de4", "message": "Extract delta from loop since it is constant, and bail early if we would never set candidate", "committedDate": "2020-01-29T16:32:21Z", "type": "commit"}, {"oid": "16221e4d154e54aae8c54d46ca35404502d0e4b2", "url": "https://github.com/elastic/elasticsearch/commit/16221e4d154e54aae8c54d46ca35404502d0e4b2", "message": "Simplify condition", "committedDate": "2020-01-29T16:32:22Z", "type": "commit"}, {"oid": "2e15e51cb78307323a0817e4c412aa43120a4399", "url": "https://github.com/elastic/elasticsearch/commit/2e15e51cb78307323a0817e4c412aa43120a4399", "message": "Assignment is never read", "committedDate": "2020-01-29T16:32:22Z", "type": "commit"}, {"oid": "9616a759c9db82901d0e39240711989b656c81eb", "url": "https://github.com/elastic/elasticsearch/commit/9616a759c9db82901d0e39240711989b656c81eb", "message": "Check shard is on node and has a better id before checking allocation deciders", "committedDate": "2020-01-29T16:32:22Z", "type": "commit"}, {"oid": "d0b1bb3d77abf6c1ca566de04dd34652667528e5", "url": "https://github.com/elastic/elasticsearch/commit/d0b1bb3d77abf6c1ca566de04dd34652667528e5", "message": "Tricky simplification\n\nminCost == weight.weight(this, maxNode, idx) - weight.weight(this, minNode, idx) so:\n\nminCost <= delta\n<=> weight.weight(this, maxNode, idx) - weight.weight(this, minNode, idx)\n         <= weight.weight(this, minNode, idx) - weight.weight(this, maxNode, idx) + 2;\n<=> 2 * weight.weight(this, maxNode, idx) - 2 * weight.weight(this, minNode, idx) <= 2;\n<=> weight.weight(this, maxNode, idx) - weight.weight(this, minNode, idx) <= 1\n<=> minCost <= 1", "committedDate": "2020-01-29T16:32:23Z", "type": "commit"}, {"oid": "521d7c8c4946281a2c42e3d5962b278a82502083", "url": "https://github.com/elastic/elasticsearch/commit/521d7c8c4946281a2c42e3d5962b278a82502083", "message": "Move check on minCost to caller", "committedDate": "2020-01-29T16:41:17Z", "type": "commit"}, {"oid": "bacce1cb706d203cc971ad8bbe746cb432c50db8", "url": "https://github.com/elastic/elasticsearch/commit/bacce1cb706d203cc971ad8bbe746cb432c50db8", "message": "Reduce canAllocate/canRebalance calls by checking the shards in order", "committedDate": "2020-01-29T16:46:40Z", "type": "commit"}, {"oid": "0bae119d5a1c44aea768c5f81be6e16ed3691631", "url": "https://github.com/elastic/elasticsearch/commit/0bae119d5a1c44aea768c5f81be6e16ed3691631", "message": "Don't call canAllocate if canRebalance already said no", "committedDate": "2020-01-29T16:47:39Z", "type": "commit"}, {"oid": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4", "url": "https://github.com/elastic/elasticsearch/commit/5ffbbac3e8d0f9b568e54876ced522bc2933f6c4", "message": "Extract field, don't need a new comparator each time", "committedDate": "2020-01-29T16:55:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MTU0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372891547", "bodyText": "1.0f", "author": "ywelsch", "createdAt": "2020-01-30T11:16:32Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -408,12 +395,9 @@ private MoveDecision decideRebalance(final ShardRouting shard) {\n                     // more even, it doesn't make sense to execute the heavyweight operation of relocating a shard unless\n                     // the gains make it worth it, as defined by the threshold\n                     boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false;\n-                    // simulate the weight of the node if we were to relocate the shard to it\n-                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName);\n                     // calculate the delta of the weights of the two nodes if we were to add the shard to the\n                     // node in question and move it away from the node that currently holds it.\n-                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName);\n-                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta;\n+                    boolean betterWeightWithShardAdded = nodeWeight + 1 < currentWeight;", "originalCommit": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2ODAxMA==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373468010", "bodyText": "\ud83d\udc4d 482be93", "author": "DaveCTurner", "createdAt": "2020-01-31T13:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MjA4OA==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372892088", "bodyText": "perhaps just\nif (rebalanceDecision.type() == Type.NO) {\n  continue;\n}\n\nand the same for the allocationDecision below", "author": "ywelsch", "createdAt": "2020-01-30T11:17:59Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -1000,30 +995,32 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {\n                     if (shard.started()) {\n                         // skip initializing, unassigned and relocating shards we can't relocate them anyway\n-                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n-                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n-                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))\n-                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {\n-                            if (maxNode.containsShard(shard)) {\n-                                // simulate moving shard from maxNode to minNode\n-                                final float delta = weight.weightShardAdded(\n-                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx);\n-                                if (delta < minCost ||\n-                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {\n-                                    /* this last line is a tie-breaker to make the shard allocation alg deterministic\n-                                     * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/\n-                                    minCost = delta;\n-                                    candidate = shard;\n-                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n-                                }\n-                            }\n+                        if (maxNode.containsShard(shard)) {\n+                            shardRoutings.add(shard);\n                         }\n                     }\n                 }\n \n+                // look for a relocation candidate, in descending order of shard id so that the decision is deterministic\n+                shardRoutings.sort(BY_DESCENDING_SHARD_ID);\n+                for (ShardRouting shard : shardRoutings) {\n+                    final Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n+                    if ((rebalanceDecision.type() != Type.YES) && (rebalanceDecision.type() != Type.THROTTLE)) {\n+                        continue;", "originalCommit": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDAxMA==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373470010", "bodyText": "\ud83d\udc4d b4f90c2", "author": "DaveCTurner", "createdAt": "2020-01-31T13:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MjA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5Mjk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372892972", "bodyText": "Should we move this up as well, so that we can avoid the if (candidate != null) { check (as it's only assigned once now)?", "author": "ywelsch", "createdAt": "2020-01-30T11:20:12Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -1000,30 +995,32 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {\n                     if (shard.started()) {\n                         // skip initializing, unassigned and relocating shards we can't relocate them anyway\n-                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n-                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n-                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))\n-                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {\n-                            if (maxNode.containsShard(shard)) {\n-                                // simulate moving shard from maxNode to minNode\n-                                final float delta = weight.weightShardAdded(\n-                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx);\n-                                if (delta < minCost ||\n-                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {\n-                                    /* this last line is a tie-breaker to make the shard allocation alg deterministic\n-                                     * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/\n-                                    minCost = delta;\n-                                    candidate = shard;\n-                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n-                                }\n-                            }\n+                        if (maxNode.containsShard(shard)) {\n+                            shardRoutings.add(shard);\n                         }\n                     }\n                 }\n \n+                // look for a relocation candidate, in descending order of shard id so that the decision is deterministic\n+                shardRoutings.sort(BY_DESCENDING_SHARD_ID);\n+                for (ShardRouting shard : shardRoutings) {\n+                    final Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n+                    if ((rebalanceDecision.type() != Type.YES) && (rebalanceDecision.type() != Type.THROTTLE)) {\n+                        continue;\n+                    }\n+                    final Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n+                    if ((allocationDecision.type() != Type.YES) && (allocationDecision.type() != Type.THROTTLE)) {\n+                        continue;\n+                    }\n+                    candidate = shard;\n+                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n+                    break;\n+                }\n+\n                 if (candidate != null) {", "originalCommit": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDA2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373470063", "bodyText": "Yes, thanks, that's nicer still. ad503a5.", "author": "DaveCTurner", "createdAt": "2020-01-31T13:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5Mjk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwMjA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372902085", "bodyText": "I think this could now translate into a nice stream one liner?\nindex.stream().filter(ShardRouting::started).filter(maxNode::containsShard).sorted(Comparator.comparing(ShardRouting::id).reversed())\n\nthen either collect or do the final filtering and findFirst?", "author": "henningandersen", "createdAt": "2020-01-30T11:42:16Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -993,24 +993,27 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {", "originalCommit": "bacce1cb706d203cc971ad8bbe746cb432c50db8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTg5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373469893", "bodyText": "We can't use findFirst since we also need to capture the decision from the first matching shard; however nor do we need to collect into a list: 8971daa.\n(Of course .sorted() has to allocate an array anyway, but I think that Collectors#toList always copies its input even if it's already an array, so at least there's that)", "author": "DaveCTurner", "createdAt": "2020-01-31T13:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwMjA4NQ=="}], "type": "inlineReview"}, {"oid": "86cebb32b2fdcc550c66c7d22783e1b4d8e6ff44", "url": "https://github.com/elastic/elasticsearch/commit/86cebb32b2fdcc550c66c7d22783e1b4d8e6ff44", "message": "Merge remote-tracking branch 'upstream/master' into 2020-01-29-balanced-shards-allocator-simplification", "committedDate": "2020-01-31T12:33:23Z", "type": "commit"}, {"oid": "8971daab704814f21f931250a0f188c048544675", "url": "https://github.com/elastic/elasticsearch/commit/8971daab704814f21f931250a0f188c048544675", "message": "Use a stream", "committedDate": "2020-01-31T12:51:54Z", "type": "commit"}, {"oid": "b4f90c20f3c439f2c7d614767bd77866e86f8d17", "url": "https://github.com/elastic/elasticsearch/commit/b4f90c20f3c439f2c7d614767bd77866e86f8d17", "message": "Simplify not-YES to NO", "committedDate": "2020-01-31T12:51:54Z", "type": "commit"}, {"oid": "ad503a5b0573eb9617c95c7403e133966edbe727", "url": "https://github.com/elastic/elasticsearch/commit/ad503a5b0573eb9617c95c7403e133966edbe727", "message": "No need for mutable candidate, just do the thing inside the loop", "committedDate": "2020-01-31T12:58:33Z", "type": "commit"}, {"oid": "482be939fd69d23cca58b8469ef65edd24511ab8", "url": "https://github.com/elastic/elasticsearch/commit/482be939fd69d23cca58b8469ef65edd24511ab8", "message": "1.0f", "committedDate": "2020-01-31T12:59:10Z", "type": "commit"}, {"oid": "f2e3a77d9e88fbafdff66bde808ee26b41489fa9", "url": "https://github.com/elastic/elasticsearch/commit/f2e3a77d9e88fbafdff66bde808ee26b41489fa9", "message": "Log throttled relocation too (previously logged as 'no relocation' at TRACE)", "committedDate": "2020-01-31T13:20:31Z", "type": "commit"}]}