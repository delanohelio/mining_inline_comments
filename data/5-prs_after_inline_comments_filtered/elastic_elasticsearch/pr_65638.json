{"pr_number": 65638, "pr_title": "[ML] adding ml autoscaling integration test", "pr_createdAt": "2020-11-30T22:05:43Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65638", "timeline": [{"oid": "e35fe6ab5a52280a39890d00cb387380b3ea5a47", "url": "https://github.com/elastic/elasticsearch/commit/e35fe6ab5a52280a39890d00cb387380b3ea5a47", "message": "[ML] adding ml autoscaling integration test", "committedDate": "2020-11-30T21:59:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NzE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65638#discussion_r533277149", "bodyText": "We will have to be careful that the Cloud infrastructure never tries to set this setting higher than 3 in a pre-7.11/post-7.11 mixed version cluster.  This should be possible for autoscaling, as we've previously said that autoscaling won't attempt to do anything in such a cluster.\nThis ties in with the Cloud-side PR to set the settings required for ML autoscaling.  It is probably best if this one doesn't go in elasticsearch.yml, but instead gets set using a cluster settings API call once the entire cluster has been upgraded to 7.11 or higher.\nAlso, the docs state that the maximum value is 3.  I think it's probably best to leave the docs like this for the time being.  Maybe in a year or two we can adjust them, but while there is a risk of problems in mixed version clusters it's probably best that we don't.", "author": "droberts195", "createdAt": "2020-12-01T10:16:18Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java", "diffHunk": "@@ -449,7 +449,7 @@\n         false,\n         Property.NodeScope);\n     public static final Setting<Integer> MAX_LAZY_ML_NODES =\n-            Setting.intSetting(\"xpack.ml.max_lazy_ml_nodes\", 0, 0, 3, Property.Dynamic, Property.NodeScope);\n+            Setting.intSetting(\"xpack.ml.max_lazy_ml_nodes\", 0, 0, Property.Dynamic, Property.NodeScope);", "originalCommit": "e35fe6ab5a52280a39890d00cb387380b3ea5a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyNjg0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65638#discussion_r533326847", "bodyText": "I can see where the 1328196267L comes from in the previous assertion: ceil((100 + 40 + 200 + 40) * 1024^2 * 100 / 30).\nBut why is this one 380991001934L?  ceil((100 + 40 + 200 + 40 + 20000 + 40 + 10000 + 40 + 30000 + 40) * 1024^2 * 100 / 30) = 211462826667\nI think it would be good to put the expected formula that's been evaluated in a comment so that if ever there are changes to the constants used in the code then the person who edits the expected result here doesn't just mindlessly paste in whatever makes the test pass but can use the formula to manually check the result makes sense given their new constants.", "author": "droberts195", "createdAt": "2020-12-01T11:09:32Z", "path": "x-pack/plugin/ml/qa/native-multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/ml/integration/AutoscalingIT.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.integration;\n+\n+import org.elasticsearch.cluster.NamedDiff;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.reindex.ReindexPlugin;\n+import org.elasticsearch.ingest.common.IngestCommonPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.transport.Netty4Plugin;\n+import org.elasticsearch.xpack.autoscaling.Autoscaling;\n+import org.elasticsearch.xpack.autoscaling.AutoscalingMetadata;\n+import org.elasticsearch.xpack.autoscaling.action.GetAutoscalingCapacityAction;\n+import org.elasticsearch.xpack.autoscaling.action.PutAutoscalingPolicyAction;\n+import org.elasticsearch.xpack.autoscaling.capacity.AutoscalingDeciderResult;\n+import org.elasticsearch.xpack.autoscaling.capacity.AutoscalingDeciderResults;\n+import org.elasticsearch.xpack.core.ml.job.config.AnalysisConfig;\n+import org.elasticsearch.xpack.core.ml.job.config.AnalysisLimits;\n+import org.elasticsearch.xpack.core.ml.job.config.DataDescription;\n+import org.elasticsearch.xpack.core.ml.job.config.Detector;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.datastreams.DataStreamsPlugin;\n+import org.elasticsearch.xpack.ilm.IndexLifecycle;\n+import org.elasticsearch.xpack.ml.LocalStateMachineLearning;\n+import org.elasticsearch.xpack.ml.autoscaling.MlAutoscalingDeciderService;\n+import org.elasticsearch.xpack.ml.autoscaling.MlScalingReason;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasKey;\n+\n+public class AutoscalingIT extends MlNativeAutodetectIntegTestCase {\n+\n+    @Override\n+    protected List<NamedWriteableRegistry.Entry> getNamedWritableEntries() {\n+        List<NamedWriteableRegistry.Entry> entries = super.getNamedWritableEntries();\n+        entries.add(new NamedWriteableRegistry.Entry(Metadata.Custom.class, AutoscalingMetadata.NAME, AutoscalingMetadata::new));\n+        entries.add(new NamedWriteableRegistry.Entry(NamedDiff.class,\n+            AutoscalingMetadata.NAME,\n+            AutoscalingMetadata.AutoscalingMetadataDiff::new));\n+        entries.add(new NamedWriteableRegistry.Entry(\n+            AutoscalingDeciderResult.Reason.class,\n+            MlScalingReason.NAME,\n+            MlScalingReason::new\n+        ));\n+        return entries;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(\n+            LocalStateMachineLearning.class,\n+            Netty4Plugin.class,\n+            ReindexPlugin.class,\n+            Autoscaling.class,\n+            // The monitoring plugin requires script and gsub processors to be loaded\n+            IngestCommonPlugin.class,\n+            // The monitoring plugin script processor references painless. Include this for script compilation.\n+            // This is to reduce log spam\n+            MockPainlessScriptEngine.TestPlugin.class,\n+            // ILM is required for .ml-state template index settings\n+            IndexLifecycle.class,\n+            DataStreamsPlugin.class);\n+    }\n+\n+    @Override\n+    protected Settings externalClusterClientSettings() {\n+        return Settings.builder().put(super.externalClusterClientSettings())\n+            .put(Autoscaling.AUTOSCALING_ENABLED_SETTING.getKey(), true)\n+            .build();\n+    }\n+\n+    public void testMLAutoscalingCapacity() {\n+        SortedMap<String, Settings> deciders = new TreeMap<>();\n+        deciders.put(MlAutoscalingDeciderService.NAME, Settings.builder().build());\n+        final PutAutoscalingPolicyAction.Request request = new PutAutoscalingPolicyAction.Request(\n+            \"ml_test\",\n+            new TreeSet<>(Arrays.asList(\"ml\")),\n+            deciders\n+        );\n+        assertAcked(client().execute(PutAutoscalingPolicyAction.INSTANCE, request).actionGet());\n+\n+        assertMlCapacity(\n+            client().execute(\n+                GetAutoscalingCapacityAction.INSTANCE,\n+                new GetAutoscalingCapacityAction.Request()\n+            ).actionGet(),\n+            \"Requesting scale down as tier and/or node size could be smaller\",\n+            0L,\n+            0L);\n+\n+        putJob(\"job1\", 100);\n+        putJob(\"job2\", 200);\n+        openJob(\"job1\");\n+        openJob(\"job2\");\n+\n+        assertMlCapacity(\n+            client().execute(\n+                GetAutoscalingCapacityAction.INSTANCE,\n+                new GetAutoscalingCapacityAction.Request()\n+            ).actionGet(),\n+            \"Requesting scale down as tier and/or node size could be smaller\",\n+            1328196267L,\n+            734003200L);\n+\n+        putJob(\"bigjob1\", 20_000);\n+        putJob(\"bigjob2\", 10_000);\n+        putJob(\"bigjob3\", 30_000);\n+        openJob(\"bigjob1\");\n+        openJob(\"bigjob2\");\n+        openJob(\"bigjob3\");\n+\n+        assertMlCapacity(\n+            client().execute(\n+                GetAutoscalingCapacityAction.INSTANCE,\n+                new GetAutoscalingCapacityAction.Request()\n+            ).actionGet(),\n+            \"requesting scale up as number of jobs in queues exceeded configured limit\",\n+            380991001934L,", "originalCommit": "e35fe6ab5a52280a39890d00cb387380b3ea5a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMzE5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65638#discussion_r533333194", "bodyText": "This is running on the assumption that xpack.ml.max_machine_memory_percent is set to the default of 30 and xpack.ml.use_auto_machine_memory_percent is false right?  I think it's worth adding a comment to say that these are the expectations for this test and it will need modifying if either of those defaults is ever changed.  It will make it clearer for future maintainers where the numbers have come from.", "author": "droberts195", "createdAt": "2020-12-01T11:20:41Z", "path": "x-pack/plugin/ml/qa/native-multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/ml/integration/AutoscalingIT.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.integration;\n+\n+import org.elasticsearch.cluster.NamedDiff;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.reindex.ReindexPlugin;\n+import org.elasticsearch.ingest.common.IngestCommonPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.transport.Netty4Plugin;\n+import org.elasticsearch.xpack.autoscaling.Autoscaling;\n+import org.elasticsearch.xpack.autoscaling.AutoscalingMetadata;\n+import org.elasticsearch.xpack.autoscaling.action.GetAutoscalingCapacityAction;\n+import org.elasticsearch.xpack.autoscaling.action.PutAutoscalingPolicyAction;\n+import org.elasticsearch.xpack.autoscaling.capacity.AutoscalingDeciderResult;\n+import org.elasticsearch.xpack.autoscaling.capacity.AutoscalingDeciderResults;\n+import org.elasticsearch.xpack.core.ml.job.config.AnalysisConfig;\n+import org.elasticsearch.xpack.core.ml.job.config.AnalysisLimits;\n+import org.elasticsearch.xpack.core.ml.job.config.DataDescription;\n+import org.elasticsearch.xpack.core.ml.job.config.Detector;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.datastreams.DataStreamsPlugin;\n+import org.elasticsearch.xpack.ilm.IndexLifecycle;\n+import org.elasticsearch.xpack.ml.LocalStateMachineLearning;\n+import org.elasticsearch.xpack.ml.autoscaling.MlAutoscalingDeciderService;\n+import org.elasticsearch.xpack.ml.autoscaling.MlScalingReason;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasKey;\n+\n+public class AutoscalingIT extends MlNativeAutodetectIntegTestCase {\n+\n+    @Override\n+    protected List<NamedWriteableRegistry.Entry> getNamedWritableEntries() {\n+        List<NamedWriteableRegistry.Entry> entries = super.getNamedWritableEntries();\n+        entries.add(new NamedWriteableRegistry.Entry(Metadata.Custom.class, AutoscalingMetadata.NAME, AutoscalingMetadata::new));\n+        entries.add(new NamedWriteableRegistry.Entry(NamedDiff.class,\n+            AutoscalingMetadata.NAME,\n+            AutoscalingMetadata.AutoscalingMetadataDiff::new));\n+        entries.add(new NamedWriteableRegistry.Entry(\n+            AutoscalingDeciderResult.Reason.class,\n+            MlScalingReason.NAME,\n+            MlScalingReason::new\n+        ));\n+        return entries;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(\n+            LocalStateMachineLearning.class,\n+            Netty4Plugin.class,\n+            ReindexPlugin.class,\n+            Autoscaling.class,\n+            // The monitoring plugin requires script and gsub processors to be loaded\n+            IngestCommonPlugin.class,\n+            // The monitoring plugin script processor references painless. Include this for script compilation.\n+            // This is to reduce log spam\n+            MockPainlessScriptEngine.TestPlugin.class,\n+            // ILM is required for .ml-state template index settings\n+            IndexLifecycle.class,\n+            DataStreamsPlugin.class);\n+    }\n+\n+    @Override\n+    protected Settings externalClusterClientSettings() {\n+        return Settings.builder().put(super.externalClusterClientSettings())\n+            .put(Autoscaling.AUTOSCALING_ENABLED_SETTING.getKey(), true)\n+            .build();\n+    }\n+\n+    public void testMLAutoscalingCapacity() {", "originalCommit": "e35fe6ab5a52280a39890d00cb387380b3ea5a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0c1099a7caf533cdf31a59378fc2307504ceba1b", "url": "https://github.com/elastic/elasticsearch/commit/0c1099a7caf533cdf31a59378fc2307504ceba1b", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-autoscaling-integration-test", "committedDate": "2020-12-01T13:06:12Z", "type": "commit"}, {"oid": "2a1b44da07486ff89a241beed0d7d004a5aa9f4b", "url": "https://github.com/elastic/elasticsearch/commit/2a1b44da07486ff89a241beed0d7d004a5aa9f4b", "message": "addressing PR comments", "committedDate": "2020-12-01T15:13:54Z", "type": "commit"}, {"oid": "b76f5cdfa12adbf5ab8ee36ef47190d8e603e4b6", "url": "https://github.com/elastic/elasticsearch/commit/b76f5cdfa12adbf5ab8ee36ef47190d8e603e4b6", "message": "fixing format", "committedDate": "2020-12-01T16:22:49Z", "type": "commit"}, {"oid": "72268d9c3455655b97ac4598e1c88f5538b18bc6", "url": "https://github.com/elastic/elasticsearch/commit/72268d9c3455655b97ac4598e1c88f5538b18bc6", "message": "fixing tests format", "committedDate": "2020-12-01T17:39:58Z", "type": "commit"}, {"oid": "90328f2fb9f069fdf4aca889e259107eeb1928c0", "url": "https://github.com/elastic/elasticsearch/commit/90328f2fb9f069fdf4aca889e259107eeb1928c0", "message": "fixing test", "committedDate": "2020-12-01T17:51:11Z", "type": "commit"}, {"oid": "8b863ce088f5ab0f1ee0d06197bb879080b2be79", "url": "https://github.com/elastic/elasticsearch/commit/8b863ce088f5ab0f1ee0d06197bb879080b2be79", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-autoscaling-integration-test", "committedDate": "2020-12-02T18:28:06Z", "type": "commit"}, {"oid": "727b28bbac7c36cef74e08661d282d6ee32f92f1", "url": "https://github.com/elastic/elasticsearch/commit/727b28bbac7c36cef74e08661d282d6ee32f92f1", "message": "fixing tests", "committedDate": "2020-12-02T18:58:48Z", "type": "commit"}]}