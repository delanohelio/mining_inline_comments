{"pr_number": 51558, "pr_title": "EQL: Add AstBuilder to convert to QL tree", "pr_createdAt": "2020-01-28T18:16:04Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51558", "timeline": [{"oid": "ee75ddf1815ff0a74e045707a4161b1b0f1c4c2e", "url": "https://github.com/elastic/elasticsearch/commit/ee75ddf1815ff0a74e045707a4161b1b0f1c4c2e", "message": "EQL: Add AstBuilder visitors", "committedDate": "2020-01-28T02:35:35Z", "type": "commit"}, {"oid": "b237eeabc5dd7431c93d806f6f470daeacf674dc", "url": "https://github.com/elastic/elasticsearch/commit/b237eeabc5dd7431c93d806f6f470daeacf674dc", "message": "EQL: Add tests for wildcards and sets", "committedDate": "2020-01-28T17:37:39Z", "type": "commit"}, {"oid": "b594566cfc6b301e749baca51ccce74748e71937", "url": "https://github.com/elastic/elasticsearch/commit/b594566cfc6b301e749baca51ccce74748e71937", "message": "EQL: Fix licensing", "committedDate": "2020-01-28T17:59:26Z", "type": "commit"}, {"oid": "89c912636e792f5372cd4acedad8d2a674ae9cb0", "url": "https://github.com/elastic/elasticsearch/commit/89c912636e792f5372cd4acedad8d2a674ae9cb0", "message": "EQL: Fix ExpressionTests.java license", "committedDate": "2020-01-28T22:52:03Z", "type": "commit"}, {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "url": "https://github.com/elastic/elasticsearch/commit/0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "message": "EQL: Cleanup imports", "committedDate": "2020-01-28T23:05:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQxOTM4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372419383", "bodyText": "Can you give an example of the grammar this should parse?\nResolution of pattern literals should be handled inside the analyzer and grammar not the parser.\nFor example in SQL * as in SELECT * FROM  is handled as UnresolvedStar (which means it's not a literal but a dedicated char) which is then resolved to a proper function.\nThis seems to be a similar case.\nSee \n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java\n    \n    \n         Line 167\n      in\n      893d4a2\n    \n    \n    \n    \n\n        \n          \n           public Expression visitStar(StarContext ctx) { \n        \n    \n  \n\n\nand\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/antlr/SqlBase.g4\n    \n    \n         Line 237\n      in\n      893d4a2\n    \n    \n    \n    \n\n        \n          \n           | (qualifiedName DOT)? ASTERISK                                                            #star", "author": "costin", "createdAt": "2020-01-29T14:38:45Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/ExpressionBuilder.java", "diffHunk": "@@ -6,6 +6,188 @@\n \n package org.elasticsearch.xpack.eql.parser;\n \n-public class ExpressionBuilder extends IdentifierBuilder {\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ArithmeticUnaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ComparisonContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ContainsExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.DereferenceContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.FunctionExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalBinaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalNotContext;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.Function;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Not;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Add;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Div;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mod;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mul;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Sub;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.tree.Source;\n \n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+public class ExpressionBuilder extends LiteralBuilder {\n+\n+    protected Expression expression(ParseTree ctx) {\n+        return typedParsing(ctx, Expression.class);\n+    }\n+\n+    protected List<Expression> expressions(List<? extends ParserRuleContext> contexts) {\n+        return visitList(contexts, Expression.class);\n+    }\n+\n+    @Override\n+    public Expression visitSingleExpression(EqlBaseParser.SingleExpressionContext ctx) {\n+        return expression(ctx.expression());\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticUnary(ArithmeticUnaryContext ctx) {\n+        Expression expr = expression(ctx.valueExpression());\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        return type == EqlBaseParser.MINUS ? new Neg(source, expr) : expr;\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticBinary(EqlBaseParser.ArithmeticBinaryContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        switch (type) {\n+            case EqlBaseParser.ASTERISK:\n+                return new Mul(source, left, right);\n+            case EqlBaseParser.SLASH:\n+                return new Div(source, left, right);\n+            case EqlBaseParser.PERCENT:\n+                return new Mod(source, left, right);\n+            case EqlBaseParser.PLUS:\n+                return new Add(source, left, right);\n+            case EqlBaseParser.MINUS:\n+                return new Sub(source, left, right);\n+            default:\n+                throw new ParsingException(source, \"Unknown arithmetic {}\", source.text());\n+        }\n+    }\n+\n+    @Override\n+    public Expression visitComparison(ComparisonContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        TerminalNode op = (TerminalNode) ctx.comparisonOperator().getChild(0);\n+\n+        Source source = source(ctx);\n+\n+        // check if the RHS is a wildcard string and convert to a function check instead\n+        if (right instanceof Literal) {", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUxMzA2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372513061", "bodyText": "Good catch. Yeah that makes sense to move this.\nThis will catch the syntax command_line == \"*some*wildcard* expression*\". Even more broadly, any time the RHS of != or == is a string with an asterisk.", "author": "rw-access", "createdAt": "2020-01-29T17:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQxOTM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwNTI1OA==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373005258", "bodyText": "removed this handling in eba19f7.\nwill add back later when an analyzer is created", "author": "rw-access", "createdAt": "2020-01-30T15:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQxOTM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1NDYwMg==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373154602", "bodyText": "This will catch the syntax command_line == \"*some*wildcard* expression*\". Even more broadly, any time the RHS of != or == is a string with an asterisk.\n\nThis seems similar to the Regex functions in QL that map to RLIKE and LIKE in SQL. Essentially it's a scalar around the regex pattern by encapsulating its logic into a dedicated class.\nSee\n\n  \n    \n      elasticsearch/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/regex/LikePattern.java\n    \n    \n         Line 12\n      in\n      789724a\n    \n    \n    \n    \n\n        \n          \n           /** \n        \n    \n  \n\n\nand \n  \n    \n      elasticsearch/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/regex/RegexMatch.java\n    \n    \n         Line 1\n      in\n      789724a\n    \n    \n    \n    \n\n        \n          \n           /* \n        \n    \n  \n\n hierarchy.\nIf you know for sure in the parser that != and == followed by a string with asterisk is wildcard match, you can instantiate the function directly:\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java\n    \n    \n         Line 223\n      in\n      789724a\n    \n    \n    \n    \n\n        \n          \n           switch (pCtx.kind.getType()) { \n        \n    \n  \n\n\nThis has the nice side-effect of using a function that does not have to be declared in the registry (and thus cannot be instantiated by a query).", "author": "costin", "createdAt": "2020-01-30T19:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQxOTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMTA1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372421059", "bodyText": "IsNotNull and IsNull haven't been moved since in SQL null means missing as oppose to null value. This leads to subtle semantics such as 3-value bool logic (TRUE AND null -> null, FALSE AND null -> FALSE, TRUE AND TRUE -> TRUE).\nAre the semantics the same ?", "author": "costin", "createdAt": "2020-01-29T14:41:35Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/ExpressionBuilder.java", "diffHunk": "@@ -6,6 +6,188 @@\n \n package org.elasticsearch.xpack.eql.parser;\n \n-public class ExpressionBuilder extends IdentifierBuilder {\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ArithmeticUnaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ComparisonContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ContainsExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.DereferenceContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.FunctionExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalBinaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalNotContext;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.Function;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Not;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Add;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Div;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mod;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mul;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Sub;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.tree.Source;\n \n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+public class ExpressionBuilder extends LiteralBuilder {\n+\n+    protected Expression expression(ParseTree ctx) {\n+        return typedParsing(ctx, Expression.class);\n+    }\n+\n+    protected List<Expression> expressions(List<? extends ParserRuleContext> contexts) {\n+        return visitList(contexts, Expression.class);\n+    }\n+\n+    @Override\n+    public Expression visitSingleExpression(EqlBaseParser.SingleExpressionContext ctx) {\n+        return expression(ctx.expression());\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticUnary(ArithmeticUnaryContext ctx) {\n+        Expression expr = expression(ctx.valueExpression());\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        return type == EqlBaseParser.MINUS ? new Neg(source, expr) : expr;\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticBinary(EqlBaseParser.ArithmeticBinaryContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        switch (type) {\n+            case EqlBaseParser.ASTERISK:\n+                return new Mul(source, left, right);\n+            case EqlBaseParser.SLASH:\n+                return new Div(source, left, right);\n+            case EqlBaseParser.PERCENT:\n+                return new Mod(source, left, right);\n+            case EqlBaseParser.PLUS:\n+                return new Add(source, left, right);\n+            case EqlBaseParser.MINUS:\n+                return new Sub(source, left, right);\n+            default:\n+                throw new ParsingException(source, \"Unknown arithmetic {}\", source.text());\n+        }\n+    }\n+\n+    @Override\n+    public Expression visitComparison(ComparisonContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        TerminalNode op = (TerminalNode) ctx.comparisonOperator().getChild(0);\n+\n+        Source source = source(ctx);\n+\n+        // check if the RHS is a wildcard string and convert to a function check instead\n+        if (right instanceof Literal) {\n+            Object rightValue = ((Literal) right).value();\n+            if ((rightValue instanceof String) && ((String) rightValue).contains(\"*\")) {\n+\n+                List<Expression> arguments = Arrays.asList(left, right);\n+                UnresolvedFunction.ResolutionType resolutionType = UnresolvedFunction.ResolutionType.STANDARD;\n+                Expression wildcardExpression = new UnresolvedFunction(source, \"wildcard\", resolutionType, arguments);\n+\n+                switch (op.getSymbol().getType()) {\n+                    case EqlBaseParser.EQ:\n+                        return wildcardExpression;\n+                    case EqlBaseParser.NEQ:\n+                        return new Not(source, wildcardExpression);\n+                }\n+            }\n+        }\n+\n+        switch (op.getSymbol().getType()) {\n+            case EqlBaseParser.EQ:\n+                // TODO: check for left == null after moving IsNotNull from SQL -> QL", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUxNDYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372514614", "bodyText": "Great point. We've used == null and != null for existence checks in EQL, but with ES can fields be set directly to null? That seems like it would rarely provide value. So I think we should be okay with using null as missing here too.", "author": "rw-access", "createdAt": "2020-01-29T17:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0NjcyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373146721", "bodyText": "In ES null also means missing however one can set a default value to check on it (see https://www.elastic.co/guide/en/elasticsearch/reference/current/null-value.html).\nThe not null checks map nicely to dedicated queries (missing / not-missing). Not sure about the bool logic though but we can have dedicated AND / OR for EQL if the behavior differs from that of SQL.", "author": "costin", "createdAt": "2020-01-30T19:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMzc1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372423752", "bodyText": "Since it's a char not a string we're replacing, use\nidentifier.replace('`', '')", "author": "costin", "createdAt": "2020-01-29T14:45:45Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/IdentifierBuilder.java", "diffHunk": "@@ -14,7 +16,17 @@ public String visitIdentifier(IdentifierContext ctx) {\n         return ctx == null ? null : unquoteIdentifier(ctx.getText());\n     }\n \n+    @Override\n+    public String visitQualifiedName(QualifiedNameContext ctx) {\n+        if (ctx == null) {\n+            return null;\n+        }\n+\n+        // this is fine, because we've already checked for array indexes [...]\n+        return Strings.collectionToDelimitedString(visitList(ctx.identifier(), String.class), \".\");\n+    }\n+\n     private static String unquoteIdentifier(String identifier) {\n-        return identifier.replace(\"\\\"\\\"\", \"\\\"\");\n+        return identifier.replace(\"`\", \"\");", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUxOTI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372519281", "bodyText": "Oh, I just double checked, and it doesn't look like there's a version of the method for this since '' is an empty character literal.", "author": "rw-access", "createdAt": "2020-01-29T17:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMzc1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0ODM0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373148347", "bodyText": "indeed - strings it is..", "author": "costin", "createdAt": "2020-01-30T19:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMzc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyNDg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372424880", "bodyText": "Should it be ?\" or is ?' allowed as well ? In both cases I would do the check a bit stricter to not trip if somehow a different char follows ?", "author": "costin", "createdAt": "2020-01-29T14:47:30Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LiteralBuilder.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class LiteralBuilder extends IdentifierBuilder {\n+\n+    static String unquoteString(String text) {\n+        // remove leading and trailing ' for strings and also eliminate escaped single quotes\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        // unescaped strings can be interpreted directly\n+        if (text.startsWith(\"?\")) {", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUyMDg3NA==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372520874", "bodyText": "Both ?\"...\" and ?'...' are valid syntax, and enforced by the grammar, so we're okay. I can add a unit test for leaving a space between ? and \"/' or something like that.", "author": "rw-access", "createdAt": "2020-01-29T17:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyNDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyNjE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372426195", "bodyText": "Extract the pattern out to avoid compiling one per each string. Further more if there's not regex used, simply splitting the string and parsing it manually might be a bit more investment but easier to maintain long term.\nCurrently the identifier bits are mixed with the literal ones.", "author": "costin", "createdAt": "2020-01-29T14:49:35Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LiteralBuilder.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class LiteralBuilder extends IdentifierBuilder {\n+\n+    static String unquoteString(String text) {\n+        // remove leading and trailing ' for strings and also eliminate escaped single quotes\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        // unescaped strings can be interpreted directly\n+        if (text.startsWith(\"?\")) {\n+            return text.substring(2, text.length() - 1);\n+        }\n+\n+        text = text.substring(1, text.length() - 1);\n+        Pattern regex = Pattern.compile(\"\\\\\\\\.\");", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyNzQ3NA==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372427474", "bodyText": "If you want to extract literals, move them after ExpressionBuilder (since Literals are expressions) - i.e. LiteralBuilder extends ExpressionBuilder", "author": "costin", "createdAt": "2020-01-29T14:51:42Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LiteralBuilder.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class LiteralBuilder extends IdentifierBuilder {", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMzExNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372433115", "bodyText": "The query should map to a Filter, that is a LogicalPlan (action) not an Expression (properties):\ncostin@5237f2b#diff-74e29c0f2741ee97378ecd3b111c6e8cR20\nor\nhttps://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/LogicalPlanBuilder.java#L125", "author": "costin", "createdAt": "2020-01-29T15:00:06Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/QueryBuilder.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+public class QueryBuilder extends ExpressionBuilder {\n+\n+    @Override\n+    public Expression visitEventQuery(EqlBaseParser.EventQueryContext ctx) {", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3NzgwMg==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372677802", "bodyText": "resolved in d976f1e", "author": "rw-access", "createdAt": "2020-01-29T22:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMzExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNTMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372435302", "bodyText": "formatting is off", "author": "costin", "createdAt": "2020-01-29T15:03:35Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\nworld\", AstBuilder.unquoteString(\"'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\nworld\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n+\n+        // test for unescaped strings: ?\"....\" or ?'....'\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"?'hello\\\"world'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"?\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n+    }\n+\n+    public void testLiterals() {\n+        assertEquals(Literal.TRUE, parser.createExpression(\"true\"));\n+        assertEquals(Literal.FALSE, parser.createExpression(\"false\"));\n+        assertEquals(Literal.NULL, parser.createExpression(\"null\"));\n+    }\n+\n+    public void testSingleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello ' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testSingleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"?'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello \\\\' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"?\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\\\\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testNumbers() {\n+        assertEquals(new Literal(null, 8589934592L, DataTypes.LONG), parser.createExpression(\"8589934592\"));\n+        assertEquals(new Literal(null, 5, DataTypes.INTEGER), parser.createExpression(\"5\"));\n+        assertEquals(new Literal(null, 5e14, DataTypes.DOUBLE), parser.createExpression(\"5e14\"));\n+        assertEquals(new Literal(null, 5.2, DataTypes.DOUBLE), parser.createExpression(\"5.2\"));\n+\n+        Expression parsed = parser.createExpression(\"-5.2\");\n+        Expression expected = new Neg(null, new Literal(null, 5.2, DataTypes.DOUBLE));\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testBackQuotedAttribute() {\n+        String quote = \"`\";\n+        String qualifier = \"table\";\n+        String name = \"@timestamp\";\n+        Expression exp = parser.createExpression(quote + qualifier + quote + \".\" + quote + name + quote);\n+        assertThat(exp, instanceOf(UnresolvedAttribute.class));\n+        UnresolvedAttribute ua = (UnresolvedAttribute) exp;\n+        assertThat(ua.name(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifiedName(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifier(), is(nullValue()));\n+    }\n+\n+    public void testFunctions() {\n+        List<Expression> arguments = Arrays.asList(\n+            new UnresolvedAttribute(null, \"some.field\"),\n+            new Literal(null, \"test string\", DataTypes.KEYWORD)\n+        );\n+        UnresolvedFunction.ResolutionType resolutionType = UnresolvedFunction.ResolutionType.STANDARD;\n+        Expression expected = new UnresolvedFunction(null, \"concat\", resolutionType, arguments);\n+\n+        assertEquals(expected, parser.createExpression(\"concat(some.field, 'test string')\"));\n+    }\n+\n+    public void testComparison() {\n+        String fieldText = \"field\";\n+        String valueText = \"2.0\";\n+\n+        Expression field = expr(fieldText);\n+        Expression value = expr(valueText);\n+\n+        assertEquals( new Equals(null, field, value), expr(fieldText + \"==\" + valueText));", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNjI4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372436289", "bodyText": "you could import static unquoteString and further mroe extract it a public static method into StringUtils and then invoke it inside AstBuilder.\n\n\nthe import should be on IdentifierBuilder.unquoteStringnotAstBuidler` - not sure what IDE you are using but normally you should get a warning about this (static methods are not inherited and thus there's no dispatch).\n\n\nunquote tests should sit in their own test class IdentifierTests or StringUtilsTests.", "author": "costin", "createdAt": "2020-01-29T15:05:08Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NjA3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372566072", "bodyText": "1 - I can move that to another StringUtils class\n2 - that'll change the import. LiteralBuilder I think would've made more sense. and aren't static methods are still inherited but can't be overwritten, which is why there's no dispatch? (IntelliJ didn't warn, but you're right on best practice regardless)\n3 - will do\nedit: I saw the QL StringUtils class and since this escaping is likely EQL specific, it would make sense in another class. at the least, I'll move unquoteString into AbstractBuilder, since that's what SQL does for its unquoteString. update this code to call AbstractBuilder.unquoteString", "author": "rw-access", "createdAt": "2020-01-29T18:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNjI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1MDAxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373150019", "bodyText": "static methods by definition are not virtual so the inheritance is really about visibility.\nUsing a subclass is misleading as the caller might think this is an overridden method when in fact that's not the case. The end result is the same though (it might very well be that IntelliJ has a working for this somewhere that needs enabling).", "author": "costin", "createdAt": "2020-01-30T19:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNjI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNjc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372436782", "bodyText": "why not use expr everywhere instead of parser.createExpression", "author": "costin", "createdAt": "2020-01-29T15:05:58Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\nworld\", AstBuilder.unquoteString(\"'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\nworld\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n+\n+        // test for unescaped strings: ?\"....\" or ?'....'\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"?'hello\\\"world'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"?\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n+    }\n+\n+    public void testLiterals() {\n+        assertEquals(Literal.TRUE, parser.createExpression(\"true\"));", "originalCommit": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372563537", "bodyText": "definitely will switch this. at one point, parser.createExpression was too cumbersome or verbose, so I added this but didn't go back to updating the earlier tests", "author": "rw-access", "createdAt": "2020-01-29T18:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNjc4Mg=="}], "type": "inlineReview"}, {"oid": "eba19f752782f8780025eaecafbe3946722f337f", "url": "https://github.com/elastic/elasticsearch/commit/eba19f752782f8780025eaecafbe3946722f337f", "message": "EQL: PR feedback and remove LiteralBuilder", "committedDate": "2020-01-29T21:26:50Z", "type": "commit"}, {"oid": "d976f1e9ec1c6cb4eaa712bde3352142500bb53f", "url": "https://github.com/elastic/elasticsearch/commit/d976f1e9ec1c6cb4eaa712bde3352142500bb53f", "message": "EQL: Split off logical plan from expressions", "committedDate": "2020-01-29T22:55:43Z", "type": "commit"}, {"oid": "324f54c4cf93083610a3c2f834c3236712518901", "url": "https://github.com/elastic/elasticsearch/commit/324f54c4cf93083610a3c2f834c3236712518901", "message": "EQL: Remove stray import", "committedDate": "2020-01-29T23:00:15Z", "type": "commit"}, {"oid": "7acdf28948dbc6f881266f60e782a656046446a8", "url": "https://github.com/elastic/elasticsearch/commit/7acdf28948dbc6f881266f60e782a656046446a8", "message": "EQL: Add predicate handling for set checks", "committedDate": "2020-01-29T23:33:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAzOTM5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373039391", "bodyText": "Maybe you can keep the comment.", "author": "matriv", "createdAt": "2020-01-30T16:03:37Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/AbstractBuilder.java", "diffHunk": "@@ -113,14 +115,7 @@ static String text(ParseTree node) {\n         return node == null ? null : node.getText();\n     }\n \n-    /**", "originalCommit": "324f54c4cf93083610a3c2f834c3236712518901", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1MjUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373052525", "bodyText": "leftover?", "author": "matriv", "createdAt": "2020-01-30T16:25:04Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/GrammarTests.java", "diffHunk": "@@ -28,29 +28,14 @@\n  */\n public class GrammarTests extends ESTestCase {\n \n-    public void testStrings() throws Exception {\n-        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));\n-        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"\\\"hello'world\\\"\"));\n-        assertEquals(\"hello\\nworld\", AstBuilder.unquoteString(\"'hello\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\nworld\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n-\n-        // test for unescaped strings: ?\"....\" or ?'....'\n-        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"?'hello\\\"world'\"));\n-        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\"world'\"));\n-        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"?\\\"hello'world\\\"\"));\n-        assertEquals(\"hello\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n-    }\n-\n     public void testSupportedQueries() throws Exception {\n         EqlParser parser = new EqlParser();\n         List<Tuple<String, Integer>> lines = readQueries(\"/queries-supported.eql\");\n         for (Tuple<String, Integer> line : lines) {\n             String q = line.v1();\n+            parser.createStatement(q);\n \n+            /*", "originalCommit": "324f54c4cf93083610a3c2f834c3236712518901", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1Mjk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373052963", "bodyText": "Maybe add a TODO?", "author": "matriv", "createdAt": "2020-01-30T16:25:47Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.eql.parser.AbstractBuilder.unquoteString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", unquoteString(\"'hello\\\"world'\"));\n+        assertEquals(\"hello'world\", unquoteString(\"\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\nworld\", unquoteString(\"'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\nworld\", unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\"world\", unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n+\n+        // test for unescaped strings: ?\"....\" or ?'....'\n+        assertEquals(\"hello\\\"world\", unquoteString(\"?'hello\\\"world'\"));\n+        assertEquals(\"hello\\\\\\\"world\", unquoteString(\"?'hello\\\\\\\"world'\"));\n+        assertEquals(\"hello'world\", unquoteString(\"?\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\\\nworld\", unquoteString(\"?'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\nworld\", unquoteString(\"?'hello\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\nworld\", unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n+    }\n+\n+    public void testLiterals() {\n+        assertEquals(Literal.TRUE, expr(\"true\"));\n+        assertEquals(Literal.FALSE, expr(\"false\"));\n+        assertEquals(Literal.NULL, expr(\"null\"));\n+    }\n+\n+    public void testSingleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello ' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testSingleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"?'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello \\\\' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"?\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\\\\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testNumbers() {\n+        assertEquals(new Literal(null, 8589934592L, DataTypes.LONG), expr(\"8589934592\"));\n+        assertEquals(new Literal(null, 5, DataTypes.INTEGER), expr(\"5\"));\n+        assertEquals(new Literal(null, 5e14, DataTypes.DOUBLE), expr(\"5e14\"));\n+        assertEquals(new Literal(null, 5.2, DataTypes.DOUBLE), expr(\"5.2\"));\n+\n+        Expression parsed = expr(\"-5.2\");\n+        Expression expected = new Neg(null, new Literal(null, 5.2, DataTypes.DOUBLE));\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testBackQuotedAttribute() {\n+        String quote = \"`\";\n+        String qualifier = \"table\";\n+        String name = \"@timestamp\";\n+        Expression exp = expr(quote + qualifier + quote + \".\" + quote + name + quote);\n+        assertThat(exp, instanceOf(UnresolvedAttribute.class));\n+        UnresolvedAttribute ua = (UnresolvedAttribute) exp;\n+        assertThat(ua.name(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifiedName(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifier(), is(nullValue()));\n+    }\n+\n+    public void testFunctions() {\n+        List<Expression> arguments = Arrays.asList(\n+            new UnresolvedAttribute(null, \"some.field\"),\n+            new Literal(null, \"test string\", DataTypes.KEYWORD)\n+        );\n+        UnresolvedFunction.ResolutionType resolutionType = UnresolvedFunction.ResolutionType.STANDARD;\n+        Expression expected = new UnresolvedFunction(null, \"concat\", resolutionType, arguments);\n+\n+        assertEquals(expected, expr(\"concat(some.field, 'test string')\"));\n+    }\n+\n+    public void testComparison() {\n+        String fieldText = \"field\";\n+        String valueText = \"2.0\";\n+\n+        Expression field = expr(fieldText);\n+        Expression value = expr(valueText);\n+\n+        assertEquals(new Equals(null, field, value), expr(fieldText + \"==\" + valueText));\n+        assertEquals(new NotEquals(null, field, value), expr(fieldText + \"!=\" + valueText));\n+        assertEquals(new LessThanOrEqual(null, field, value), expr(fieldText + \"<=\" + valueText));\n+        assertEquals(new GreaterThanOrEqual(null, field, value), expr(fieldText + \">=\" + valueText));\n+        assertEquals(new GreaterThan(null, field, value), expr(fieldText + \">\" + valueText));\n+        assertEquals(new LessThan(null, field, value), expr(fieldText + \"<\" + valueText));\n+    }\n+\n+    public void testBoolean() {\n+        String leftText = \"process_name == 'net.exe'\";\n+        String rightText = \"command_line == '* localgroup*'\";\n+\n+        Expression lhs = expr(leftText);\n+        Expression rhs = expr(rightText);\n+\n+        Expression booleanAnd = expr(leftText + \" and \" + rightText);\n+        assertEquals(new And(null, lhs, rhs), booleanAnd);\n+\n+        Expression booleanOr = expr(leftText + \" or \" + rightText);\n+        assertEquals(new Or(null, lhs, rhs), booleanOr);\n+    }\n+\n+    /*", "originalCommit": "324f54c4cf93083610a3c2f834c3236712518901", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MDY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373170680", "bodyText": "@rw-access Is this still needed as is?", "author": "matriv", "createdAt": "2020-01-30T20:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1Mjk2Mw=="}], "type": "inlineReview"}, {"oid": "160ba32f59c11143ef9ff036e575900d5366f931", "url": "https://github.com/elastic/elasticsearch/commit/160ba32f59c11143ef9ff036e575900d5366f931", "message": "EQL: Remove commented out dead code", "committedDate": "2020-01-30T16:54:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1NjY3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373156676", "bodyText": "\ud83d\udc4d", "author": "costin", "createdAt": "2020-01-30T19:45:27Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/EsIndex.java", "diffHunk": "@@ -33,4 +34,23 @@ public String name() {\n     public String toString() {\n         return name;\n     }\n+\n+    @Override", "originalCommit": "160ba32f59c11143ef9ff036e575900d5366f931", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2edd94865508c9397f36892ebfe3057e61a53d13", "url": "https://github.com/elastic/elasticsearch/commit/2edd94865508c9397f36892ebfe3057e61a53d13", "message": "EQL: Remove wildcard test, wait until analyzer", "committedDate": "2020-01-31T15:38:49Z", "type": "commit"}]}