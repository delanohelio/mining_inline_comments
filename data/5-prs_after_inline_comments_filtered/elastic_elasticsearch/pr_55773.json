{"pr_number": 55773, "pr_title": "Add Functionality to Consistently Read RepositoryData For CS Updates", "pr_createdAt": "2020-04-26T10:22:07Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55773", "timeline": [{"oid": "095b2692aac8fa7586b80f5ef481569142ea69ba", "url": "https://github.com/elastic/elasticsearch/commit/095b2692aac8fa7586b80f5ef481569142ea69ba", "message": "Add Functionality to Consistently Update RepositoryData\n\nUsing optimistic locking, add the ability to run a repository state\nupdate task with a consistent view of the current repository data.\nAllows for a follow-up to remove the snapshot init state.\n\nCloses #55702", "committedDate": "2020-04-26T10:18:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI3NjAwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415276009", "bodyText": "This is a little less ergonomic than I would've liked but I found it easiest to produce a CS update task in the Repository API compared to other mechanism because the existing code is so heavily built on using state in CS update tasks to do logic between execute and clusterStateProcessed, so I figured doing it this way and in the repository allows for the follow-ups to be relatively isolated changes.", "author": "original-brownbear", "createdAt": "2020-04-26T10:28:09Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1160,23 +1160,28 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         return snapshotEntry;\n     }\n \n-    /**\n-     * Deletes snapshots that are assumed to be in the repository and not tracked as in-progress in the cluster state.\n-     *\n-     * @param snapshotIds       Snapshots to delete\n-     * @param repoName          Repository name\n-     * @param repositoryStateId Repository generation to base the delete on\n-     * @param listener          Listener to complete when done\n-     */\n-    private void deleteCompletedSnapshots(List<SnapshotId> snapshotIds, String repoName, long repositoryStateId, Priority priority,\n-                                          ActionListener<Void> listener) {\n+    private ClusterStateUpdateTask createDeleteStateUpdate(List<SnapshotId> snapshotIds, String repoName, long repositoryStateId,\n+                                                           Priority priority, ActionListener<Void> listener) {\n+        // Short circuit to noop state update if there isn't anything to delete\n         if (snapshotIds.isEmpty()) {\n-            listener.onResponse(null);\n-            return;\n+            return new ClusterStateUpdateTask() {", "originalCommit": "095b2692aac8fa7586b80f5ef481569142ea69ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "url": "https://github.com/elastic/elasticsearch/commit/7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "message": "more efficient", "committedDate": "2020-04-26T16:10:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM0NTY1NA==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415345654", "bodyText": "This could technically be done quite a bit more efficiently by not forking off to the generic pool when we just get cached repository data, but I figured this is good enough and I can back-port it to 7.x without trouble because even in a mixed 7.x/6.x cluster, a 7.x master node will always update the repo metadata when writing new repository data so this simple solution avoids dealing with all the details of the org.elasticsearch.repositories.blobstore.BlobStoreRepository#bestEffortConsistency flag.", "author": "original-brownbear", "createdAt": "2020-04-26T16:19:08Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java", "diffHunk": "@@ -330,6 +330,60 @@ protected void doClose() {\n         }\n     }\n \n+    @Override\n+    public void executeConsistentStateUpdate(Function<RepositoryData, ClusterStateUpdateTask> createUpdateTask,\n+                                             Consumer<Exception> onFailure) {\n+        threadPool.generic().execute(new AbstractRunnable() {", "originalCommit": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM1NjU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415356599", "bodyText": "Added this test to cover the scenario of concurrent deletes causing the repository data that a delete is based on to be outdated in addition to the coverage we have for concurrent snapshot + delete", "author": "original-brownbear", "createdAt": "2020-04-26T17:16:22Z", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -738,6 +739,63 @@ public void onFailure(Exception e) {\n         assertEquals(0, snapshotInfo.failedShards());\n     }\n \n+    public void testConcurrentDeletes() {", "originalCommit": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM1NzczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415357735", "bodyText": "With more and more cluster state related logic leaking into the repository code, I think we should just eventually refactor  things such that the repository only deals with reading and writing data in some form (obviously lots of tricky details here around source only repos and S3 waiting and whatnot) and completely delegate the responsibility for this kind of magic to either the SnapshotsService or some other component. But until then this is basically the method we want to make life a lot less complicated in the SnapshotsService", "author": "original-brownbear", "createdAt": "2020-04-26T17:22:20Z", "path": "server/src/main/java/org/elasticsearch/repositories/Repository.java", "diffHunk": "@@ -256,6 +258,19 @@ void restoreShard(Store store, SnapshotId snapshotId, IndexId indexId, ShardId s\n      */\n     void updateState(ClusterState state);\n \n+    /**\n+     * Execute a cluster state update with a consistent view of the current {@link RepositoryData}. The {@link ClusterState} passed to the\n+     * task generated through {@code createUpdateTask} is guaranteed to point at the same state for this repository as the did the state\n+     * at the time the {@code RepositoryData} was loaded.\n+     * This allows for operations on the repository that need a consistent view of both the cluster state and the repository contents at\n+     * one point in time like for example, checking if a snapshot is in the repository before adding the delete operation for it to the\n+     * cluster state.\n+     *\n+     * @param createUpdateTask function to supply cluster state update task\n+     * @param onFailure        error handler invoked on failure to get a consistent view of the current {@link RepositoryData}\n+     */\n+    void executeConsistentStateUpdate(Function<RepositoryData, ClusterStateUpdateTask> createUpdateTask, Consumer<Exception> onFailure);", "originalCommit": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NjU0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415546549", "bodyText": "throw UnsupportedOperation here?", "author": "ywelsch", "createdAt": "2020-04-27T06:33:54Z", "path": "test/framework/src/main/java/org/elasticsearch/index/shard/RestoreOnlyRepository.java", "diffHunk": "@@ -153,4 +155,9 @@ public void verify(String verificationToken, DiscoveryNode localNode) {\n     @Override\n     public void updateState(final ClusterState state) {\n     }\n+\n+    @Override\n+    public void executeConsistentStateUpdate(Function<RepositoryData, ClusterStateUpdateTask> createUpdateTask,\n+                                             Consumer<Exception> onFailure) {\n+    }", "originalCommit": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415633679", "bodyText": "Sure :)", "author": "original-brownbear", "createdAt": "2020-04-27T08:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NjU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NzkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415547910", "bodyText": "Could repositoriesService.repository(repositoryName) throw an exception here?", "author": "ywelsch", "createdAt": "2020-04-27T06:36:42Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1083,18 +1083,18 @@ public void onFailure(String source, Exception e) {\n             @Override\n             public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                 if (runningSnapshot == null) {\n-                    threadPool.generic().execute(ActionRunnable.wrap(listener, l ->\n-                            repositoriesService.repository(repositoryName).getRepositoryData(ActionListener.wrap(repositoryData ->\n-                                    deleteCompletedSnapshots(matchingSnapshotIds(repositoryData, snapshotNames, repositoryName),\n-                                            repositoryName, repositoryData.getGenId(), Priority.NORMAL, l), l::onFailure))));\n+                    repositoriesService.repository(repositoryName).executeConsistentStateUpdate(repositoryData ->", "originalCommit": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5NTkxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415595919", "bodyText": "Close to impossible but I suppose there is a slim chance of concurrently removing the repository here so I added a catch for that :)", "author": "original-brownbear", "createdAt": "2020-04-27T08:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MDkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415550925", "bodyText": "This is using ClusterStateUpdateTask in a weird way, directly calling some methods on it, but ignoring other things (e.g. priority / listeners?)", "author": "ywelsch", "createdAt": "2020-04-27T06:43:09Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java", "diffHunk": "@@ -330,6 +330,60 @@ protected void doClose() {\n         }\n     }\n \n+    @Override\n+    public void executeConsistentStateUpdate(Function<RepositoryData, ClusterStateUpdateTask> createUpdateTask,", "originalCommit": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NTEwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415585105", "bodyText": "Yea, this is a little less ergonomic than I'd like it to be. Though, practically speaking the priority is not and won't be used anywhere (as in the delete which runs at normal and all upcoming use-cases of this) anyway so I decided to ignore it.\nThe whole listeners thing I think I got correct though? Since clusterStatePublished is final and empty in ClusterStateUpdateTask and we don't use onNoLongerMaster yet in the task passed I figured why add dead code?", "author": "original-brownbear", "createdAt": "2020-04-27T07:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MDkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2MDA4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415560083", "bodyText": "As we are just protecting against concurrent changes done on the same node, I wonder if we can avoid calling getRepositoryData here for every caller of executeConsistentStateUpdate, or do some sharing between multiple callers of this method. In particular, I'm worried about situations where it takes a long time for the norma-priority CS update task below to be executed, and where stuff might have been invalidated again and again (think e.g. about a misconfigured deletion policy). The task here also does not seem to support timeouts? (This makes me also notice that deleteCompletedSnapshots should probably use the timeout from the DeleteSnapshotRequest).", "author": "ywelsch", "createdAt": "2020-04-27T07:01:17Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java", "diffHunk": "@@ -330,6 +330,60 @@ protected void doClose() {\n         }\n     }\n \n+    @Override\n+    public void executeConsistentStateUpdate(Function<RepositoryData, ClusterStateUpdateTask> createUpdateTask,\n+                                             Consumer<Exception> onFailure) {\n+        threadPool.generic().execute(new AbstractRunnable() {\n+            @Override\n+            protected void doRun() {\n+                final RepositoryMetadata repositoryMetadataStart = metadata;\n+                getRepositoryData(ActionListener.wrap(repositoryData ->\n+                        clusterService.submitStateUpdateTask(\"consistent state update\", new ClusterStateUpdateTask() {", "originalCommit": "7fbebe2d82f200eab83ed4132c85a0cbb8827fb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415633278", "bodyText": "As we are just protecting against concurrent changes done on the same node\n\nPractically yes, theoretically no I think it could be across nodes? Technically we could have a delete along the lines of:\n\nMaster reads repository data and then gets stuck for 30s or whatever\nNew master takes over and completes a repository operation then dies\nMaster from step 1 is back ...\n\nNot likely, but possible and a scenario that SnapshotResiliencyTests could cover (they currently don't but might be worth adding).\n\nI'm worried about situations where it takes a long time for the norma-priority CS update task below to be executed, and where stuff might have been invalidated again and again (think e.g. about a misconfigured deletion policy)\n\nI'm not sure this is all that likely in practice since we keep loading the RepositoryData from cache and currently a delete does 4 state updates of which only two modify the repository metadata? So I would imagine that practically even if you somehow send a barrage of delete requests those will mostly work out fine just because it's so unlikely for these back to back repo metadata updates to go through that quickly (they will always require at least one additional update to the cluster state before). Not saying I'm against optimizing this (always looking for ways to not have to load too many RepositoryData instances on heap) but it seemed not strictly necessary for now (that's why I wrote https://github.com/elastic/elasticsearch/pull/55773/files#r415345654 , we can probably already way optimize this by exploiting the way the cache works).\n\nThe task here also does not seem to support timeouts? (This makes me also notice that deleteCompletedSnapshots should probably use the timeout from the DeleteSnapshotRequest).\n\nRight we haven't been using those timeouts in deletes ever I think ... maybe something to fix in a follow-up since it'll require a few changes here and there because we currently don't pass the timeout from the request to the SnapshotsService?", "author": "original-brownbear", "createdAt": "2020-04-27T08:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2MDA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTgxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r415735811", "bodyText": "Opened #55798 for the timeout thing (was a small change after all ...)", "author": "original-brownbear", "createdAt": "2020-04-27T11:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2MDA4Mw=="}], "type": "inlineReview"}, {"oid": "17e104296f13215054e03580345c750aa6c4bd46", "url": "https://github.com/elastic/elasticsearch/commit/17e104296f13215054e03580345c750aa6c4bd46", "message": "Merge remote-tracking branch 'elastic/master' into add-lock-mechanism-to-repo", "committedDate": "2020-04-27T07:29:56Z", "type": "commit"}, {"oid": "b46783b91c782a2556337c061aed946be8123e57", "url": "https://github.com/elastic/elasticsearch/commit/b46783b91c782a2556337c061aed946be8123e57", "message": "changes", "committedDate": "2020-04-27T08:02:33Z", "type": "commit"}, {"oid": "c4517940c76a5618cb516d2e91677fcab07702b4", "url": "https://github.com/elastic/elasticsearch/commit/c4517940c76a5618cb516d2e91677fcab07702b4", "message": "Merge remote-tracking branch 'elastic/master' into add-lock-mechanism-to-repo", "committedDate": "2020-04-27T08:02:56Z", "type": "commit"}, {"oid": "677c67981235e5c6504a2dc7130875fa762cc1bd", "url": "https://github.com/elastic/elasticsearch/commit/677c67981235e5c6504a2dc7130875fa762cc1bd", "message": "Merge remote-tracking branch 'elastic/master' into add-lock-mechanism-to-repo", "committedDate": "2020-04-27T11:41:02Z", "type": "commit"}, {"oid": "ee60aaffc962c5515230297cb0d033dfd028bbde", "url": "https://github.com/elastic/elasticsearch/commit/ee60aaffc962c5515230297cb0d033dfd028bbde", "message": "Merge remote-tracking branch 'elastic/master' into add-lock-mechanism-to-repo", "committedDate": "2020-04-27T12:38:57Z", "type": "commit"}, {"oid": "67d06f4924d62ffb3a9ed539f58b459d3fa2faa7", "url": "https://github.com/elastic/elasticsearch/commit/67d06f4924d62ffb3a9ed539f58b459d3fa2faa7", "message": "Merge remote-tracking branch 'elastic/master' into add-lock-mechanism-to-repo", "committedDate": "2020-04-27T13:35:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQxNDEwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r416414100", "bodyText": "\"consistent state update\". Can you pass in a more descriptive state update message?", "author": "ywelsch", "createdAt": "2020-04-28T08:06:31Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java", "diffHunk": "@@ -327,6 +327,60 @@ protected void doClose() {\n         }\n     }\n \n+    @Override\n+    public void executeConsistentStateUpdate(Function<RepositoryData, ClusterStateUpdateTask> createUpdateTask,\n+                                             Consumer<Exception> onFailure) {\n+        threadPool.generic().execute(new AbstractRunnable() {\n+            @Override\n+            protected void doRun() {\n+                final RepositoryMetadata repositoryMetadataStart = metadata;\n+                getRepositoryData(ActionListener.wrap(repositoryData ->\n+                        clusterService.submitStateUpdateTask(\"consistent state update\", new ClusterStateUpdateTask() {", "originalCommit": "c4517940c76a5618cb516d2e91677fcab07702b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQxNTQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r416415479", "bodyText": "Also, can we add the timeout here now?", "author": "ywelsch", "createdAt": "2020-04-28T08:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQxNDEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUxMjg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55773#discussion_r416512879", "bodyText": "Sure added the timeout, passing a source now + took the opportunity to also pass the task priority along now.", "author": "original-brownbear", "createdAt": "2020-04-28T10:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQxNDEwMA=="}], "type": "inlineReview"}, {"oid": "702f265565ae2e8519cae056d33ce66d38179df8", "url": "https://github.com/elastic/elasticsearch/commit/702f265565ae2e8519cae056d33ce66d38179df8", "message": "Merge remote-tracking branch 'elastic/master' into add-lock-mechanism-to-repo", "committedDate": "2020-04-28T08:32:19Z", "type": "commit"}, {"oid": "e1427e042d734a77335dc2aeae7791d37d32b2d1", "url": "https://github.com/elastic/elasticsearch/commit/e1427e042d734a77335dc2aeae7791d37d32b2d1", "message": "timeout + source", "committedDate": "2020-04-28T10:41:13Z", "type": "commit"}]}