{"pr_number": 50782, "pr_title": "Write CS asynchronously on data-only nodes", "pr_createdAt": "2020-01-09T08:47:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50782", "timeline": [{"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a", "url": "https://github.com/elastic/elasticsearch/commit/e1471fa9843e988f1570eb73c0f443b76a0f400a", "message": "Write CS asynchronously on data-only nodes", "committedDate": "2020-01-09T08:42:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3NjA5MA==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364676090", "bodyText": "I think it'd be neater for the caller to construct this PersistedState (no need for it to be a LucenePersistedState either, and it already carries the current term and last-accepted state).", "author": "DaveCTurner", "createdAt": "2020-01-09T10:55:05Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);", "originalCommit": "e1471fa9843e988f1570eb73c0f443b76a0f400a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyNjQxNA==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364726414", "bodyText": "Fixed in f6ada35", "author": "ywelsch", "createdAt": "2020-01-09T13:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3NjA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjM0MA==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364682340", "bodyText": "Could this executor have a bounded queue? AFAICT there'll only be \u22641 task.", "author": "DaveCTurner", "createdAt": "2020-01-09T11:10:25Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(", "originalCommit": "e1471fa9843e988f1570eb73c0f443b76a0f400a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyNjU4OA==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364726588", "bodyText": "yes, fixed in f6ada35", "author": "ywelsch", "createdAt": "2020-01-09T13:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjcxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364682719", "bodyText": "I think this is unexpected unless we're shutting down, so maybe better to assert threadPoolExecutor.isShutdown().", "author": "DaveCTurner", "createdAt": "2020-01-09T11:11:18Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);\n+        }\n+\n+        @Override\n+        public void setCurrentTerm(long currentTerm) {\n+            synchronized (mutex) {\n+                super.setCurrentTerm(currentTerm);\n+                if (newCurrentTermQueued) {\n+                    logger.trace(\"term update already queued (setting term to {})\", currentTerm);\n+                } else {\n+                    logger.trace(\"queuing term update (setting term to {})\", currentTerm);\n+                    newCurrentTermQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void setLastAcceptedState(ClusterState clusterState) {\n+            synchronized (mutex) {\n+                super.setLastAcceptedState(clusterState);\n+                if (newStateQueued) {\n+                    logger.trace(\"cluster state update already queued (setting cluster state to {})\", clusterState.version());\n+                } else {\n+                    logger.trace(\"queuing cluster state update (setting cluster state to {})\", clusterState.version());\n+                    newStateQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        private void scheduleUpdate() {\n+            assert Thread.holdsLock(mutex);\n+            try {\n+                threadPoolExecutor.execute(new AbstractRunnable() {\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.error(\"Exception occurred when storing new meta data\", e);\n+                    }\n+\n+                    @Override\n+                    protected void doRun() {\n+                        final Long term;\n+                        final ClusterState clusterState;\n+                        synchronized (mutex) {\n+                            if (newCurrentTermQueued) {\n+                                term = getCurrentTerm();\n+                                newCurrentTermQueued = false;\n+                            } else {\n+                                term = null;\n+                            }\n+                            if (newStateQueued) {\n+                                clusterState = getLastAcceptedState();\n+                                newStateQueued = false;\n+                            } else {\n+                                clusterState = null;\n+                            }\n+                        }\n+                        // write current term before last accepted state so that it is never below term in last accepted state\n+                        if (term != null) {\n+                            lucenePersistedState.setCurrentTerm(term);\n+                        }\n+                        if (clusterState != null) {\n+                            lucenePersistedState.setLastAcceptedState(resetVotingConfiguration(clusterState));\n+                        }\n+                    }\n+                });\n+            } catch (EsRejectedExecutionException e) {\n+                // ignore cases where we are shutting down..., there is really nothing interesting to be done here...", "originalCommit": "e1471fa9843e988f1570eb73c0f443b76a0f400a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyNjc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364726787", "bodyText": "added assertion in f6ada35", "author": "ywelsch", "createdAt": "2020-01-09T13:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4NDc0OA==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364684748", "bodyText": "\ud83d\udc4d Slightly subtle given that we're already under the Coordinator's mutex here, but we aren't in the scheduled updater thread so it's important to be under our own mutex too.", "author": "DaveCTurner", "createdAt": "2020-01-09T11:16:50Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);\n+        }\n+\n+        @Override\n+        public void setCurrentTerm(long currentTerm) {\n+            synchronized (mutex) {\n+                super.setCurrentTerm(currentTerm);", "originalCommit": "e1471fa9843e988f1570eb73c0f443b76a0f400a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTc2OA==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364691768", "bodyText": "I see some slightly questionable synchronisation here. We construct the PersistedClusterStateService.Writer using a simple ArrayList of MetaDataIndexWriters, and then iterate through that when closing it on (potentially) a different thread. Unrelated to this PR, I just noticed it.", "author": "DaveCTurner", "createdAt": "2020-01-09T11:34:16Z", "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);\n+        }\n+\n+        @Override\n+        public void setCurrentTerm(long currentTerm) {\n+            synchronized (mutex) {\n+                super.setCurrentTerm(currentTerm);\n+                if (newCurrentTermQueued) {\n+                    logger.trace(\"term update already queued (setting term to {})\", currentTerm);\n+                } else {\n+                    logger.trace(\"queuing term update (setting term to {})\", currentTerm);\n+                    newCurrentTermQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void setLastAcceptedState(ClusterState clusterState) {\n+            synchronized (mutex) {\n+                super.setLastAcceptedState(clusterState);\n+                if (newStateQueued) {\n+                    logger.trace(\"cluster state update already queued (setting cluster state to {})\", clusterState.version());\n+                } else {\n+                    logger.trace(\"queuing cluster state update (setting cluster state to {})\", clusterState.version());\n+                    newStateQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        private void scheduleUpdate() {\n+            assert Thread.holdsLock(mutex);\n+            try {\n+                threadPoolExecutor.execute(new AbstractRunnable() {\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.error(\"Exception occurred when storing new meta data\", e);\n+                    }\n+\n+                    @Override\n+                    protected void doRun() {\n+                        final Long term;\n+                        final ClusterState clusterState;\n+                        synchronized (mutex) {\n+                            if (newCurrentTermQueued) {\n+                                term = getCurrentTerm();\n+                                newCurrentTermQueued = false;\n+                            } else {\n+                                term = null;\n+                            }\n+                            if (newStateQueued) {\n+                                clusterState = getLastAcceptedState();\n+                                newStateQueued = false;\n+                            } else {\n+                                clusterState = null;\n+                            }\n+                        }\n+                        // write current term before last accepted state so that it is never below term in last accepted state\n+                        if (term != null) {\n+                            lucenePersistedState.setCurrentTerm(term);\n+                        }\n+                        if (clusterState != null) {\n+                            lucenePersistedState.setLastAcceptedState(resetVotingConfiguration(clusterState));\n+                        }\n+                    }\n+                });\n+            } catch (EsRejectedExecutionException e) {\n+                // ignore cases where we are shutting down..., there is really nothing interesting to be done here...\n+                if (threadPoolExecutor.isShutdown() == false) {\n+                    throw e;\n+                }\n+            }\n+        }\n+\n+        static final CoordinationMetaData.VotingConfiguration staleStateConfiguration =\n+            new CoordinationMetaData.VotingConfiguration(Collections.singleton(\"STALE_STATE_CONFIG\"));\n+\n+        static ClusterState resetVotingConfiguration(ClusterState clusterState) {\n+            CoordinationMetaData newCoordinationMetaData = CoordinationMetaData.builder(clusterState.coordinationMetaData())\n+                .lastAcceptedConfiguration(staleStateConfiguration)\n+                .lastCommittedConfiguration(staleStateConfiguration)\n+                .build();\n+            return ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData())\n+                .coordinationMetaData(newCoordinationMetaData).build()).build();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            try {\n+                ThreadPool.terminate(threadPoolExecutor, 10, TimeUnit.SECONDS);\n+            } finally {\n+                lucenePersistedState.close();", "originalCommit": "e1471fa9843e988f1570eb73c0f443b76a0f400a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyNzA0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364727046", "bodyText": "I have a follow-up PR that addresses this and other issues related to the PersistedClusterStateService.Writer lifecycle.", "author": "ywelsch", "createdAt": "2020-01-09T13:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTc2OA=="}], "type": "inlineReview"}, {"oid": "f6ada35fe9286cf623814d5502d4625747f7d282", "url": "https://github.com/elastic/elasticsearch/commit/f6ada35fe9286cf623814d5502d4625747f7d282", "message": "review comments", "committedDate": "2020-01-09T13:03:15Z", "type": "commit"}]}