{"pr_number": 59376, "pr_title": "Cache API key doc to reduce traffic to the security index", "pr_createdAt": "2020-07-13T00:30:16Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59376", "timeline": [{"oid": "32a7a3195ceb4bdce7d8c50d9ed0a94171144b7e", "url": "https://github.com/elastic/elasticsearch/commit/32a7a3195ceb4bdce7d8c50d9ed0a94171144b7e", "message": "WIP: add cache for API Key document.", "committedDate": "2020-07-15T01:25:26Z", "type": "forcePushed"}, {"oid": "7501b0502006ea5cc566d3cbadfe7fff1a014e95", "url": "https://github.com/elastic/elasticsearch/commit/7501b0502006ea5cc566d3cbadfe7fff1a014e95", "message": "WIP: add cache for API Key document.", "committedDate": "2020-07-20T06:09:23Z", "type": "commit"}, {"oid": "7501b0502006ea5cc566d3cbadfe7fff1a014e95", "url": "https://github.com/elastic/elasticsearch/commit/7501b0502006ea5cc566d3cbadfe7fff1a014e95", "message": "WIP: add cache for API Key document.", "committedDate": "2020-07-20T06:09:23Z", "type": "forcePushed"}, {"oid": "97e1318e5092940c4efc1ab4c1cb63c541cde4aa", "url": "https://github.com/elastic/elasticsearch/commit/97e1318e5092940c4efc1ab4c1cb63c541cde4aa", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-08-03T05:48:15Z", "type": "commit"}, {"oid": "c166c13a97effe3d01bcd31f6206cefdb0787af0", "url": "https://github.com/elastic/elasticsearch/commit/c166c13a97effe3d01bcd31f6206cefdb0787af0", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-08-10T02:15:02Z", "type": "commit"}, {"oid": "df2a1d8614a9ac1631e1183ea265fdc7c48d8651", "url": "https://github.com/elastic/elasticsearch/commit/df2a1d8614a9ac1631e1183ea265fdc7c48d8651", "message": "WIP: Have one cache for API key doc and auth result.", "committedDate": "2020-08-11T06:51:53Z", "type": "commit"}, {"oid": "e20dad8b78a364ce653aea638b33d3e6de5d7ef4", "url": "https://github.com/elastic/elasticsearch/commit/e20dad8b78a364ce653aea638b33d3e6de5d7ef4", "message": "Revert \"WIP: Have one cache for API key doc and auth result.\"\n\nThis reverts commit df2a1d8614a9ac1631e1183ea265fdc7c48d8651.", "committedDate": "2020-08-12T04:17:09Z", "type": "commit"}, {"oid": "f425470e8d3aa8117320f593bbd50f2984d2f527", "url": "https://github.com/elastic/elasticsearch/commit/f425470e8d3aa8117320f593bbd50f2984d2f527", "message": "Add security cache common behaviours and handlers", "committedDate": "2020-08-13T06:34:04Z", "type": "commit"}, {"oid": "5536b88112c7039a0fff7b3fd3f6e9dbac7e771f", "url": "https://github.com/elastic/elasticsearch/commit/5536b88112c7039a0fff7b3fd3f6e9dbac7e771f", "message": "checkstyle", "committedDate": "2020-08-13T06:44:29Z", "type": "commit"}, {"oid": "05dc6aeab88099dd9a1b3720d43e05d9e1062614", "url": "https://github.com/elastic/elasticsearch/commit/05dc6aeab88099dd9a1b3720d43e05d9e1062614", "message": "Fix for no cache scenario", "committedDate": "2020-08-13T08:05:50Z", "type": "commit"}, {"oid": "c5c690b5e45da3ea518b4fad358cf71e3797e6a2", "url": "https://github.com/elastic/elasticsearch/commit/c5c690b5e45da3ea518b4fad358cf71e3797e6a2", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-08-13T08:06:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNzgxNw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r469937817", "bodyText": "I think we probably prefer to have a singleton instance for this class similar to all other components. If so, I can make it so and have it injected into the Transport action.", "author": "ywangd", "createdAt": "2020-08-13T13:08:51Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/SecurityCacheRegistry.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+public class SecurityCacheRegistry {\n+\n+    private static final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();", "originalCommit": "c5c690b5e45da3ea518b4fad358cf71e3797e6a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e62e81021a6c7a8d01bd506103985a90be22532", "url": "https://github.com/elastic/elasticsearch/commit/9e62e81021a6c7a8d01bd506103985a90be22532", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-09-04T03:04:52Z", "type": "commit"}, {"oid": "a0b3bd0911ce7cea7d2d03fa3d8996362cf828fd", "url": "https://github.com/elastic/elasticsearch/commit/a0b3bd0911ce7cea7d2d03fa3d8996362cf828fd", "message": "Simplify security cache based on feedback.", "committedDate": "2020-09-07T03:34:19Z", "type": "commit"}, {"oid": "33a75532fd10928f71d9264beb2b5abef0650fa4", "url": "https://github.com/elastic/elasticsearch/commit/33a75532fd10928f71d9264beb2b5abef0650fa4", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-09-07T03:45:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MTM3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r484641375", "bodyText": "I wonder about this.\nIt defaults to 24h, and we don 't have much in place to clean it up.\nShould it really cache for that long? It's expiry after access, so 1h feels like it would be sufficient.\nFrom my brief reading, once the doc cache expires (5m after last write) there will be no incoming references to these entries. They may get revived, but I don't think holding onto that memory for 24h is justified.", "author": "tvernum", "createdAt": "2020-09-08T04:20:04Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -192,14 +199,42 @@ public ApiKeyService(Settings settings, Clock clock, Client client, XPackLicense\n         this.threadPool = threadPool;\n         this.cacheHasher = Hasher.resolve(CACHE_HASH_ALGO_SETTING.get(settings));\n         final TimeValue ttl = CACHE_TTL_SETTING.get(settings);\n+        final Integer maximumWeight = CACHE_MAX_KEYS_SETTING.get(settings);\n         if (ttl.getNanos() > 0) {\n             this.apiKeyAuthCache = CacheBuilder.<String, ListenableFuture<CachedApiKeyHashResult>>builder()\n                 .setExpireAfterWrite(ttl)\n-                .setMaximumWeight(CACHE_MAX_KEYS_SETTING.get(settings))\n+                .setMaximumWeight(maximumWeight)\n                 .build();\n+            this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()\n+                .setExpireAfterAccess(ttl)", "originalCommit": "33a75532fd10928f71d9264beb2b5abef0650fa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3NDc4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r484974789", "bodyText": "I changed it to 1h. It was set to 24h because\n\n24h is an existing setting, so felt easy to reuse. I understand technically it has different meaning. But the subtlety here feels irrelevant to end-users.\nUnlike API key document cache, the role descriptor cache, in theory, never \"expires\" in that they will never be outdated. Sure the entries may no longer be needed, but the association between a hash and its original content can never be invalid. Also many API keys may share the same role descriptors, for example, the superuser (limiting) role. These made me feel it is plausible to cache the descriptors for longer. Because even when a Key is expired or invalidated or haven't checked in for a while, it is likey a new key will be replacing it and the new key will have the exact same role descriptors and thus reuse the cache entries.\n\nWith above being said, I don't think the benefit of caching for longer is anyway significant, since the main performance hit is the document retrieval itself. So I am OK to have it at a shorter duration.", "author": "ywangd", "createdAt": "2020-09-08T14:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MjM0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r484642342", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void invalidate(String name, Collection<String> keys) {\n          \n          \n            \n                public static void invalidateByKey(String cacheName, Collection<String> keys) {", "author": "tvernum", "createdAt": "2020-09-08T04:24:26Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistry.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+/**\n+ * A registry that provides common cache invalidation services for caches that relies on the security index.\n+ */\n+public class CacheInvalidatorRegistry {\n+\n+    private static final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();\n+\n+    public static void registerCacheInvalidator(String name, CacheInvalidator cacheInvalidator) {\n+        // TODO: check no overriding entries\n+        cacheInvalidators.put(name, cacheInvalidator);\n+    }\n+\n+    public static void onSecurityIndexStageChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState)\n+            || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            cacheInvalidators.values().forEach(CacheInvalidator::invalidateAll);\n+        }\n+    }\n+\n+    public static void invalidate(String name, Collection<String> keys) {", "originalCommit": "33a75532fd10928f71d9264beb2b5abef0650fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MjUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r484642501", "bodyText": "This name implies invalidating all caches, not all entries in 1 cache.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void invalidateAll(String name) {\n          \n          \n            \n                public static void invalidateCache(String cacheName) {", "author": "tvernum", "createdAt": "2020-09-08T04:25:05Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistry.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+/**\n+ * A registry that provides common cache invalidation services for caches that relies on the security index.\n+ */\n+public class CacheInvalidatorRegistry {\n+\n+    private static final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();\n+\n+    public static void registerCacheInvalidator(String name, CacheInvalidator cacheInvalidator) {\n+        // TODO: check no overriding entries\n+        cacheInvalidators.put(name, cacheInvalidator);\n+    }\n+\n+    public static void onSecurityIndexStageChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState)\n+            || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            cacheInvalidators.values().forEach(CacheInvalidator::invalidateAll);\n+        }\n+    }\n+\n+    public static void invalidate(String name, Collection<String> keys) {\n+        final CacheInvalidator cacheInvalidator = cacheInvalidators.get(name);\n+        if (cacheInvalidator != null) {\n+            cacheInvalidator.invalidate(keys);\n+        }\n+    }\n+\n+    public static void invalidateAll(String name) {", "originalCommit": "33a75532fd10928f71d9264beb2b5abef0650fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aafed3f0ae978c6788dcfe7236831d0ee65ef407", "url": "https://github.com/elastic/elasticsearch/commit/aafed3f0ae978c6788dcfe7236831d0ee65ef407", "message": "Apply suggestions from code review\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-09-08T14:25:38Z", "type": "commit"}, {"oid": "283d1f5628ef575e7daa82934760c126aaaa2fe3", "url": "https://github.com/elastic/elasticsearch/commit/283d1f5628ef575e7daa82934760c126aaaa2fe3", "message": "feedback", "committedDate": "2020-09-08T14:29:15Z", "type": "commit"}, {"oid": "57d23ce6c1c3554fe88d11375b6788f2c30f29ed", "url": "https://github.com/elastic/elasticsearch/commit/57d23ce6c1c3554fe88d11375b6788f2c30f29ed", "message": "feedback", "committedDate": "2020-09-08T14:41:51Z", "type": "commit"}, {"oid": "0fc0a0215f202af77c48a821c201bec555ac1654", "url": "https://github.com/elastic/elasticsearch/commit/0fc0a0215f202af77c48a821c201bec555ac1654", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-09-11T02:00:14Z", "type": "commit"}, {"oid": "c94e0037979e057cc4a3f5c8d37a9bd3bb7d2318", "url": "https://github.com/elastic/elasticsearch/commit/c94e0037979e057cc4a3f5c8d37a9bd3bb7d2318", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-09-18T06:38:41Z", "type": "commit"}, {"oid": "7a7b0a78dac4997aa2f1e93575538208b62a3d13", "url": "https://github.com/elastic/elasticsearch/commit/7a7b0a78dac4997aa2f1e93575538208b62a3d13", "message": "Add tests for api key doc caches", "committedDate": "2020-09-21T03:55:05Z", "type": "commit"}, {"oid": "17c6f3a58ed120e56bab0dd5b11d9c5adb875f65", "url": "https://github.com/elastic/elasticsearch/commit/17c6f3a58ed120e56bab0dd5b11d9c5adb875f65", "message": "One more scenario for cache miss", "committedDate": "2020-09-21T04:07:28Z", "type": "commit"}, {"oid": "32fcccfc84910059ff18e21f7a605507cd8b2c3f", "url": "https://github.com/elastic/elasticsearch/commit/32fcccfc84910059ff18e21f7a605507cd8b2c3f", "message": "Replace static class with the existing component pattern", "committedDate": "2020-09-21T04:37:59Z", "type": "commit"}, {"oid": "fda220bce75bce69549965d4330691b6c46cc3bd", "url": "https://github.com/elastic/elasticsearch/commit/fda220bce75bce69549965d4330691b6c46cc3bd", "message": "Add tests for consistent cache", "committedDate": "2020-09-21T05:02:26Z", "type": "commit"}, {"oid": "abfb40c14f662b627faa11f344f7778c0ecaa1fb", "url": "https://github.com/elastic/elasticsearch/commit/abfb40c14f662b627faa11f344f7778c0ecaa1fb", "message": "Add tests for cache invalidator registry", "committedDate": "2020-09-21T05:20:31Z", "type": "commit"}, {"oid": "3f7a586e48d3e68e0f511e50a4ddf5d622cd31f3", "url": "https://github.com/elastic/elasticsearch/commit/3f7a586e48d3e68e0f511e50a4ddf5d622cd31f3", "message": "Add tests for integration tests for cache invalidation", "committedDate": "2020-09-21T06:37:53Z", "type": "commit"}, {"oid": "41cc5957e313b4eeafe2255469b63a4aac5781f5", "url": "https://github.com/elastic/elasticsearch/commit/41cc5957e313b4eeafe2255469b63a4aac5781f5", "message": "Minor test tweak", "committedDate": "2020-09-21T06:48:20Z", "type": "commit"}, {"oid": "36ae9c85acefcf0525f1acd2c6fca5cee150791f", "url": "https://github.com/elastic/elasticsearch/commit/36ae9c85acefcf0525f1acd2c6fca5cee150791f", "message": "Add client code, yaml tests and documentation", "committedDate": "2020-09-21T08:29:25Z", "type": "commit"}, {"oid": "066dbb8aeb0d0edac1836aa1f16f25ab253859d6", "url": "https://github.com/elastic/elasticsearch/commit/066dbb8aeb0d0edac1836aa1f16f25ab253859d6", "message": "Fix json spec file", "committedDate": "2020-09-21T08:36:11Z", "type": "commit"}, {"oid": "b78eeec1955f2cf36d69b96e39d564aea73c8e7e", "url": "https://github.com/elastic/elasticsearch/commit/b78eeec1955f2cf36d69b96e39d564aea73c8e7e", "message": "Fix tests", "committedDate": "2020-09-21T08:53:57Z", "type": "commit"}, {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "url": "https://github.com/elastic/elasticsearch/commit/26741a405a2e1eb931068ee1d8951a0c241e42fe", "message": "update doc", "committedDate": "2020-09-21T11:05:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2OTMxMg==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r498369312", "bodyText": "do we really need a lock to protect an atomic variable? What does this achieve.", "author": "albertzaharovits", "createdAt": "2020-10-01T16:22:44Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/ConsistentCache.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.util.concurrent.ReleasableLock;\n+\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * A wrapper of {@link Cache} that minimizes the possibility of caching stale results.\n+ */\n+public class ConsistentCache<K, V> {\n+\n+    private static final Logger logger = LogManager.getLogger(ConsistentCache.class);\n+\n+    private final Cache<K, V> delegate;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n+    private final ReadWriteLock invalidationLock = new ReentrantReadWriteLock();\n+    private final ReleasableLock invalidationReadLock = new ReleasableLock(invalidationLock.readLock());\n+    private final ReleasableLock invalidationWriteLock = new ReleasableLock(invalidationLock.writeLock());\n+\n+    public ConsistentCache(Cache<K, V> delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    public Checkpoint<K, V> checkpoint() {\n+        final long invalidationCounter = numInvalidation.get();\n+        return (key, value) -> {\n+            try (ReleasableLock ignored = invalidationReadLock.acquire()) {\n+                if (invalidationCounter == numInvalidation.get()) {\n+                    logger.debug(\"Caching for key [{}], value [{}]\", key, value);\n+                    delegate.put(key, value);\n+                    return true;\n+                }\n+            }\n+            return false;\n+        };\n+    }\n+\n+    public V get(K key) {\n+        return delegate.get(key);\n+    }\n+\n+    // If there are secondary caches that must be invalidated when the main\n+    // entry is invalidated, they can be registered via the removalListener\n+    public void invalidate(Collection<K> keys) {\n+        try (ReleasableLock ignored = invalidationWriteLock.acquire()) {\n+            numInvalidation.incrementAndGet();\n+        }", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMTY0MA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r498621640", "bodyText": "Please see my other comment", "author": "ywangd", "createdAt": "2020-10-02T05:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2OTMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjA1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r498402055", "bodyText": "It's a bit hard to understand the reasoning for the \"consistent cache\" here.\nMy understanding is that you're trying to guard against a doc update (a call to invalidate a key), followed by a cache clear call (they are currently separate endpoints), after the doc has been retrieved by the get, but before the handler is called. IMO, this is a narrow time window for this big of a complication (the ConsistentCache complication).\nAlternatively, what do you say you make the current invalidation counter part of the cached value (the CachedApiKeyDoc instance). In this case, you always populate the cache values with the current invalidation counter, but you never use a cache entry with an older invalidation counter compared to the current (you remove the entry and try the get).", "author": "albertzaharovits", "createdAt": "2020-10-01T17:21:31Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -364,13 +425,16 @@ private void loadApiKeyAndValidateCredentials(ThreadContext ctx, ApiKeyCredentia\n                         response.getSourceAsBytesRef(), XContentType.JSON)) {\n                         apiKeyDoc = ApiKeyDoc.fromXContent(parser);\n                     }\n-                    validateApiKeyCredentials(docId, apiKeyDoc, credentials, clock, ActionListener.delegateResponse(listener, (l, e) -> {\n-                        if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) {\n-                            listener.onResponse(AuthenticationResult.terminate(\"server is too busy to respond\", e));\n-                        } else {\n-                            listener.onFailure(e);\n+                    if (checkpoint != null) {\n+                        final CachedApiKeyDoc cachedApiKeyDoc = apiKeyDoc.toCachedApiKeyDoc();\n+                        if (checkpoint.put(docId, cachedApiKeyDoc)) {", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMTUwNA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r498621504", "bodyText": "The ConsistentCache is an attempt to extract a pattern from existing code so that caching behaviour can be reused in different places. The CompositeRolesStore is an example of this pattern, which is also applied for NativePrivilegeStore in my previous PR (#55836) for caching application privileges. The complexity is real but it is not new. It is exactly because of the complexity, I am attempting to extract the logic in a separate class so it can be reused, e.g. replacing the existing caching code of NativePrivilegeStore in future PRs.\nThe purpose of this piece of code is to minimize the possibility of caching stale results and invalidate it as soon as possible if we do end up caching it. Tim and I had some discussion about how it works. Unfortunately, I just realised that I didn't add a comment after our discussion so that the reasonsing is not obvious. I will try to capture it here. In summary, both the AtomicLong and ReadWriteLock are necessary due to the aysnc and non-atomic nature of operations in the system. The problem arises because of following few things:\n\nThe read and write calls to the security index are independant.\nThe clear cache call is independant as well. This include both standalone clear cache call initiated by the users or the ones as consequence of write calls.\nAtomicLong#get and any actions guarded by it are not an atomic group.\n\nThe ReadWriteLock helps make above async stuff easier to reason about and minimize the possibility of stale results being cached. We can use following scenario as an example:\nA read successfully retrieves an document from the security index. But before the code is done with the retrieved document, a write call happens. The write call basically makes the last read document stale. So we do not want to cache the retrieved document. The write call fires a cache invalidation request, which is currently inflight. Before caching the document, the read thread checks whether invalidation has happened with the following code:\nif (invalidationCounter == numInvalidation.get()) {\n    cacheTheDocument();\n}\nHowever, even if the check passes, it is still possible that the invalidation thread gets executed immedilatey after the check and before the actual caching call. So the read thread will end up caching a stale document. The chance for this to happen may be low, but it is hard to reason about because it is a racing condition. When it happens, it is likely an API key is invalidated, but because it is errorneously cached, subsequent requests will only see the cached result not errorneously succeeds.\nWhen we add the ReadWriteLock, the code becomes:\ntry (ReleasableLock ignored = invalidationReadLock.acquire()) {\n    if (invalidationCounter == numInvalidation.get()) {\n        cacheTheDocument();\n    }\n}\nIt helps with above issue because: If the read thread reaches the critical region first and acquires the lock, it can be sure that the counter will not suddenly change again when cacheTheDocument is executing. In another word, the invalidation thread will be put on hold because of the locking. So even if the read thread does cache a stale document, once it releases the lock, the invalidation thread will acquire it and invalidate the document momentarily. Thus minimises the possibility of caching stale documents.\nWithout the ReadWriteLock, it does not matter where you place the AtomicLong counter because the real problem is because anything guarded by the counter cannot be guaranteed to finish execution before the counter changes again. And this could happen regardless of where the code is.", "author": "ywangd", "createdAt": "2020-10-02T05:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0MDA0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499140043", "bodyText": "Thank you @ywangd for the detailed explanation!\nI understand it fully now, both the invalidation counter and the locking. You are right.", "author": "albertzaharovits", "createdAt": "2020-10-03T11:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499131823", "bodyText": "I would suggest there be an enum for the cache names. But this to me shows that it's not quite suitable as a request param.", "author": "albertzaharovits", "createdAt": "2020-10-03T09:21:08Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/ClearSecurityCacheRequest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.Validatable;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+/**\n+ * The request used to clear the specified cache.\n+ */\n+public final class ClearSecurityCacheRequest implements Validatable {\n+\n+    private final String cacheName;", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5OTk1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499199952", "bodyText": "I think string is fine since there is a CacheInvalidator that already controls the available/valid entries. I don't see what extra value enum could provide here. Please also see my other comment about why it is a request param.", "author": "ywangd", "createdAt": "2020-10-04T02:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIxNzI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499217298", "bodyText": "The construction of ClearSecurityCacheRequest object happens on the client side. We might have validation for its parameters on the server side, but the caller has to hard code the \"api_key\" value in the client code. Something like:\npublic final class ClearSecurityCacheRequest implements Validatable {\n    \n    enum CacheName {\n        API_KEY\n    }\n\n    private final CacheName cacheName;\n\nwould help a bit.\nA separate request object type would still be preferable IMO.", "author": "albertzaharovits", "createdAt": "2020-10-04T07:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NDMxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499244311", "bodyText": "Client side is a good point. Until we can have auto-generation of client from API spec, we'll have to maintain this manually. I added a dedicated ClearApiKeyCacheRequest for the client code.", "author": "ywangd", "createdAt": "2020-10-04T13:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0OTI1MA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499149250", "bodyText": "Personally, putting myself in the shoes of the user, I don't think a general API like this is an improvement over what there is already:\n\n/_security/realm/{realms}/_clear_cache\n/_security/role/{name}/_clear_cache\n/_security/privilege/{application}/_clear_cache\n\nI think it is good that we're combining the transport actions under a single one, like a function with parameters which is called from the REST handler.\nBut the cache_name, and especially the keys parameters, are not easy to figure out by the caller and they require reading the javadocs (eg when you clear the api key cache are the keys the API key ids or the API key names). For the existing APIs, it is easy to tell what the value of the parameter should be from the name of the parameter itself. The value of the parameters is also something that the calling user created (e.g. a role), not the name of an internal object (e.g. the caller modified some entity (e.g. role/application privilege), and it should clear the cache for that entity, almost the same URL path).\nIf you still think that the cache name should be a parameter that the caller fills, then I would suggest:\nPOST _security/caches/{name}/_clear with optional URL parameters for the keys parameter.\nMy suggestion for the clear cache for API keys is\nPOST _security/api_key/_clear_cache, given the existing structure of API key APIs, and I wouldn't worry about parameters (but if we must, then they'd be in the request body, again to jibe with the other APIs).", "author": "albertzaharovits", "createdAt": "2020-10-03T13:46:45Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/RestClearSecurityCacheAction.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestActions.NodesResponseRestListener;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheAction;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheRequest;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+\n+public class RestClearSecurityCacheAction extends SecurityBaseRestHandler {\n+\n+    public RestClearSecurityCacheAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"security_clear_cache_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return Collections.singletonList(new Route(POST, \"/_security/{cache_name}/{keys}/_clear_cache\"));", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5OTA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499199071", "bodyText": "Sorry this is a mistake on my side and thanks for catching it. My intention for the new Clear Cache API is just an internal refactoring and should not require user awareness. This is why I kept the Rest end point to be compatible with the existing ones, e.g. /_security/privilege/{application}/_clear_cache, where privilege is the cache name and {application} is the keys. My plan was to introduce the new cache clearing API as if it is just for API key, i.e, I planned to document it just like all the other existing APIs and what user should be seeing is just /_security/api_key/{id}/_clear_cache.\nBut somehow I got carried away by the changes and added documentation for the generic API itself, which like you said, is low level and not user friendly. Hence I will drop this documentation and just document it in the context of API key. Whether these cache clearing APIs internally use a single or different actions are implementation details and should not concern users. On the surface (documentation), user will just see that we add another cache clearing API for API keys, i.e. /_security/api_key/{id}/_clear_cache.", "author": "ywangd", "createdAt": "2020-10-04T02:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0OTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIxNTk0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499215947", "bodyText": "On the surface (documentation), user will just see that we add another cache clearing API for API keys, i.e. /_security/api_key/{id}/_clear_cache.\n\nThe _security/api_key APIs have the parameters in the request body because of the multiple ways to refer to keys (by id, name, user and realm). If you put in the id in the URL path for the cache clear operation, it would be unlike the other APIs and would be more complex to introduce clearing of the cache for keys by other params.", "author": "albertzaharovits", "createdAt": "2020-10-04T07:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0OTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIxNjg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499216885", "bodyText": "I don't think we want to match the cache clearing API with other \"api_key\" APIs. It is never a goal to clear cache by API key names, users or realms. Caches are always cleared by the keys, i.e. id in API key's case.  So I don't see any problem here.", "author": "ywangd", "createdAt": "2020-10-04T07:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0OTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1ODcyMA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499458720", "bodyText": "@albertzaharovits Per our discussion, I have changed the Rest Action class to be dedicated to \"clear API key cache\". Thanks for the feedback!", "author": "ywangd", "createdAt": "2020-10-05T09:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0OTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDIxNA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499154214", "bodyText": "I don't think that the class name or the documentation help in understanding when all this is needed, i.e. what is consistency in this case? Is the regular Cache inconsistent?\nSimilarly with the checkpoint caller. I need to read the code to have any clue of what a checkpoint.put does.\nMy feeling is that you're trying too hard to hide the lock and the counter.\nWhat do you say of something like:\npublic class CacheInvalidationHelper<K, V> {\n\n    private final Cache<K, V> cache;\n    private final AtomicLong currentInvalidationCounter = new AtomicLong();\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final ReleasableLock putLock = new ReleasableLock(lock.readLock());\n    private final ReleasableLock invalidateLock = new ReleasableLock(lock.writeLock());\n\n    public CacheInvalidationHelper(Cache<K, V> cache) {\n        this.cache = cache;\n    }\n\n    public Long getCurrentInvalidationCount() {\n        return this.currentInvalidationCounter.get();\n    }\n\n    public void putIfNoInvalidationSince(K key, V value, Long previousInvalidationCounter) {\n        try (ReleasableLock ignored = putLock.acquire()) {\n            if (previousInvalidationCounter == currentInvalidationCounter.get()) {\n                cache.put(key, value);\n            }\n        }\n    }\n\n    public void invalidate(K key) {\n        try (ReleasableLock ignored = invalidateLock.acquire()) {\n            currentInvalidationCounter.incrementAndGet();\n        }\n        cache.invalidate(key);\n    }\n\n    public void invalidateAll() {\n        try (ReleasableLock ignored = invalidateLock.acquire()) {\n            currentInvalidationCounter.incrementAndGet();\n        }\n        cache.invalidateAll();\n    }\n}", "author": "albertzaharovits", "createdAt": "2020-10-03T14:49:50Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/ConsistentCache.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.util.concurrent.ReleasableLock;\n+\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * A wrapper of {@link Cache} that minimizes the possibility of caching stale results.\n+ */\n+public class ConsistentCache<K, V> {", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5ODU1OA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499198558", "bodyText": "I like this version. I will update the code like it except that I might change the class name to something like StaleMinimizingCacheWrapper to be more meaningful and specific.\nI agree that the ConsistentCache is not a good abstraction in that its interface is unintuitive to use. The background is that I started from a very complex version where I tried to provide an unified interface for security related caches and hide all implementation details, which turned out to be too much to hide. I have since tried to decompose it to a simpler version, i.e. the ConsistentCache. The general approach for simplication is to make inner steps explicit instead of trying to hide them (this is also Tim's suggestion) and also cater for fewer use cases. But my thoughts were still biased by the initial complex version, which prevented me to further simplfy it. For this, I think \"pulling the counter out explicity\" is indeed the right move. So the overall journey has been from an attempt to have \"one cache to rule them all\" to a more pragmatic one that is just for code reuse. It is less satisfying that I was not able to achieve the initial goal. But given what we have, I think the simpler abstraction is the right one for the time being.", "author": "ywangd", "createdAt": "2020-10-04T02:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIxODY2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499218662", "bodyText": "Not to dwell too much on it, but StaleMinimizing... is not what the class does but what it is used for. You're tying the class to a particular circumstance. It is \"stale minimizing\" only in the particular context that it is used in. I think it would be much simpler to explain how it achieves the minimization in a comment at the use site, like in the CompositeRolesStore class, than in the class's javadoc. The name is also a bit intimidating, IMO.\nThe CacheInvalidationHelper name is inspired by CacheIteratorHelper .", "author": "albertzaharovits", "createdAt": "2020-10-04T08:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDU2OA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499220568", "bodyText": "One main reason that I don't think CacheInvalidationHelper is a proper name is because the class is essentially a Cache. If you look past the counter and lock, it is just a regular Cache. So I'd much prefer to call it something along the line of XxxCache or XxxCacheWrapper. \"Minimizing the chane of stale entries\" is the new feature added onto the exiting Cache class. Often times, classes like this are named as AdjectiveNoun, e.g. Realm and CachingRealm. So I think StaleMinimizingCache[Wrapper] is an accurate name. If you feel strong about StaleMinimizing, how about InvalidationCountingCache[Wrapper]? It is still accurate, but less comprehensive.", "author": "ywangd", "createdAt": "2020-10-04T08:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDU0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499154545", "bodyText": "I think \"expire after use\" is more suitable here. There's no reason to evict an in-use cached credential. What do you think?", "author": "albertzaharovits", "createdAt": "2020-10-03T14:53:48Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -192,14 +199,42 @@ public ApiKeyService(Settings settings, Clock clock, Client client, XPackLicense\n         this.threadPool = threadPool;\n         this.cacheHasher = Hasher.resolve(CACHE_HASH_ALGO_SETTING.get(settings));\n         final TimeValue ttl = CACHE_TTL_SETTING.get(settings);\n+        final Integer maximumWeight = CACHE_MAX_KEYS_SETTING.get(settings);\n         if (ttl.getNanos() > 0) {\n             this.apiKeyAuthCache = CacheBuilder.<String, ListenableFuture<CachedApiKeyHashResult>>builder()\n                 .setExpireAfterWrite(ttl)", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5ODY2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499198669", "bodyText": "We already have \"expire after xxx\" for all caches. The maximum weight is to control the overall size of a cache so that it does not grow unbounded. They are for different purposes.", "author": "ywangd", "createdAt": "2020-10-04T02:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIxOTY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499219690", "bodyText": "I think I haven't expressed myself clearly, what I meant:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .setExpireAfterWrite(ttl)\n          \n          \n            \n                            .setExpireAfterAccess(ttl)\n          \n      \n    \n    \n  \n\nI think the \"expire after write\" is suitable for the doc cache but the credential cache might benefit more from the \"expire after access\" strategy because the underlying data (the key secret) never changes.", "author": "albertzaharovits", "createdAt": "2020-10-04T08:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0NDc2MA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499244760", "bodyText": "Ah OK I see your point now. This is existing code. I thought there was a reason why \"expire after write\" is used, but now I cannot remember any. I agree that \"expire after access\" seems to be a better fit. But I seem to remember noticing this previously, but I am not sure now why it was kept like this. I could be missing something. If you don't mind. I'll leave this out as future work.", "author": "ywangd", "createdAt": "2020-10-04T13:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NTk1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499155959", "bodyText": "Too bad this doesn't return the failed nodes. Not something to tackle atm.", "author": "albertzaharovits", "createdAt": "2020-10-03T15:12:59Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/ClearSecurityCacheResponse.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.NodesResponseHeader;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * The response object that will be returned when clearing a security cache\n+ */\n+public final class ClearSecurityCacheResponse extends SecurityNodesResponse {", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NjUzNg==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499156536", "bodyText": "As a possible refactoring in the future, the logic that puts and gets an API key doc into the cache, which uses a secondary cache for the role descriptors is a nice thing to encapsulate.", "author": "albertzaharovits", "createdAt": "2020-10-03T15:19:45Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -364,13 +425,16 @@ private void loadApiKeyAndValidateCredentials(ThreadContext ctx, ApiKeyCredentia\n                         response.getSourceAsBytesRef(), XContentType.JSON)) {\n                         apiKeyDoc = ApiKeyDoc.fromXContent(parser);\n                     }\n-                    validateApiKeyCredentials(docId, apiKeyDoc, credentials, clock, ActionListener.delegateResponse(listener, (l, e) -> {\n-                        if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) {\n-                            listener.onResponse(AuthenticationResult.terminate(\"server is too busy to respond\", e));\n-                        } else {\n-                            listener.onFailure(e);\n+                    if (checkpoint != null) {\n+                        final CachedApiKeyDoc cachedApiKeyDoc = apiKeyDoc.toCachedApiKeyDoc();\n+                        if (checkpoint.put(docId, cachedApiKeyDoc)) {\n+                            roleDescriptorsBytesCache.computeIfAbsent(\n+                                cachedApiKeyDoc.roleDescriptorsHash, k -> apiKeyDoc.roleDescriptorsBytes);\n+                            roleDescriptorsBytesCache.computeIfAbsent(\n+                                cachedApiKeyDoc.limitedByRoleDescriptorsHash, k -> apiKeyDoc.limitedByRoleDescriptorsBytes);", "originalCommit": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMwMDg3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499300873", "bodyText": "Add a new ApiKeyDocCache inner class to encapsulate the secondary cache. It is the right thing to do for this PR. Thanks!", "author": "ywangd", "createdAt": "2020-10-04T23:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NjUzNg=="}], "type": "inlineReview"}, {"oid": "7e828b476405524c0b26c2675440152e9f5114da", "url": "https://github.com/elastic/elasticsearch/commit/7e828b476405524c0b26c2675440152e9f5114da", "message": "Address feedback: simplify consistent cache", "committedDate": "2020-10-04T11:33:12Z", "type": "commit"}, {"oid": "9d24f0a92fd917dd248e023873d3514b85dcb326", "url": "https://github.com/elastic/elasticsearch/commit/9d24f0a92fd917dd248e023873d3514b85dcb326", "message": "Address feedback: only expose clear api key cache API. Client side dedicate clear api key cache request class", "committedDate": "2020-10-04T12:05:45Z", "type": "commit"}, {"oid": "748ddbb9efcbb369bb2e7050c8fb505b3f71aef4", "url": "https://github.com/elastic/elasticsearch/commit/748ddbb9efcbb369bb2e7050c8fb505b3f71aef4", "message": "Add cache clear call after key invalidation", "committedDate": "2020-10-04T12:58:11Z", "type": "commit"}, {"oid": "52d793a3ce6dd9dec22cb88675d4232035761ec4", "url": "https://github.com/elastic/elasticsearch/commit/52d793a3ce6dd9dec22cb88675d4232035761ec4", "message": "checkstyle", "committedDate": "2020-10-04T13:07:17Z", "type": "commit"}, {"oid": "f3b683e5f699994628d1dfa10851bcd2da004c5e", "url": "https://github.com/elastic/elasticsearch/commit/f3b683e5f699994628d1dfa10851bcd2da004c5e", "message": "More check style", "committedDate": "2020-10-04T13:08:42Z", "type": "commit"}, {"oid": "720ee2aa174c758540989eb66572fc64933ef182", "url": "https://github.com/elastic/elasticsearch/commit/720ee2aa174c758540989eb66572fc64933ef182", "message": "Fix tests", "committedDate": "2020-10-04T22:39:48Z", "type": "commit"}, {"oid": "52e4d6b42d14e0c356d2560daa67040642a69d38", "url": "https://github.com/elastic/elasticsearch/commit/52e4d6b42d14e0c356d2560daa67040642a69d38", "message": "Refactor to better manage the secondary role descriptor cache", "committedDate": "2020-10-04T23:29:02Z", "type": "commit"}, {"oid": "901e85f4f011e33c45a0a851c0f4ed223102c539", "url": "https://github.com/elastic/elasticsearch/commit/901e85f4f011e33c45a0a851c0f4ed223102c539", "message": "null check optimize", "committedDate": "2020-10-04T23:37:05Z", "type": "commit"}, {"oid": "70ab17bb566320da7a23e81676e309438705ed5b", "url": "https://github.com/elastic/elasticsearch/commit/70ab17bb566320da7a23e81676e309438705ed5b", "message": "Fix tests", "committedDate": "2020-10-04T23:47:11Z", "type": "commit"}, {"oid": "4cbffa3eb2df1010ceffe7124650b1c02ac4f1b8", "url": "https://github.com/elastic/elasticsearch/commit/4cbffa3eb2df1010ceffe7124650b1c02ac4f1b8", "message": "checkstyle", "committedDate": "2020-10-05T00:28:39Z", "type": "commit"}, {"oid": "ac8ca3591b4d593eab8b1f53752f5a1d5bec5bda", "url": "https://github.com/elastic/elasticsearch/commit/ac8ca3591b4d593eab8b1f53752f5a1d5bec5bda", "message": "Fix tests", "committedDate": "2020-10-05T02:20:16Z", "type": "commit"}, {"oid": "11e591babca2733bc1ce37c692989e38c9586350", "url": "https://github.com/elastic/elasticsearch/commit/11e591babca2733bc1ce37c692989e38c9586350", "message": "Address feedback - add dedicated rest action for clear api key cache", "committedDate": "2020-10-05T09:17:40Z", "type": "commit"}, {"oid": "fe0922581dad62fb59a72dd4dbb55f80bfbc5866", "url": "https://github.com/elastic/elasticsearch/commit/fe0922581dad62fb59a72dd4dbb55f80bfbc5866", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance", "committedDate": "2020-10-06T00:00:11Z", "type": "commit"}, {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "url": "https://github.com/elastic/elasticsearch/commit/fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "message": "Remove clear security request base class from client code", "committedDate": "2020-10-06T00:29:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MjQzMw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499972433", "bodyText": "Nit: There's no reason to use addPathPartAsIs for one and addPathPart for the other part.\nSeeing different methods being called here, makes the reader try and work out why they're different, but as far as I can tell, there is no reason, and it could just be any one of these:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .addPathPartAsIs(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n          \n            \n                        .addPathPart(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .addPathPartAsIs(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n          \n            \n                        .addPathPart(\"_security\", \"api_key\")\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .addPathPartAsIs(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n          \n            \n                        .addPathPartAsIs(\"_security/api_key\")", "author": "tvernum", "createdAt": "2020-10-06T02:31:49Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/SecurityRequestConverters.java", "diffHunk": "@@ -184,10 +185,20 @@ static Request clearRolesCache(ClearRolesCacheRequest disableCacheRequest) {\n         return new Request(HttpPost.METHOD_NAME, endpoint);\n     }\n \n-    static Request clearPrivilegesCache(ClearPrivilegesCacheRequest disableCacheRequest) {\n+    static Request clearPrivilegesCache(ClearPrivilegesCacheRequest clearPrivilegesCacheRequest) {\n         String endpoint = new RequestConverters.EndpointBuilder()\n             .addPathPartAsIs(\"_security/privilege\")\n-            .addCommaSeparatedPathParts(disableCacheRequest.applications())\n+            .addCommaSeparatedPathParts(clearPrivilegesCacheRequest.applications())\n+            .addPathPart(\"_clear_cache\")\n+            .build();\n+        return new Request(HttpPost.METHOD_NAME, endpoint);\n+    }\n+\n+    static Request clearApiKeyCache(ClearApiKeyCacheRequest clearApiKeyCacheRequest) {\n+        String endpoint = new RequestConverters.EndpointBuilder()\n+            .addPathPartAsIs(\"_security\")\n+            .addPathPart(\"api_key\")", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzY2NA==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499973664", "bodyText": "Nit: Having an empty array mean clear-all is a dangerous Java API.\nIt means this:\nString[] ids = {};\nnew ClearApiKeyCacheRequest(ids);\n\nclears the whole cache, despite reading as though it clears an explicit list.\nI would prefer something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ClearApiKeyCacheRequest(String... ids) {\n          \n          \n            \n                    this.ids = ids;\n          \n          \n            \n                }\n          \n          \n            \n                private ClearApiKeyCacheRequest(String... ids) {\n          \n          \n            \n                    this.ids = ids;\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                public static ClearApiKeyCacheRequest clearAll() {\n          \n          \n            \n                    return new ClearApiKeyCacheRequest();\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                public static ClearApiKeyCacheRequest clearById(String ... ids) { \n          \n          \n            \n                    if (ids.length == 0) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Ids cannot be empty\");\n          \n          \n            \n                    }  \n          \n          \n            \n                    return new ClearApiKeyCacheRequest(ids);\n          \n          \n            \n                 }\n          \n      \n    \n    \n  \n\nor\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ClearApiKeyCacheRequest(String... ids) {\n          \n          \n            \n                    this.ids = ids;\n          \n          \n            \n                }\n          \n          \n            \n                public ClearApiKeyCacheRequest() {\n          \n          \n            \n                    this.ids = new String[0];\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public ClearApiKeyCacheRequest(String id1, String... otherIds) {\n          \n          \n            \n                    this.ids = ArrayUtils.concat(new String[] { id1 }, otherIds);\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                public ClearApiKeyCacheRequest(List<String> ids) {\n          \n          \n            \n                    if (ids.isEmpty()) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Ids cannot be empty\");\n          \n          \n            \n                    }\n          \n          \n            \n                    this.ids = ids.toArray(String[]::new);\n          \n          \n            \n                }", "author": "tvernum", "createdAt": "2020-10-06T02:37:21Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/ClearApiKeyCacheRequest.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.Validatable;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * The request used to clear the API key cache.\n+ */\n+public final class ClearApiKeyCacheRequest implements Validatable {\n+\n+    private final String[] ids;\n+\n+    /**\n+     * @param ids      An array of API Key ids to be cleared from the specified cache.\n+     *                 If not specified, all entries will be cleared.\n+     */\n+    public ClearApiKeyCacheRequest(String... ids) {\n+        this.ids = ids;\n+    }", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MTcxNw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499981717", "bodyText": "Why is the max 5min? Are we sure we don't ever want to let someone increase that TTL?\nIt seems like something we'd like to have available if we need to boost performance.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(0), TimeValue.timeValueMinutes(5), Property.NodeScope);\n          \n          \n            \n                    TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(0), TimeValue.timeValueMinutes(15), Property.NodeScope);", "author": "tvernum", "createdAt": "2020-10-06T03:11:08Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -160,6 +168,8 @@\n         TimeValue.timeValueHours(24L), Property.NodeScope);\n     public static final Setting<Integer> CACHE_MAX_KEYS_SETTING = Setting.intSetting(\"xpack.security.authc.api_key.cache.max_keys\",\n         10000, Property.NodeScope);\n+    public static final Setting<TimeValue> DOC_CACHE_TTL_SETTING = Setting.timeSetting(\"xpack.security.authc.api_key.doc_cache.ttl\",\n+        TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(0), TimeValue.timeValueMinutes(5), Property.NodeScope);", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MzQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499983453", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"clearing the API key cache failed. \" + \"please clear the caches manually\", e));\n          \n          \n            \n                                    \"clearing the API key cache failed; please clear the caches manually\", e));", "author": "tvernum", "createdAt": "2020-10-06T03:18:25Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -904,6 +965,25 @@ private void indexInvalidation(Collection<String> apiKeyIds, ActionListener<Inva\n         }\n     }\n \n+    private void clearCache(InvalidateApiKeyResponse result, ActionListener<InvalidateApiKeyResponse> listener) {\n+        final ClearSecurityCacheRequest clearApiKeyCacheRequest =\n+            new ClearSecurityCacheRequest().cacheName(\"api_key\").keys(result.getInvalidatedApiKeys().toArray(String[]::new));\n+        executeAsyncWithOrigin(client, SECURITY_ORIGIN, ClearSecurityCacheAction.INSTANCE, clearApiKeyCacheRequest,\n+            new ActionListener<>() {\n+                @Override\n+                public void onResponse(ClearSecurityCacheResponse nodes) {\n+                    listener.onResponse(result);\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.error(\"unable to clear API key cache\", e);\n+                    listener.onFailure(new ElasticsearchException(\n+                        \"clearing the API key cache failed. \" + \"please clear the caches manually\", e));", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NDI1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499984256", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * are replaced by their hashes. The actual values are stored in a separate role descriptor cache.\n          \n          \n            \n                 * are replaced by their hashes. The actual values are stored in a separate role descriptor cache,\n          \n          \n            \n                 * so that duplicate role descriptors are cached only once (and therefore consume less memory).", "author": "tvernum", "createdAt": "2020-10-06T03:21:56Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -1088,8 +1168,128 @@ public ApiKeyDoc(\n             this.creator = creator;\n         }\n \n+        public CachedApiKeyDoc toCachedApiKeyDoc() {\n+            final MessageDigest digest = MessageDigests.sha256();\n+            digest.update(BytesReference.toBytes(roleDescriptorsBytes));\n+            final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            digest.reset();\n+            digest.update(BytesReference.toBytes(limitedByRoleDescriptorsBytes));\n+            final String limitedByRoleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            return new CachedApiKeyDoc(\n+                creationTime,\n+                expirationTime,\n+                invalidated,\n+                hash,\n+                name,\n+                version,\n+                creator,\n+                roleDescriptorsHash,\n+                limitedByRoleDescriptorsHash);\n+        }\n+\n         static ApiKeyDoc fromXContent(XContentParser parser) {\n             return PARSER.apply(parser, null);\n         }\n     }\n+\n+    /**\n+     * A cached version of the {@link ApiKeyDoc}. The main difference is that the role descriptors\n+     * are replaced by their hashes. The actual values are stored in a separate role descriptor cache.", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NTI3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499985275", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()\n          \n          \n            \n                        // We don't use the doc TTL because that TTL is very low to avoid the risk of\n          \n          \n            \n                        // caching an invalidated API key. But role descriptors are immutable and may be shared between\n          \n          \n            \n                        // multiple API keys, so we cache for longer and rely on the weight to manage the cache size.\n          \n          \n            \n                        this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()", "author": "tvernum", "createdAt": "2020-10-06T03:26:34Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -1088,8 +1168,128 @@ public ApiKeyDoc(\n             this.creator = creator;\n         }\n \n+        public CachedApiKeyDoc toCachedApiKeyDoc() {\n+            final MessageDigest digest = MessageDigests.sha256();\n+            digest.update(BytesReference.toBytes(roleDescriptorsBytes));\n+            final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            digest.reset();\n+            digest.update(BytesReference.toBytes(limitedByRoleDescriptorsBytes));\n+            final String limitedByRoleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            return new CachedApiKeyDoc(\n+                creationTime,\n+                expirationTime,\n+                invalidated,\n+                hash,\n+                name,\n+                version,\n+                creator,\n+                roleDescriptorsHash,\n+                limitedByRoleDescriptorsHash);\n+        }\n+\n         static ApiKeyDoc fromXContent(XContentParser parser) {\n             return PARSER.apply(parser, null);\n         }\n     }\n+\n+    /**\n+     * A cached version of the {@link ApiKeyDoc}. The main difference is that the role descriptors\n+     * are replaced by their hashes. The actual values are stored in a separate role descriptor cache.\n+     */\n+    public static final class CachedApiKeyDoc {\n+        final long creationTime;\n+        final long expirationTime;\n+        final Boolean invalidated;\n+        final String hash;\n+        final String name;\n+        final int version;\n+        final Map<String, Object> creator;\n+        final String roleDescriptorsHash;\n+        final String limitedByRoleDescriptorsHash;\n+\n+        public CachedApiKeyDoc(\n+            long creationTime, long expirationTime,\n+            Boolean invalidated,\n+            String hash,\n+            String name, int version, Map<String, Object> creator,\n+            String roleDescriptorsHash,\n+            String limitedByRoleDescriptorsHash) {\n+            this.creationTime = creationTime;\n+            this.expirationTime = expirationTime;\n+            this.invalidated = invalidated;\n+            this.hash = hash;\n+            this.name = name;\n+            this.version = version;\n+            this.creator = creator;\n+            this.roleDescriptorsHash = roleDescriptorsHash;\n+            this.limitedByRoleDescriptorsHash = limitedByRoleDescriptorsHash;\n+        }\n+\n+        public ApiKeyDoc toApiKeyDoc(BytesReference roleDescriptorsBytes, BytesReference limitedByRoleDescriptorsBytes) {\n+            return new ApiKeyDoc(\n+                \"api_key\",\n+                creationTime,\n+                expirationTime,\n+                invalidated,\n+                hash,\n+                name,\n+                version,\n+                roleDescriptorsBytes,\n+                limitedByRoleDescriptorsBytes,\n+                creator);\n+        }\n+    }\n+\n+    private static final class ApiKeyDocCache {\n+        private final InvalidationCountingCacheWrapper<String, ApiKeyService.CachedApiKeyDoc> docCache;\n+        private final Cache<String, BytesReference> roleDescriptorsBytesCache;\n+\n+        ApiKeyDocCache(TimeValue ttl, int maximumWeight) {\n+            this.docCache = new InvalidationCountingCacheWrapper<>(\n+                CacheBuilder.<String, ApiKeyService.CachedApiKeyDoc>builder()\n+                    .setMaximumWeight(maximumWeight)\n+                    .setExpireAfterWrite(ttl)\n+                    .build()\n+            );\n+            this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NTg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499985889", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class TransportClearSecurityCacheAction extends TransportNodesAction<ClearSecurityCacheRequest, ClearSecurityCacheResponse,\n          \n          \n            \n            /**\n          \n          \n            \n             * Clears a security cache by name (with optional keys).\n          \n          \n            \n             * @see CacheInvalidatorRegistry\n          \n          \n            \n             */\n          \n          \n            \n            public class TransportClearSecurityCacheAction extends TransportNodesAction<ClearSecurityCacheRequest, ClearSecurityCacheResponse,", "author": "tvernum", "createdAt": "2020-10-06T03:29:30Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportClearSecurityCacheAction.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheAction;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheResponse;\n+import org.elasticsearch.xpack.security.support.CacheInvalidatorRegistry;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class TransportClearSecurityCacheAction extends TransportNodesAction<ClearSecurityCacheRequest, ClearSecurityCacheResponse,", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NjEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499986123", "bodyText": "Ideally we would have serialization tests for every class that has a writeTo method.", "author": "tvernum", "createdAt": "2020-10-06T03:30:27Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/ClearSecurityCacheRequest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.support.nodes.BaseNodesRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.io.IOException;\n+\n+public class ClearSecurityCacheRequest extends BaseNodesRequest<ClearSecurityCacheRequest> {\n+\n+    private String cacheName;\n+    private String[] keys;\n+\n+    public ClearSecurityCacheRequest() {\n+        super((String[]) null);\n+    }\n+\n+    public ClearSecurityCacheRequest(StreamInput in) throws IOException {\n+        super(in);\n+        cacheName = in.readString();\n+        keys = in.readOptionalStringArray();\n+    }\n+\n+    public ClearSecurityCacheRequest cacheName(String cacheName) {\n+        this.cacheName = cacheName;\n+        return this;\n+    }\n+\n+    public String cacheName() {\n+        return cacheName;\n+    }\n+\n+    public ClearSecurityCacheRequest keys(String... keys) {\n+        this.keys = keys;\n+        return this;\n+    }\n+\n+    public String[] keys() {\n+        return keys;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(cacheName);\n+        out.writeOptionalStringArray(keys);\n+    }", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5NTc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499995763", "bodyText": "Add a serialisation test.", "author": "ywangd", "createdAt": "2020-10-06T04:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NjEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NzQ5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499987492", "bodyText": "A Nit, with a real implication.\nThis test name just refers to the method that it tests. It doesn't actually say what behaviour it's testing, just the method it calls. A name like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testInvalidateByKey() {\n          \n          \n            \n                public void testInvalidateByKeyCallsCorrectInvalidatorObject() {\n          \n      \n    \n    \n  \n\nwould be more descriptive.\nAnd the implication is that because we have a method named test{SomeMethod} it leads to thinking that we just need to call some stuff on that method and we're done, and skips the thinking step of What cases do I need to test?.\nAnd in this case, there's no tests for invalidating a cache that hasn't been registered. Should that be a no-op? Or a failure?", "author": "tvernum", "createdAt": "2020-10-06T03:35:56Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistryTests.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.security.support.CacheInvalidatorRegistry.CacheInvalidator;\n+import org.junit.Before;\n+\n+import java.time.Instant;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+public class CacheInvalidatorRegistryTests extends ESTestCase {\n+\n+    private CacheInvalidatorRegistry cacheInvalidatorRegistry;\n+\n+    @Before\n+    public void setup() {\n+        cacheInvalidatorRegistry = new CacheInvalidatorRegistry();\n+    }\n+\n+    public void testRegistryWillNotAllowInvalidatorsWithDuplicatedName() {\n+        cacheInvalidatorRegistry.registerCacheInvalidator(\"service1\", mock(CacheInvalidator.class));\n+        final IllegalArgumentException e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> cacheInvalidatorRegistry.registerCacheInvalidator(\"service1\", mock(CacheInvalidator.class)));\n+        assertThat(e.getMessage(), containsString(\"already has an entry with name: [service1]\"));\n+    }\n+\n+    public void testSecurityIndexStateChangeWillInvalidateAllRegisteredInvalidators() {\n+        final CacheInvalidator invalidator1 = mock(CacheInvalidator.class);\n+        cacheInvalidatorRegistry.registerCacheInvalidator(\"service1\", invalidator1);\n+        final CacheInvalidator invalidator2 = mock(CacheInvalidator.class);\n+        cacheInvalidatorRegistry.registerCacheInvalidator(\"service2\", invalidator2);\n+\n+        final SecurityIndexManager.State previousState = SecurityIndexManager.State.UNRECOVERED_STATE;\n+        final SecurityIndexManager.State currentState = new SecurityIndexManager.State(\n+            Instant.now(), true, true, true, Version.CURRENT,\n+            \".security\", ClusterHealthStatus.GREEN, IndexMetadata.State.OPEN);\n+\n+        cacheInvalidatorRegistry.onSecurityIndexStageChange(previousState, currentState);\n+        verify(invalidator1).invalidateAll();\n+        verify(invalidator2).invalidateAll();\n+    }\n+\n+    public void testInvalidateByKey() {", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NzY0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499987645", "bodyText": "The lack of an else seems like dangerous leniency. Why do we silently pretend to invalidate a cache that doesn't exist?", "author": "tvernum", "createdAt": "2020-10-06T03:36:40Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistry.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+/**\n+ * A registry that provides common cache invalidation services for caches that relies on the security index.\n+ */\n+public class CacheInvalidatorRegistry {\n+\n+    private final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();\n+\n+    public CacheInvalidatorRegistry() {\n+    }\n+\n+    public void registerCacheInvalidator(String name, CacheInvalidator cacheInvalidator) {\n+        if (cacheInvalidators.containsKey(name)) {\n+            throw new IllegalArgumentException(\"Cache invalidator registry already has an entry with name: [\" + name + \"]\");\n+        }\n+        cacheInvalidators.put(name, cacheInvalidator);\n+    }\n+\n+    public void onSecurityIndexStageChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState)\n+            || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            cacheInvalidators.values().forEach(CacheInvalidator::invalidateAll);\n+        }\n+    }\n+\n+    public void invalidateByKey(String cacheName, Collection<String> keys) {\n+        final CacheInvalidator cacheInvalidator = cacheInvalidators.get(cacheName);\n+        if (cacheInvalidator != null) {\n+            cacheInvalidator.invalidate(keys);\n+        }", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5NTk2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499995967", "bodyText": "This is a good point and there is no reason for this leniency. Add an else branch to throw exception and also relevant tests.", "author": "ywangd", "createdAt": "2020-10-06T04:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4Nzg2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499987865", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testItemWillNotBeCachedWhenInvalidationHappensBetweenCheckpointAndItsUsage() throws InterruptedException {\n          \n          \n            \n                public void testItemWillNotBeCachedIfInvalidationCounterHasChanged() throws InterruptedException {", "author": "tvernum", "createdAt": "2020-10-06T03:37:46Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/support/InvalidationCountingCacheWrapperTests.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.elasticsearch.common.cache.CacheBuilder;\n+import org.elasticsearch.test.ESTestCase;\n+import org.junit.Before;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class InvalidationCountingCacheWrapperTests extends ESTestCase {\n+\n+    private InvalidationCountingCacheWrapper<String, String> invalidationCountingCacheWrapper;\n+\n+    @Before\n+    public void setup() {\n+        invalidationCountingCacheWrapper = new InvalidationCountingCacheWrapper<>(CacheBuilder.<String, String>builder().build());\n+    }\n+\n+    public void testItemWillCached() {\n+        final long invalidationCount = invalidationCountingCacheWrapper.getInvalidationCount();\n+        assertTrue(invalidationCountingCacheWrapper.putIfNoInvalidationSince(\"foo\", \"bar\", invalidationCount));\n+        assertEquals(\"bar\", invalidationCountingCacheWrapper.get(\"foo\"));\n+    }\n+\n+    public void testItemWillNotBeCachedWhenInvalidationHappensBetweenCheckpointAndItsUsage() throws InterruptedException {", "originalCommit": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1a3b40e1b6d098a9e1930558cfd85025e5402f4", "url": "https://github.com/elastic/elasticsearch/commit/e1a3b40e1b6d098a9e1930558cfd85025e5402f4", "message": "Apply suggestions from code review\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-10-06T03:47:47Z", "type": "commit"}, {"oid": "cefed1a4c7dcd0232120a52824a5e5a69771ff61", "url": "https://github.com/elastic/elasticsearch/commit/cefed1a4c7dcd0232120a52824a5e5a69771ff61", "message": "Apply suggestions from code review\n\nCo-authored-by: Tim Vernum <tim@adjective.org>", "committedDate": "2020-10-06T03:49:49Z", "type": "commit"}, {"oid": "ef95a1dd11410530bccba9d0ddbbb46d50ea4e82", "url": "https://github.com/elastic/elasticsearch/commit/ef95a1dd11410530bccba9d0ddbbb46d50ea4e82", "message": "Address feedback", "committedDate": "2020-10-06T04:12:15Z", "type": "commit"}]}