{"pr_number": 62906, "pr_title": "Introduce runtime section in mappings", "pr_createdAt": "2020-09-24T23:10:47Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62906", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjE1OA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r495802158", "bodyText": "How does this work when parsing documents? We presumably want to ensure that an incoming doc is parsed using the non-runtime version of the mapper if this exists?", "author": "romseygeek", "createdAt": "2020-09-28T09:21:08Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java", "diffHunk": "@@ -51,26 +51,36 @@ private static void put(Map<String, Analyzer> analyzers, String key, Analyzer va\n \n     public static MappingLookup fromMapping(Mapping mapping, Analyzer defaultIndex) {\n         List<ObjectMapper> newObjectMappers = new ArrayList<>();\n-        List<FieldMapper> newFieldMappers = new ArrayList<>();\n+        Map<String, FieldMapper> newFieldMappers = new HashMap<>();\n         List<FieldAliasMapper> newFieldAliasMappers = new ArrayList<>();\n+\n+        collect(mapping.root, newObjectMappers, newFieldMappers, newFieldAliasMappers);\n+\n+        //add runtime fields and replace concrete fields with runtime fields with the same name\n+        for (RuntimeFieldMapper runtimeMapper : mapping.root.runtimeMappers()) {", "originalCommit": "d7cbcceca39894a77516a033f7f380da7de238ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMzk4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r495813986", "bodyText": "good point. I thought that I tested this, but looking at the code I think replacing the field mappers should also affect documents parsing which I think is not what we want.", "author": "javanna", "createdAt": "2020-09-28T09:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNzc2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r495817765", "bodyText": "Yeah, I think we need to do this via MappedFieldType, not via FieldMapper, unfortunately.  Which means we need to move valueFetcher() - I can make a start on that today.", "author": "romseygeek", "createdAt": "2020-09-28T09:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNDMyNA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r495824324", "bodyText": "I am not sure that valueFetcher is the only problem, I would be happy if that was the case.\nSo the idea could be to only replace field mappers that are provided to FieldTypeLookup? And go through the usages of MappingLookup#getMapper and MappingLookup#iterator to see if they may need to access the runtime fields or not?", "author": "javanna", "createdAt": "2020-09-28T09:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNjYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r495826635", "bodyText": "Yes, that sounds reasonable.  Or we could even pass the runtime mappers directly to FieldTypeLookup, like we do currently with aliases, and re-map things in there?", "author": "romseygeek", "createdAt": "2020-09-28T10:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyODg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r495828898", "bodyText": "yea that would work too, ok I will try to find out what else may be on our way here.", "author": "javanna", "createdAt": "2020-09-28T10:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjE1OA=="}], "type": "inlineReview"}, {"oid": "dd5f648d77a15238def61e9aa53f19cd950d2224", "url": "https://github.com/elastic/elasticsearch/commit/dd5f648d77a15238def61e9aa53f19cd950d2224", "message": "Add support for runtime section in the mappings\n\nThe runtime section is at the same level as the existing properties section. Its purpose is to hold runtime fields only. With the introduction of the runtime section, a runtime field can be defined by specifying its type (previously called runtime_type) and script.\n\nFields defined in the runtime section can be updated at any time as they are not present in the lucene index. They get replaced entirely when they get updated.\n\nThanks to the introduction of the runtime section, runtime fields can override existing mapped fields defined with the same name, similarly to runtime fields defined in the search request.", "committedDate": "2020-11-10T16:47:06Z", "type": "commit"}, {"oid": "dd5f648d77a15238def61e9aa53f19cd950d2224", "url": "https://github.com/elastic/elasticsearch/commit/dd5f648d77a15238def61e9aa53f19cd950d2224", "message": "Add support for runtime section in the mappings\n\nThe runtime section is at the same level as the existing properties section. Its purpose is to hold runtime fields only. With the introduction of the runtime section, a runtime field can be defined by specifying its type (previously called runtime_type) and script.\n\nFields defined in the runtime section can be updated at any time as they are not present in the lucene index. They get replaced entirely when they get updated.\n\nThanks to the introduction of the runtime section, runtime fields can override existing mapped fields defined with the same name, similarly to runtime fields defined in the search request.", "committedDate": "2020-11-10T16:47:06Z", "type": "forcePushed"}, {"oid": "8bad8dbe0da3a8cf55da9ba9e7691f52e22d36e7", "url": "https://github.com/elastic/elasticsearch/commit/8bad8dbe0da3a8cf55da9ba9e7691f52e22d36e7", "message": "iter", "committedDate": "2020-11-10T17:12:17Z", "type": "commit"}, {"oid": "5f059980a75d49dd6f454eb1dfe39e65d843d56e", "url": "https://github.com/elastic/elasticsearch/commit/5f059980a75d49dd6f454eb1dfe39e65d843d56e", "message": "fix PermissionsIT", "committedDate": "2020-11-10T19:08:45Z", "type": "commit"}, {"oid": "740425f91789c927e1722b80a8a25ad93aefb8bf", "url": "https://github.com/elastic/elasticsearch/commit/740425f91789c927e1722b80a8a25ad93aefb8bf", "message": "Merge branch 'master' into enhancement/mapping_runtime_section", "committedDate": "2020-11-11T10:33:14Z", "type": "commit"}, {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1", "url": "https://github.com/elastic/elasticsearch/commit/ae573321e1f91aae349b44f3a4cd01dd955033e1", "message": "Merge branch 'master' into enhancement/mapping_runtime_section", "committedDate": "2020-11-11T10:34:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2ODEyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521268125", "bodyText": "I am not a big fan of this public static method here, but I think it's important to share it between QueryShardContext and RootObjectMapper", "author": "javanna", "createdAt": "2020-11-11T10:40:16Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/RuntimeFieldType.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Base implementation for a runtime field that can be defined as part of the runtime section of the index mappings\n+ */\n+public abstract class RuntimeFieldType extends MappedFieldType implements ToXContentFragment {\n+\n+    protected RuntimeFieldType(String name, Map<String, String> meta) {\n+        super(name, false, false, false, TextSearchInfo.SIMPLE_MATCH_WITHOUT_TERMS, meta);\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(name());\n+        builder.field(\"type\", typeName());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        doXContentBody(builder, includeDefaults);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    /**\n+     * Prints out the parameters that subclasses expose\n+     */\n+    protected abstract void doXContentBody(XContentBuilder builder, boolean includeDefaults) throws IOException;\n+\n+    /**\n+     * Parser for a runtime field. Creates the appropriate {@link RuntimeFieldType} for a runtime field,\n+     * as defined in the runtime section of the index mappings.\n+     */\n+    public interface Parser {\n+        RuntimeFieldType parse(String name, Map<String, Object> node, Mapper.TypeParser.ParserContext parserContext)\n+            throws MapperParsingException;\n+    }\n+\n+    public static void parseRuntimeFields(Map<String, Object> node,", "originalCommit": "ae573321e1f91aae349b44f3a4cd01dd955033e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2ODQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521268439", "bodyText": "this was moved from RuntimeFieldMapperTests", "author": "javanna", "createdAt": "2020-11-11T10:40:54Z", "path": "server/src/test/java/org/elasticsearch/index/IndexSortSettingsTests.java", "diffHunk": "@@ -129,4 +144,50 @@ public void testInvalidMissing() {\n         assertThat(exc.getMessage(), containsString(\"Illegal missing value:[default],\" +\n             \" must be one of [_last, _first]\"));\n     }\n+\n+    public void testIndexSorting() {", "originalCommit": "ae573321e1f91aae349b44f3a4cd01dd955033e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2MzQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521363478", "bodyText": "Nice!", "author": "nik9000", "createdAt": "2020-11-11T13:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2ODQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MTc1MA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521271750", "bodyText": "these three tests I borrowed from MapperTestCase , they were previously run as part of RuntimeFieldMapperTests", "author": "javanna", "createdAt": "2020-11-11T10:47:03Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldTypeTestCase.java", "diffHunk": "@@ -6,29 +6,173 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.search.Query;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.indices.mapper.MapperRegistry;\n+import org.elasticsearch.plugins.MapperPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.ScriptPlugin;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n \n import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.BiConsumer;\n \n+import static java.util.stream.Collectors.toList;\n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+public abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+\n+    private static final ToXContent.Params INCLUDE_DEFAULTS = new ToXContent.MapParams(Map.of(\"include_defaults\", \"true\"));\n+\n     protected abstract MappedFieldType simpleMappedFieldType() throws IOException;\n \n     protected abstract MappedFieldType loopFieldType() throws IOException;\n \n-    protected abstract String runtimeType();\n+    protected abstract String typeName();\n+\n+    public final void testMinimalSerializesToItself() throws IOException {\n+        XContentBuilder orig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(runtimeFieldMapping(this::minimalMapping)).documentMapper().mapping().toXContent(orig, ToXContent.EMPTY_PARAMS);\n+        orig.endObject();\n+        XContentBuilder parsedFromOrig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(orig).documentMapper().mapping().toXContent(parsedFromOrig, ToXContent.EMPTY_PARAMS);\n+        parsedFromOrig.endObject();\n+        assertEquals(Strings.toString(orig), Strings.toString(parsedFromOrig));\n+    }\n+\n+    public final void testMeta() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"foo\", \"bar\"));\n+        });\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(this::minimalMapping);\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"baz\", \"quux\"));\n+        });\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+    }\n+\n+    public final void testMinimalMappingToMaximal() throws IOException {", "originalCommit": "ae573321e1f91aae349b44f3a4cd01dd955033e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MTk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521271951", "bodyText": "these were moved from RuntimeFieldMapperTests", "author": "javanna", "createdAt": "2020-11-11T10:47:25Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldTypeTestCase.java", "diffHunk": "@@ -6,29 +6,173 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.search.Query;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.indices.mapper.MapperRegistry;\n+import org.elasticsearch.plugins.MapperPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.ScriptPlugin;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n \n import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.BiConsumer;\n \n+import static java.util.stream.Collectors.toList;\n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+public abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+\n+    private static final ToXContent.Params INCLUDE_DEFAULTS = new ToXContent.MapParams(Map.of(\"include_defaults\", \"true\"));\n+\n     protected abstract MappedFieldType simpleMappedFieldType() throws IOException;\n \n     protected abstract MappedFieldType loopFieldType() throws IOException;\n \n-    protected abstract String runtimeType();\n+    protected abstract String typeName();\n+\n+    public final void testMinimalSerializesToItself() throws IOException {\n+        XContentBuilder orig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(runtimeFieldMapping(this::minimalMapping)).documentMapper().mapping().toXContent(orig, ToXContent.EMPTY_PARAMS);\n+        orig.endObject();\n+        XContentBuilder parsedFromOrig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(orig).documentMapper().mapping().toXContent(parsedFromOrig, ToXContent.EMPTY_PARAMS);\n+        parsedFromOrig.endObject();\n+        assertEquals(Strings.toString(orig), Strings.toString(parsedFromOrig));\n+    }\n+\n+    public final void testMeta() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"foo\", \"bar\"));\n+        });\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(this::minimalMapping);\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"baz\", \"quux\"));\n+        });\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+    }\n+\n+    public final void testMinimalMappingToMaximal() throws IOException {\n+        XContentBuilder orig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(runtimeFieldMapping(this::minimalMapping)).documentMapper().mapping().toXContent(orig, INCLUDE_DEFAULTS);\n+        orig.endObject();\n+        XContentBuilder parsedFromOrig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(orig).documentMapper().mapping().toXContent(parsedFromOrig, INCLUDE_DEFAULTS);\n+        parsedFromOrig.endObject();\n+        assertEquals(Strings.toString(orig), Strings.toString(parsedFromOrig));\n+    }\n+\n+    public void testScriptIsRequired() throws Exception {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> { b.field(\"type\", typeName()); });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: script must be specified for runtime field [field]\", exception.getMessage());\n+    }\n+\n+    public void testCopyToIsNotSupported() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"copy_to\", \"target\");\n+        });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: runtime field [field] does not support [copy_to]\", exception.getMessage());\n+    }\n+\n+    public void testMultiFieldsIsNotSupported() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.startObject(\"fields\").startObject(\"test\").field(\"type\", \"keyword\").endObject().endObject();\n+        });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: runtime field [field] does not support [fields]\", exception.getMessage());\n+    }\n+\n+    public void testStoredScriptsAreNotSupported() throws Exception {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            b.field(\"type\", typeName());\n+            b.startObject(\"script\").field(\"id\", \"test\").endObject();\n+        });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: stored scripts are not supported for runtime field [field]\", exception.getMessage());\n+    }\n+\n+    public void testFieldCaps() throws Exception {", "originalCommit": "ae573321e1f91aae349b44f3a4cd01dd955033e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MzA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521273071", "bodyText": "these were moved from RuntimeFieldMapperTests", "author": "javanna", "createdAt": "2020-11-11T10:49:32Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/DateScriptFieldTypeTests.java", "diffHunk": "@@ -63,8 +67,43 @@\n import static org.hamcrest.Matchers.closeTo;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n \n public class DateScriptFieldTypeTests extends AbstractNonTextScriptFieldTypeTestCase {\n+\n+    public void testDateWithFormat() throws IOException {\n+        CheckedSupplier<XContentBuilder, IOException> mapping = () -> runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"format\", \"yyyy-MM-dd\");\n+        });\n+        MapperService mapperService = createMapperService(mapping.get());\n+        MappedFieldType fieldType = mapperService.fieldType(\"field\");\n+        assertThat(fieldType, instanceOf(DateScriptFieldType.class));\n+        assertEquals(Strings.toString(mapping.get()), Strings.toString(mapperService.documentMapper()));\n+    }\n+\n+    public void testDateWithLocale() throws IOException {\n+        CheckedSupplier<XContentBuilder, IOException> mapping = () -> runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"locale\", \"en_GB\");\n+        });\n+        MapperService mapperService = createMapperService(mapping.get());\n+        MappedFieldType fieldType = mapperService.fieldType(\"field\");\n+        assertThat(fieldType, instanceOf(DateScriptFieldType.class));\n+        assertEquals(Strings.toString(mapping.get()), Strings.toString(mapperService.documentMapper()));\n+    }\n+\n+    public void testDateWithLocaleAndFormat() throws IOException {\n+        CheckedSupplier<XContentBuilder, IOException> mapping = () -> runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"format\", \"yyyy-MM-dd\").field(\"locale\", \"en_GB\");\n+        });\n+        MapperService mapperService = createMapperService(mapping.get());\n+        MappedFieldType fieldType = mapperService.fieldType(\"field\");\n+        assertThat(fieldType, instanceOf(DateScriptFieldType.class));\n+        assertEquals(Strings.toString(mapping.get()), Strings.toString(mapperService.documentMapper()));\n+    }", "originalCommit": "ae573321e1f91aae349b44f3a4cd01dd955033e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "353dcd8366b702fb77af4e1a4ed41f3324f9795e", "url": "https://github.com/elastic/elasticsearch/commit/353dcd8366b702fb77af4e1a4ed41f3324f9795e", "message": "iter", "committedDate": "2020-11-11T10:51:39Z", "type": "commit"}, {"oid": "357f821d18cd05b5a1a6e3f44140cf98e49886b0", "url": "https://github.com/elastic/elasticsearch/commit/357f821d18cd05b5a1a6e3f44140cf98e49886b0", "message": "import", "committedDate": "2020-11-11T10:52:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5MTUxMg==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521291512", "bodyText": "Dumb question: is there a reason this can't extend MappingServiceTestCase?", "author": "romseygeek", "createdAt": "2020-11-11T11:24:39Z", "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldTypeTestCase.java", "diffHunk": "@@ -6,29 +6,170 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.search.Query;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.indices.mapper.MapperRegistry;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.ScriptPlugin;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n \n import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.BiConsumer;\n \n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+public abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {", "originalCommit": "357f821d18cd05b5a1a6e3f44140cf98e49886b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMyNDcyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521324721", "bodyText": "A question I asked myself too. I think that MapperServiceTestCase revolves around ordinary fields that have a field mapper and a field type. Runtime fields are created differently and don't have a field mapper. I did not feel like extending MapperServiceTestCase to support runtime fields. I can see how we may want to reconsider this once we have more runtime field types", "author": "javanna", "createdAt": "2020-11-11T12:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5MTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMzOTgyNw==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521339827", "bodyText": "MapperTestCase expects a FieldMapper, but MapperServiceTestCase just provides the helper functions and doesn't have any abstract methods on it.  Would save copying the createMapperService() methods.", "author": "romseygeek", "createdAt": "2020-11-11T12:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5MTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQxNzE2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521417163", "bodyText": "that works! I had tried MapperTestCase because I was annoyed that I had to copy methods from it, but with MapperServiceTestcase at least I don't have to copy createMapperService.", "author": "javanna", "createdAt": "2020-11-11T14:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5MTUxMg=="}], "type": "inlineReview"}, {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328", "url": "https://github.com/elastic/elasticsearch/commit/78445671b96d4ca81054e46dfa916310cf9d2328", "message": "fix tests", "committedDate": "2020-11-11T12:43:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NTI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521365285", "bodyText": "I think extending MapperServiceTestCase will get you these \"for free\".", "author": "nik9000", "createdAt": "2020-11-11T13:41:33Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -19,25 +19,68 @@\n \n package org.elasticsearch.index.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n+import org.apache.lucene.search.Query;\n import org.elasticsearch.Version;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MapperService.MergeReason;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.plugins.MapperPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.test.ESTestCase;\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n \n import static org.elasticsearch.test.VersionUtils.randomVersionBetween;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.instanceOf;\n \n-public class RootObjectMapperTests extends ESSingleNodeTestCase {\n+public class RootObjectMapperTests extends ESTestCase {\n+\n+    private static MapperService createMapperService() {\n+        return createMapperService(Version.CURRENT);\n+    }\n+\n+    private static MapperService createMapperService(Version indexCreatedVersion) {\n+        return createMapperService(indexCreatedVersion, Collections.emptyList());\n+    }\n+\n+    private static MapperService createMapperService(List<MapperPlugin> mapperPlugins) {\n+        return createMapperService(Version.CURRENT, mapperPlugins);\n+    }\n+\n+    private static MapperService createMapperService(Version indexCreatedVersion, List<MapperPlugin> mapperPlugins) {\n+        Settings settings = Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0)\n+            .put(\"index.version.created\", indexCreatedVersion).build();\n+        IndexMetadata indexMetadata = IndexMetadata.builder(\"index\").settings(settings).build();\n+        IndexSettings indexSettings = new IndexSettings(indexMetadata, Settings.EMPTY);\n+        IndexAnalyzers indexAnalyzers = new IndexAnalyzers(\n+            Map.of(\"default\", new NamedAnalyzer(\"default\", AnalyzerScope.INDEX, new StandardAnalyzer())), Map.of(), Map.of());\n+        IndicesModule indicesModule = new IndicesModule(mapperPlugins);\n+        SimilarityService similarityService = new SimilarityService(indexSettings, null, Collections.emptyMap());\n+        return new MapperService(indexSettings, indexAnalyzers, NamedXContentRegistry.EMPTY, similarityService,\n+            indicesModule.getMapperRegistry(), () -> {\n+                throw new UnsupportedOperationException();\n+            }, () -> true, null);\n+    }", "originalCommit": "78445671b96d4ca81054e46dfa916310cf9d2328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NDU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521464571", "bodyText": "yes, I had to rework stuff a bit but it works.", "author": "javanna", "createdAt": "2020-11-11T16:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NzIzMg==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521367232", "bodyText": "Could you do it more like:\nXcontentbuidler b = ;\nb.startObject().startObject(\"_doc\").startObject(\"runtime\");\nb.startObject(\"f1\").field(\"type\", \"test\").field(\"prop1\", \"value1\").endObject();\n...\n\nI think grouping the fields onto one line each makes them easier to read.", "author": "nik9000", "createdAt": "2020-11-11T13:44:42Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -465,13 +503,216 @@ public void testIllegalDynamicTemplate7DotXIndex() throws Exception {\n         }\n         mapping.endObject();\n         Version createdVersion = randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_7_0);\n-        Settings indexSettings = Settings.builder()\n-            .put(IndexMetadata.SETTING_INDEX_VERSION_CREATED.getKey(), createdVersion)\n-            .build();\n-        MapperService mapperService = createIndex(\"test\", indexSettings).mapperService();\n+        MapperService mapperService = createMapperService(createdVersion);\n         DocumentMapper mapper = mapperService.merge(\"type\", new CompressedXContent(Strings.toString(mapping)), MergeReason.MAPPING_UPDATE);\n         assertThat(mapper.mappingSource().toString(), containsString(\"\\\"type\\\":\\\"string\\\"\"));\n         assertWarnings(\"dynamic template [my_template] has invalid content [{\\\"match_mapping_type\\\":\\\"string\\\",\\\"mapping\\\":{\\\"type\\\":\" +\n             \"\\\"string\\\"}}], caused by [No mapper found for type [string]]\");\n     }\n+\n+    public void testRuntimeSection() throws IOException {\n+        MapperService mapperService = createMapperService(Collections.singletonList(new RuntimeFieldPlugin()));\n+        MergeReason reason = randomFrom(MergeReason.MAPPING_UPDATE, MergeReason.INDEX_TEMPLATE);\n+        String mapping = Strings.toString(XContentFactory.jsonBuilder()", "originalCommit": "78445671b96d4ca81054e46dfa916310cf9d2328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2ODIyNg==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521368226", "bodyText": "The mapping method on MapperServiceTestCase is a helper for test cases that make the mapping. It always spits out properties which you don't want, but it might be useful to look at and adapt just to save a little copy and pasting on these mappings.", "author": "nik9000", "createdAt": "2020-11-11T13:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NzIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NDY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521464670", "bodyText": "on it", "author": "javanna", "createdAt": "2020-11-11T16:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NzIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MTM0MA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521371340", "bodyText": "If you do Map.ofEntries and then do a Map.entry for each pair the formatter will \"do the right thing\" to keep these a little more readable. I think.", "author": "nik9000", "createdAt": "2020-11-11T13:51:08Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/RuntimeFields.java", "diffHunk": "@@ -6,29 +6,55 @@\n \n package org.elasticsearch.xpack.runtimefields;\n \n-import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.BooleanFieldMapper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.RuntimeFieldType;\n import org.elasticsearch.plugins.MapperPlugin;\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.plugins.ScriptPlugin;\n import org.elasticsearch.script.ScriptContext;\n import org.elasticsearch.xpack.runtimefields.mapper.BooleanFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.BooleanScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DateFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DateScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DoubleFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DoubleScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.GeoPointFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.GeoPointScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.IpFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.IpScriptFieldType;\n+import org.elasticsearch.xpack.runtimefields.mapper.KeywordScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.LongFieldScript;\n-import org.elasticsearch.xpack.runtimefields.mapper.RuntimeFieldMapper;\n+import org.elasticsearch.xpack.runtimefields.mapper.LongScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.StringFieldScript;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n public final class RuntimeFields extends Plugin implements MapperPlugin, ScriptPlugin {\n \n     @Override\n-    public Map<String, Mapper.TypeParser> getMappers() {\n-        return Collections.singletonMap(RuntimeFieldMapper.CONTENT_TYPE, RuntimeFieldMapper.PARSER);\n+    public Map<String, RuntimeFieldType.Parser> getRuntimeFieldTypes() {\n+        return Map.of(\n+            BooleanFieldMapper.CONTENT_TYPE,", "originalCommit": "78445671b96d4ca81054e46dfa916310cf9d2328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MDQ1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521470452", "bodyText": "it seems overkill to do that so that the formatter does the right thing?", "author": "javanna", "createdAt": "2020-11-11T16:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MTM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MzU4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521473586", "bodyText": "It makes the code a ton easier to read which I like.", "author": "nik9000", "createdAt": "2020-11-11T16:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MTM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MDc0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521480748", "bodyText": "done", "author": "javanna", "createdAt": "2020-11-11T16:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MTM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MjEyOA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521372128", "bodyText": "Would it be more clear if we made the subclasses override doXContentBody?", "author": "nik9000", "createdAt": "2020-11-11T13:52:26Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -12,52 +12,58 @@\n import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;\n import org.apache.lucene.search.spans.SpanQuery;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.CheckedBiConsumer;\n import org.elasticsearch.common.TriFunction;\n import org.elasticsearch.common.geo.ShapeRelation;\n import org.elasticsearch.common.time.DateMathParser;\n import org.elasticsearch.common.unit.Fuzziness;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.mapper.ContentPath;\n import org.elasticsearch.index.mapper.DocValueFetcher;\n+import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n-import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.RuntimeFieldType;\n import org.elasticsearch.index.mapper.ValueFetcher;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.search.lookup.SearchLookup;\n \n+import java.io.IOException;\n import java.time.ZoneId;\n+import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n \n import static org.elasticsearch.search.SearchService.ALLOW_EXPENSIVE_QUERIES;\n \n /**\n  * Abstract base {@linkplain MappedFieldType} for scripted fields.\n  */\n-abstract class AbstractScriptFieldType<LeafFactory> extends MappedFieldType {\n+abstract class AbstractScriptFieldType<LeafFactory> extends RuntimeFieldType {\n     protected final Script script;\n     private final TriFunction<String, Map<String, Object>, SearchLookup, LeafFactory> factory;\n+    private final CheckedBiConsumer<XContentBuilder, Boolean, IOException> toXContent;\n+\n+    AbstractScriptFieldType(String name, TriFunction<String, Map<String, Object>, SearchLookup, LeafFactory> factory, Builder builder) {\n+        this(name, factory, builder.script.getValue(), builder.meta.getValue(), builder::toXContent);\n+    }\n \n     AbstractScriptFieldType(\n         String name,\n-        Script script,\n         TriFunction<String, Map<String, Object>, SearchLookup, LeafFactory> factory,\n-        Map<String, String> meta\n+        Script script,\n+        Map<String, String> meta,\n+        CheckedBiConsumer<XContentBuilder, Boolean, IOException> toXContent\n     ) {\n-        super(name, false, false, false, TextSearchInfo.SIMPLE_MATCH_WITHOUT_TERMS, meta);\n-        this.script = script;\n+        super(name, meta);\n         this.factory = factory;\n-    }\n-\n-    protected abstract String runtimeType();\n-\n-    @Override\n-    public final String typeName() {\n-        return RuntimeFieldMapper.CONTENT_TYPE;\n-    }\n-\n-    @Override\n-    public final String familyTypeName() {\n-        return runtimeType();\n+        this.script = script;\n+        this.toXContent = toXContent;", "originalCommit": "78445671b96d4ca81054e46dfa916310cf9d2328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MjE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521472168", "bodyText": "so, this is slightly hacky, it is done this way so that we get the Parameter serialization for free. We reuse the FieldMapper parsing code without having a FieldMapper. The constructors that take a function are there only for testing, because I don't want to have to create a FieldMapper.Builder in our tests.", "author": "javanna", "createdAt": "2020-11-11T16:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MjEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mjg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521372885", "bodyText": "I'd just do MappedFieldType or even RuntimeFieldType on the link, just to keep it a little shorter. I think it is ok to import classes just so javadoc can see them.", "author": "nik9000", "createdAt": "2020-11-11T13:53:41Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -174,46 +180,115 @@ public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRew\n     private String unsupported(String query, String supported) {\n         return String.format(\n             Locale.ROOT,\n-            \"Can only use %s queries on %s fields - not on [%s] which is of type [%s] with runtime_type [%s]\",\n+            \"Can only use %s queries on %s fields - not on [%s] which is a runtime field of type [%s]\",\n             query,\n             supported,\n             name(),\n-            RuntimeFieldMapper.CONTENT_TYPE,\n-            runtimeType()\n+            typeName()\n         );\n     }\n \n     protected final void checkAllowExpensiveQueries(QueryShardContext context) {\n         if (context.allowExpensiveQueries() == false) {\n             throw new ElasticsearchException(\n-                \"queries cannot be executed against [\"\n-                    + RuntimeFieldMapper.CONTENT_TYPE\n-                    + \"] fields while [\"\n-                    + ALLOW_EXPENSIVE_QUERIES.getKey()\n-                    + \"] is set to [false].\"\n+                \"queries cannot be executed against runtime fields while [\" + ALLOW_EXPENSIVE_QUERIES.getKey() + \"] is set to [false].\"\n             );\n         }\n     }\n \n-    /**\n-     * The format that this field should use. The default implementation is\n-     * {@code null} because most fields don't support formats.\n-     */\n-    protected String format() {\n-        return null;\n+    @Override\n+    public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(docValueFormat(format, null), lookup.doc().getForField(this));\n+    }\n+\n+    @Override\n+    protected final void doXContentBody(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+        toXContent.accept(builder, includeDefaults);\n     }\n \n     /**\n-     * The locale that this field's format should use. The default\n-     * implementation is {@code null} because most fields don't\n-     * support formats.\n+     *  For runtime fields the {@link RuntimeFieldType.Parser} returns directly the {@link org.elasticsearch.index.mapper.MappedFieldType}.", "originalCommit": "78445671b96d4ca81054e46dfa916310cf9d2328", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521373775", "bodyText": "Is this something we should keep doing forever or just a way to get this in without making 123213214 changes? Like, should we stop doing this in a follow up change?", "author": "nik9000", "createdAt": "2020-11-11T13:55:09Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -174,46 +180,115 @@ public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRew\n     private String unsupported(String query, String supported) {\n         return String.format(\n             Locale.ROOT,\n-            \"Can only use %s queries on %s fields - not on [%s] which is of type [%s] with runtime_type [%s]\",\n+            \"Can only use %s queries on %s fields - not on [%s] which is a runtime field of type [%s]\",\n             query,\n             supported,\n             name(),\n-            RuntimeFieldMapper.CONTENT_TYPE,\n-            runtimeType()\n+            typeName()\n         );\n     }\n \n     protected final void checkAllowExpensiveQueries(QueryShardContext context) {\n         if (context.allowExpensiveQueries() == false) {\n             throw new ElasticsearchException(\n-                \"queries cannot be executed against [\"\n-                    + RuntimeFieldMapper.CONTENT_TYPE\n-                    + \"] fields while [\"\n-                    + ALLOW_EXPENSIVE_QUERIES.getKey()\n-                    + \"] is set to [false].\"\n+                \"queries cannot be executed against runtime fields while [\" + ALLOW_EXPENSIVE_QUERIES.getKey() + \"] is set to [false].\"\n             );\n         }\n     }\n \n-    /**\n-     * The format that this field should use. The default implementation is\n-     * {@code null} because most fields don't support formats.\n-     */\n-    protected String format() {\n-        return null;\n+    @Override\n+    public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(docValueFormat(format, null), lookup.doc().getForField(this));\n+    }\n+\n+    @Override\n+    protected final void doXContentBody(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+        toXContent.accept(builder, includeDefaults);\n     }\n \n     /**\n-     * The locale that this field's format should use. The default\n-     * implementation is {@code null} because most fields don't\n-     * support formats.\n+     *  For runtime fields the {@link RuntimeFieldType.Parser} returns directly the {@link org.elasticsearch.index.mapper.MappedFieldType}.\n+     *  Internally we still create a {@link Builder} so we reuse the {@link FieldMapper.Parameter} infrastructure,\n+     *  but {@link Builder#init(FieldMapper)} and {@link Builder#build(ContentPath)} are never called as\n+     *  {@link RuntimeFieldTypeParser#parse(String, Map, Mapper.TypeParser.ParserContext)} calls\n+     *  {@link Builder#parse(String, Mapper.TypeParser.ParserContext, Map)} and returns the corresponding\n+     *  {@link org.elasticsearch.index.mapper.MappedFieldType}.\n      */", "originalCommit": "78445671b96d4ca81054e46dfa916310cf9d2328", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MzIwNA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521473204", "bodyText": "ehm, doing what?", "author": "javanna", "createdAt": "2020-11-11T16:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NDE5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521474196", "bodyText": "Using the Builder at all. It feels like it makes sense because we have them now, but maybe its overkill?", "author": "nik9000", "createdAt": "2020-11-11T16:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3ODU2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521478561", "bodyText": "I like using Parameters to define what gets parsed and to reuse that part of the existing mappings infra. I think that not using them would mean going back to manual parsing and printing.", "author": "javanna", "createdAt": "2020-11-11T16:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3OTU2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521479569", "bodyText": "Me too! I just wonder if we can avoid building the FieldMapper then. Like, in a follow up? Or not. I dunno. It just fields weird to build a dummy field mapper to make parsing easier. No big deal.", "author": "nik9000", "createdAt": "2020-11-11T16:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MTU5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521481593", "bodyText": "we do not build the field mapper at all!", "author": "javanna", "createdAt": "2020-11-11T16:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MjgzMg==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521482832", "bodyText": "pressed enter too quickly: we skip calling build on the builder. we make the builder create the right field type and return that, without creating the field mapper.", "author": "javanna", "createdAt": "2020-11-11T16:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5MTk5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521491998", "bodyText": "OH! I see you even said it. I should read more closely!", "author": "nik9000", "createdAt": "2020-11-11T16:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk2Nzk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521967997", "bodyText": "one follow-up we could think of to clean things up is to extract the parsing bits from FieldMapper.Builder as well as the Parameter class so that parsing can be done outside of a Builder.", "author": "javanna", "createdAt": "2020-11-12T09:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}], "type": "inlineReview"}, {"oid": "58c07f75a80d1b24b89dbc75ad5c4012be1e509c", "url": "https://github.com/elastic/elasticsearch/commit/58c07f75a80d1b24b89dbc75ad5c4012be1e509c", "message": "iter", "committedDate": "2020-11-11T14:55:05Z", "type": "commit"}, {"oid": "131f83c2d8902c206b114188c3115e75905fb19c", "url": "https://github.com/elastic/elasticsearch/commit/131f83c2d8902c206b114188c3115e75905fb19c", "message": "iter", "committedDate": "2020-11-11T16:21:13Z", "type": "commit"}, {"oid": "99988214ce08190f435894fe2d3fac6716086af9", "url": "https://github.com/elastic/elasticsearch/commit/99988214ce08190f435894fe2d3fac6716086af9", "message": "Merge branch 'master' into enhancement/mapping_runtime_section", "committedDate": "2020-11-11T16:21:42Z", "type": "commit"}, {"oid": "380a1333d431a1ce042da8762833943b54be1fb9", "url": "https://github.com/elastic/elasticsearch/commit/380a1333d431a1ce042da8762833943b54be1fb9", "message": "spotless", "committedDate": "2020-11-11T16:22:36Z", "type": "commit"}, {"oid": "6c4edd4d3b4d32b9f98db80ca57f8f8a9be1ec6e", "url": "https://github.com/elastic/elasticsearch/commit/6c4edd4d3b4d32b9f98db80ca57f8f8a9be1ec6e", "message": "formatting", "committedDate": "2020-11-11T16:29:48Z", "type": "commit"}, {"oid": "b53bf037eb98fe12ad629974ef00a54b5e37410e", "url": "https://github.com/elastic/elasticsearch/commit/b53bf037eb98fe12ad629974ef00a54b5e37410e", "message": "fix test", "committedDate": "2020-11-11T17:46:52Z", "type": "commit"}, {"oid": "1701c2e5b798286649454556afb74d94eb976a67", "url": "https://github.com/elastic/elasticsearch/commit/1701c2e5b798286649454556afb74d94eb976a67", "message": "Merge branch 'master' into enhancement/mapping_runtime_section", "committedDate": "2020-11-11T19:16:24Z", "type": "commit"}, {"oid": "3e64d012b35a4df374f6bbf8fa2da79b95ea7587", "url": "https://github.com/elastic/elasticsearch/commit/3e64d012b35a4df374f6bbf8fa2da79b95ea7587", "message": "Merge branch 'master' into enhancement/mapping_runtime_section", "committedDate": "2020-11-12T09:12:50Z", "type": "commit"}, {"oid": "21a2f47e0458cb3fd93df7f8d529871e8336057c", "url": "https://github.com/elastic/elasticsearch/commit/21a2f47e0458cb3fd93df7f8d529871e8336057c", "message": "fix test", "committedDate": "2020-11-12T09:36:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5NzAyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521997021", "bodyText": "This is an interesting one.  I'm not really sure what sourcePaths should return for runtime fields - I feel like maybe it should be an empty set?  The ValueFetcher isn't using sourcePaths to load data for these fields, so maybe it doesn't matter.", "author": "romseygeek", "createdAt": "2020-11-12T10:24:24Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/FieldTypeLookupTests.java", "diffHunk": "@@ -101,28 +104,94 @@ public void testSourcePathsWithCopyTo() {\n             .copyTo(\"field\")\n             .build(new ContentPath());\n \n-        FieldTypeLookup lookup = new FieldTypeLookup(Arrays.asList(field, otherField), emptyList());\n+        FieldTypeLookup lookup = new FieldTypeLookup(Arrays.asList(field, otherField), emptyList(), emptyList());\n \n         assertEquals(Set.of(\"other_field\", \"field\"), lookup.sourcePaths(\"field\"));\n         assertEquals(Set.of(\"other_field\", \"field\"), lookup.sourcePaths(\"field.subfield1\"));\n     }\n \n     public void testIteratorImmutable() {\n         MockFieldMapper f1 = new MockFieldMapper(\"foo\");\n-        FieldTypeLookup lookup = new FieldTypeLookup(Collections.singletonList(f1), emptyList());\n-\n-        try {\n-            Iterator<MappedFieldType> itr = lookup.iterator();\n-            assertTrue(itr.hasNext());\n-            assertEquals(f1.fieldType(), itr.next());\n-            itr.remove();\n-            fail(\"remove should have failed\");\n-        } catch (UnsupportedOperationException e) {\n-            // expected\n+        FieldTypeLookup lookup = new FieldTypeLookup(Collections.singletonList(f1), emptyList(), emptyList());\n+\n+        Iterator<MappedFieldType> itr = lookup.iterator();\n+        assertTrue(itr.hasNext());\n+        assertEquals(f1.fieldType(), itr.next());\n+        expectThrows(UnsupportedOperationException.class, itr::remove);\n+    }\n+\n+    public void testRuntimeFieldsLookup() {\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField runtime = new TestRuntimeField(\"runtime\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(concrete), emptyList(), List.of(runtime));\n+        assertThat(fieldTypeLookup.get(\"concrete\"), instanceOf(MockFieldMapper.FakeFieldType.class));\n+        assertThat(fieldTypeLookup.get(\"runtime\"), instanceOf(TestRuntimeField.class));\n+        assertEquals(2, size(fieldTypeLookup.iterator()));\n+    }\n+\n+    public void testRuntimeFieldOverrides() {\n+        MockFieldMapper field = new MockFieldMapper(\"field\");\n+        MockFieldMapper subfield = new MockFieldMapper(\"object.subfield\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField fieldOverride = new TestRuntimeField(\"field\");\n+        TestRuntimeField subfieldOverride = new TestRuntimeField(\"object.subfield\");\n+        TestRuntimeField runtime = new TestRuntimeField(\"runtime\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field, concrete, subfield), emptyList(),\n+            List.of(fieldOverride, runtime, subfieldOverride));\n+        assertThat(fieldTypeLookup.get(\"field\"), instanceOf(TestRuntimeField.class));\n+        assertThat(fieldTypeLookup.get(\"object.subfield\"), instanceOf(TestRuntimeField.class));\n+        assertThat(fieldTypeLookup.get(\"concrete\"), instanceOf(MockFieldMapper.FakeFieldType.class));\n+        assertThat(fieldTypeLookup.get(\"runtime\"), instanceOf(TestRuntimeField.class));\n+        assertEquals(4, size(fieldTypeLookup.iterator()));\n+    }\n+\n+    public void testRuntimeFieldsSimpleMatchToFullName() {\n+        MockFieldMapper field1 = new MockFieldMapper(\"field1\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField field2 = new TestRuntimeField(\"field2\");\n+        TestRuntimeField subfield = new TestRuntimeField(\"object.subfield\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field1, concrete), emptyList(), List.of(field2, subfield));\n+        {\n+            Set<String> matches = fieldTypeLookup.simpleMatchToFullName(\"fie*\");\n+            assertEquals(2, matches.size());\n+            assertTrue(matches.contains(\"field1\"));\n+            assertTrue(matches.contains(\"field2\"));\n+        }\n+        {\n+            Set<String> matches = fieldTypeLookup.simpleMatchToFullName(\"object.sub*\");\n+            assertEquals(1, matches.size());\n+            assertTrue(matches.contains(\"object.subfield\"));\n+        }\n+    }\n+\n+    public void testRuntimeFieldsSourcePaths() {\n+        MockFieldMapper field1 = new MockFieldMapper(\"field1\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField field2 = new TestRuntimeField(\"field2\");\n+        TestRuntimeField subfield = new TestRuntimeField(\"object.subfield\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field1, concrete), emptyList(), List.of(field2, subfield));\n+        {\n+            Set<String> sourcePaths = fieldTypeLookup.sourcePaths(\"field1\");\n+            assertEquals(1, sourcePaths.size());\n+            assertTrue(sourcePaths.contains(\"field1\"));\n+        }\n+        {\n+            Set<String> sourcePaths = fieldTypeLookup.sourcePaths(\"field2\");\n+            assertEquals(1, sourcePaths.size());\n+            assertTrue(sourcePaths.contains(\"field2\"));", "originalCommit": "21a2f47e0458cb3fd93df7f8d529871e8336057c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5NTEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522095126", "bodyText": "I see what you mean, though the logic in the method is very simple and I am reluctant to special case runtime fields, under the assumption that they are never in source. Also runtime fields can be plugged in and maybe we should not make assumptions about how they will fetch their values?", "author": "javanna", "createdAt": "2020-11-12T13:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5NzAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMDgwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522110801", "bodyText": "I figure there is a chance runtime fields will use the source path, yeah. But at least for now they don't so it doesn't really matter. I guess emptySet is more correct, but, yeah, it doesn't really matter.", "author": "nik9000", "createdAt": "2020-11-12T13:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5NzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxNjc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522016798", "bodyText": "Can we add a test to see what happens when you merge in a concrete field as well?", "author": "romseygeek", "createdAt": "2020-11-12T10:56:09Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -465,13 +447,127 @@ public void testIllegalDynamicTemplate7DotXIndex() throws Exception {\n         }\n         mapping.endObject();\n         Version createdVersion = randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_7_0);\n-        Settings indexSettings = Settings.builder()\n-            .put(IndexMetadata.SETTING_INDEX_VERSION_CREATED.getKey(), createdVersion)\n-            .build();\n-        MapperService mapperService = createIndex(\"test\", indexSettings).mapperService();\n-        DocumentMapper mapper = mapperService.merge(\"type\", new CompressedXContent(Strings.toString(mapping)), MergeReason.MAPPING_UPDATE);\n-        assertThat(mapper.mappingSource().toString(), containsString(\"\\\"type\\\":\\\"string\\\"\"));\n+        MapperService mapperService = createMapperService(createdVersion, mapping);\n+        assertThat(mapperService.documentMapper().mappingSource().toString(), containsString(\"\\\"type\\\":\\\"string\\\"\"));\n         assertWarnings(\"dynamic template [my_template] has invalid content [{\\\"match_mapping_type\\\":\\\"string\\\",\\\"mapping\\\":{\\\"type\\\":\" +\n             \"\\\"string\\\"}}], caused by [No mapper found for type [string]]\");\n     }\n+\n+    @Override\n+    protected Collection<? extends Plugin> getPlugins() {\n+        return Collections.singletonList(new RuntimeFieldPlugin());\n+    }\n+\n+    public void testRuntimeSection() throws IOException {\n+        String mapping = Strings.toString(runtimeMapping(builder -> {\n+            builder.startObject(\"field1\").field(\"type\", \"test\").field(\"prop1\", \"value1\").endObject();\n+            builder.startObject(\"field2\").field(\"type\", \"test\").field(\"prop2\", \"value2\").endObject();\n+            builder.startObject(\"field3\").field(\"type\", \"test\").endObject();\n+        }));\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n+    }\n+\n+    public void testRuntimeSectionMerge() throws IOException {\n+        MapperService mapperService;\n+        {\n+            String mapping = Strings.toString(runtimeMapping(builder -> {\n+                builder.startObject(\"field1\").field(\"type\", \"test\").field(\"prop1\", \"first version\").endObject();\n+                builder.startObject(\"field2\").field(\"type\", \"test\").endObject();\n+            }));\n+            mapperService = createMapperService(mapping);\n+            assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n+        }\n+        {\n+            String mapping = Strings.toString(runtimeMapping(\n+                builder -> builder.startObject(\"field1\").field(\"type\", \"test\").field(\"prop2\", \"second version\").endObject()));\n+            merge(mapperService, mapping);\n+            RuntimeField field1 = (RuntimeField)mapperService.fieldType(\"field1\");\n+            assertNull(field1.prop1);\n+            assertEquals(\"second version\", field1.prop2);\n+            RuntimeField field2 = (RuntimeField)mapperService.fieldType(\"field2\");\n+            assertNull(field2.prop1);\n+            assertNull(field2.prop2);\n+        }", "originalCommit": "21a2f47e0458cb3fd93df7f8d529871e8336057c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5NTQxMw==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522095413", "bodyText": "done", "author": "javanna", "createdAt": "2020-11-12T13:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxNjc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxNzY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522017694", "bodyText": "Much nicer to only have this on the DateFieldType, thanks!", "author": "romseygeek", "createdAt": "2020-11-12T10:57:34Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -174,46 +180,115 @@ public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRew\n     private String unsupported(String query, String supported) {\n         return String.format(\n             Locale.ROOT,\n-            \"Can only use %s queries on %s fields - not on [%s] which is of type [%s] with runtime_type [%s]\",\n+            \"Can only use %s queries on %s fields - not on [%s] which is a runtime field of type [%s]\",\n             query,\n             supported,\n             name(),\n-            RuntimeFieldMapper.CONTENT_TYPE,\n-            runtimeType()\n+            typeName()\n         );\n     }\n \n     protected final void checkAllowExpensiveQueries(QueryShardContext context) {\n         if (context.allowExpensiveQueries() == false) {\n             throw new ElasticsearchException(\n-                \"queries cannot be executed against [\"\n-                    + RuntimeFieldMapper.CONTENT_TYPE\n-                    + \"] fields while [\"\n-                    + ALLOW_EXPENSIVE_QUERIES.getKey()\n-                    + \"] is set to [false].\"\n+                \"queries cannot be executed against runtime fields while [\" + ALLOW_EXPENSIVE_QUERIES.getKey() + \"] is set to [false].\"\n             );\n         }\n     }\n \n-    /**\n-     * The format that this field should use. The default implementation is\n-     * {@code null} because most fields don't support formats.\n-     */\n-    protected String format() {\n-        return null;", "originalCommit": "21a2f47e0458cb3fd93df7f8d529871e8336057c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9b38b205c112fbdf272109102e5eafd6b2fd2cb5", "url": "https://github.com/elastic/elasticsearch/commit/9b38b205c112fbdf272109102e5eafd6b2fd2cb5", "message": "expand tests", "committedDate": "2020-11-12T11:36:04Z", "type": "commit"}, {"oid": "7fc73eb2f0195cf58680e0da3e4852ba55f8be01", "url": "https://github.com/elastic/elasticsearch/commit/7fc73eb2f0195cf58680e0da3e4852ba55f8be01", "message": "Merge branch 'master' into enhancement/mapping_runtime_section", "committedDate": "2020-11-12T13:00:24Z", "type": "commit"}, {"oid": "4b8361e7a30eca598c4c3caf3f7fa80613461ae1", "url": "https://github.com/elastic/elasticsearch/commit/4b8361e7a30eca598c4c3caf3f7fa80613461ae1", "message": "add comment", "committedDate": "2020-11-12T13:05:59Z", "type": "commit"}, {"oid": "e081564ba0174044f052a53b8285bff67e4df37f", "url": "https://github.com/elastic/elasticsearch/commit/e081564ba0174044f052a53b8285bff67e4df37f", "message": "fix test", "committedDate": "2020-11-12T13:11:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5ODExOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522098119", "bodyText": "@nik9000 this is for you I think :)", "author": "javanna", "createdAt": "2020-11-12T13:17:57Z", "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -116,20 +111,22 @@ protected boolean modifySearch(ApiCallSection search) {\n                         return mergeMappings(new String[] { \"*\" });\n                     }\n                     String[] patterns = Arrays.stream(index.split(\",\")).map(m -> m.equals(\"_all\") ? \"*\" : m).toArray(String[]::new);\n+                    // TODO this is always false?", "originalCommit": "e081564ba0174044f052a53b8285bff67e4df37f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMzI0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522113244", "bodyText": "ooops. I think I mean length == 1. I can take a look in a follow up.", "author": "nik9000", "createdAt": "2020-11-12T13:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5ODExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522111147", "bodyText": "This one got harder to read!", "author": "nik9000", "createdAt": "2020-11-12T13:38:55Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -150,51 +153,50 @@ public void testDynamicTemplates() throws Exception {\n                         .endArray()\n                     .endObject()\n                 .endObject());\n-        MapperService mapperService = createIndex(\"test\").mapperService();\n-        DocumentMapper mapper = mapperService.merge(\"type\", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE);\n-        assertEquals(mapping, mapper.mappingSource().toString());\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n \n         // no update if templates are not set explicitly\n         String mapping2 = Strings.toString(XContentFactory.jsonBuilder()\n                 .startObject()\n-                .startObject(\"type\")\n+                .startObject(MapperService.SINGLE_MAPPING_NAME)\n                 .endObject()\n             .endObject());\n-        mapper = mapperService.merge(\"type\", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE);\n-        assertEquals(mapping, mapper.mappingSource().toString());\n+        merge(mapperService, mapping2);\n+        assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n \n         String mapping3 = Strings.toString(XContentFactory.jsonBuilder()\n                 .startObject()\n-                .startObject(\"type\")\n-                    .field(\"dynamic_templates\", Arrays.asList())\n+                .startObject(MapperService.SINGLE_MAPPING_NAME)\n+                    .field(\"dynamic_templates\", Collections.emptyList())\n                 .endObject()\n             .endObject());\n-        mapper = mapperService.merge(\"type\", new CompressedXContent(mapping3), MergeReason.MAPPING_UPDATE);\n-        assertEquals(mapping3, mapper.mappingSource().toString());\n+        merge(mapperService, mapping3);\n+        assertEquals(mapping3, mapperService.documentMapper().mappingSource().toString());\n     }\n \n     public void testDynamicTemplatesForIndexTemplate() throws IOException {\n         String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()\n             .startArray(\"dynamic_templates\")\n-                .startObject()\n-                    .startObject(\"first_template\")\n-                        .field(\"path_match\", \"first\")\n-                        .startObject(\"mapping\")\n-                            .field(\"type\", \"keyword\")\n-                        .endObject()\n-                    .endObject()\n-                .endObject()\n-                .startObject()\n-                    .startObject(\"second_template\")\n-                        .field(\"path_match\", \"second\")\n-                        .startObject(\"mapping\")\n-                            .field(\"type\", \"keyword\")\n-                        .endObject()\n-                    .endObject()\n-                .endObject()\n+            .startObject()", "originalCommit": "e081564ba0174044f052a53b8285bff67e4df37f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExODEyOA==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522118128", "bodyText": "will fix", "author": "javanna", "createdAt": "2020-11-12T13:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMzUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522113525", "bodyText": "\u2764\ufe0f", "author": "nik9000", "createdAt": "2020-11-12T13:42:30Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/RuntimeFields.java", "diffHunk": "@@ -6,29 +6,48 @@\n \n package org.elasticsearch.xpack.runtimefields;\n \n-import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.BooleanFieldMapper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.RuntimeFieldType;\n import org.elasticsearch.plugins.MapperPlugin;\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.plugins.ScriptPlugin;\n import org.elasticsearch.script.ScriptContext;\n import org.elasticsearch.xpack.runtimefields.mapper.BooleanFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.BooleanScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DateFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DateScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DoubleFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DoubleScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.GeoPointFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.GeoPointScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.IpFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.IpScriptFieldType;\n+import org.elasticsearch.xpack.runtimefields.mapper.KeywordScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.LongFieldScript;\n-import org.elasticsearch.xpack.runtimefields.mapper.RuntimeFieldMapper;\n+import org.elasticsearch.xpack.runtimefields.mapper.LongScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.StringFieldScript;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n public final class RuntimeFields extends Plugin implements MapperPlugin, ScriptPlugin {\n \n     @Override\n-    public Map<String, Mapper.TypeParser> getMappers() {\n-        return Collections.singletonMap(RuntimeFieldMapper.CONTENT_TYPE, RuntimeFieldMapper.PARSER);\n+    public Map<String, RuntimeFieldType.Parser> getRuntimeFieldTypes() {\n+        return Map.ofEntries(", "originalCommit": "e081564ba0174044f052a53b8285bff67e4df37f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "567ff82050163400c28a441e5d0aaf383aa94f2a", "url": "https://github.com/elastic/elasticsearch/commit/567ff82050163400c28a441e5d0aaf383aa94f2a", "message": "restore formatting", "committedDate": "2020-11-12T13:57:34Z", "type": "commit"}]}