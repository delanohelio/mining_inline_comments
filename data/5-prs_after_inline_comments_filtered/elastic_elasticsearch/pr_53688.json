{"pr_number": 53688, "pr_title": "EQL: Add Substring function with Python semantics", "pr_createdAt": "2020-03-17T18:35:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53688", "timeline": [{"oid": "d23ce79af733b43118d80f18031e3947af89b276", "url": "https://github.com/elastic/elasticsearch/commit/d23ce79af733b43118d80f18031e3947af89b276", "message": "EQL: Add Substring function with Python semantics\n\nInitial function added to act as a template.\nDoes not reuse substring from SQL due to the difference in semantics and\nthe accepted arguments.\nCurrently it is missing any integration test as, the usage of scripting,\nrequires an actual integration test against a proper cluster (and likely\nits own QA project).", "committedDate": "2020-03-17T18:32:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg5NzM4OA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r393897388", "bodyText": "I think these should be ifs if we're preserving EQL's current semantics", "author": "rw-access", "createdAt": "2020-03-17T18:47:52Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtils.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.common.Strings.hasLength;\n+\n+final class StringUtils {\n+\n+    private StringUtils() {}\n+\n+    /**\n+     * Returns a substring using the Python slice semantics, meaning\n+     * start and end can be negative\n+     */\n+    static String substringSlice(String string, int start, int end) {\n+        if (hasLength(string) == false) {\n+            return string;\n+        }\n+\n+        int length = string.length();\n+        \n+        // handle first negative values\n+        while (start < 0) {", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg5Nzk0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r393897946", "bodyText": "This will always be an empty string, so could return early\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        start = validEndIndex;\n          \n          \n            \n                        return org.elasticsearch.xpack.ql.util.StringUtils.EMPTY;", "author": "rw-access", "createdAt": "2020-03-17T18:48:49Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtils.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.common.Strings.hasLength;\n+\n+final class StringUtils {\n+\n+    private StringUtils() {}\n+\n+    /**\n+     * Returns a substring using the Python slice semantics, meaning\n+     * start and end can be negative\n+     */\n+    static String substringSlice(String string, int start, int end) {\n+        if (hasLength(string) == false) {\n+            return string;\n+        }\n+\n+        int length = string.length();\n+        \n+        // handle first negative values\n+        while (start < 0) {\n+            start += length;\n+        }\n+        while (end < 0) {\n+            end += length;\n+        }\n+        int validEndIndex = length;\n+\n+        if (start > validEndIndex) {\n+            start = validEndIndex;", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg5ODU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r393898590", "bodyText": "since the while would be gone, you could have negative indices, so would need to check again\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (start >= end) {\n          \n          \n            \n                    if (start < 0 || start >= end) {", "author": "rw-access", "createdAt": "2020-03-17T18:50:03Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtils.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.common.Strings.hasLength;\n+\n+final class StringUtils {\n+\n+    private StringUtils() {}\n+\n+    /**\n+     * Returns a substring using the Python slice semantics, meaning\n+     * start and end can be negative\n+     */\n+    static String substringSlice(String string, int start, int end) {\n+        if (hasLength(string) == false) {\n+            return string;\n+        }\n+\n+        int length = string.length();\n+        \n+        // handle first negative values\n+        while (start < 0) {\n+            start += length;\n+        }\n+        while (end < 0) {\n+            end += length;\n+        }\n+        int validEndIndex = length;\n+\n+        if (start > validEndIndex) {\n+            start = validEndIndex;\n+        }\n+        if (end > validEndIndex) {\n+            end = validEndIndex;\n+        }\n+\n+        if (start >= end) {", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI2NDQ5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394264491", "bodyText": "I don't think you need validEndIndex, do you?", "author": "astefan", "createdAt": "2020-03-18T11:03:19Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtils.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.common.Strings.hasLength;\n+\n+final class StringUtils {\n+\n+    private StringUtils() {}\n+\n+    /**\n+     * Returns a substring using the Python slice semantics, meaning\n+     * start and end can be negative\n+     */\n+    static String substringSlice(String string, int start, int end) {\n+        if (hasLength(string) == false) {\n+            return string;\n+        }\n+\n+        int length = string.length();\n+        \n+        // handle first negative values\n+        while (start < 0) {\n+            start += length;\n+        }\n+        while (end < 0) {\n+            end += length;\n+        }\n+        int validEndIndex = length;", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI5OTAyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394299026", "bodyText": "Could this while be replaced with this simple math?\nif (end < 0) {\n   end = end - end/length * length + (end % length != 0 ? length : 0);\n}", "author": "astefan", "createdAt": "2020-03-18T12:09:47Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtils.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.common.Strings.hasLength;\n+\n+final class StringUtils {\n+\n+    private StringUtils() {}\n+\n+    /**\n+     * Returns a substring using the Python slice semantics, meaning\n+     * start and end can be negative\n+     */\n+    static String substringSlice(String string, int start, int end) {\n+        if (hasLength(string) == false) {\n+            return string;\n+        }\n+\n+        int length = string.length();\n+        \n+        // handle first negative values\n+        while (start < 0) {\n+            start += length;\n+        }\n+        while (end < 0) {", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM3MjA1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394372057", "bodyText": "No so simple :)", "author": "costin", "createdAt": "2020-03-18T14:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI5OTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQwMzE5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394403199", "bodyText": ":-) instead of subtracting length each time and then check if the value is still negative, the formula above subtracts the entire amount once by dividing the end value by length (to see how many lengths \"fit\" in \"end\") and taking the whole part only (not also the decimals), multiplying by length and adding a possible remainder (defined as end % length).", "author": "astefan", "createdAt": "2020-03-18T14:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI5OTAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwOTQ3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394309472", "bodyText": "If there is no end, shouldn't end be treated as the end of the string itself, meaning source's length?", "author": "astefan", "createdAt": "2020-03-18T12:29:10Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Substring.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.function.OptionalArgument;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.lang.String.format;\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.SubstringFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific substring function - similar to the one in Python.\n+ * Note this is different than the one in SQL.\n+ */\n+public class Substring extends ScalarFunction implements OptionalArgument {\n+\n+    private final Expression source, start, end;\n+\n+    public Substring(Source source, Expression src, Expression start, Expression end) {\n+        super(source, end != null ? Arrays.asList(src, start, end) : Arrays.asList(src, new Literal(source, 0, DataTypes.INTEGER), start));", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMDE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394310152", "bodyText": "I think here you mean to use start == null, no?", "author": "astefan", "createdAt": "2020-03-18T12:30:23Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Substring.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.function.OptionalArgument;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.lang.String.format;\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.SubstringFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific substring function - similar to the one in Python.\n+ * Note this is different than the one in SQL.\n+ */\n+public class Substring extends ScalarFunction implements OptionalArgument {\n+\n+    private final Expression source, start, end;\n+\n+    public Substring(Source source, Expression src, Expression start, Expression end) {\n+        super(source, end != null ? Arrays.asList(src, start, end) : Arrays.asList(src, new Literal(source, 0, DataTypes.INTEGER), start));\n+        this.source = src;\n+        this.start = end == null ? new Literal(source, 0, DataTypes.INTEGER) : start;", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMDQ5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394310494", "bodyText": "If end == null shouldn't end be the length of the string itself?", "author": "astefan", "createdAt": "2020-03-18T12:30:57Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Substring.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.function.OptionalArgument;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.lang.String.format;\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.SubstringFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific substring function - similar to the one in Python.\n+ * Note this is different than the one in SQL.\n+ */\n+public class Substring extends ScalarFunction implements OptionalArgument {\n+\n+    private final Expression source, start, end;\n+\n+    public Substring(Source source, Expression src, Expression start, Expression end) {\n+        super(source, end != null ? Arrays.asList(src, start, end) : Arrays.asList(src, new Literal(source, 0, DataTypes.INTEGER), start));\n+        this.source = src;\n+        this.start = end == null ? new Literal(source, 0, DataTypes.INTEGER) : start;\n+        this.end = end == null ? start : end;", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMjQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394312459", "bodyText": "Why using length and not end? It's more consistent if the same names are kept throughout the class.", "author": "astefan", "createdAt": "2020-03-18T12:34:39Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Substring.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.function.OptionalArgument;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.lang.String.format;\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.SubstringFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific substring function - similar to the one in Python.\n+ * Note this is different than the one in SQL.\n+ */\n+public class Substring extends ScalarFunction implements OptionalArgument {\n+\n+    private final Expression source, start, end;\n+\n+    public Substring(Source source, Expression src, Expression start, Expression end) {\n+        super(source, end != null ? Arrays.asList(src, start, end) : Arrays.asList(src, new Literal(source, 0, DataTypes.INTEGER), start));\n+        this.source = src;\n+        this.start = end == null ? new Literal(source, 0, DataTypes.INTEGER) : start;\n+        this.end = end == null ? start : end;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution sourceResolution = isStringAndExact(source, sourceText(), ParamOrdinal.FIRST);\n+        if (sourceResolution.unresolved()) {\n+            return sourceResolution;\n+        }\n+\n+        TypeResolution startResolution = isInteger(start, sourceText(), ParamOrdinal.SECOND);\n+        if (startResolution.unresolved()) {\n+            return startResolution;\n+        }\n+\n+        return isInteger(end, sourceText(), ParamOrdinal.THIRD);\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        return new SubstringFunctionPipe(source(), this, Expressions.pipe(source), Expressions.pipe(start), Expressions.pipe(end));\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return source.foldable() && start.foldable() && end.foldable();\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return doProcess(source.fold(), start.fold(), end.fold());\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Substring::new, source, start, end);\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        ScriptTemplate sourceScript = asScript(source);\n+        ScriptTemplate startScript = asScript(start);\n+        ScriptTemplate lengthScript = asScript(end);", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMjU5OA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394312598", "bodyText": "Why length and not end?", "author": "astefan", "createdAt": "2020-03-18T12:34:55Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Substring.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.function.OptionalArgument;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.lang.String.format;\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.SubstringFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific substring function - similar to the one in Python.\n+ * Note this is different than the one in SQL.\n+ */\n+public class Substring extends ScalarFunction implements OptionalArgument {\n+\n+    private final Expression source, start, end;\n+\n+    public Substring(Source source, Expression src, Expression start, Expression end) {\n+        super(source, end != null ? Arrays.asList(src, start, end) : Arrays.asList(src, new Literal(source, 0, DataTypes.INTEGER), start));\n+        this.source = src;\n+        this.start = end == null ? new Literal(source, 0, DataTypes.INTEGER) : start;\n+        this.end = end == null ? start : end;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution sourceResolution = isStringAndExact(source, sourceText(), ParamOrdinal.FIRST);\n+        if (sourceResolution.unresolved()) {\n+            return sourceResolution;\n+        }\n+\n+        TypeResolution startResolution = isInteger(start, sourceText(), ParamOrdinal.SECOND);\n+        if (startResolution.unresolved()) {\n+            return startResolution;\n+        }\n+\n+        return isInteger(end, sourceText(), ParamOrdinal.THIRD);\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        return new SubstringFunctionPipe(source(), this, Expressions.pipe(source), Expressions.pipe(start), Expressions.pipe(end));\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return source.foldable() && start.foldable() && end.foldable();\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return doProcess(source.fold(), start.fold(), end.fold());\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Substring::new, source, start, end);\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        ScriptTemplate sourceScript = asScript(source);\n+        ScriptTemplate startScript = asScript(start);\n+        ScriptTemplate lengthScript = asScript(end);\n+\n+        return asScriptFrom(sourceScript, startScript, lengthScript);\n+    }\n+\n+    protected ScriptTemplate asScriptFrom(ScriptTemplate sourceScript, ScriptTemplate startScript, ScriptTemplate lengthScript) {\n+        return new ScriptTemplate(format(Locale.ROOT, formatTemplate(\"{eql}.%s(%s,%s,%s)\"),\n+                \"substring\",\n+                sourceScript.template(),\n+                startScript.template(),\n+                lengthScript.template()),", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMzcwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394313709", "bodyText": "newEnd?", "author": "astefan", "createdAt": "2020-03-18T12:36:50Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/SubstringFunctionPipe.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.execution.search.QlSourceBuilder;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class SubstringFunctionPipe extends Pipe {\n+\n+    private final Pipe source, start, end;\n+\n+    public SubstringFunctionPipe(Source source, Expression expression, Pipe src, Pipe start, Pipe end) {\n+        super(source, expression, Arrays.asList(src, start, end));\n+        this.source = src;\n+        this.start = start;\n+        this.end = end;\n+    }\n+\n+    @Override\n+    public final Pipe replaceChildren(List<Pipe> newChildren) {\n+        if (newChildren.size() != 3) {\n+            throw new IllegalArgumentException(\"expected [3] children but received [\" + newChildren.size() + \"]\");\n+        }\n+        return replaceChildren(newChildren.get(0), newChildren.get(1), newChildren.get(2));\n+    }\n+\n+    @Override\n+    public final Pipe resolveAttributes(AttributeResolver resolver) {\n+        Pipe newSource = source.resolveAttributes(resolver);\n+        Pipe newStart = start.resolveAttributes(resolver);\n+        Pipe newLength = end.resolveAttributes(resolver);", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxNTE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394315175", "bodyText": "== false instead of !?", "author": "astefan", "createdAt": "2020-03-18T12:39:25Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/SubstringFunctionProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class SubstringFunctionProcessor implements Processor {\n+\n+    public static final String NAME = \"ssub\";\n+\n+    private final Processor source, start, end;\n+\n+    public SubstringFunctionProcessor(Processor source, Processor start, Processor end) {\n+        this.source = source;\n+        this.start = start;\n+        this.end = end;\n+    }\n+\n+    public SubstringFunctionProcessor(StreamInput in) throws IOException {\n+        source = in.readNamedWriteable(Processor.class);\n+        start = in.readNamedWriteable(Processor.class);\n+        end = in.readNamedWriteable(Processor.class);\n+    }\n+\n+    @Override\n+    public final void writeTo(StreamOutput out) throws IOException {\n+        out.writeNamedWriteable(source);\n+        out.writeNamedWriteable(start);\n+        out.writeNamedWriteable(end);\n+    }\n+\n+    @Override\n+    public Object process(Object input) {\n+        return doProcess(source.process(input), start.process(input), end.process(input));\n+    }\n+\n+    public static Object doProcess(Object source, Object start, Object end) {\n+        if (source == null) {\n+            return null;\n+        }\n+        if (!(source instanceof String || source instanceof Character)) {\n+            throw new EqlIllegalArgumentException(\"A string/char is required; received [{}]\", source);\n+        }\n+        if (start == null || end == null) {\n+            return source;\n+        }\n+        if (!(start instanceof Number)) {", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxNTQyMg==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394315422", "bodyText": "I thought end can be negative?", "author": "astefan", "createdAt": "2020-03-18T12:39:51Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/SubstringFunctionProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class SubstringFunctionProcessor implements Processor {\n+\n+    public static final String NAME = \"ssub\";\n+\n+    private final Processor source, start, end;\n+\n+    public SubstringFunctionProcessor(Processor source, Processor start, Processor end) {\n+        this.source = source;\n+        this.start = start;\n+        this.end = end;\n+    }\n+\n+    public SubstringFunctionProcessor(StreamInput in) throws IOException {\n+        source = in.readNamedWriteable(Processor.class);\n+        start = in.readNamedWriteable(Processor.class);\n+        end = in.readNamedWriteable(Processor.class);\n+    }\n+\n+    @Override\n+    public final void writeTo(StreamOutput out) throws IOException {\n+        out.writeNamedWriteable(source);\n+        out.writeNamedWriteable(start);\n+        out.writeNamedWriteable(end);\n+    }\n+\n+    @Override\n+    public Object process(Object input) {\n+        return doProcess(source.process(input), start.process(input), end.process(input));\n+    }\n+\n+    public static Object doProcess(Object source, Object start, Object end) {\n+        if (source == null) {\n+            return null;\n+        }\n+        if (!(source instanceof String || source instanceof Character)) {\n+            throw new EqlIllegalArgumentException(\"A string/char is required; received [{}]\", source);\n+        }\n+        if (start == null || end == null) {\n+            return source;\n+        }\n+        if (!(start instanceof Number)) {\n+            throw new EqlIllegalArgumentException(\"A number is required; received [{}]\", start);\n+        }\n+        if (!(end instanceof Number)) {\n+            throw new EqlIllegalArgumentException(\"A number is required; received [{}]\", end);\n+        }\n+        if (((Number) end).intValue() < 0) {", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxNTgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394315831", "bodyText": "Extra empty line.", "author": "astefan", "createdAt": "2020-03-18T12:40:36Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/whitelist/InternalEqlScriptUtils.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.whitelist;\n+\n+import org.elasticsearch.xpack.eql.expression.function.scalar.string.SubstringFunctionProcessor;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.whitelist.InternalQlScriptUtils;\n+\n+/*\n+ * Whitelisted class for EQL scripts.\n+ * Acts as a registry of the various static methods used <b>internally</b> by the scalar functions\n+ * (to simplify the whitelist definition).\n+ */\n+public class InternalEqlScriptUtils extends InternalQlScriptUtils {\n+\n+    InternalEqlScriptUtils() {}\n+\n+", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxNjc4MA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394316780", "bodyText": "Magic", "author": "astefan", "createdAt": "2020-03-18T12:42:24Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -143,7 +141,7 @@ public void testFunctionVerificationUnknown() {\n                 error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n         assertEquals(\"1:15: Unknown function [add]\",\n                 error(\"process where add(serial_event_id, 0) == 1\"));\n-        assertEquals(\"1:15: Unknown function [subtract]\",\n+        assertEquals(\"1:15: Unknown function [subtract], did you mean [substring]?\",", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyMDI4MA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394320280", "bodyText": "No tests with null values?", "author": "astefan", "createdAt": "2020-03-18T12:48:34Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtilsTests.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.StringUtils.substringSlice;\n+\n+public class StringUtilsTests extends ESTestCase {", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8499f3cc41190fd4bb9044cd72d00b5cbe9e9176", "url": "https://github.com/elastic/elasticsearch/commit/8499f3cc41190fd4bb9044cd72d00b5cbe9e9176", "message": "Merge branch 'master' into eql/functions-nointeg", "committedDate": "2020-03-18T14:06:46Z", "type": "commit"}, {"oid": "537d87013f3e4a11d8b66d4af648100aef117e8f", "url": "https://github.com/elastic/elasticsearch/commit/537d87013f3e4a11d8b66d4af648100aef117e8f", "message": "Address feedback", "committedDate": "2020-03-18T14:47:44Z", "type": "commit"}, {"oid": "7db46a6cd2e67ed995b181eea7de018baf4c3aaa", "url": "https://github.com/elastic/elasticsearch/commit/7db46a6cd2e67ed995b181eea7de018baf4c3aaa", "message": "Fix incorrect assignment", "committedDate": "2020-03-18T17:37:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyODM1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394328355", "bodyText": "could be also final ?", "author": "matriv", "createdAt": "2020-03-18T13:02:13Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/scalar/whitelist/InternalQlScriptUtils.java", "diffHunk": "@@ -9,12 +9,16 @@\n import org.elasticsearch.index.fielddata.ScriptDocValues;\n import org.elasticsearch.xpack.ql.expression.predicate.logical.BinaryLogicProcessor.BinaryLogicOperation;\n import org.elasticsearch.xpack.ql.expression.predicate.logical.NotProcessor;\n+import org.elasticsearch.xpack.ql.expression.predicate.nulls.CheckNullProcessor.CheckNullOperation;\n import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.BinaryComparisonProcessor.BinaryComparisonOperation;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.InProcessor;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.RegexProcessor.RegexOperation;\n import org.elasticsearch.xpack.ql.util.StringUtils;\n \n+import java.util.List;\n import java.util.Map;\n \n-public abstract class InternalQlScriptUtils {\n+public class InternalQlScriptUtils {", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MzY1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394973655", "bodyText": "No because it is extended by the other Script classes.", "author": "costin", "createdAt": "2020-03-19T11:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyODM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA0ODkxNw==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r395048917", "bodyText": "ah yes, sorry.", "author": "matriv", "createdAt": "2020-03-19T14:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyODM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyOTAyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394329029", "bodyText": "Why is that?", "author": "matriv", "createdAt": "2020-03-18T13:03:20Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/action/AbstractEqlIntegTestCase.java", "diffHunk": "@@ -35,7 +35,7 @@ protected Settings nodeSettings(int nodeOrdinal) {\n \n     @Override\n     protected Collection<Class<? extends Plugin>> nodePlugins() {\n-        return Collections.singletonList(LocalStateEqlXPackPlugin.class);\n+        return Arrays.asList(LocalStateEqlXPackPlugin.class);", "originalCommit": "d23ce79af733b43118d80f18031e3947af89b276", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MzkwMA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394973900", "bodyText": "Leftover.", "author": "costin", "createdAt": "2020-03-19T11:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyOTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2MTI0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394661246", "bodyText": "This check couldn't be included inside the\nif (end < 0)\n\n?", "author": "matriv", "createdAt": "2020-03-18T21:53:40Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtils.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.common.Strings.hasLength;\n+\n+final class StringUtils {\n+\n+    private StringUtils() {}\n+\n+    /**\n+     * Returns a substring using the Python slice semantics, meaning\n+     * start and end can be negative\n+     */\n+    static String substringSlice(String string, int start, int end) {\n+        if (hasLength(string) == false) {\n+            return string;\n+        }\n+\n+        int length = string.length();\n+        \n+        // handle first negative values\n+        if (start < 0) {\n+            start += length;\n+        }\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (end < 0) {\n+            end += length;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+        if (end > length) {", "originalCommit": "7db46a6cd2e67ed995b181eea7de018baf4c3aaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3NDUyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394974529", "bodyText": "No because once checks the lower limit, whether end is still negative (after potentially adding length) while the other checks the upper limit.", "author": "costin", "createdAt": "2020-03-19T12:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2MTI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2MjA0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394662046", "bodyText": "Here also, shouldn't be end?", "author": "matriv", "createdAt": "2020-03-18T21:55:33Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/SubstringFunctionPipe.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.execution.search.QlSourceBuilder;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class SubstringFunctionPipe extends Pipe {\n+\n+    private final Pipe source, start, end;\n+\n+    public SubstringFunctionPipe(Source source, Expression expression, Pipe src, Pipe start, Pipe end) {\n+        super(source, expression, Arrays.asList(src, start, end));\n+        this.source = src;\n+        this.start = start;\n+        this.end = end;\n+    }\n+\n+    @Override\n+    public final Pipe replaceChildren(List<Pipe> newChildren) {\n+        if (newChildren.size() != 3) {\n+            throw new IllegalArgumentException(\"expected [3] children but received [\" + newChildren.size() + \"]\");\n+        }\n+        return replaceChildren(newChildren.get(0), newChildren.get(1), newChildren.get(2));\n+    }\n+\n+    @Override\n+    public final Pipe resolveAttributes(AttributeResolver resolver) {\n+        Pipe newSource = source.resolveAttributes(resolver);\n+        Pipe newStart = start.resolveAttributes(resolver);\n+        Pipe newLength = end.resolveAttributes(resolver);\n+        if (newSource == source && newStart == start && newLength == end) {\n+            return this;\n+        }\n+        return replaceChildren(newSource, newStart, newLength);\n+    }\n+\n+    @Override\n+    public boolean supportedByAggsOnlyQuery() {\n+        return source.supportedByAggsOnlyQuery() && start.supportedByAggsOnlyQuery() && end.supportedByAggsOnlyQuery();\n+    }\n+\n+    @Override\n+    public boolean resolved() {\n+        return source.resolved() && start.resolved() && end.resolved();\n+    }\n+\n+    protected Pipe replaceChildren(Pipe newSource, Pipe newStart, Pipe newLength) {\n+        return new SubstringFunctionPipe(source(), expression(), newSource, newStart, newLength);\n+    }\n+\n+    @Override\n+    public final void collectFields(QlSourceBuilder sourceBuilder) {\n+        source.collectFields(sourceBuilder);\n+        start.collectFields(sourceBuilder);\n+        end.collectFields(sourceBuilder);\n+    }\n+\n+    @Override\n+    protected NodeInfo<SubstringFunctionPipe> info() {\n+        return NodeInfo.create(this, SubstringFunctionPipe::new, expression(), source, start, end);\n+    }\n+\n+    @Override\n+    public SubstringFunctionProcessor asProcessor() {\n+        return new SubstringFunctionProcessor(source.asProcessor(), start.asProcessor(), end.asProcessor());\n+    }\n+    \n+    public Pipe src() {\n+        return source;\n+    }\n+    \n+    public Pipe start() {\n+        return start;\n+    }\n+    \n+    public Pipe length() {", "originalCommit": "7db46a6cd2e67ed995b181eea7de018baf4c3aaa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2NDY3OA==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394664678", "bodyText": "How about both negative and both higher than length?\nAlso a test for both positive and both higher than end.", "author": "matriv", "createdAt": "2020-03-18T22:01:30Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtilsTests.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.StringUtils.substringSlice;\n+\n+public class StringUtilsTests extends ESTestCase {\n+\n+    public void testSubstringSlicePositive() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(str.substring(1, 7), substringSlice(str, 1, 7));\n+    }\n+\n+    public void testSubstringSliceNegative() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(str.substring(5, 9), substringSlice(str, -5, -1));\n+    }\n+\n+    public void testSubstringSliceNegativeOverLength() {", "originalCommit": "7db46a6cd2e67ed995b181eea7de018baf4c3aaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3NjI5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394976291", "bodyText": "That's what the test does - -15 and -11 are both negative and higher than length.\nAm I missing something?", "author": "costin", "createdAt": "2020-03-19T12:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2NDY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MjU1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r395052552", "bodyText": "Sorry my bad about the negative.", "author": "matriv", "createdAt": "2020-03-19T14:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2NDY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2NTIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r394665217", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testEndHigherThanLenght() {\n          \n          \n            \n                public void testEndHigherThanLength() {", "author": "matriv", "createdAt": "2020-03-18T22:02:49Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtilsTests.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.StringUtils.substringSlice;\n+\n+public class StringUtilsTests extends ESTestCase {\n+\n+    public void testSubstringSlicePositive() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(str.substring(1, 7), substringSlice(str, 1, 7));\n+    }\n+\n+    public void testSubstringSliceNegative() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(str.substring(5, 9), substringSlice(str, -5, -1));\n+    }\n+\n+    public void testSubstringSliceNegativeOverLength() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(\"\", substringSlice(str, -15, -11));\n+    }\n+\n+    public void testSubstringRandomSlicePositive() {\n+        String str = randomAlphaOfLength(10);\n+        int start = randomInt(5);\n+        int end = start + randomInt(3);\n+        assertEquals(str.substring(start, end), substringSlice(str, start, end));\n+    }\n+\n+    public void testSubstringRandomSliceNegative() {\n+        String str = randomAlphaOfLength(10);\n+        int end = 1 + randomInt(3);\n+        int start = end + randomInt(5);\n+        assertEquals(str.substring(10 - start, 10 - end), substringSlice(str, -start, -end));\n+    }\n+\n+    public void testStartNegativeHigherThanLength() {\n+        String str = randomAlphaOfLength(10);\n+        int start = 10 + randomInt(10);\n+        assertEquals(str.substring(0, 10 - 1), substringSlice(str, -start, -1));\n+    }\n+\n+    public void testEndHigherThanLenght() {", "originalCommit": "7db46a6cd2e67ed995b181eea7de018baf4c3aaa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ffd50c87d23d13571c842b43c20281202d9e51b0", "url": "https://github.com/elastic/elasticsearch/commit/ffd50c87d23d13571c842b43c20281202d9e51b0", "message": "Address feedback", "committedDate": "2020-03-19T12:10:41Z", "type": "commit"}, {"oid": "bd49db73e51360ea789c5c27c407d90929c07a57", "url": "https://github.com/elastic/elasticsearch/commit/bd49db73e51360ea789c5c27c407d90929c07a57", "message": "Fix super initialization", "committedDate": "2020-03-19T12:24:35Z", "type": "commit"}, {"oid": "85eec10b491c716152b4ea58737d0c8b07768641", "url": "https://github.com/elastic/elasticsearch/commit/85eec10b491c716152b4ea58737d0c8b07768641", "message": "Another rename", "committedDate": "2020-03-19T12:25:37Z", "type": "commit"}, {"oid": "b7c8ba9c9eba7475d94cfa723fe7133988cf325d", "url": "https://github.com/elastic/elasticsearch/commit/b7c8ba9c9eba7475d94cfa723fe7133988cf325d", "message": "Fix failing test", "committedDate": "2020-03-19T12:39:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MzI4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r395053287", "bodyText": "Maybe random ints (negative too) for completeness?", "author": "matriv", "createdAt": "2020-03-19T14:10:05Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/StringUtilsTests.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.StringUtils.substringSlice;\n+\n+public class StringUtilsTests extends ESTestCase {\n+\n+    public void testSubstringSlicePositive() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(str.substring(1, 7), substringSlice(str, 1, 7));\n+    }\n+\n+    public void testSubstringSliceNegative() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(str.substring(5, 9), substringSlice(str, -5, -1));\n+    }\n+\n+    public void testSubstringSliceNegativeOverLength() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(\"\", substringSlice(str, -15, -11));\n+    }\n+\n+    public void testSubstringSlicePositiveOverLength() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(\"\", substringSlice(str, 11, 14));\n+    }\n+\n+    public void testSubstringHigherEndThanStartNegative() {\n+        String str = randomAlphaOfLength(10);\n+        assertEquals(\"\", substringSlice(str, -20, -11));\n+    }\n+\n+    public void testSubstringRandomSlicePositive() {\n+        String str = randomAlphaOfLength(10);\n+        int start = randomInt(5);\n+        int end = start + randomInt(3);\n+        assertEquals(str.substring(start, end), substringSlice(str, start, end));\n+    }\n+\n+    public void testSubstringRandomSliceNegative() {\n+        String str = randomAlphaOfLength(10);\n+        int end = 1 + randomInt(3);\n+        int start = end + randomInt(5);\n+        assertEquals(str.substring(10 - start, 10 - end), substringSlice(str, -start, -end));\n+    }\n+\n+    public void testStartNegativeHigherThanLength() {\n+        String str = randomAlphaOfLength(10);\n+        int start = 10 + randomInt(10);\n+        assertEquals(str.substring(0, 10 - 1), substringSlice(str, -start, -1));\n+    }\n+\n+    public void testEndHigherThanLength() {\n+        String str = randomAlphaOfLength(10);\n+        int end = 10 + randomInt(10);\n+        assertEquals(str, substringSlice(str, 0, end));\n+    }\n+\n+    public void testSubstringRandomSliceSameStartEnd() {\n+        String str = randomAlphaOfLength(10);\n+        int start = randomInt();\n+        assertEquals(\"\", substringSlice(str, start, start));\n+    }\n+\n+    public void testNullValue() {\n+        assertNull(substringSlice(null, 0, 0));", "originalCommit": "b7c8ba9c9eba7475d94cfa723fe7133988cf325d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MDc1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53688#discussion_r395090751", "bodyText": "Those are covered in testSubstringRandomSliceNegative", "author": "costin", "createdAt": "2020-03-19T14:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MzI4Nw=="}], "type": "inlineReview"}]}