{"pr_number": 53994, "pr_title": "Refactor global build info plugin to leverage JavaInstallationRegistry", "pr_createdAt": "2020-03-23T16:39:34Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53994", "timeline": [{"oid": "712906a1d22a8c4ec6a2ff8f1993e7adad40b3a8", "url": "https://github.com/elastic/elasticsearch/commit/712906a1d22a8c4ec6a2ff8f1993e7adad40b3a8", "message": "Refactor global build info plugin to leverage JavaInstallationRegistry\n\nThis commit removes the configuration time vs execution time distinction\nwith regards to certain BuildParms properties. Because of the cost of\ndetermining Java versions for configuration JDK locations we deferred\nthis until execution time. This had two main downsides. First, we had\nto implement all this build logic in tasks, which required a bunch of\nadditional plumbing and complexity. Second, because some information\nwasn't known during configuration time, we had to nest any build logic\nthat depended on this in awkward callbacks.\n\nWe now defer to the JavaInstallationRegistry recently added in Gradle.\nThis utility uses a much more efficient method for probing Java\ninstallations vs our jrunscript implementation. This, combined with some\noptimizations to avoid probing the current JVM as well as deferring\nsome evaluation via Providers when probing installations for BWC builds\nwe can maintain effectively the same configuration time performance\nwhile removing a bunch of complexity and runtime cost (snapshotting\ninputs for the GenerateGlobalBuildInfoTask was very expensive). The end\nresult should be a much more responsive build execution in almost all\nscenarios.", "committedDate": "2020-03-23T16:38:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMTAxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53994#discussion_r396611019", "bodyText": "accidental indentation?", "author": "rjernst", "createdAt": "2020-03-23T17:05:28Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/util/Util.java", "diffHunk": "@@ -7,7 +7,7 @@\n  * not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n+ *         http://www.apache.org/licenses/LICENSE-2.0", "originalCommit": "712906a1d22a8c4ec6a2ff8f1993e7adad40b3a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMjM0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53994#discussion_r396622343", "bodyText": "Yeah, this is actually messed up in ide.gradle. I've fixed that as well.", "author": "mark-vieira", "createdAt": "2020-03-23T17:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMTAxOQ=="}], "type": "inlineReview"}, {"oid": "d3e1ba3687c95ca0be62866402e32468ab940e2a", "url": "https://github.com/elastic/elasticsearch/commit/d3e1ba3687c95ca0be62866402e32468ab940e2a", "message": "Fix Apache license header formatting", "committedDate": "2020-03-23T17:21:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzODM5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53994#discussion_r396638392", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"The %s must be set to a JDK installation directory for Java\" + \" %d but is [%s] corresponding to [%s]\",\n          \n          \n            \n                        \"The %s must be set to a JDK installation directory for Java %d but is [%s] corresponding to [%s]\",", "author": "pugnascotia", "createdAt": "2020-03-23T17:45:09Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java", "diffHunk": "@@ -33,102 +42,168 @@\n import java.util.stream.Stream;\n \n public class GlobalBuildInfoPlugin implements Plugin<Project> {\n-    private static final String GLOBAL_INFO_EXTENSION_NAME = \"globalInfo\";\n+    private static final Logger LOGGER = Logging.getLogger(GlobalBuildInfoPlugin.class);\n     private static Integer _defaultParallel = null;\n \n+    private final JavaInstallationRegistry javaInstallationRegistry;\n+    private final ObjectFactory objects;\n+    private final ProviderFactory providers;\n+\n+    @Inject\n+    public GlobalBuildInfoPlugin(JavaInstallationRegistry javaInstallationRegistry, ObjectFactory objects, ProviderFactory providers) {\n+        this.javaInstallationRegistry = javaInstallationRegistry;\n+        this.objects = objects;\n+        this.providers = providers;\n+    }\n+\n     @Override\n     public void apply(Project project) {\n         if (project != project.getRootProject()) {\n             throw new IllegalStateException(this.getClass().getName() + \" can only be applied to the root project.\");\n         }\n \n-        GlobalInfoExtension extension = project.getExtensions().create(GLOBAL_INFO_EXTENSION_NAME, GlobalInfoExtension.class);\n-\n-        JavaVersion minimumCompilerVersion = JavaVersion.toVersion(getResourceContents(\"/minimumCompilerVersion\"));\n-        JavaVersion minimumRuntimeVersion = JavaVersion.toVersion(getResourceContents(\"/minimumRuntimeVersion\"));\n+        JavaVersion minimumCompilerVersion = JavaVersion.toVersion(Util.getResourceContents(\"/minimumCompilerVersion\"));\n+        JavaVersion minimumRuntimeVersion = JavaVersion.toVersion(Util.getResourceContents(\"/minimumRuntimeVersion\"));\n \n         File compilerJavaHome = findCompilerJavaHome();\n         File runtimeJavaHome = findRuntimeJavaHome(compilerJavaHome);\n \n-        String testSeedProperty = System.getProperty(\"tests.seed\");\n-        final String testSeed;\n-        if (testSeedProperty == null) {\n-            long seed = new Random(System.currentTimeMillis()).nextLong();\n-            testSeed = Long.toUnsignedString(seed, 16).toUpperCase(Locale.ROOT);\n-        } else {\n-            testSeed = testSeedProperty;\n-        }\n-\n-        final String buildSnapshotSystemProperty = System.getProperty(\"build.snapshot\", \"true\");\n-        final boolean isSnapshotBuild;\n-        switch (buildSnapshotSystemProperty) {\n-            case \"true\":\n-                isSnapshotBuild = true;\n-                break;\n-            case \"false\":\n-                isSnapshotBuild = false;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\n-                    \"build.snapshot was set to [\" + buildSnapshotSystemProperty + \"] but can only be unset or [true|false]\"\n-                );\n-        }\n-        final List<JavaHome> javaVersions = new ArrayList<>();\n-        for (int version = 8; version <= Integer.parseInt(minimumCompilerVersion.getMajorVersion()); version++) {\n-            if (System.getenv(getJavaHomeEnvVarName(Integer.toString(version))) != null) {\n-                javaVersions.add(JavaHome.of(version, new File(findJavaHome(Integer.toString(version)))));\n-            }\n-        }\n-\n-        GenerateGlobalBuildInfoTask generateTask = project.getTasks()\n-            .create(\"generateGlobalBuildInfo\", GenerateGlobalBuildInfoTask.class, task -> {\n-                task.setJavaVersions(javaVersions);\n-                task.setMinimumCompilerVersion(minimumCompilerVersion);\n-                task.setMinimumRuntimeVersion(minimumRuntimeVersion);\n-                task.setCompilerJavaHome(compilerJavaHome);\n-                task.setRuntimeJavaHome(runtimeJavaHome);\n-                task.getOutputFile().set(new File(project.getBuildDir(), \"global-build-info\"));\n-                task.getCompilerVersionFile().set(new File(project.getBuildDir(), \"java-compiler-version\"));\n-                task.getRuntimeVersionFile().set(new File(project.getBuildDir(), \"java-runtime-version\"));\n-            });\n-\n-        PrintGlobalBuildInfoTask printTask = project.getTasks().create(\"printGlobalBuildInfo\", PrintGlobalBuildInfoTask.class, task -> {\n-            task.getBuildInfoFile().set(generateTask.getOutputFile());\n-            task.getCompilerVersionFile().set(generateTask.getCompilerVersionFile());\n-            task.getRuntimeVersionFile().set(generateTask.getRuntimeVersionFile());\n-            task.setGlobalInfoListeners(extension.listeners);\n-        });\n-\n         // Initialize global build parameters\n         BuildParams.init(params -> {\n             params.reset();\n             params.setCompilerJavaHome(compilerJavaHome);\n             params.setRuntimeJavaHome(runtimeJavaHome);\n+            params.setCompilerJavaVersion(determineJavaVersion(\"compiler java.home\", compilerJavaHome, minimumCompilerVersion));\n+            params.setRuntimeJavaVersion(determineJavaVersion(\"runtime java.home\", runtimeJavaHome, minimumRuntimeVersion));\n             params.setIsRutimeJavaHomeSet(compilerJavaHome.equals(runtimeJavaHome) == false);\n-            params.setJavaVersions(javaVersions);\n+            params.setJavaVersions(getAvailableJavaVersions(minimumCompilerVersion));\n             params.setMinimumCompilerVersion(minimumCompilerVersion);\n             params.setMinimumRuntimeVersion(minimumRuntimeVersion);\n             params.setGradleJavaVersion(Jvm.current().getJavaVersion());\n             params.setGitRevision(gitRevision(project.getRootProject().getRootDir()));\n             params.setBuildDate(ZonedDateTime.now(ZoneOffset.UTC));\n-            params.setTestSeed(testSeed);\n+            params.setTestSeed(getTestSeed());\n             params.setIsCi(System.getenv(\"JENKINS_URL\") != null);\n             params.setIsInternal(GlobalBuildInfoPlugin.class.getResource(\"/buildSrc.marker\") != null);\n             params.setDefaultParallel(findDefaultParallel(project));\n-            params.setInFipsJvm(isInFipsJvm());\n-            params.setIsSnapshotBuild(isSnapshotBuild);\n+            params.setInFipsJvm(Util.getBooleanProperty(\"tests.fips.enabled\", false));\n+            params.setIsSnapshotBuild(Util.getBooleanProperty(\"build.snapshot\", true));\n         });\n \n-        project.allprojects(\n-            p -> {\n-                // Make sure than any task execution generates and prints build info\n-                p.getTasks().configureEach(task -> {\n-                    if (task != generateTask && task != printTask) {\n-                        task.dependsOn(printTask);\n+        // Print global build info header just before task execution\n+        project.getGradle().getTaskGraph().whenReady(graph -> logGlobalBuildInfo());\n+    }\n+\n+    private void logGlobalBuildInfo() {\n+        final String osName = System.getProperty(\"os.name\");\n+        final String osVersion = System.getProperty(\"os.version\");\n+        final String osArch = System.getProperty(\"os.arch\");\n+        final Jvm gradleJvm = Jvm.current();\n+        final String gradleJvmDetails = getJavaInstallation(gradleJvm.getJavaHome()).getImplementationName();\n+\n+        LOGGER.quiet(\"=======================================\");\n+        LOGGER.quiet(\"Elasticsearch Build Hamster says Hello!\");\n+        LOGGER.quiet(\"  Gradle Version        : \" + GradleVersion.current().getVersion());\n+        LOGGER.quiet(\"  OS Info               : \" + osName + \" \" + osVersion + \" (\" + osArch + \")\");\n+        if (Jvm.current().getJavaVersion().equals(BuildParams.getCompilerJavaVersion()) == false || BuildParams.getIsRuntimeJavaHomeSet()) {\n+            String compilerJvmDetails = getJavaInstallation(BuildParams.getCompilerJavaHome()).getImplementationName();\n+            String runtimeJvmDetails = getJavaInstallation(BuildParams.getRuntimeJavaHome()).getImplementationName();\n+\n+            LOGGER.quiet(\"  Compiler JDK Version  : \" + BuildParams.getCompilerJavaVersion() + \" (\" + compilerJvmDetails + \")\");\n+            LOGGER.quiet(\"  Compiler java.home    : \" + BuildParams.getCompilerJavaHome());\n+            LOGGER.quiet(\"  Runtime JDK Version   : \" + BuildParams.getRuntimeJavaVersion() + \" (\" + runtimeJvmDetails + \")\");\n+            LOGGER.quiet(\"  Runtime java.home     : \" + BuildParams.getRuntimeJavaHome());\n+            LOGGER.quiet(\"  Gradle JDK Version    : \" + gradleJvm.getJavaVersion() + \" (\" + gradleJvmDetails + \")\");\n+            LOGGER.quiet(\"  Gradle java.home      : \" + gradleJvm.getJavaHome());\n+        } else {\n+            LOGGER.quiet(\"  JDK Version           : \" + gradleJvm.getJavaVersion() + \" (\" + gradleJvmDetails + \")\");\n+            LOGGER.quiet(\"  JAVA_HOME             : \" + gradleJvm.getJavaHome());\n+        }\n+        LOGGER.quiet(\"  Random Testing Seed   : \" + BuildParams.getTestSeed());\n+        LOGGER.quiet(\"  In FIPS 140 mode      : \" + BuildParams.isInFipsJvm());\n+        LOGGER.quiet(\"=======================================\");\n+    }\n+\n+    private JavaVersion determineJavaVersion(String description, File javaHome, JavaVersion requiredVersion) {\n+        JavaInstallation installation = getJavaInstallation(javaHome);\n+        JavaVersion actualVersion = installation.getJavaVersion();\n+        if (actualVersion.isCompatibleWith(requiredVersion) == false) {\n+            throwInvalidJavaHomeException(\n+                description,\n+                javaHome,\n+                Integer.parseInt(requiredVersion.getMajorVersion()),\n+                Integer.parseInt(actualVersion.getMajorVersion())\n+            );\n+        }\n+\n+        return actualVersion;\n+    }\n+\n+    private JavaInstallation getJavaInstallation(File javaHome) {\n+        JavaInstallation installation;\n+        if (isCurrentJavaHome(javaHome)) {\n+            installation = javaInstallationRegistry.getInstallationForCurrentVirtualMachine().get();\n+        } else {\n+            installation = javaInstallationRegistry.installationForDirectory(objects.directoryProperty().fileValue(javaHome)).get();\n+        }\n+\n+        return installation;\n+    }\n+\n+    private List<JavaHome> getAvailableJavaVersions(JavaVersion minimumCompilerVersion) {\n+        final List<JavaHome> javaVersions = new ArrayList<>();\n+        for (int v = 8; v <= Integer.parseInt(minimumCompilerVersion.getMajorVersion()); v++) {\n+            int version = v;\n+            String javaHomeEnvVarName = getJavaHomeEnvVarName(Integer.toString(version));\n+            if (System.getenv(javaHomeEnvVarName) != null) {\n+                File javaHomeDirectory = new File(findJavaHome(Integer.toString(version)));\n+                Provider<JavaInstallation> javaInstallationProvider = javaInstallationRegistry.installationForDirectory(\n+                    objects.directoryProperty().fileValue(javaHomeDirectory)\n+                );\n+                JavaHome javaHome = JavaHome.of(version, providers.provider(() -> {\n+                    int actualVersion = Integer.parseInt(javaInstallationProvider.get().getJavaVersion().getMajorVersion());\n+                    if (actualVersion != version) {\n+                        throwInvalidJavaHomeException(\"env variable \" + javaHomeEnvVarName, javaHomeDirectory, version, actualVersion);\n                     }\n-                });\n+                    return javaHomeDirectory;\n+                }));\n+                javaVersions.add(javaHome);\n             }\n+        }\n+        return javaVersions;\n+    }\n+\n+    private static boolean isCurrentJavaHome(File javaHome) {\n+        try {\n+            return Files.isSameFile(javaHome.toPath(), Jvm.current().getJavaHome().toPath());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private static String getTestSeed() {\n+        String testSeedProperty = System.getProperty(\"tests.seed\");\n+        final String testSeed;\n+        if (testSeedProperty == null) {\n+            long seed = new Random(System.currentTimeMillis()).nextLong();\n+            testSeed = Long.toUnsignedString(seed, 16).toUpperCase(Locale.ROOT);\n+        } else {\n+            testSeed = testSeedProperty;\n+        }\n+        return testSeed;\n+    }\n+\n+    private static void throwInvalidJavaHomeException(String description, File javaHome, int expectedVersion, int actualVersion) {\n+        String message = String.format(\n+            Locale.ROOT,\n+            \"The %s must be set to a JDK installation directory for Java\" + \" %d but is [%s] corresponding to [%s]\",", "originalCommit": "d3e1ba3687c95ca0be62866402e32468ab940e2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "960aba04b83d46a0d6ce2b21313cbfed64961cb6", "url": "https://github.com/elastic/elasticsearch/commit/960aba04b83d46a0d6ce2b21313cbfed64961cb6", "message": "Update buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java\n\nCo-Authored-By: Rory Hunter <pugnascotia@users.noreply.github.com>", "committedDate": "2020-03-23T17:45:33Z", "type": "commit"}, {"oid": "997f3ab86fe85992b7d32446ad0d01c3354e3e51", "url": "https://github.com/elastic/elasticsearch/commit/997f3ab86fe85992b7d32446ad0d01c3354e3e51", "message": "Merge branch 'master' into global-build-info-refactor-v2", "committedDate": "2020-03-23T17:58:12Z", "type": "commit"}]}