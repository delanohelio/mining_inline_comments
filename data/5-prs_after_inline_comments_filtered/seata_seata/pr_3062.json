{"pr_number": 3062, "pr_title": "optimize: refactor the redis session store", "pr_createdAt": "2020-08-26T06:12:57Z", "pr_url": "https://github.com/seata/seata/pull/3062", "timeline": [{"oid": "e9e72550fdf5946b055d5b089178bf329966ee6b", "url": "https://github.com/seata/seata/commit/e9e72550fdf5946b055d5b089178bf329966ee6b", "message": "release 0.5.1", "committedDate": "2019-04-30T08:44:14Z", "type": "commit"}, {"oid": "f017c6b875c304f75fe34be37f9d4cf75e2f45f4", "url": "https://github.com/seata/seata/commit/f017c6b875c304f75fe34be37f9d4cf75e2f45f4", "message": "release 0.5.2\n\nrelease 0.5.2", "committedDate": "2019-05-17T10:12:34Z", "type": "commit"}, {"oid": "7ca3332d67c2f0d43ce7d854e6bbb04e48bcae8b", "url": "https://github.com/seata/seata/commit/7ca3332d67c2f0d43ce7d854e6bbb04e48bcae8b", "message": "Release 0.6.0 (#1106)", "committedDate": "2019-05-24T09:47:44Z", "type": "commit"}, {"oid": "dc088cb9551d58acdf343f66166985e8fa8712fd", "url": "https://github.com/seata/seata/commit/dc088cb9551d58acdf343f66166985e8fa8712fd", "message": "Revert \"Release 0.6.0 (#1106)\" (#1107)", "committedDate": "2019-05-27T02:27:47Z", "type": "commit"}, {"oid": "da96029455843dfd8ace1c085e8a170f05ad659a", "url": "https://github.com/seata/seata/commit/da96029455843dfd8ace1c085e8a170f05ad659a", "message": "re-merging 0.6.0", "committedDate": "2019-05-27T02:40:28Z", "type": "commit"}, {"oid": "ca567ef724cc53ef624a42718997853fbdddae54", "url": "https://github.com/seata/seata/commit/ca567ef724cc53ef624a42718997853fbdddae54", "message": "Release 0.6.1\n\nRelease 0.6.1", "committedDate": "2019-05-31T07:33:13Z", "type": "commit"}, {"oid": "1b90f935a27a928a8a75e8c11a4687235f1507d9", "url": "https://github.com/seata/seata/commit/1b90f935a27a928a8a75e8c11a4687235f1507d9", "message": "release 0.7.0", "committedDate": "2019-07-12T07:12:02Z", "type": "commit"}, {"oid": "39e4d892ada776f35c78528c85e773dd6ac8f5f1", "url": "https://github.com/seata/seata/commit/39e4d892ada776f35c78528c85e773dd6ac8f5f1", "message": "release 0.7.1\n\nrelease 0.7.1", "committedDate": "2019-07-15T12:01:04Z", "type": "commit"}, {"oid": "09456818ecd6644439366647021b683516225cb3", "url": "https://github.com/seata/seata/commit/09456818ecd6644439366647021b683516225cb3", "message": "release 0.8.0\n\nrelease 0.8.0", "committedDate": "2019-08-16T08:13:03Z", "type": "commit"}, {"oid": "9ffa29044209f04c222eab5445c8b01ea6295522", "url": "https://github.com/seata/seata/commit/9ffa29044209f04c222eab5445c8b01ea6295522", "message": "release  0.8.1", "committedDate": "2019-09-18T09:39:19Z", "type": "commit"}, {"oid": "a174ed5594d405ba26706c355327ac0ac8017b27", "url": "https://github.com/seata/seata/commit/a174ed5594d405ba26706c355327ac0ac8017b27", "message": "release 0.9.0", "committedDate": "2019-10-16T05:38:49Z", "type": "commit"}, {"oid": "5bdbc44e524263a47aa51a1a2a648b120456ee5b", "url": "https://github.com/seata/seata/commit/5bdbc44e524263a47aa51a1a2a648b120456ee5b", "message": "[release] release 1.0.0\n\n[release] release 1.0.0", "committedDate": "2019-12-20T16:59:09Z", "type": "commit"}, {"oid": "f990a575328504ef4dece32a93383f1debc0d7f2", "url": "https://github.com/seata/seata/commit/f990a575328504ef4dece32a93383f1debc0d7f2", "message": "release: release 1.1.0", "committedDate": "2020-02-19T15:13:24Z", "type": "commit"}, {"oid": "04d0568c0e89fd77c5a8c22a9d39025a0be41051", "url": "https://github.com/seata/seata/commit/04d0568c0e89fd77c5a8c22a9d39025a0be41051", "message": "Merge pull request #2582 from seata/1.2.0\n\nrelease 1.2.0", "committedDate": "2020-04-21T04:40:55Z", "type": "commit"}, {"oid": "2e2a4247a82e76d51a56485b46c0d948a0c1ea13", "url": "https://github.com/seata/seata/commit/2e2a4247a82e76d51a56485b46c0d948a0c1ea13", "message": "release: release 1.3.0", "committedDate": "2020-07-15T16:28:39Z", "type": "commit"}, {"oid": "9faed6ba5feb8548d7f74b4e262c2ef4358f6d47", "url": "https://github.com/seata/seata/commit/9faed6ba5feb8548d7f74b4e262c2ef4358f6d47", "message": "refactor:the redis session store", "committedDate": "2020-08-26T06:08:57Z", "type": "commit"}, {"oid": "fde56757241724949d95dbaa15f0fc9c8261feed", "url": "https://github.com/seata/seata/commit/fde56757241724949d95dbaa15f0fc9c8261feed", "message": "add:add license info", "committedDate": "2020-08-26T11:07:54Z", "type": "commit"}, {"oid": "0b5e5aef3fda289d0c89dba0f88b57bf1f8a423c", "url": "https://github.com/seata/seata/commit/0b5e5aef3fda289d0c89dba0f88b57bf1f8a423c", "message": "optimize:optimize the constants", "committedDate": "2020-08-26T12:39:01Z", "type": "commit"}, {"oid": "7f5a421140dfebd1b0b387135b2af49cd6e8757c", "url": "https://github.com/seata/seata/commit/7f5a421140dfebd1b0b387135b2af49cd6e8757c", "message": "revert:the .conf", "committedDate": "2020-08-27T03:52:11Z", "type": "commit"}, {"oid": "c070883d17f399b7e26593f2b6a0aed09610e2c1", "url": "https://github.com/seata/seata/commit/c070883d17f399b7e26593f2b6a0aed09610e2c1", "message": "revert:the file.conf", "committedDate": "2020-08-27T03:55:34Z", "type": "commit"}, {"oid": "e669dfe620433856f93a38a5816681702827cdf2", "url": "https://github.com/seata/seata/commit/e669dfe620433856f93a38a5816681702827cdf2", "message": "optimize:optimize the map", "committedDate": "2020-08-30T14:46:37Z", "type": "commit"}, {"oid": "981027611019d3b848261247b89122b8cfcaea9f", "url": "https://github.com/seata/seata/commit/981027611019d3b848261247b89122b8cfcaea9f", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-08-31T10:31:29Z", "type": "commit"}, {"oid": "c2083aeda43f45c33e272c25435d3d6e312d65b1", "url": "https://github.com/seata/seata/commit/c2083aeda43f45c33e272c25435d3d6e312d65b1", "message": "optimize:add the transaction", "committedDate": "2020-09-02T12:42:58Z", "type": "commit"}, {"oid": "21c72cb96a2b36a3686f3d65cc862fb25e2bb005", "url": "https://github.com/seata/seata/commit/21c72cb96a2b36a3686f3d65cc862fb25e2bb005", "message": "fix:the BeanUtils code format", "committedDate": "2020-09-03T00:59:15Z", "type": "commit"}, {"oid": "303e9d20765fe65c2a374c48df59b3e770dac2e6", "url": "https://github.com/seata/seata/commit/303e9d20765fe65c2a374c48df59b3e770dac2e6", "message": "fix: code format", "committedDate": "2020-09-03T01:49:58Z", "type": "commit"}, {"oid": "0e1c0f165ee00f862411f5231232fba5ed9c3dc9", "url": "https://github.com/seata/seata/commit/0e1c0f165ee00f862411f5231232fba5ed9c3dc9", "message": "optimize:lpush -> rpush", "committedDate": "2020-09-03T01:59:22Z", "type": "commit"}, {"oid": "1c7cd456b2932b82aac05bdc3f08cd2bea491ce2", "url": "https://github.com/seata/seata/commit/1c7cd456b2932b82aac05bdc3f08cd2bea491ce2", "message": "add:add the test", "committedDate": "2020-09-03T11:07:14Z", "type": "commit"}, {"oid": "12a7990aba134f4ee8df914dad3ea4aa7ebdb533", "url": "https://github.com/seata/seata/commit/12a7990aba134f4ee8df914dad3ea4aa7ebdb533", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-09-03T11:07:22Z", "type": "commit"}, {"oid": "75f50babee878921a49caba17d43102e854f29f1", "url": "https://github.com/seata/seata/commit/75f50babee878921a49caba17d43102e854f29f1", "message": "fix:the code check", "committedDate": "2020-09-03T12:59:44Z", "type": "commit"}, {"oid": "786bb5c023069e4b811253eb79054b54ba2fe539", "url": "https://github.com/seata/seata/commit/786bb5c023069e4b811253eb79054b54ba2fe539", "message": "optimize:the file name", "committedDate": "2020-09-04T01:03:24Z", "type": "commit"}, {"oid": "9f11b274a062caa3c5859152dd6efc509938e548", "url": "https://github.com/seata/seata/commit/9f11b274a062caa3c5859152dd6efc509938e548", "message": "optimize:add the watch to the update global", "committedDate": "2020-09-06T14:10:17Z", "type": "commit"}, {"oid": "211fe5b0471c55cc3efde1e6156074b81124c4bc", "url": "https://github.com/seata/seata/commit/211fe5b0471c55cc3efde1e6156074b81124c4bc", "message": "optimze the utils,add annotation", "committedDate": "2020-09-07T11:16:54Z", "type": "commit"}, {"oid": "3848e444452906b9c9dec3089fb366a2b5747873", "url": "https://github.com/seata/seata/commit/3848e444452906b9c9dec3089fb366a2b5747873", "message": "fix the date", "committedDate": "2020-09-07T11:29:16Z", "type": "commit"}, {"oid": "05cff09c8b94ca1a99f4d27467cadb06621ec8a7", "url": "https://github.com/seata/seata/commit/05cff09c8b94ca1a99f4d27467cadb06621ec8a7", "message": "fix:the multi", "committedDate": "2020-09-07T11:45:52Z", "type": "commit"}, {"oid": "fe57b7a4a804a0310e4ac2f989267b52f544ceab", "url": "https://github.com/seata/seata/commit/fe57b7a4a804a0310e4ac2f989267b52f544ceab", "message": "optimize the code", "committedDate": "2020-09-07T12:12:34Z", "type": "commit"}, {"oid": "58392aec0cc6d2507c2dd49680f16201921397e8", "url": "https://github.com/seata/seata/commit/58392aec0cc6d2507c2dd49680f16201921397e8", "message": "optimize the code", "committedDate": "2020-09-07T12:14:41Z", "type": "commit"}, {"oid": "a4e63885ba5ccd953705acbd0efe10a7020565f5", "url": "https://github.com/seata/seata/commit/a4e63885ba5ccd953705acbd0efe10a7020565f5", "message": "add:the test for beanutils", "committedDate": "2020-09-10T03:07:31Z", "type": "commit"}, {"oid": "3f14c6a779c8163897260a9e9d2daf897a061b9b", "url": "https://github.com/seata/seata/commit/3f14c6a779c8163897260a9e9d2daf897a061b9b", "message": "add:the test for sessionConverter", "committedDate": "2020-09-10T08:00:28Z", "type": "commit"}, {"oid": "911a190090661f32bd97098204ab76e169249fbb", "url": "https://github.com/seata/seata/commit/911a190090661f32bd97098204ab76e169249fbb", "message": "add:test for collectionutil", "committedDate": "2020-09-10T08:50:05Z", "type": "commit"}, {"oid": "47246d6042b0a9475bacbf4e45bfcae8ab857df9", "url": "https://github.com/seata/seata/commit/47246d6042b0a9475bacbf4e45bfcae8ab857df9", "message": "add:test for redistransactionstoremanager", "committedDate": "2020-09-10T09:47:49Z", "type": "commit"}, {"oid": "c96f9f63188725f36c9b4a5141063681da3aa76a", "url": "https://github.com/seata/seata/commit/c96f9f63188725f36c9b4a5141063681da3aa76a", "message": "add:test for redistransactionstoremanager", "committedDate": "2020-09-10T11:34:09Z", "type": "commit"}, {"oid": "039e1f71e36a16f01f9e0ea407d542ceafca7802", "url": "https://github.com/seata/seata/commit/039e1f71e36a16f01f9e0ea407d542ceafca7802", "message": "add:test for redistransactionstoremanager", "committedDate": "2020-09-10T12:38:50Z", "type": "commit"}, {"oid": "27d1e57c8c77996c685e1ce4211792c4ed94b780", "url": "https://github.com/seata/seata/commit/27d1e57c8c77996c685e1ce4211792c4ed94b780", "message": "add:test for redistransactionstoremanager", "committedDate": "2020-09-11T07:20:35Z", "type": "commit"}, {"oid": "667c839709819c0280456999b7594d9fbf78c2ec", "url": "https://github.com/seata/seata/commit/667c839709819c0280456999b7594d9fbf78c2ec", "message": "Merge branch 'develop' into refactor_redis_session", "committedDate": "2020-09-14T15:25:15Z", "type": "commit"}, {"oid": "0077d56215a24f24381aa50f6ee82434c0749210", "url": "https://github.com/seata/seata/commit/0077d56215a24f24381aa50f6ee82434c0749210", "message": "Merge branch 'develop' into refactor_redis_session", "committedDate": "2020-09-15T02:17:32Z", "type": "commit"}, {"oid": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "url": "https://github.com/seata/seata/commit/66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "message": "Merge branch 'develop' into refactor_redis_session", "committedDate": "2020-09-17T14:28:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NTE3Ng==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490295176", "bodyText": "Java packages should be at the top level", "author": "a364176773", "createdAt": "2020-09-17T14:32:25Z", "path": "server/src/main/java/io/seata/server/storage/db/store/DataBaseTransactionStoreManager.java", "diffHunk": "@@ -15,6 +15,7 @@\n  */\n package io.seata.server.storage.db.store;\n \n+import io.seata.server.storage.SessionConverter;", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NTk0Ng==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490295946", "bodyText": "Java packages should be at the top level", "author": "a364176773", "createdAt": "2020-09-17T14:33:14Z", "path": "server/src/test/java/io/seata/server/session/redis/RedisSessionManagerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.seata.server.session.redis;\n+\n+import io.seata.server.session.SessionCondition;\n+import java.io.IOException;", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NjU2Nw==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490296567", "bodyText": "Java packages should be at the top level", "author": "a364176773", "createdAt": "2020-09-17T14:33:52Z", "path": "server/src/test/java/io/seata/server/session/redis/SessionConverterTest.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.server.session.redis;\n+\n+import io.seata.core.model.BranchStatus;\n+import io.seata.core.model.BranchType;\n+import io.seata.core.model.GlobalStatus;\n+import io.seata.core.store.BranchTransactionDO;\n+import io.seata.core.store.GlobalTransactionDO;\n+import io.seata.server.session.BranchSession;\n+import io.seata.server.session.GlobalSession;\n+import io.seata.server.storage.SessionConverter;\n+import java.util.Date;", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5NzI0OA==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490297248", "bodyText": "Java packages should be at the top level", "author": "a364176773", "createdAt": "2020-09-17T14:34:37Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -15,63 +15,66 @@\n  */\n package io.seata.server.storage.redis.store;\n \n+import io.seata.common.exception.RedisException;\n+import io.seata.common.util.BeanUtils;\n+import io.seata.server.storage.SessionConverter;", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMjUzNg==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490302536", "bodyText": "why not use pipeline", "author": "a364176773", "createdAt": "2020-09-17T14:40:13Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwOTU5OA==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490309598", "bodyText": "Is this possibility now?", "author": "a364176773", "createdAt": "2020-09-17T14:47:12Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMyMDc5Mg==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490320792", "bodyText": "why not use pipeline", "author": "a364176773", "createdAt": "2020-09-17T14:57:52Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0Mzc3OA==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490343778", "bodyText": "why not use pipeline", "author": "a364176773", "createdAt": "2020-09-17T15:28:48Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0NDcxOQ==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490344719", "bodyText": "you don't have to do that", "author": "a364176773", "createdAt": "2020-09-17T15:30:02Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),\n+                        globalTransactionDO.getXid());\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.hdel(globalKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+            Long lrem = jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0,\n+                    globalTransactionDO.getXid());\n+            if (lrem > 0) {", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0ODQ5MQ==", "url": "https://github.com/seata/seata/pull/3062#discussion_r490348491", "bodyText": "I think the pipe can be used instead", "author": "a364176773", "createdAt": "2020-09-17T15:35:17Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,251 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(branchListKey, branchKey);\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.del(branchKey);\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String xid = jedis.hget(branchKey, REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Long lrem = jedis.lrem(branchListKey, 0, branchKey);\n+            if (lrem > 0) {\n+                Long del = jedis.del(branchKey);\n+                if (del == 1) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(branchListKey,branchKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            String hmset = jedis.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                Long rpush = jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),\n+                        globalTransactionDO.getXid());\n+                if (rpush > 0) {\n+                    return true;\n+                } else {\n+                    jedis.hdel(globalKey);\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+            Long lrem = jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0,\n+                    globalTransactionDO.getXid());\n+            if (lrem > 0) {\n+                Long del = jedis.del(globalKey);\n+                if (del > 0) {\n+                    return true;\n+                } else {\n+                    jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);\n+            Transaction multi = jedis.multi();", "originalCommit": "66f28c784c4c0b5b2a35cd56d2b37896dee734aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3OTU5Ng==", "url": "https://github.com/seata/seata/pull/3062#discussion_r491979596", "bodyText": "I think the pipe can be used instead\n\n\u8fd9\u4e2a\u5730\u65b9\u6ca1\u6709\u4f7f\u7528pipeline,\u4e3b\u8981\u8003\u8651\uff0c\u5982\u679c\u591a\u4e2atc\u90fd\u6765\u64cd\u4f5c\uff0c\u90fd\u5224\u65ad\u5168\u5c40\u4e8b\u52a1\u662f\u5b58\u5728\u7684\uff0c\u7136\u540e\u90fd\u53bb\u4fee\u6539\uff0c\u90a3\u4f1a\u4e0d\u4f1a\u51fa\u95ee\u9898\u3002\u800c\u8fd9\u51e0\u4e2a\u547d\u4ee4\uff0c\u5c24\u5176\u662fhmset\uff0cmap\u5b58\u4e0d\u5b58\u5728\uff0c\u5b83\u90fd\u4f1a\u6210\u529f\u3002pipeline\uff0c\u770b\u8d77\u6765\u9632\u4e0d\u4f4f\u8fd9\u79cd\u5e76\u53d1\u4fee\u6539\u7684\u573a\u666f\u3002", "author": "lightClouds917", "createdAt": "2020-09-21T11:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0ODQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNjcxMA==", "url": "https://github.com/seata/seata/pull/3062#discussion_r495816710", "bodyText": "I think a direct lock + pipeline is better than Multi", "author": "a364176773", "createdAt": "2020-09-28T09:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0ODQ5MQ=="}], "type": "inlineReview"}, {"oid": "e3b44bda01313fcd65c2d6372f2910788c769834", "url": "https://github.com/seata/seata/commit/e3b44bda01313fcd65c2d6372f2910788c769834", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-09-18T03:56:05Z", "type": "commit"}, {"oid": "510f0a70b786eae92275613544c19e9d8629771b", "url": "https://github.com/seata/seata/commit/510f0a70b786eae92275613544c19e9d8629771b", "message": "Merge branch 'refactor_redis_session' of github.com:lightClouds917/seata into refactor_redis_session", "committedDate": "2020-09-18T03:58:11Z", "type": "commit"}, {"oid": "5b985212ce302fb548ce6e93e1c0380e49cb6090", "url": "https://github.com/seata/seata/commit/5b985212ce302fb548ce6e93e1c0380e49cb6090", "message": "Merge branch 'master' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-09-18T04:40:47Z", "type": "commit"}, {"oid": "89ae3ffba979bfb1a1702fe594f2bc382c8d1330", "url": "https://github.com/seata/seata/commit/89ae3ffba979bfb1a1702fe594f2bc382c8d1330", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-09-18T12:04:56Z", "type": "commit"}, {"oid": "07afa8672b209c5e544a4123e201f5dde6dea326", "url": "https://github.com/seata/seata/commit/07afa8672b209c5e544a4123e201f5dde6dea326", "message": "optimize:the code to pipleline", "committedDate": "2020-09-18T12:05:47Z", "type": "commit"}, {"oid": "3e43c93f2c4041af13dd2851f706ed55a284e635", "url": "https://github.com/seata/seata/commit/3e43c93f2c4041af13dd2851f706ed55a284e635", "message": "optimize:the code", "committedDate": "2020-09-21T11:24:44Z", "type": "commit"}, {"oid": "a9bf3bd575fdf9ef913430923cc1d90afe77c4c6", "url": "https://github.com/seata/seata/commit/a9bf3bd575fdf9ef913430923cc1d90afe77c4c6", "message": "optimize:the import", "committedDate": "2020-09-21T11:50:31Z", "type": "commit"}, {"oid": "c9201b1f8b0074c2d6a60222ed8f9324460b9609", "url": "https://github.com/seata/seata/commit/c9201b1f8b0074c2d6a60222ed8f9324460b9609", "message": "optimize:when the status equals", "committedDate": "2020-09-21T12:04:26Z", "type": "commit"}, {"oid": "5b2a2cf1fd404e0b16a56f9f1a03e70d57a91d2a", "url": "https://github.com/seata/seata/commit/5b2a2cf1fd404e0b16a56f9f1a03e70d57a91d2a", "message": "optimize:get transactionId", "committedDate": "2020-09-21T13:22:40Z", "type": "commit"}, {"oid": "bbb2886f6fc2f36dd0f48abf50077e1081878e2c", "url": "https://github.com/seata/seata/commit/bbb2886f6fc2f36dd0f48abf50077e1081878e2c", "message": "optimize:get transactionId", "committedDate": "2020-09-21T13:23:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2MTMwNw==", "url": "https://github.com/seata/seata/pull/3062#discussion_r491261307", "bodyText": "use String.valueOf(XID.getTransactionId(xid))  instead\uff1f", "author": "caohdgege", "createdAt": "2020-09-19T03:07:29Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,286 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.del(branchKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(branchListKey,0,branchKey);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(branchListKey,branchKey);\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(branchKey,branchTransactionDOMap);\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            pipelined.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), globalTransactionDO.getXid());\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.hdel(globalKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0, globalTransactionDO.getXid());\n+                    }\n+                    return false;\n+                }\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            Map<String, String> globalTransactionDoMap = jedis.hgetAll(globalKey);\n+            String xid = globalTransactionDoMap.get(REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid());\n+            pipelined.del(globalKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(globalKey,globalTransactionDoMap);\n+                    }\n+                }\n+\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);\n+            Transaction multi = jedis.multi();\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_GLOBAL_STATUS,String.valueOf(globalTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_GLOBAL_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            multi.hmset(globalKey,map);\n+            multi.lrem(buildGlobalStatus(Integer.valueOf(previousStatus)),0, xid);\n+            multi.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), xid);\n+            List<Object> exec = multi.exec();\n+            String hmset = exec.get(0).toString();\n+            long lrem  = (long)exec.get(1);\n+            long rpush = (long)exec.get(2);\n+            if (OK.equalsIgnoreCase(hmset) && lrem > 0 && rpush > 0) {\n+                return true;\n+            } else {\n+                // If someone failed, the succeed operations need rollback\n+                if (OK.equalsIgnoreCase(hmset)) {\n+                    // Defensive watch to prevent other TC server operating concurrently,give up this operate\n+                    jedis.watch(globalKey);\n+                    String xid2 = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID);\n+                    if (StringUtils.isNotEmpty(xid2)) {\n+                        Map<String,String> mapPrevious = new HashMap<>(2);\n+                        mapPrevious.put(REDIS_KEY_GLOBAL_STATUS,previousStatus);\n+                        mapPrevious.put(REDIS_KEY_GLOBAL_GMT_MODIFIED,previousGmtModified);\n+                        Transaction multi2 = jedis.multi();\n+                        multi2.hmset(globalKey,mapPrevious);\n+                        multi2.exec();\n+                    }\n+                }\n+                if (lrem > 0) {\n+                    jedis.rpush(buildGlobalStatus(Integer.valueOf(previousStatus)),xid);\n+                }\n+                if (rpush > 0) {\n+                    jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0,xid);\n+                }\n+                return false;\n+            }\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n     /**\n      * Read session global session.\n      *\n-     * @param xid\n-     *            the xid\n-     * @param withBranchSessions\n-     *            the withBranchSessions\n+     * @param xid the xid\n+     * @param withBranchSessions  the withBranchSessions\n      * @return the global session\n      */\n     @Override\n     public GlobalSession readSession(String xid, boolean withBranchSessions) {\n-        String globalSessionJson;\n+        String transactionId = xid.split(\":\")[2];", "originalCommit": "07afa8672b209c5e544a4123e201f5dde6dea326", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MDE3NA==", "url": "https://github.com/seata/seata/pull/3062#discussion_r491360174", "bodyText": "if previousStatus == currentStatus, is it necessary to do update? or just need to return true immediately", "author": "caohdgege", "createdAt": "2020-09-19T10:00:57Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,286 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.del(branchKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(branchListKey,0,branchKey);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(branchListKey,branchKey);\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(branchKey,branchTransactionDOMap);\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            pipelined.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), globalTransactionDO.getXid());\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.hdel(globalKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0, globalTransactionDO.getXid());\n+                    }\n+                    return false;\n+                }\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            Map<String, String> globalTransactionDoMap = jedis.hgetAll(globalKey);\n+            String xid = globalTransactionDoMap.get(REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid());\n+            pipelined.del(globalKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(globalKey,globalTransactionDoMap);\n+                    }\n+                }\n+\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);", "originalCommit": "07afa8672b209c5e544a4123e201f5dde6dea326", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MTY1Mw==", "url": "https://github.com/seata/seata/pull/3062#discussion_r491361653", "bodyText": "using hmget to get REDIS_KEY_GLOBAL_GMT_MODIFIED\uff0cREDIS_KEY_GLOBAL_STATUS in one time?", "author": "caohdgege", "createdAt": "2020-09-19T10:05:24Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,99 +93,286 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.del(branchKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(branchListKey,0,branchKey);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(branchListKey,branchKey);\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(branchKey,branchTransactionDOMap);\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n-            return true;\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n+            }\n+            Map<String,String> map = new HashMap<>(2);\n+            map.put(REDIS_KEY_BRANCH_STATUS,String.valueOf(branchTransactionDO.getStatus()));\n+            map.put(REDIS_KEY_BRANCH_GMT_MODIFIED,String.valueOf((new Date()).getTime()));\n+            String hmset = jedis.hmset(branchKey, map);\n+            if (OK.equalsIgnoreCase(hmset)) {\n+                return true;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Insert the global transaction.\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean insertGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            Pipeline pipeline = jedis.pipelined();\n-            if (jedis.get(key) == null) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            Date now = new Date();\n+            globalTransactionDO.setGmtCreate(now);\n+            globalTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(globalKey, BeanUtils.objectToMap(globalTransactionDO));\n+            pipelined.rpush(buildGlobalStatus(globalTransactionDO.getStatus()), globalTransactionDO.getXid());\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                String hmset = objects.get(0).toString();\n+                Long rpush = Long.valueOf(objects.get(1).toString());\n+                if (OK.equals(hmset) && rpush > 0) {\n+                    return true;\n+                } else {\n+                    if (OK.equals(hmset)) {\n+                        jedis.hdel(globalKey);\n+                    }\n+                    if (rpush > 0) {\n+                        jedis.lrem(buildGlobalStatus(globalTransactionDO.getStatus()),0, globalTransactionDO.getXid());\n+                    }\n+                    return false;\n+                }\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n-            return true;\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n+    /**\n+     * Delete the global transaction.\n+     * It will operate two parts:\n+     *  1.delete the global session map\n+     *  2.remove the xid from the global status list\n+     * If the operate failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n     private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String[] keys = new String[3];\n-            keys[0] = getGlobalKeyByXid(globalTransactionDO.getXid());\n-            keys[1] = getGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n-            keys[2] = getBranchListKeyByXid(globalTransactionDO.getXid());\n-            jedis.del(keys);\n-            return true;\n+            Map<String, String> globalTransactionDoMap = jedis.hgetAll(globalKey);\n+            String xid = globalTransactionDoMap.get(REDIS_KEY_GLOBAL_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                LOGGER.warn(\"Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server\",\n+                        globalTransactionDO.getXid());\n+                return true;\n+            }\n+\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid());\n+            pipelined.del(globalKey);\n+            List<Object> objects = pipelined.syncAndReturnAll();\n+            if (CollectionUtils.isNotEmpty(objects)) {\n+                Long lrem = Long.valueOf(objects.get(0).toString());\n+                Long del = Long.valueOf(objects.get(1).toString());\n+                if (lrem > 0 && del > 0) {\n+                    return true;\n+                } else {\n+                    if (lrem > 0) {\n+                        jedis.rpush(buildGlobalStatus(globalTransactionDO.getStatus()),globalTransactionDO.getXid());\n+                    }\n+                    if (del > 0) {\n+                        jedis.hmset(globalKey,globalTransactionDoMap);\n+                    }\n+                }\n+\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateGlobalTransactionDO(GlobalTransactionDO convertGlobalTransactionDO) {\n+    /**\n+     * Update the global transaction.\n+     * It will update two parts:\n+     *  1.the global session map\n+     *  2.the global status list\n+     * If the update failed,the succeed operates will rollback\n+     * @param globalTransactionDO\n+     * @return\n+     */\n+    private boolean updateGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) {\n+        String xid = globalTransactionDO.getXid();\n+        String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String keys = getGlobalKeyByXid(convertGlobalTransactionDO.getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            String json = JSON.toJSONString(convertGlobalTransactionDO);\n-            pipeline.set(keys, json);\n-            keys = getGlobalKeyByTransactionId(convertGlobalTransactionDO.getTransactionId());\n-            pipeline.set(keys, json);\n-            pipeline.sync();\n-            return true;\n+            // Defensive watch to prevent other TC server operating concurrently,Fail fast\n+            jedis.watch(globalKey);\n+            String previousStatus = jedis.hget(globalKey, REDIS_KEY_GLOBAL_STATUS);\n+            if (StringUtils.isEmpty(previousStatus)) {\n+                throw new StoreException(\"Global transaction is not exist, update global transaction failed.\");\n+            }\n+            String previousGmtModified = jedis.hget(globalKey, REDIS_KEY_GLOBAL_GMT_MODIFIED);", "originalCommit": "07afa8672b209c5e544a4123e201f5dde6dea326", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1OTE0NA==", "url": "https://github.com/seata/seata/pull/3062#discussion_r492059144", "bodyText": "using hmget to get REDIS_KEY_GLOBAL_GMT_MODIFIED\uff0cREDIS_KEY_GLOBAL_STATUS in one times?\n\ngood idea,i will change", "author": "lightClouds917", "createdAt": "2020-09-21T13:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MTY1Mw=="}], "type": "inlineReview"}, {"oid": "449fb8470f4d0ce21111ffc7792828c942908208", "url": "https://github.com/seata/seata/commit/449fb8470f4d0ce21111ffc7792828c942908208", "message": "optimize:hget -> hmget", "committedDate": "2020-09-21T13:52:47Z", "type": "commit"}, {"oid": "e8dd0161d9fa3751bcffd912837e33d91ce20480", "url": "https://github.com/seata/seata/commit/e8dd0161d9fa3751bcffd912837e33d91ce20480", "message": "optimize:import", "committedDate": "2020-09-21T13:56:08Z", "type": "commit"}, {"oid": "4457a14748958c41aafdc97778d4d4c14e5a6fd1", "url": "https://github.com/seata/seata/commit/4457a14748958c41aafdc97778d4d4c14e5a6fd1", "message": "fix : the conflict", "committedDate": "2020-09-25T14:24:18Z", "type": "commit"}, {"oid": "ef6a8877a344d7e5181f87561f7ed29890fce850", "url": "https://github.com/seata/seata/commit/ef6a8877a344d7e5181f87561f7ed29890fce850", "message": "optimize:the pipeline", "committedDate": "2020-09-27T07:53:53Z", "type": "commit"}, {"oid": "6e90279405d7a85b8b3ba70b526d9534b43ae3f8", "url": "https://github.com/seata/seata/commit/6e90279405d7a85b8b3ba70b526d9534b43ae3f8", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-10-05T14:12:56Z", "type": "commit"}, {"oid": "94147a3e14138f1877f7b8abe225a4d2ba94b413", "url": "https://github.com/seata/seata/commit/94147a3e14138f1877f7b8abe225a4d2ba94b413", "message": "Merge branch 'develop' into refactor_redis_session", "committedDate": "2020-10-10T07:52:22Z", "type": "commit"}, {"oid": "efa9fae17918927e49ad17e3bc9d224cea06a6e1", "url": "https://github.com/seata/seata/commit/efa9fae17918927e49ad17e3bc9d224cea06a6e1", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-10-10T08:35:09Z", "type": "commit"}, {"oid": "bb7ec61cb8618bf5225027a3cbf5caf7fc68d467", "url": "https://github.com/seata/seata/commit/bb7ec61cb8618bf5225027a3cbf5caf7fc68d467", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-10-10T11:22:39Z", "type": "commit"}, {"oid": "131e8fedfea9b75013d882314f3c6a0ac932017f", "url": "https://github.com/seata/seata/commit/131e8fedfea9b75013d882314f3c6a0ac932017f", "message": "optimize:the null judge", "committedDate": "2020-10-10T15:27:26Z", "type": "commit"}, {"oid": "ef32fc3fa0617c52a79ed676e2d581881c25df61", "url": "https://github.com/seata/seata/commit/ef32fc3fa0617c52a79ed676e2d581881c25df61", "message": "Merge branch 'refactor_redis_session' of github.com:lightClouds917/seata into refactor_redis_session", "committedDate": "2020-10-10T15:29:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0Nzk3OQ==", "url": "https://github.com/seata/seata/pull/3062#discussion_r503147979", "bodyText": "Repeat method", "author": "ph3636", "createdAt": "2020-10-12T09:05:44Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -200,213 +334,153 @@ public GlobalSession readSession(String xid) {\n     }\n \n     /**\n-     * Read session list.\n+     * Read globalSession list by global status\n      *\n-     * @param statuses\n-     *            the statuses\n+     * @param statuses the statuses\n      * @return the list\n      */\n     public List<GlobalSession> readSession(GlobalStatus[] statuses) {\n-        List<Integer> states = new ArrayList<>();\n+        List<String> statusKeys = new ArrayList<>();\n         for (int i = 0; i < statuses.length; i++) {\n-            states.add(statuses[i].getCode());\n+            statusKeys.add(buildGlobalStatus(statuses[i].getCode()));\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            Set<String> keys = new HashSet<>();\n-            String cursor = INITIAL_CURSOR;\n-            ScanParams params = new ScanParams();\n-            params.count(logQueryLimit);\n-            params.match(getGlobalKeyByXid(\"*\"));\n-            ScanResult<String> scans;\n-            do {\n-                scans = jedis.scan(cursor, params);\n-                keys.addAll(scans.getResult());\n-                cursor = scans.getCursor();\n-            } while (!INITIAL_CURSOR.equals(cursor));\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<GlobalTransactionDO> globalTransactionDOs = new ArrayList<>();\n-                for (String globalKey : keys) {\n-                    GlobalTransactionDO globalTransactionDO =\n-                        JSON.parseObject(jedis.get(globalKey), GlobalTransactionDO.class);\n-                    if (globalTransactionDO != null && states.contains(globalTransactionDO.getStatus())) {\n-                        globalTransactionDOs.add(globalTransactionDO);\n-                    }\n-                }\n-                if (CollectionUtils.isNotEmpty(globalTransactionDOs)) {\n-                    List<String> xids =\n-                        globalTransactionDOs.stream().map(GlobalTransactionDO::getXid).collect(Collectors.toList());\n-                    List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n-                    for (String xid : xids) {\n-                        Set<String> branches = lRange(jedis, getBranchListKeyByXid(xid));\n-                        if (CollectionUtils.isNotEmpty(branches)) {\n-                            branchTransactionDOs.addAll(getBranchJsons(jedis, branches));\n-                        }\n-                    }\n-                    Map<String, List<BranchTransactionDO>> branchTransactionDOsMap =\n-                        branchTransactionDOs.stream().collect(Collectors.groupingBy(BranchTransactionDO::getXid,\n-                            LinkedHashMap::new, Collectors.toList()));\n-                    return globalTransactionDOs.stream()\n-                        .map(globalTransactionDO -> getGlobalSession(globalTransactionDO,\n-                            branchTransactionDOsMap.get(globalTransactionDO.getXid())))\n-                        .collect(Collectors.toList());\n-                }\n+            Pipeline pipelined = jedis.pipelined();\n+            statusKeys.stream().forEach(statusKey -> pipelined.lrange(statusKey,0,-1));\n+            List<List<String>> list = (List<List<String>>)(List)pipelined.syncAndReturnAll();\n+            List<String> xids = new ArrayList<>();\n+            if (CollectionUtils.isNotEmpty(list)) {\n+                xids = list.stream().flatMap(ll -> ll.stream()).collect(Collectors.toList());\n             }\n+            List<GlobalSession> globalSessions = new ArrayList<>();\n+            xids.parallelStream().forEach(xid -> {\n+                GlobalSession globalSession = this.readSession(xid, true);\n+                if (globalSession != null) {\n+                    globalSessions.add(globalSession);\n+                }\n+            });\n+            return globalSessions;\n         }\n-        return null;\n     }\n \n+    /**\n+     * read the global session list by different condition\n+     * @param sessionCondition the session condition\n+     * @return the global sessions\n+     */\n     @Override\n     public List<GlobalSession> readSession(SessionCondition sessionCondition) {\n-        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            if (!StringUtils.isEmpty(sessionCondition.getXid())) {\n-                String globalSessionJson = jedis.get(getGlobalKeyByXid(sessionCondition.getXid()));\n-                if (!StringUtils.isEmpty(globalSessionJson)) {\n-                    GlobalSession session =\n-                        convertGlobalSession(JSON.parseObject(globalSessionJson, GlobalTransactionDO.class));\n-                    List<GlobalSession> globalSessions = new ArrayList<>();\n-                    globalSessions.add(session);\n-                    return globalSessions;\n-                }\n-            } else if (sessionCondition.getTransactionId() != null) {\n-                String global = jedis.get(getGlobalKeyByTransactionId(sessionCondition.getTransactionId()));\n-                if (StringUtils.isEmpty(global)) {\n-                    return null;\n-                }\n-                GlobalTransactionDO globalTransactionDO = JSON.parseObject(global, GlobalTransactionDO.class);\n-                String branchKey = getBranchListKeyByXid(globalTransactionDO.getXid());\n-                Set<String> keys = lRange(jedis, branchKey);\n-                List<BranchTransactionDO> branchTransactionDOs = null;\n-                if (CollectionUtils.isNotEmpty(keys)) {\n-                    branchTransactionDOs = getBranchJsons(jedis, keys);\n-                }\n-                GlobalSession globalSession = getGlobalSession(globalTransactionDO, branchTransactionDOs);\n-                List<GlobalSession> globalSessions = new ArrayList<>();\n+        List<GlobalSession> globalSessions = new ArrayList<>();\n+        if (StringUtils.isNotEmpty(sessionCondition.getXid())) {\n+            GlobalSession globalSession = this.readSession(sessionCondition.getXid(), true);\n+            if (globalSession != null) {\n                 globalSessions.add(globalSession);\n-                return globalSessions;\n-            } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n-                return readSession(sessionCondition.getStatuses());\n             }\n+            return globalSessions;\n+        } else if (sessionCondition.getTransactionId() != null) {\n+            GlobalSession globalSession = this\n+                    .readSessionByTransactionId(sessionCondition.getTransactionId().toString(), true);\n+            if (globalSession != null) {\n+                globalSessions.add(globalSession);\n+            }\n+            return globalSessions;\n+        } else if (CollectionUtils.isNotEmpty(sessionCondition.getStatuses())) {\n+            return readSession(sessionCondition.getStatuses());\n+        } else if (sessionCondition.getStatus() != null) {\n+            return readSession(new GlobalStatus[]{sessionCondition.getStatus()});\n         }\n         return null;\n     }\n \n-    private List<BranchTransactionDO> getBranchJsons(Jedis jedis, Set<String> keys) {\n-        List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n-        List<String> branchJsons = jedis.mget(keys.toArray(new String[0]));\n-        for (String branchJson : branchJsons) {\n-            if (!StringUtils.isEmpty(branchJson)) {\n-                branchTransactionDOs.add(JSON.parseObject(branchJson, BranchTransactionDO.class));\n+    /**\n+     * assemble the global session and branch session\n+     * @param globalTransactionDO the global transactionDo\n+     * @param branchTransactionDOs the branch transactionDos\n+     * @return the global session with branch session\n+     */\n+    private GlobalSession getGlobalSession(GlobalTransactionDO globalTransactionDO,\n+            List<BranchTransactionDO> branchTransactionDOs) {\n+        GlobalSession globalSession = SessionConverter.convertGlobalSession(globalTransactionDO);\n+        if (CollectionUtils.isNotEmpty(branchTransactionDOs)) {\n+            for (BranchTransactionDO branchTransactionDO : branchTransactionDOs) {\n+                globalSession.add(SessionConverter.convertBranchSession(branchTransactionDO));\n             }\n         }\n-        return branchTransactionDOs;\n+        return globalSession;\n     }\n \n-    private GlobalTransactionDO convertGlobalTransactionDO(SessionStorable session) {\n-        if (session == null || !(session instanceof GlobalSession)) {\n-            throw new IllegalArgumentException(\n-                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+    /**\n+     * read the global session by transactionId\n+     * @param transactionId the transaction id\n+     * @param withBranchSessions if read branch sessions\n+     * @return the global session\n+     */\n+    private GlobalSession readSessionByTransactionId(String transactionId, boolean withBranchSessions) {\n+        String globalKey = buildGlobalKeyByTransactionId(transactionId);\n+        String xid = null;\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Map<String, String> map  = jedis.hgetAll(globalKey);\n+            if (CollectionUtils.isEmpty(map)) {\n+                return null;\n+            }\n+            GlobalTransactionDO globalTransactionDO = (GlobalTransactionDO)BeanUtils.mapToObject(map, GlobalTransactionDO.class);\n+            if (globalTransactionDO != null) {\n+                xid = globalTransactionDO.getXid();\n+            }\n+            List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+            if (withBranchSessions) {\n+                branchTransactionDOs = this.readBranchSessionByXid(jedis,xid);\n+            }\n+            return getGlobalSession(globalTransactionDO,branchTransactionDOs);\n         }\n-        GlobalSession globalSession = (GlobalSession)session;\n-\n-        GlobalTransactionDO globalTransactionDO = new GlobalTransactionDO();\n-        globalTransactionDO.setXid(globalSession.getXid());\n-        globalTransactionDO.setStatus(globalSession.getStatus().getCode());\n-        globalTransactionDO.setApplicationId(globalSession.getApplicationId());\n-        globalTransactionDO.setBeginTime(globalSession.getBeginTime());\n-        globalTransactionDO.setTimeout(globalSession.getTimeout());\n-        globalTransactionDO.setTransactionId(globalSession.getTransactionId());\n-        globalTransactionDO.setTransactionName(globalSession.getTransactionName());\n-        globalTransactionDO.setTransactionServiceGroup(globalSession.getTransactionServiceGroup());\n-        globalTransactionDO.setApplicationData(globalSession.getApplicationData());\n-        return globalTransactionDO;\n     }\n \n-    private BranchTransactionDO convertBranchTransactionDO(SessionStorable session) {\n-        if (session == null || !(session instanceof BranchSession)) {\n-            throw new IllegalArgumentException(\n-                \"the parameter of SessionStorable is not available, SessionStorable:\" + StringUtils.toString(session));\n+    /**\n+     * Read the branch session list by xid\n+     * @param jedis\n+     * @param xid the xid\n+     * @return the branch transactionDo list\n+     */\n+    private List<BranchTransactionDO> readBranchSessionByXid(Jedis jedis,String xid) {\n+        List<BranchTransactionDO> branchTransactionDOs = new ArrayList<>();\n+        String branchListKey = buildBranchListKeyByXid(xid);\n+        List<String> branchKeys = jedis.lrange(branchListKey, 0, -1);\n+        Pipeline pipeline = jedis.pipelined();\n+        if (CollectionUtils.isNotEmpty(branchKeys)) {\n+            branchKeys.stream().forEachOrdered(branchKey -> pipeline.hgetAll(branchKey));\n+            List<Object> branchInfos = pipeline.syncAndReturnAll();\n+            for (Object branchInfo : branchInfos) {\n+                if (branchInfo != null) {\n+                    Map<String, String> branchInfoMap = (Map<String, String>) branchInfo;\n+                    BranchTransactionDO branchTransactionDO =\n+                            (BranchTransactionDO) BeanUtils.mapToObject(branchInfoMap, BranchTransactionDO.class);\n+                    branchTransactionDOs.add(branchTransactionDO);\n+                }\n+            }\n         }\n-        BranchSession branchSession = (BranchSession)session;\n-\n-        BranchTransactionDO branchTransactionDO = new BranchTransactionDO();\n-        branchTransactionDO.setXid(branchSession.getXid());\n-        branchTransactionDO.setBranchId(branchSession.getBranchId());\n-        branchTransactionDO.setBranchType(branchSession.getBranchType().name());\n-        branchTransactionDO.setClientId(branchSession.getClientId());\n-        branchTransactionDO.setResourceGroupId(branchSession.getResourceGroupId());\n-        branchTransactionDO.setTransactionId(branchSession.getTransactionId());\n-        branchTransactionDO.setApplicationData(branchSession.getApplicationData());\n-        branchTransactionDO.setResourceId(branchSession.getResourceId());\n-        branchTransactionDO.setStatus(branchSession.getStatus().getCode());\n-        return branchTransactionDO;\n-    }\n-\n-    private GlobalSession convertGlobalSession(GlobalTransactionDO globalTransactionDO) {\n-        GlobalSession session =\n-            new GlobalSession(globalTransactionDO.getApplicationId(), globalTransactionDO.getTransactionServiceGroup(),\n-                globalTransactionDO.getTransactionName(), globalTransactionDO.getTimeout());\n-        session.setTransactionId(globalTransactionDO.getTransactionId());\n-        session.setXid(globalTransactionDO.getXid());\n-        session.setStatus(GlobalStatus.get(globalTransactionDO.getStatus()));\n-        session.setApplicationData(globalTransactionDO.getApplicationData());\n-        session.setBeginTime(globalTransactionDO.getBeginTime());\n-        return session;\n-    }\n-\n-    private BranchSession convertBranchSession(BranchTransactionDO branchTransactionDO) {\n-        BranchSession branchSession = new BranchSession();\n-        branchSession.setXid(branchTransactionDO.getXid());\n-        branchSession.setTransactionId(branchTransactionDO.getTransactionId());\n-        branchSession.setApplicationData(branchTransactionDO.getApplicationData());\n-        branchSession.setBranchId(branchTransactionDO.getBranchId());\n-        branchSession.setBranchType(BranchType.valueOf(branchTransactionDO.getBranchType()));\n-        branchSession.setResourceId(branchTransactionDO.getResourceId());\n-        branchSession.setClientId(branchTransactionDO.getClientId());\n-        branchSession.setResourceGroupId(branchTransactionDO.getResourceGroupId());\n-        branchSession.setStatus(BranchStatus.get(branchTransactionDO.getStatus()));\n-        return branchSession;\n-    }\n-\n-    private GlobalSession getGlobalSession(GlobalTransactionDO globalTransactionDO,\n-        List<BranchTransactionDO> branchTransactionDOs) {\n-        GlobalSession globalSession = convertGlobalSession(globalTransactionDO);\n-        // branch transactions\n         if (CollectionUtils.isNotEmpty(branchTransactionDOs)) {\n-            for (BranchTransactionDO branchTransactionDO : branchTransactionDOs) {\n-                globalSession.add(convertBranchSession(branchTransactionDO));\n-            }\n+            branchTransactionDOs = branchTransactionDOs.stream().sorted(Comparator.comparing(BranchTransactionDO::getGmtCreate))\n+                    .collect(Collectors.toList());\n         }\n-        return globalSession;\n+        return branchTransactionDOs;\n     }\n \n-    private Set<String> lRange(Jedis jedis, String key) {\n-        Set<String> keys = new HashSet<>();\n-        List<String> redisBranchJson;\n-        int start = 0;\n-        int stop = logQueryLimit;\n-        do {\n-            redisBranchJson = jedis.lrange(key, start, stop);\n-            keys.addAll(redisBranchJson);\n-            start = keys.size();\n-            stop = start + logQueryLimit;\n-        } while (CollectionUtils.isNotEmpty(redisBranchJson));\n-        return keys;\n+    private String buildBranchListKeyByXid(String xid) {\n+        return REDIS_SEATA_BRANCHES_PREFIX + xid;\n     }\n \n-    private String getGlobalKeyByXid(String xid) {\n-        return DEFAULT_REDIS_SEATA_GLOBAL_SESSION_PREFIX + xid;\n+    private String buildGlobalKeyByTransactionId(Long transactionId) {\n+        return REDIS_SEATA_GLOBAL_PREFIX + transactionId;\n     }\n-\n-    private String getBranchListKeyByXid(String xid) {\n-        return DEFAULT_REDIS_SEATA_XID_BRANCHS_PREFIX + xid;\n+    private String buildGlobalKeyByTransactionId(String transactionId) {", "originalCommit": "ef32fc3fa0617c52a79ed676e2d581881c25df61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0OTA2OA==", "url": "https://github.com/seata/seata/pull/3062#discussion_r503149068", "bodyText": "Can be changed to Map<String,String> map = new HashMap<>(2, 1);", "author": "ph3636", "createdAt": "2020-10-12T09:07:32Z", "path": "server/src/main/java/io/seata/server/storage/redis/store/RedisTransactionStoreManager.java", "diffHunk": "@@ -90,100 +94,230 @@ public static RedisTransactionStoreManager getInstance() {\n     @Override\n     public boolean writeSession(LogOperation logOperation, SessionStorable session) {\n         if (LogOperation.GLOBAL_ADD.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.GLOBAL_REMOVE.equals(logOperation)) {\n-            return deleteGlobalTransactionDO(convertGlobalTransactionDO(session));\n+            return deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));\n         } else if (LogOperation.BRANCH_ADD.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_UPDATE.equals(logOperation)) {\n-            return insertOrUpdateBranchTransactionDO(convertBranchTransactionDO(session));\n+            return updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else if (LogOperation.BRANCH_REMOVE.equals(logOperation)) {\n-            return deleteBranchTransactionDO(convertBranchTransactionDO(session));\n+            return deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));\n         } else {\n             throw new StoreException(\"Unknown LogOperation:\" + logOperation.name());\n         }\n     }\n \n+    /**\n+     * Insert branch transaction\n+     * @param branchTransactionDO\n+     * @return the boolean\n+     */\n+    private boolean insertBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n+        String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+        try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n+            Date now = new Date();\n+            branchTransactionDO.setGmtCreate(now);\n+            branchTransactionDO.setGmtModified(now);\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.hmset(branchKey, BeanUtils.objectToMap(branchTransactionDO));\n+            pipelined.rpush(branchListKey, branchKey);\n+            pipelined.sync();\n+            return true;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Delete the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n     private boolean deleteBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            jedis.del(key);\n+            Map<String, String> branchTransactionDOMap = jedis.hgetAll(branchKey);\n+            String xid = branchTransactionDOMap.get(REDIS_KEY_BRANCH_XID);\n+            if (StringUtils.isEmpty(xid)) {\n+                return true;\n+            }\n+            String branchListKey = buildBranchListKeyByXid(branchTransactionDO.getXid());\n+            Pipeline pipelined = jedis.pipelined();\n+            pipelined.lrem(branchListKey, 0, branchKey);\n+            pipelined.del(branchKey);\n+            pipelined.sync();\n             return true;\n+        } catch (Exception ex) {\n+            throw new RedisException(ex);\n         }\n     }\n \n-    private boolean insertOrUpdateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+    /**\n+     * Update the branch transaction\n+     * @param branchTransactionDO\n+     * @return\n+     */\n+    private boolean updateBranchTransactionDO(BranchTransactionDO branchTransactionDO) {\n+        String branchKey = buildBranchKey(branchTransactionDO.getBranchId());\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String key = getBranchKey(branchTransactionDO.getBranchId());\n-            String branch = jedis.get(key);\n-            Pipeline pipeline = jedis.pipelined();\n-            if (StringUtils.isEmpty(branch)) {\n-                pipeline.lpush(getBranchListKeyByXid(branchTransactionDO.getXid()), key);\n+            String previousBranchStatus = jedis.hget(branchKey, REDIS_KEY_BRANCH_STATUS);\n+            if (StringUtils.isEmpty(previousBranchStatus)) {\n+                throw new StoreException(\"Branch transaction is not exist, update branch transaction failed.\");\n             }\n-            pipeline.set(key, JSON.toJSONString(branchTransactionDO));\n-            pipeline.sync();\n+            Map<String,String> map = new HashMap<>(2);", "originalCommit": "ef32fc3fa0617c52a79ed676e2d581881c25df61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6d4974f76cde268cebbacff7cc112de8430725d9", "url": "https://github.com/seata/seata/commit/6d4974f76cde268cebbacff7cc112de8430725d9", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-10-12T09:26:21Z", "type": "commit"}, {"oid": "02b67f72c0426d5f6db3b5b755057e43fc0e55cf", "url": "https://github.com/seata/seata/commit/02b67f72c0426d5f6db3b5b755057e43fc0e55cf", "message": "optimize:the map and buildGlobalKeyByTransactionId", "committedDate": "2020-10-12T09:53:24Z", "type": "commit"}, {"oid": "3cbea23731b7925e89e889412752764c6d82b05c", "url": "https://github.com/seata/seata/commit/3cbea23731b7925e89e889412752764c6d82b05c", "message": "Merge branch 'develop' into refactor_redis_session", "committedDate": "2020-10-12T10:45:18Z", "type": "commit"}, {"oid": "105a79bbf9ed76469f66c6c65c1a6d52408f2b9a", "url": "https://github.com/seata/seata/commit/105a79bbf9ed76469f66c6c65c1a6d52408f2b9a", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis_session", "committedDate": "2020-10-13T11:43:30Z", "type": "commit"}, {"oid": "7ab7a9ea6a6791f16e8a162b84feb3fd4dd645f2", "url": "https://github.com/seata/seata/commit/7ab7a9ea6a6791f16e8a162b84feb3fd4dd645f2", "message": "Merge branch 'develop' into refactor_redis_session", "committedDate": "2020-10-15T15:18:10Z", "type": "commit"}, {"oid": "d6a03f7effd7f5cf41b604757c9d9e1667346e06", "url": "https://github.com/seata/seata/commit/d6a03f7effd7f5cf41b604757c9d9e1667346e06", "message": "fix:the conflict", "committedDate": "2020-10-19T05:53:40Z", "type": "commit"}, {"oid": "47187eb0a44d2fb0b61e858bc9da76e1919c3d51", "url": "https://github.com/seata/seata/commit/47187eb0a44d2fb0b61e858bc9da76e1919c3d51", "message": "Merge branch 'refactor_redis_session' of github.com:lightClouds917/seata into refactor_redis_session", "committedDate": "2020-10-19T05:56:07Z", "type": "commit"}]}