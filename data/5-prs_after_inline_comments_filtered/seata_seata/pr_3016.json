{"pr_number": 3016, "pr_title": "optimize: refactor the redis lock string to hash", "pr_createdAt": "2020-08-14T01:36:57Z", "pr_url": "https://github.com/seata/seata/pull/3016", "timeline": [{"oid": "b133981aebf2df9e30465bbd09896623c81ed776", "url": "https://github.com/seata/seata/commit/b133981aebf2df9e30465bbd09896623c81ed776", "message": "refactor:the redis lock string to hash", "committedDate": "2020-08-14T01:06:18Z", "type": "commit"}, {"oid": "0a0fe6e82c988178511a2212d1e7e4b9f556ceb7", "url": "https://github.com/seata/seata/commit/0a0fe6e82c988178511a2212d1e7e4b9f556ceb7", "message": "optimize:code format", "committedDate": "2020-08-14T01:56:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MzQwNA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r470383404", "bodyText": "cannot play the role of competition lock", "author": "a364176773", "createdAt": "2020-08-14T03:01:58Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -70,59 +87,80 @@ public boolean acquireLock(List<RowLock> rowLocks) {\n             return true;\n         }\n         Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        String status = OK;\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<Object> existedXidObjs = pipeline1.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedXidObjs;\n+            Map<String, LockDO> map = new HashMap<>(needLockKeys.size(), 1);\n+\n+            String needLockXid = rowLocks.get(0).getXid();\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedXid = existedXids.get(i);\n+                if (StringUtils.isEmpty(existedXid)) {\n+                    //If empty,we need to lock this row\n+                    map.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n+\n             if (map.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n             map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+                Map<String, String> lockMap = new HashMap<>(8);\n+                lockMap.put(XID, value.getXid());\n+                lockMap.put(TRANSACTION_ID, value.getTransactionId().toString());\n+                lockMap.put(BRANCH_ID, value.getBranchId().toString());\n+                lockMap.put(RESOURCE_ID, value.getResourceId());\n+                lockMap.put(TABLE_NAME, value.getTableName());\n+                lockMap.put(ROW_KEY, value.getRowKey());\n+                lockMap.put(PK, value.getPk());\n+                pipeline.hmset(key, lockMap);", "originalCommit": "0a0fe6e82c988178511a2212d1e7e4b9f556ceb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MDIxNA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r471970214", "bodyText": "fixed.", "author": "lightClouds917", "createdAt": "2020-08-18T07:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MzQwNA=="}], "type": "inlineReview"}, {"oid": "14f8ec02faa91ce4f94d4bc59e435066a862e61b", "url": "https://github.com/seata/seata/commit/14f8ec02faa91ce4f94d4bc59e435066a862e61b", "message": "refactor:refactor the redis lock data structure", "committedDate": "2020-08-18T03:53:59Z", "type": "commit"}, {"oid": "92275de275a98b11baf0ee39de54927d80faf659", "url": "https://github.com/seata/seata/commit/92275de275a98b11baf0ee39de54927d80faf659", "message": "refactor:refactor the redis lock data structure", "committedDate": "2020-08-18T04:37:10Z", "type": "commit"}, {"oid": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "url": "https://github.com/seata/seata/commit/1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "message": "fix:the hsetnx response", "committedDate": "2020-08-18T07:42:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NDQ0NA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r471984444", "bodyText": "partitions.get(i).contains", "author": "a364176773", "createdAt": "2020-08-18T07:50:33Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {", "originalCommit": "92275de275a98b11baf0ee39de54927d80faf659", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjA3NQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126075", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NDQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjU2MQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r471986561", "bodyText": "del successSet. toArray (new String[0])", "author": "a364176773", "createdAt": "2020-08-18T07:54:19Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,178 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "originalCommit": "92275de275a98b11baf0ee39de54927d80faf659", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjEwNQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126105", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTU0MA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r471991540", "bodyText": "only need to xid", "author": "a364176773", "createdAt": "2020-08-18T08:02:33Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjEyNA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126124", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5Nzc4Nw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r471997787", "bodyText": "List< Integer > results = (List) (List) pipeline.syncAndReturnAll();", "author": "a364176773", "createdAt": "2020-08-18T08:13:32Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjE0Nw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126147", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5Nzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk2Ng==", "url": "https://github.com/seata/seata/pull/3016#discussion_r471999966", "bodyText": "the lock can only be actively unlocked by the owner without having to retrieve it again", "author": "a364176773", "createdAt": "2020-08-18T08:17:15Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjE3MQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126171", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDEzNg==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472004136", "bodyText": "only need to xid", "author": "a364176773", "createdAt": "2020-08-18T08:24:03Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDM0OQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472004349", "bodyText": "only need to xid", "author": "a364176773", "createdAt": "2020-08-18T08:24:24Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjE5NQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126195", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNTU2NA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472005564", "bodyText": "del needReleaseKeys. toArray (new String[0])", "author": "a364176773", "createdAt": "2020-08-18T08:26:19Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjIzNA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126234", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTU1NQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472011555", "bodyText": "del rowkey", "author": "a364176773", "createdAt": "2020-08-18T08:35:51Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjI2Mw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126263", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTYzMQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472011631", "bodyText": "del rowkey", "author": "a364176773", "createdAt": "2020-08-18T08:35:58Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +87,179 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(\n+                    needLockKey -> pipeline1.hmget(needLockKey, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipeline1.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info == null)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockInfo.get(0), needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n+                        LOGGER.error(\n+                                \"Acquire lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n             List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results2 = (List<Integer>) (List) results;\n+            List<List<Integer>> partitions = Lists.partition(results2, 7);\n+\n+            Set<String> successSet = new HashSet<>();\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    successSet.add(key);\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (successSet.size() > 0) {\n+                    Pipeline pipeline2 = jedis.pipelined();\n+                    successSet.forEach(locKey ->\n+                            pipeline2.hdel(locKey, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                                    TABLE_NAME, ROW_KEY, PK));\n+                    pipeline2.sync();\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());\n+            return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        String[] keys = new String[rowLocks.size()];\n-        List<LockDO> locks = convertToLockDO(rowLocks);\n-        for (int i = 0; i < locks.size(); i++) {\n-            String key = getLockKey(locks.get(i).getRowKey());\n-            keys[i] = key;\n-        }\n+        String currentXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+        List<String> needReleaseKeys = new ArrayList<>(rowLocks.size());\n+        List<LockDO> needReleaseLocks = convertToLockDO(rowLocks);\n+        needReleaseLocks.stream()\n+                .forEach(lockDO -> needReleaseKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-            Pipeline pipeline = jedis.pipelined();\n-            pipeline.del(keys);\n-            Arrays.stream(keys).forEach(key -> pipeline.lrem(xidLockKey, 0, key));\n-            pipeline.sync();\n+            Pipeline pipelined = jedis.pipelined();\n+            needReleaseKeys.stream()\n+                    .forEach(key -> pipelined.hmget(key, XID, TABLE_NAME, PK, BRANCH_ID));\n+            List<Object> existedObjs = pipelined.syncAndReturnAll();\n+            List<List<String>> existedLockInfos = (List<List<String>>) (List) existedObjs;\n+\n+            for (int i = 0; i < existedLockInfos.size(); i++) {\n+                List<String> existedLockInfo = existedLockInfos.get(i);\n+                if (CollectionUtils.isNotEmpty(existedLockInfo) ||\n+                        existedLockInfo.stream().allMatch(info -> info != null)) {\n+                    if (!StringUtils.equals(currentXid, existedLockInfo.get(0))) {\n+                        LOGGER.error(\n+                                \"Release lock failed,Global lock on [{}:{}] is holding by xid {} branchId {}\",\n+                                existedLockInfo.get(1), existedLockInfo.get(2),\n+                                existedLockInfo.get(0), existedLockInfo.get(3));\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            Pipeline pipelined1 = jedis.pipelined();\n+            needReleaseKeys.stream().forEach(key ->\n+                    pipelined1.hdel(key, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,\n+                            TABLE_NAME, ROW_KEY, PK));\n+            pipelined1.hdel(buildXidLockKey(currentXid), branchId.toString());\n+            pipelined1.sync();\n             return true;\n         }\n     }\n \n     @Override\n     public boolean releaseLock(String xid, List<Long> branchIds) {\n         if (CollectionUtils.isEmpty(branchIds)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            String lockListKey = getXidLockKey(xid);\n-            Set<String> keys = lRange(jedis, lockListKey);\n-            if (CollectionUtils.isNotEmpty(keys)) {\n-                List<String> delKeys = new ArrayList<>();\n-                List<String> values = jedis.mget(keys.toArray(new String[0]));\n-                for (String value : values) {\n-                    Iterator<Long> it = branchIds.iterator();\n-                    LockDO lock = JSON.parseObject(value, LockDO.class);\n-                    while (it.hasNext()) {\n-                        Long branchId = it.next();\n-                        if (lock != null && Objects.equals(lock.getBranchId(), branchId)) {\n-                            delKeys.add(getLockKey(lock.getRowKey()));\n-                            break;\n+            String xidLockKey = buildXidLockKey(xid);\n+            String[] branchIdsArray = new String[branchIds.size()];\n+            for (int i = 0; i < branchIds.size(); i++) {\n+                branchIdsArray[i] = branchIds.get(i).toString();\n+            }\n+            List<String> rowKeys = jedis.hmget(xidLockKey, branchIdsArray);\n+\n+            if (CollectionUtils.isNotEmpty(rowKeys)) {\n+                Pipeline pipelined = jedis.pipelined();\n+                pipelined.hdel(xidLockKey, branchIdsArray);\n+                rowKeys.stream().forEach(rowKeyStr -> {\n+                    if (StringUtils.isNotEmpty(rowKeyStr)) {\n+                        if (rowKeyStr.contains(SEMICOLON)) {\n+                            String[] keys = rowKeyStr.split(SEMICOLON);\n+                            Arrays.asList(keys).stream().forEach(rowKey -> {\n+                                if (StringUtils.isNotEmpty(rowKey)) {\n+                                    pipelined.hdel(rowKey, XID, TRANSACTION_ID, BRANCH_ID,\n+                                            RESOURCE_ID, TABLE_NAME, ROW_KEY, PK);\n+                                }\n+                            });\n+                        } else {\n+                            pipelined.hdel(rowKeyStr, XID, TRANSACTION_ID, BRANCH_ID, RESOURCE_ID,", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjMxNQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126315", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMjYxNw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472012617", "bodyText": "List existedXids = (List) (List) pipeline.syncAndReturnAll();", "author": "a364176773", "createdAt": "2020-08-18T08:37:34Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +282,23 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<Object> existedRowLockXid = pipeline.syncAndReturnAll();\n+            List<String> existedXids = (List<String>) (List) existedRowLockXid;", "originalCommit": "1f4cca9c462a0d18a58d8cdd23a7d97fdbaaeb4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyNjMzNw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472126337", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-18T12:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxMjYxNw=="}], "type": "inlineReview"}, {"oid": "f4a0ebb5653704e50bccc07f0b39a60ec9f2d131", "url": "https://github.com/seata/seata/commit/f4a0ebb5653704e50bccc07f0b39a60ec9f2d131", "message": "optimize:the code", "committedDate": "2020-08-18T11:16:49Z", "type": "commit"}, {"oid": "93bb511d77726bee31b4f21fbb72561314497ba6", "url": "https://github.com/seata/seata/commit/93bb511d77726bee31b4f21fbb72561314497ba6", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis", "committedDate": "2020-08-18T11:30:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5NTE1MQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472195151", "bodyText": "hset enough", "author": "a364176773", "createdAt": "2020-08-18T13:27:08Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()\n+                        .getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {\n+                needLockDOS = needLockDOS.stream().\n+                        filter(LambdaUtils.distinctByKey(LockDO::getRowKey))\n+                        .collect(Collectors.toList());\n             }\n-            List<String> existedKeyList = new ArrayList<>();\n-            locks.forEach(lockDO -> {\n-                existedKeyList.add(getLockKey(lockDO.getRowKey()));\n-            });\n-            List<String> lockList = jedis.mget(existedKeyList.toArray(new String[0]));\n-            Map<String, String> map = new HashMap<>(existedKeyList.size(), 1);\n-            for (int i = 0; i < existedKeyList.size(); i++) {\n-                String existedValue = lockList.get(i);\n-                if (existedValue == null) {\n-                    String key = existedKeyList.get(i);\n-                    map.put(key, JSON.toJSONString(locks.get(i)));\n+            List<String> needLockKeys = new ArrayList<>();\n+            needLockDOS.forEach(lockDO -> needLockKeys.add(buildLockKey(lockDO.getRowKey())));\n+\n+            Pipeline pipeline1 = jedis.pipelined();\n+            needLockKeys.stream().forEachOrdered(needLockKey -> pipeline1.hget(needLockKey, XID));\n+            List<String> existedLockInfos = (List<String>) (List) pipeline1.syncAndReturnAll();\n+            Map<String, LockDO> needAddLock = new HashMap<>(needLockKeys.size(), 1);\n+\n+            for (int i = 0; i < needLockKeys.size(); i++) {\n+                String existedLockXid = existedLockInfos.get(i);\n+                if (StringUtils.isEmpty(existedLockXid)) {\n+                    //If empty,we need to lock this row\n+                    needAddLock.put(needLockKeys.get(i), needLockDOS.get(i));\n                 } else {\n-                    LockDO existed = JSON.parseObject(existedValue, LockDO.class);\n-                    if (!StringUtils.equals(existed.getXid(), locks.get(i).getXid())) {\n+                    if (!StringUtils.equals(existedLockXid, needLockXid)) {\n+                        //If not equals,means the rowkey is holding by another global transaction\n                         return false;\n                     }\n                 }\n             }\n-            if (map.isEmpty()) {\n+\n+            if (needAddLock.isEmpty()) {\n                 return true;\n             }\n             Pipeline pipeline = jedis.pipelined();\n             List<String> readyKeys = new ArrayList<>();\n-            map.forEach((key, value) -> {\n-                pipeline.setnx(key, value);\n+            needAddLock.forEach((key, value) -> {\n+                pipeline.hsetnx(key, XID, value.getXid());\n+                pipeline.hsetnx(key, TRANSACTION_ID, value.getTransactionId().toString());\n+                pipeline.hsetnx(key, BRANCH_ID, value.getBranchId().toString());\n+                pipeline.hsetnx(key, RESOURCE_ID, value.getResourceId());\n+                pipeline.hsetnx(key, TABLE_NAME, value.getTableName());\n+                pipeline.hsetnx(key, ROW_KEY, value.getRowKey());\n+                pipeline.hsetnx(key, PK, value.getPk());\n                 readyKeys.add(key);\n             });\n-            List<Object> results = pipeline.syncAndReturnAll();\n-            for (int i = 0; i < results.size(); i++) {\n-                Long result = (long)results.get(i);\n+            List<Integer> results = (List<Integer>) (List) pipeline.syncAndReturnAll();\n+            List<List<Integer>> partitions = Lists.partition(results, 7);\n+\n+            String[] success = new String[partitions.size()];\n+            for (int i = 0; i < partitions.size(); i++) {\n                 String key = readyKeys.get(i);\n-                if (result != 1) {\n-                    status = result;\n+                if (partitions.get(i).contains(FAILED)) {\n+                    status = FAILED;\n                 } else {\n-                    successList.add(key);\n+                    success[0] = key;\n                 }\n             }\n-            if (status != 1) {\n-                String[] rms = successList.toArray(new String[0]);\n-                if (rms.length > 0) {\n-                    jedis.del(rms);\n+\n+            //If someone has failed,all the lockkey which has been added need to be delete.\n+            if (FAILED.equals(status)) {\n+                if (success.length > 0) {\n+                    jedis.del(success);\n                 }\n                 return false;\n-            } else {\n-                try {\n-                    String xidLockKey = getXidLockKey(locks.get(0).getXid());\n-                    jedis.lpush(xidLockKey, readyKeys.toArray(new String[0]));\n-                } catch (Exception e) {\n-                    return false;\n-                }\n-                return true;\n             }\n+            String xidLockKey = buildXidLockKey(needLockXid);\n+            StringJoiner lockKeysString = new StringJoiner(SEMICOLON);\n+            needLockKeys.stream().forEach(lockKey -> lockKeysString.add(lockKey));\n+            jedis.hsetnx(xidLockKey, branchId.toString(), lockKeysString.toString());", "originalCommit": "93bb511d77726bee31b4f21fbb72561314497ba6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU3Nzc3NQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472577775", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-19T01:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5NTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MjI0Mw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472242243", "bodyText": "please pay attention to this problem: list All elements are null\nexistedXids.size>0", "author": "a364176773", "createdAt": "2020-08-18T14:31:26Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -207,41 +237,22 @@ public boolean isLockable(List<RowLock> rowLocks) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> xid.equals(existedXid));", "originalCommit": "93bb511d77726bee31b4f21fbb72561314497ba6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU3Nzc4OQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472577789", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-19T01:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MjI0Mw=="}], "type": "inlineReview"}, {"oid": "01974758bf4ac6b928f6e53b8c1d02f904fa6fe0", "url": "https://github.com/seata/seata/commit/01974758bf4ac6b928f6e53b8c1d02f904fa6fe0", "message": "fix:list All elements are null", "committedDate": "2020-08-19T01:04:12Z", "type": "commit"}, {"oid": "d83284f57fa41a676592c7561c742028e0034a44", "url": "https://github.com/seata/seata/commit/d83284f57fa41a676592c7561c742028e0034a44", "message": "format:format the code", "committedDate": "2020-08-19T01:14:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4NTM1OA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472585358", "bodyText": "don't need the logQueryLimit", "author": "a364176773", "createdAt": "2020-08-19T01:39:15Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -60,131 +82,139 @@\n      */\n     public RedisLocker() {\n         logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n+                ConfigurationFactory.getInstance()", "originalCommit": "d83284f57fa41a676592c7561c742028e0034a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0MTAxNw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r472641017", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-19T03:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4NTM1OA=="}], "type": "inlineReview"}, {"oid": "3897037fa6655229355028e6bcbef63bd0714bb4", "url": "https://github.com/seata/seata/commit/3897037fa6655229355028e6bcbef63bd0714bb4", "message": "del:the logQueryLimit", "committedDate": "2020-08-19T01:59:38Z", "type": "commit"}, {"oid": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "url": "https://github.com/seata/seata/commit/91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis", "committedDate": "2020-08-19T03:09:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3MzE5OA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r475473198", "bodyText": "Can be completed or deleted", "author": "ph3636", "createdAt": "2020-08-24T09:37:52Z", "path": "common/src/main/java/io/seata/common/Constants.java", "diffHunk": "@@ -40,8 +41,15 @@\n      */\n     public static final String DBKEYS_SPLIT_CHAR = \",\";\n \n-    /** the start time of transaction */\n-    public static final String START_TIME  = \"start-time\";\n+    /**\n+     * The constant ;", "originalCommit": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA3NjAzNA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r477076034", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-26T06:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3MzE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDA0MQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r475474041", "bodyText": "Can be placed below", "author": "ph3636", "createdAt": "2020-08-24T09:38:54Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -15,23 +15,21 @@\n  */\n package io.seata.server.storage.redis.lock;\n \n+import static io.seata.common.Constants.SEMICOLON;\n+\n+import com.google.common.collect.Lists;", "originalCommit": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzMjM3Mg==", "url": "https://github.com/seata/seata/pull/3016#discussion_r477132372", "bodyText": "It seemed that the java package was on the top", "author": "ph3636", "createdAt": "2020-08-26T08:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA5ODU1OA==", "url": "https://github.com/seata/seata/pull/3016#discussion_r478098558", "bodyText": "It seemed that the java package was on the top\n\nfinished", "author": "lightClouds917", "createdAt": "2020-08-27T04:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r475475275", "bodyText": "Remove equal to", "author": "ph3636", "createdAt": "2020-08-24T09:41:09Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -40,151 +38,170 @@\n import redis.clients.jedis.Pipeline;\n \n /**\n+ * The redis lock store operation\n+ *\n  * @author funkye\n+ * @author wangzhongxiang\n  */\n public class RedisLocker extends AbstractLocker {\n \n-    private static final Integer DEFAULT_QUERY_LIMIT = 100;\n+    private static final Integer SUCCEED = 1;\n+\n+    private static final Integer FAILED = 0;\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_PREFIX = \"SEATA_LOCK_\";\n \n     private static final String DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX = \"SEATA_LOCK_XID_\";\n \n-    /**\n-     * The query limit.\n-     */\n-    private int logQueryLimit;\n+    private static final String XID = \"xid\";\n+\n+    private static final String TRANSACTION_ID = \"transactionId\";\n+\n+    private static final String BRANCH_ID = \"branchId\";\n+\n+    private static final String RESOURCE_ID = \"resourceId\";\n+\n+    private static final String TABLE_NAME = \"tableName\";\n+\n+    private static final String PK = \"pk\";\n+\n+    private static final String ROW_KEY = \"rowKey\";\n \n     /**\n      * Instantiates a new Redis locker.\n      */\n     public RedisLocker() {\n-        logQueryLimit =\n-            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.STORE_REDIS_QUERY_LIMIT, DEFAULT_QUERY_LIMIT);\n     }\n \n     @Override\n     public boolean acquireLock(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n-        Set<String> successList = new HashSet<>();\n-        long status = 1;\n+        Integer status = SUCCEED;\n+        String needLockXid = rowLocks.get(0).getXid();\n+        Long branchId = rowLocks.get(0).getBranchId();\n+\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n-            List<LockDO> locks = convertToLockDO(rowLocks);\n-            if (locks.size() > 1) {\n-                locks =\n-                    locks.stream().filter(LambdaUtils.distinctByKey(LockDO::getRowKey)).collect(Collectors.toList());\n+            List<LockDO> needLockDOS = convertToLockDO(rowLocks);\n+            if (needLockDOS.size() >= 1) {", "originalCommit": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA3NjA4Mw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r477076083", "bodyText": "finished", "author": "lightClouds917", "createdAt": "2020-08-26T06:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzMTUzNQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r477131535", "bodyText": "The meaning here is the same as before, so be it", "author": "ph3636", "createdAt": "2020-08-26T08:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA5ODc2NQ==", "url": "https://github.com/seata/seata/pull/3016#discussion_r478098765", "bodyText": "The meaning here is the same as before, so be it\n\nfinished", "author": "lightClouds917", "createdAt": "2020-08-27T04:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4NjY0Nw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r475486647", "bodyText": "Change the names of these two keys for structure error", "author": "ph3636", "createdAt": "2020-08-24T10:01:45Z", "path": "server/src/main/java/io/seata/server/storage/redis/lock/RedisLocker.java", "diffHunk": "@@ -200,48 +217,28 @@ public boolean releaseLock(String xid, Long branchId) {\n     @Override\n     public boolean isLockable(List<RowLock> rowLocks) {\n         if (CollectionUtils.isEmpty(rowLocks)) {\n-            // no lock\n             return true;\n         }\n         try (Jedis jedis = JedisPooledFactory.getJedisInstance()) {\n             List<LockDO> locks = convertToLockDO(rowLocks);\n             Set<String> lockKeys = new HashSet<>();\n             for (LockDO rowlock : locks) {\n-                lockKeys.add(getLockKey(rowlock.getRowKey()));\n+                lockKeys.add(buildLockKey(rowlock.getRowKey()));\n             }\n-            List<String> rowlockJsons = jedis.mget(lockKeys.toArray(new String[0]));\n+\n             String xid = rowLocks.get(0).getXid();\n-            for (String rowlockJson : rowlockJsons) {\n-                if (!StringUtils.isEmpty(rowlockJson)) {\n-                    LockDO lock = JSON.parseObject(rowlockJson, LockDO.class);\n-                    if (lock != null && !Objects.equals(lock.getXid(), xid)) {\n-                        return false;\n-                    }\n-                }\n-            }\n+            Pipeline pipeline = jedis.pipelined();\n+            lockKeys.stream().forEach(key -> pipeline.hget(key, XID));\n+            List<String> existedXids = (List<String>) (List) pipeline.syncAndReturnAll();\n+            return existedXids.stream().allMatch(existedXid -> existedXid == null || xid.equals(existedXid));\n         }\n-        return true;\n-    }\n-\n-    private Set<String> lRange(Jedis jedis, String key) {\n-        Set<String> keys = new HashSet<>();\n-        List<String> redisLockJson;\n-        int start = 0;\n-        int stop = logQueryLimit;\n-        do {\n-            redisLockJson = jedis.lrange(key, start, stop);\n-            keys.addAll(redisLockJson);\n-            start = keys.size();\n-            stop = start + logQueryLimit;\n-        } while (CollectionUtils.isNotEmpty(redisLockJson));\n-        return keys;\n     }\n \n-    private String getXidLockKey(String xid) {\n+    private String buildXidLockKey(String xid) {\n         return DEFAULT_REDIS_SEATA_LOCK_XID_PREFIX + xid;\n     }\n \n-    private String getLockKey(String rowKey) {\n+    private String buildLockKey(String rowKey) {\n         return DEFAULT_REDIS_SEATA_LOCK_PREFIX + rowKey;", "originalCommit": "91360c7adeeeb3d8bc6e0f58e82fb8946f9df2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA3NjE4Mw==", "url": "https://github.com/seata/seata/pull/3016#discussion_r477076183", "bodyText": "Change the names of these two keys for structure error\n\nfinished", "author": "lightClouds917", "createdAt": "2020-08-26T06:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4NjY0Nw=="}], "type": "inlineReview"}, {"oid": "024a7e6b2067273e1ab3b7125e7d4f943acc8fab", "url": "https://github.com/seata/seata/commit/024a7e6b2067273e1ab3b7125e7d4f943acc8fab", "message": "Merge branch 'develop' into refactor_redis", "committedDate": "2020-08-25T02:06:38Z", "type": "commit"}, {"oid": "12b8253c91a6a8ee18e17752fdd77c5d91c91060", "url": "https://github.com/seata/seata/commit/12b8253c91a6a8ee18e17752fdd77c5d91c91060", "message": "Merge branch 'develop' of github.com:seata/seata into refactor_redis", "committedDate": "2020-08-26T06:14:43Z", "type": "commit"}, {"oid": "8d3f4cf1156e514f7209c10c3eb99ef4fd0349bb", "url": "https://github.com/seata/seata/commit/8d3f4cf1156e514f7209c10c3eb99ef4fd0349bb", "message": "optimize:optimize the code", "committedDate": "2020-08-26T06:40:17Z", "type": "commit"}, {"oid": "f0ddec3febb26ddedbecf1770b3ebfcb82f0a36f", "url": "https://github.com/seata/seata/commit/f0ddec3febb26ddedbecf1770b3ebfcb82f0a36f", "message": "optimize:optimize the code", "committedDate": "2020-08-26T06:41:03Z", "type": "commit"}, {"oid": "79c9dc468c986a53210c9f2b194135f57ec2b0ac", "url": "https://github.com/seata/seata/commit/79c9dc468c986a53210c9f2b194135f57ec2b0ac", "message": "Merge branch 'refactor_redis' of github.com:lightClouds917/seata into refactor_redis", "committedDate": "2020-08-26T06:42:16Z", "type": "commit"}, {"oid": "c226a3041749fc1470e6ad1cbb6da6a12b70d25b", "url": "https://github.com/seata/seata/commit/c226a3041749fc1470e6ad1cbb6da6a12b70d25b", "message": "optimize:optimize the code", "committedDate": "2020-08-26T06:45:34Z", "type": "commit"}, {"oid": "9978b936b199aa0b35e413e3a5944d5d4481d5b1", "url": "https://github.com/seata/seata/commit/9978b936b199aa0b35e413e3a5944d5d4481d5b1", "message": "optimize:optimize the code", "committedDate": "2020-08-26T07:05:58Z", "type": "commit"}, {"oid": "5da63d9fe355a42ba60ba6dcd042b0e7d63b0bb5", "url": "https://github.com/seata/seata/commit/5da63d9fe355a42ba60ba6dcd042b0e7d63b0bb5", "message": "optimize:the code", "committedDate": "2020-08-27T03:45:41Z", "type": "commit"}, {"oid": "aa93a678040c29ec10495de3b949011119b835d8", "url": "https://github.com/seata/seata/commit/aa93a678040c29ec10495de3b949011119b835d8", "message": "Merge branch 'develop' into refactor_redis", "committedDate": "2020-08-28T09:51:45Z", "type": "commit"}, {"oid": "4913506665a834e2cd05b9560a3632c7df0963c1", "url": "https://github.com/seata/seata/commit/4913506665a834e2cd05b9560a3632c7df0963c1", "message": "Merge branch 'develop' into refactor_redis", "committedDate": "2020-09-03T05:51:06Z", "type": "commit"}]}