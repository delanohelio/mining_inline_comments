{"pr_number": 3175, "pr_title": "optimize: improve UUIDGenerator using \"history time\" version of snowflake algorithm", "pr_createdAt": "2020-10-10T03:50:53Z", "pr_url": "https://github.com/seata/seata/pull/3175", "timeline": [{"oid": "0d796cbd50e927e326059201268aeb45ee11bb52", "url": "https://github.com/seata/seata/commit/0d796cbd50e927e326059201268aeb45ee11bb52", "message": "optimize: improve UUIDGenerator using \"history time\" version of snowflake algorithm", "committedDate": "2020-10-10T03:27:00Z", "type": "commit"}, {"oid": "2a77d19b3300a8f3a0dbd82c2a19c9f12eac946a", "url": "https://github.com/seata/seata/commit/2a77d19b3300a8f3a0dbd82c2a19c9f12eac946a", "message": "optimize: fix style", "committedDate": "2020-10-10T04:18:02Z", "type": "commit"}, {"oid": "74954515fe8d02ff599c478affbafd584cd69399", "url": "https://github.com/seata/seata/commit/74954515fe8d02ff599c478affbafd584cd69399", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-10-12T02:33:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1MDUyOA==", "url": "https://github.com/seata/seata/pull/3175#discussion_r502750528", "bodyText": "do not use *", "author": "a364176773", "createdAt": "2020-10-10T05:46:33Z", "path": "common/src/test/java/io/seata/common/util/IdWorkerTest.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.util;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;", "originalCommit": "2a77d19b3300a8f3a0dbd82c2a19c9f12eac946a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyODUzNQ==", "url": "https://github.com/seata/seata/pull/3175#discussion_r503628535", "bodyText": "idea auto merge these in one *", "author": "selfishlover", "createdAt": "2020-10-13T02:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc1MDUyOA=="}], "type": "inlineReview"}, {"oid": "c093777b331d7a8acf9b4abd284802097b92a8a1", "url": "https://github.com/seata/seata/commit/c093777b331d7a8acf9b4abd284802097b92a8a1", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-10-12T10:12:32Z", "type": "commit"}, {"oid": "d4d29b13f9428ff15071ed80041f7984e574a2d1", "url": "https://github.com/seata/seata/commit/d4d29b13f9428ff15071ed80041f7984e574a2d1", "message": "optimize: adjust line", "committedDate": "2020-10-12T10:16:33Z", "type": "commit"}, {"oid": "4947d78b294cc55fa9f0a42d0ec66b208aba2af3", "url": "https://github.com/seata/seata/commit/4947d78b294cc55fa9f0a42d0ec66b208aba2af3", "message": "Merge remote-tracking branch 'origin/feature-optimized-snowfake' into feature-optimized-snowfake", "committedDate": "2020-10-12T10:16:55Z", "type": "commit"}, {"oid": "4e4229b9183d8b515de4334e0ca6e53624e763ca", "url": "https://github.com/seata/seata/commit/4e4229b9183d8b515de4334e0ca6e53624e763ca", "message": "optimize: fix style", "committedDate": "2020-10-13T06:44:53Z", "type": "commit"}, {"oid": "8a0156dfd5167b523015139b1d822511e49065a5", "url": "https://github.com/seata/seata/commit/8a0156dfd5167b523015139b1d822511e49065a5", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-10-17T14:37:36Z", "type": "commit"}, {"oid": "f077b7cfb968838d02d8d84abfa6d77137cc29fa", "url": "https://github.com/seata/seata/commit/f077b7cfb968838d02d8d84abfa6d77137cc29fa", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-10-19T09:49:22Z", "type": "commit"}, {"oid": "bdedd8818054899965d3f95e7b958b1b007edebe", "url": "https://github.com/seata/seata/commit/bdedd8818054899965d3f95e7b958b1b007edebe", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-10-21T03:52:09Z", "type": "commit"}, {"oid": "782f2a9dfff329c037a8053e1905d8f17230407c", "url": "https://github.com/seata/seata/commit/782f2a9dfff329c037a8053e1905d8f17230407c", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-10-22T09:25:00Z", "type": "commit"}, {"oid": "2f9ff34540a50865bb8623f0b5d2c42b6a092a45", "url": "https://github.com/seata/seata/commit/2f9ff34540a50865bb8623f0b5d2c42b6a092a45", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-10-28T04:06:47Z", "type": "commit"}, {"oid": "c642166330bd0858ca365736b5d28f97ca4f8797", "url": "https://github.com/seata/seata/commit/c642166330bd0858ca365736b5d28f97ca4f8797", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-11-22T12:47:07Z", "type": "commit"}, {"oid": "c2d3c1ad47b9720bcffe604dc401739eb7a2f396", "url": "https://github.com/seata/seata/commit/c2d3c1ad47b9720bcffe604dc401739eb7a2f396", "message": "Merge branch 'develop' into feature-optimized-snowfake", "committedDate": "2020-12-05T01:30:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3ODAxNQ==", "url": "https://github.com/seata/seata/pull/3175#discussion_r536478015", "bodyText": "if currentWithSequence will never be negative number, I think use\n>>\n\nis enought.", "author": "l81893521", "createdAt": "2020-12-05T01:48:34Z", "path": "common/src/main/java/io/seata/common/util/IdWorker.java", "diffHunk": "@@ -14,161 +14,173 @@\n  *  limitations under the License.\n  */\n package io.seata.common.util;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * @author funkye\n  */\n public class IdWorker {\n \n-    private volatile static IdWorker idWorker = null;\n-\n     /**\n      * Start time cut (2020-05-03)\n      */\n     private final long twepoch = 1588435200000L;\n \n     /**\n-     * The number of bits occupied by the machine id\n+     * The number of bits occupied by workerId\n      */\n-    private final long workerIdBits = 10L;\n+    private final int workerIdBits = 10;\n \n     /**\n-     * Maximum supported machine id, the result is 1023 (this shift algorithm can quickly calculate the largest decimal\n-     * number that can be represented by a few binary numbers)\n+     * The number of bits occupied by timestamp\n      */\n-    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);\n+    private final int timestampBits = 41;\n \n     /**\n-     * The number of bits the sequence occupies in id\n+     * The number of bits occupied by sequence\n      */\n-    private final long sequenceBits = 12L;\n+    private final int sequenceBits = 12;\n \n     /**\n-     * Machine ID left 12 digits\n+     * Maximum supported machine id, the result is 1023\n      */\n-    private final long workerIdShift = sequenceBits;\n+    private final int maxWorkerId = ~(-1 << workerIdBits);\n \n     /**\n-     * Time truncated to the left by 22 bits (10 + 12)\n+     * business meaning: machine ID (0 ~ 1023)\n+     * actual layout in memory:\n+     * highest 1 bit: 0\n+     * middle 10 bit: workerId\n+     * lowest 53 bit: all 0\n      */\n-    private final long timestampLeftShift = sequenceBits + workerIdBits;\n+    private long workerId;\n \n     /**\n-     * Generate sequence mask\n+     * timestamp and sequence mix in one Long\n+     * highest 11 bit: not used\n+     * middle  41 bit: timestamp\n+     * lowest  12 bit: sequence\n      */\n-    private final long sequenceMask = -1L ^ (-1L << sequenceBits);\n+    private AtomicLong timestampAndSequence;\n \n     /**\n-     * Machine ID (0 ~ 1023)\n+     * mask that help to extract timestamp and sequence from a long\n      */\n-    private long workerId;\n+    private final long timestampAndSequenceMask = ~(-1L << (timestampBits + sequenceBits));\n \n     /**\n-     * Sequence in milliseconds (0 ~ 4095)\n+     * instantiate an IdWorker using given workerId\n+     * @param workerId if null, then will auto assign one\n      */\n-    private long sequence = 0L;\n+    public IdWorker(Long workerId) {\n+        initTimestampAndSequence();\n+        initWorkerId(workerId);\n+    }\n \n     /**\n-     * Time of last ID generation\n+     * init first timestamp and sequence immediately\n      */\n-    private long lastTimestamp = -1L;\n+    private void initTimestampAndSequence() {\n+        long timestamp = getNewestTimestamp();\n+        long timestampWithSequence = timestamp << sequenceBits;\n+        this.timestampAndSequence = new AtomicLong(timestampWithSequence);\n+    }\n \n     /**\n-     * Constructor\n-     *\n-     * @param workerId\n-     *            Job ID (0 ~ 1023)\n+     * init workerId\n+     * @param workerId if null, then auto generate one\n      */\n-    public IdWorker(long workerId) {\n+    private void initWorkerId(Long workerId) {\n+        if (workerId == null) {\n+            workerId = generateWorkerId();\n+        }\n         if (workerId > maxWorkerId || workerId < 0) {\n-            throw new IllegalArgumentException(\n-                String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n+            String message = String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId);\n+            throw new IllegalArgumentException(message);\n         }\n-        this.workerId = workerId;\n+        this.workerId = workerId << (timestampBits + sequenceBits);\n     }\n \n     /**\n-     * Get the next ID (the method is thread-safe)\n-     *\n-     * @return SnowflakeId\n+     * get next UUID(base on snowflake algorithm), which look like:\n+     * highest 1 bit: always 0\n+     * next   10 bit: workerId\n+     * next   41 bit: timestamp\n+     * lowest 12 bit: sequence\n+     * @return UUID\n      */\n-    public synchronized long nextId() {\n-        long timestamp = timeGen();\n-\n-        if (timestamp < lastTimestamp) {\n-            throw new RuntimeException(String.format(\n-                \"clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n-        }\n-\n-        if (lastTimestamp == timestamp) {\n-            sequence = (sequence + 1) & sequenceMask;\n-            if (sequence == 0) {\n-                timestamp = tilNextMillis(lastTimestamp);\n-            }\n-        } else {\n-            sequence = 0L;\n-        }\n-        lastTimestamp = timestamp;\n-\n-        return ((timestamp - twepoch) << timestampLeftShift) | (workerId << workerIdShift) | sequence;\n+    public long nextId() {\n+        waitIfNecessary();\n+        long next = timestampAndSequence.incrementAndGet();\n+        long timestampWithSequence = next & timestampAndSequenceMask;\n+        return workerId | timestampWithSequence;\n     }\n \n     /**\n-     * Block until the next millisecond until a new timestamp is obtained\n-     *\n-     * @param lastTimestamp\n-     *            Time of last ID generation\n-     * @return Current timestamp\n+     * block current thread if the QPS of acquiring UUID is too high\n+     * that current sequence space is exhausted\n      */\n-    protected long tilNextMillis(long lastTimestamp) {\n-        long timestamp = timeGen();\n-        while (timestamp <= lastTimestamp) {\n-            timestamp = timeGen();\n+    private void waitIfNecessary() {\n+        long currentWithSequence = timestampAndSequence.get();\n+        long current = currentWithSequence >>> sequenceBits;", "originalCommit": "c2d3c1ad47b9720bcffe604dc401739eb7a2f396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE3ODU4Mg==", "url": "https://github.com/seata/seata/pull/3175#discussion_r537178582", "bodyText": "currentWithSequence could be a negative number(though it would be a long long time to reach this~). What ever, >>> and >> have the same speed for cpu.", "author": "selfishlover", "createdAt": "2020-12-07T01:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3ODAxNQ=="}], "type": "inlineReview"}, {"oid": "456a442f215adaf7476fe0a1ab112a80854529d7", "url": "https://github.com/seata/seata/commit/456a442f215adaf7476fe0a1ab112a80854529d7", "message": "append author", "committedDate": "2020-12-08T02:11:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwNjM5Mg==", "url": "https://github.com/seata/seata/pull/3175#discussion_r538206392", "bodyText": "I think origin generate worker id is better than this.", "author": "l81893521", "createdAt": "2020-12-08T10:10:52Z", "path": "common/src/main/java/io/seata/common/util/IdWorker.java", "diffHunk": "@@ -14,161 +14,174 @@\n  *  limitations under the License.\n  */\n package io.seata.common.util;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * @author funkye\n+ * @author selfishlover\n  */\n public class IdWorker {\n \n-    private volatile static IdWorker idWorker = null;\n-\n     /**\n      * Start time cut (2020-05-03)\n      */\n     private final long twepoch = 1588435200000L;\n \n     /**\n-     * The number of bits occupied by the machine id\n+     * The number of bits occupied by workerId\n      */\n-    private final long workerIdBits = 10L;\n+    private final int workerIdBits = 10;\n \n     /**\n-     * Maximum supported machine id, the result is 1023 (this shift algorithm can quickly calculate the largest decimal\n-     * number that can be represented by a few binary numbers)\n+     * The number of bits occupied by timestamp\n      */\n-    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);\n+    private final int timestampBits = 41;\n \n     /**\n-     * The number of bits the sequence occupies in id\n+     * The number of bits occupied by sequence\n      */\n-    private final long sequenceBits = 12L;\n+    private final int sequenceBits = 12;\n \n     /**\n-     * Machine ID left 12 digits\n+     * Maximum supported machine id, the result is 1023\n      */\n-    private final long workerIdShift = sequenceBits;\n+    private final int maxWorkerId = ~(-1 << workerIdBits);\n \n     /**\n-     * Time truncated to the left by 22 bits (10 + 12)\n+     * business meaning: machine ID (0 ~ 1023)\n+     * actual layout in memory:\n+     * highest 1 bit: 0\n+     * middle 10 bit: workerId\n+     * lowest 53 bit: all 0\n      */\n-    private final long timestampLeftShift = sequenceBits + workerIdBits;\n+    private long workerId;\n \n     /**\n-     * Generate sequence mask\n+     * timestamp and sequence mix in one Long\n+     * highest 11 bit: not used\n+     * middle  41 bit: timestamp\n+     * lowest  12 bit: sequence\n      */\n-    private final long sequenceMask = -1L ^ (-1L << sequenceBits);\n+    private AtomicLong timestampAndSequence;\n \n     /**\n-     * Machine ID (0 ~ 1023)\n+     * mask that help to extract timestamp and sequence from a long\n      */\n-    private long workerId;\n+    private final long timestampAndSequenceMask = ~(-1L << (timestampBits + sequenceBits));\n \n     /**\n-     * Sequence in milliseconds (0 ~ 4095)\n+     * instantiate an IdWorker using given workerId\n+     * @param workerId if null, then will auto assign one\n      */\n-    private long sequence = 0L;\n+    public IdWorker(Long workerId) {\n+        initTimestampAndSequence();\n+        initWorkerId(workerId);\n+    }\n \n     /**\n-     * Time of last ID generation\n+     * init first timestamp and sequence immediately\n      */\n-    private long lastTimestamp = -1L;\n+    private void initTimestampAndSequence() {\n+        long timestamp = getNewestTimestamp();\n+        long timestampWithSequence = timestamp << sequenceBits;\n+        this.timestampAndSequence = new AtomicLong(timestampWithSequence);\n+    }\n \n     /**\n-     * Constructor\n-     *\n-     * @param workerId\n-     *            Job ID (0 ~ 1023)\n+     * init workerId\n+     * @param workerId if null, then auto generate one\n      */\n-    public IdWorker(long workerId) {\n+    private void initWorkerId(Long workerId) {\n+        if (workerId == null) {\n+            workerId = generateWorkerId();\n+        }\n         if (workerId > maxWorkerId || workerId < 0) {\n-            throw new IllegalArgumentException(\n-                String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n+            String message = String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId);\n+            throw new IllegalArgumentException(message);\n         }\n-        this.workerId = workerId;\n+        this.workerId = workerId << (timestampBits + sequenceBits);\n     }\n \n     /**\n-     * Get the next ID (the method is thread-safe)\n-     *\n-     * @return SnowflakeId\n+     * get next UUID(base on snowflake algorithm), which look like:\n+     * highest 1 bit: always 0\n+     * next   10 bit: workerId\n+     * next   41 bit: timestamp\n+     * lowest 12 bit: sequence\n+     * @return UUID\n      */\n-    public synchronized long nextId() {\n-        long timestamp = timeGen();\n-\n-        if (timestamp < lastTimestamp) {\n-            throw new RuntimeException(String.format(\n-                \"clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n-        }\n-\n-        if (lastTimestamp == timestamp) {\n-            sequence = (sequence + 1) & sequenceMask;\n-            if (sequence == 0) {\n-                timestamp = tilNextMillis(lastTimestamp);\n-            }\n-        } else {\n-            sequence = 0L;\n-        }\n-        lastTimestamp = timestamp;\n-\n-        return ((timestamp - twepoch) << timestampLeftShift) | (workerId << workerIdShift) | sequence;\n+    public long nextId() {\n+        waitIfNecessary();\n+        long next = timestampAndSequence.incrementAndGet();\n+        long timestampWithSequence = next & timestampAndSequenceMask;\n+        return workerId | timestampWithSequence;\n     }\n \n     /**\n-     * Block until the next millisecond until a new timestamp is obtained\n-     *\n-     * @param lastTimestamp\n-     *            Time of last ID generation\n-     * @return Current timestamp\n+     * block current thread if the QPS of acquiring UUID is too high\n+     * that current sequence space is exhausted\n      */\n-    protected long tilNextMillis(long lastTimestamp) {\n-        long timestamp = timeGen();\n-        while (timestamp <= lastTimestamp) {\n-            timestamp = timeGen();\n+    private void waitIfNecessary() {\n+        long currentWithSequence = timestampAndSequence.get();\n+        long current = currentWithSequence >>> sequenceBits;\n+        long newest = getNewestTimestamp();\n+        if (current >= newest) {\n+            try {\n+                Thread.sleep(5);\n+            } catch (InterruptedException ignore) {\n+                // don't care\n+            }\n         }\n-        return timestamp;\n     }\n \n     /**\n-     * Returns the current time in milliseconds\n-     *\n-     * @return Current time (ms)\n+     * get newest timestamp relative to twepoch\n      */\n-    protected long timeGen() {\n-        return System.currentTimeMillis();\n-    }\n-\n-    public static IdWorker getInstance() {\n-        if (idWorker == null) {\n-            synchronized (IdWorker.class) {\n-                if (idWorker == null) {\n-                    init(initWorkerId());\n-                }\n-            }\n-        }\n-        return idWorker;\n+    private long getNewestTimestamp() {\n+        return System.currentTimeMillis() - twepoch;\n     }\n \n-    public static long initWorkerId() {\n-        InetAddress address;\n+    /**\n+     * auto generate workerId, try using mac first, if failed, then randomly generate one\n+     * @return workerId\n+     */\n+    private long generateWorkerId() {", "originalCommit": "456a442f215adaf7476fe0a1ab112a80854529d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}